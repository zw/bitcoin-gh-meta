[
   {
      "body" : "Compiling on OS X, with Xcode 8\r\n```\r\n  CXX      test/test_test_bitcoin-cuckoocache_tests.o\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:24:\r\nIn file included from /usr/local/include/boost/test/utils/wrap_stringstream.hpp:26:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/sstream:174:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream:138:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios:216:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale:18:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex:177:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:992:39: error: \r\n      type 'float' cannot be used prior to '::' because it has no members\r\n    : public binary_function<typename _Predicate::first_argument_type,\r\n                                      ^\r\n./cuckoocache.h:206:65: note: in instantiation of template class\r\n      'std::__1::binary_negate<float>' requested here\r\n        depth_limit = std::max((uint8_t)1, static_cast<uint8_t>(std::log...\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:24:\r\nIn file included from /usr/local/include/boost/test/utils/wrap_stringstream.hpp:26:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/sstream:174:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream:138:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios:216:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale:18:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex:177:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1002:36: error: \r\n      type 'float' cannot be used prior to '::' because it has no members\r\n    bool operator()(const typename _Predicate::first_argument_type& __x,\r\n                                   ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:206:70: error: no member named 'log2' in namespace 'std'\r\n        depth_limit = std::max((uint8_t)1, static_cast<uint8_t>(std::log2(static...\r\n                                                                ~~~~~^\r\n3 errors generated.\r\n```",
      "created_at" : "2016-10-09T10:40:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252478919",
      "id" : 252478919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-09T10:40:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252478919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake should be fixed, <cmath> wasn't included for some reason.",
      "created_at" : "2016-10-09T13:52:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252487581",
      "id" : 252487581,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-09T13:52:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252487581",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Concept ACK and code review ACK.\r\n\r\nI still need to read up on the security/performance guarantees to understand better, but the implementation looks sane.",
      "created_at" : "2016-10-10T17:17:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252683343",
      "id" : 252683343,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-10T17:17:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252683343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Concept ACK, if nothing else the increase in entries-per-byte should be a big win for memory usage.",
      "created_at" : "2016-10-16T14:38:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-254050628",
      "id" : 254050628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-16T14:38:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254050628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "I just pushed up 4 commits which further improve the cuckoo cache. These commits add epochs/generations for the cache entries which improves the hit rate. Below is a brief description of the changes, for more detail, see the code & code documentation.\r\n\r\nThe first 2 commits are changes to the tests. The first commit simplifies what is checked in the existing tests (it was over specific to that Cache's design). The second adds a new test which fails under the existing code because the code does not prioritize newer entries.\r\n\r\nThe third patch adds generations to cache which work as follows: a bit vector is used to track if the element belongs to the current or prior generation. Once the number of the current generation's non-deleted elements exceeds ~45%, the generation is retired. The previously retired generation is marked deleted. Because the cache deletes lazily, these entries are still present but are more likely to be overwritten than elements in the currently retired generation. Generations are scanned to see if they should be retired using a heuristic of how many inserts would need to occur since the last scan to exceed the generation size.\r\n\r\nThe fourth commit increases the number of hashes used per element from 2 to 8. The benefit of this change is that it permits using a large generation size (e.g., 45%) compared to 2 hashes (30%). A larger generation size is the \"effective size\" of the cache, i.e., new entries stay in the current generation for longer.\r\n\r\nPerformance is markedly better, especially under attack scenarios. @morcos has run several simulations which back up this claim. \r\n\r\nThere is a slight (1-bit per entry) memory overhead to this approach. This does not negatively impact this cache because the trade off is worth it for intelligently deleting older entries. Only one bit is used for simplicity, as we get three represented states (deleted, old, current). Using more generations (lets say, 1 more bit) would allow for more granular freeing of only the oldest quarter and not half per scan. This has advantages, but also an additional memory cost and two generations was sufficient for this use case.\r\n\r\n\r\n\r\n\r\n\r\nOn a slightly separate note, another side benefit of this cache that I failed to mention when I opened the PR (before these added commits) is that inserts are guaranteed to terminate (in the sigcache currently in master, insert may run forever if GetRand is \"unlucky\").",
      "created_at" : "2016-10-20T21:56:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-255239670",
      "id" : 255239670,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-20T21:56:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255239670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "I've squashed all the commits (unsquashed still available here if you've already looked at this. https://github.com/bitcoin/bitcoin/compare/master...JeremyRubin:cuckoocache-pull-request-not-squashed). I've also edited the PR message.\r\n\r\nThe current Travis failed build seems to be related to the ongoing Dyn DDoS attack, as Travis is telling me variants of \r\n`The repository at JeremyRubin/bitcoin was not found.` and `The repository at bitcoin/bitcoin was not found.`. When that attack eases, I'll make travis retry.",
      "created_at" : "2016-10-21T18:56:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-255441541",
      "id" : 255441541,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-21T18:56:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255441541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84566874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84566874"
         }
      },
      "body" : "Instead of size, store the log2 of the size, and use a bitshift or mask here. Modulus operations are very slow.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T01:22:50Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84566874",
      "id" : 84566874,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5340391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84566874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581083"
         }
      },
      "body" : "Yes, this is a rather slow operation, but I don't quite fully understand your operation... doesn't that only work if you're at power of two size?\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T17:12:03Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581083",
      "id" : 84581083,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5352833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581083",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581146"
         }
      },
      "body" : "Yes.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T17:15:12Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581146",
      "id" : 84581146,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5352886,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581354"
         }
      },
      "body" : "Unfortunately the size currently isn't restricted to be a power of two, and by default is not a power of two. Are you suggesting we limit it to be a power of two?\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T17:28:25Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581354",
      "id" : 84581354,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353078,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581401"
         }
      },
      "body" : "Yes :) Sorry if that wasn't obvious. We could benchmark whether it matters compared to other operations of course, but restricting to a power of two means you at most get something that's a factor sqrt(2) off of your desired size, which seems acceptable for a cache.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T17:31:08Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581401",
      "id" : 84581401,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581867"
         }
      },
      "body" : "Apologies, long rambly response below:\n\nOverall, I think it's a reasonable idea to do this. Modulo is slow. It's not the bottleneck, but it's a low cost way to make this code faster.\n\nThere are a couple of weird things though. You have currently about 2 bits of bookkeeping overhead per entry (one bit for erasure, one bit for epoch). If you're restricting to a power of two size for the main cache memory, you also may as well do some of the following if the user specifies more space: more generations for finer grained generations; additional fee tracking to preferentially evict low fee items; some kind of mempool pointer/index map to evict signatures on mempool eviction. (preface: I don't like this idea, but for sake of discussion) You could also keep a large and a small cache and look up from both; letting you target size = 2^m + 2^n.\n\nAlso, power of two works reasonably well low in the series (1,2,4,8,16,32,64,128) but it seems to be kind of uncomfortably that at say a 1GB cache you have to choose between 1 and 2 GB if you want to increase a little bit. Yes, sqrt, but people have fixed memory sizes so it does kind of matter.\n\nMaybe a better inbetween would be to do as (roughly) follows (should work on GCC, clang, and msvc):\n\n```\nDEFAULT_MAX_SIGCACHE_SIZE = 32;\n#ifdef __MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\nbool fast_mod = __builtin_popcount(size) == 1;\ncompute_hash(E e) {\n    if (fast_mod)\n        // compute hash with masks\n    else\n       // compute hash with mod\n}\n```\n\nand by default not count the bookkeeping bits in the size computation. That way if you pass in a power of two megabytes as the parameter, you get this magic boost in performance, and if you pass in a non power of two if you get what you asked for. The branch shouldn't hurt because it should be easily predicted.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-10-22T17:57:51Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581867",
      "id" : 84581867,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Tested ACK either 3ba2bf4ecca453e926754db35fb6ca3b8141c4e7 or 121dfcd798bda9998dda13fa304be2d0afb7ec82 \r\n\r\nI gave some nits about the comments offline.\r\nI am ambivalent about the change to eliminate modulo. \r\n\r\nI have extensively tested the performance of this patch.  Lock contention on the sig cache is a serious bottleneck to ConnectBlock performance with 8 or more cores.  This patch appears to all but eliminate that contention and leads to a 40% improvement in ConnectBlock time for 16 cores.  It also allows for further performance improvements that would not see any benefit until this bottleneck was removed.\r\n\r\nI have also tested the hit rate performance and it is a significant improvement over the existing sigcache in the event of a spam attack, for a long running node, or in the event of a reorg.\r\n\r\nIn addition to reviewing the included tests, I've also run my own tests and done code review to be sure that there are no false positives.\r\n",
      "created_at" : "2016-10-28T14:13:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-256931331",
      "id" : 256931331,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-28T14:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256931331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "ACK 453aef4",
      "created_at" : "2016-11-01T14:40:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-257583560",
      "id" : 257583560,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-01T14:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/257583560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r86878082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/86878082"
         }
      },
      "body" : "Nit: You have some trailing whitespace on 3 lines in this file, including this one.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-07T21:53:25Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r86878082",
      "id" : 86878082,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 84,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/86878082",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r86878499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/86878499"
         }
      },
      "body" : "Why not use release/acquire - its identical instructions on x86 and wont require a full flush anywhere else to be correct (indeed, relaxed is maybe better the way its implemented now, but if we want the read/write locks in the sigcache to be more effecient we might not want to have a full flush there).\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-07T21:55:26Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r86878499",
      "id" : 86878499,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 32,
      "path" : "src/cuckoocache.h",
      "position" : 33,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/86878499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r87071931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87071931"
         }
      },
      "body" : "It seems to be a strange api to require that a copy be made as the parameter in the function, and then rely on std::move to make insertion effecient (which we cant do for uint256, since it doesnt have any non-POD memory). Seems just as good (and much more common) to pass in a const-reference and then just let operator=() handle the copy.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-08T20:03:22Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) & hash_mask,\n+                hash_function.template operator()<1>(e) & hash_mask,\n+                hash_function.template operator()<2>(e) & hash_mask,\n+                hash_function.template operator()<3>(e) & hash_mask,\n+                hash_function.template operator()<4>(e) & hash_mask,\n+                hash_function.template operator()<5>(e) & hash_mask,\n+                hash_function.template operator()<6>(e) & hash_mask,\n+                hash_function.template operator()<7>(e) & hash_mask};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with two hash locations.\n+     *\n+     * It drops the last tried element if it runs out of depth before\n+     * encountering an open slot.\n+     *\n+     * Thus\n+     *\n+     * insert(x);\n+     * return contains(x, false);\n+     *\n+     * is not guaranteed to return true.\n+     *\n+     * @param e the element to insert\n+     * @post one of the following: All previously inserted elements and e are\n+     * now in the table, one previously inserted element is evicted from the\n+     * table, the entry attempted to be inserted is evicted.\n+     *\n+     */\n+    inline void insert(Element e)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r87071931",
      "id" : 87071931,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 363,
      "path" : "src/cuckoocache.h",
      "position" : 368,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87071931",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Testing this (OSX 10.12, XCode 8.1):\r\nCompiling threw 1 new warning:\r\n```\r\nIn file included from script/sigcache.cpp:14:\r\n./cuckoocache.h:220:17: warning: suggest braces around initialization of subobject [-Wmissing-braces]\r\n        return {hash_function.template operator()<0>(e) & hash_mask,\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n./cuckoocache.h:438:40: note: in instantiation of member function 'CuckooCache::cache<uint256, (anonymous\r\n      namespace)::SignatureCacheHasher>::compute_hashes' requested here\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                       ^\r\nscript/sigcache.cpp:70:25: note: in instantiation of member function 'CuckooCache::cache<uint256,\r\n      (anonymous namespace)::SignatureCacheHasher>::contains' requested here\r\n        return setValid.contains(entry, erase);\r\n```\r\n\r\nErrors trying to compile the tests:\r\n```\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:218:36: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\r\n                                   ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:368:33: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:438:33: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n```\r\n```\r\n  CXX      test/test_test_bitcoin-key_tests.o\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:18:\r\nIn file included from /usr/local/include/boost/test/tree/observer.hpp:17:\r\nIn file included from /usr/local/include/boost/test/detail/global_typedef.hpp:15:\r\nIn file included from /usr/local/include/boost/test/utils/basic_cstring/basic_cstring.hpp:21:\r\nIn file included from /usr/local/include/boost/test/utils/basic_cstring/bcs_char_traits.hpp:25:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string:439:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm:628:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1740:31: error: no matching constructor\r\n      for initialization of 'block_activity'\r\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\r\n                              ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1656:18: note: in instantiation of\r\n      function template specialization 'std::__1::allocator<block_activity>::construct<block_activity, const unsigned int &, CuckooCache::cache<uint256,\r\n      cuckoocache_tests::uint256Hasher> &>' requested here\r\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\r\n                 ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1502:14: note: in instantiation of\r\n      function template specialization 'std::__1::allocator_traits<std::__1::allocator<block_activity> >::__construct<block_activity, const unsigned int\r\n      &, CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>' requested here\r\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\r\n             ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/deque:1801:21: note: in instantiation of\r\n      function template specialization 'std::__1::allocator_traits<std::__1::allocator<block_activity> >::construct<block_activity, const unsigned int &,\r\n      CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>' requested here\r\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);\r\n                    ^\r\ntest/cuckoocache_tests.cpp:368:18: note: in instantiation of function template specialization 'std::__1::deque<block_activity,\r\n      std::__1::allocator<block_activity> >::emplace_back<const unsigned int &, CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>'\r\n      requested here\r\n        last_few.emplace_back(BLOCK_SIZE, set);\r\n                 ^\r\ntest/cuckoocache_tests.cpp:391:5: note: in instantiation of function template specialization\r\n      'cuckoocache_tests::test_cache_generations<CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> >' requested here\r\n    test_cache_generations<CuckooCache::cache<uint256, uint256Hasher>>();\r\n    ^\r\ntest/cuckoocache_tests.cpp:324:12: note: candidate constructor (the implicit move constructor) not viable: requires 1 argument, but 2 were provided\r\n    struct block_activity {\r\n           ^\r\ntest/cuckoocache_tests.cpp:324:12: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 2 were provided\r\n4 errors generated.\r\n```",
      "created_at" : "2016-11-09T14:55:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259433117",
      "id" : 259433117,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T14:55:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259433117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake I think I can fix the warnings but I'm curious as to how much that's a goal given that that flag should be deprecated & there are lots of build errors. Happy to push a squashme if you think so.\r\n\r\nThe build errors should be fixable, must be a different include order or something, I need to add a `#include<array>`.",
      "created_at" : "2016-11-09T21:18:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259529310",
      "id" : 259529310,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T21:18:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259529310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@JeremyRubin The warning isn't so much of an issue, was just making a note of it.",
      "created_at" : "2016-11-09T23:19:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259555316",
      "id" : 259555316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T23:19:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259555316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake please confirm fix when you have a moment.",
      "created_at" : "2016-11-10T02:39:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259587267",
      "id" : 259587267,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-10T02:39:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259587267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@JeremyRubin Everything compiling file now. \r\n\r\nCan you suggest tests/benchmarks that reviewers can run to test the performance increase here, or is that going to be hard for anyone without a-lot of cores?",
      "created_at" : "2016-11-10T02:48:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259588355",
      "id" : 259588355,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-10T02:48:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259588355",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88109729"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88109729"
         }
      },
      "body" : "Where does the requirement for POD come from?\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-15T20:49:36Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88109729",
      "id" : 88109729,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 152,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 8693054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88109729",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88128072"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88128072"
         }
      },
      "body" : "Any reason why these locks aren't integrated into the cache class? It isn't obvious to be how to correctly synchronize the erase method with the rest.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-15T22:24:38Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88128072",
      "id" : 88128072,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 143,
      "path" : "src/cuckoocache.h",
      "position" : 144,
      "pull_request_review_id" : 8693054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88128072",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169538"
         }
      },
      "body" : "Yes there is a reason.\n\nThe locks aren't actually needed at all how the cache is currently used. All that needs to happen is per thread: at the beginning of a block processing, a memory acquire; at the end of block processing a memory release. Additionally, one more lock must be acquired before block processing by the master to ensure that there are no concurrent writers (from addtomempool) and that master must not release until all slaves release as well. This is much better than the repeated acquire/release of locking/unlocking on every single signature operation.\n\nI have written a version of the code which has this semantics, but some feedback from others felt that it was fragile & prone to someone else breaking that behavior down the line (bad for maintainability). In the interest of keeping that optimization available and not introducing a maintenance hazard, I kept the locking where it was in the \"layer up\".\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-16T05:11:24Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169538",
      "id" : 88169538,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 143,
      "path" : "src/cuckoocache.h",
      "position" : 144,
      "pull_request_review_id" : 8750626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169538",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169799"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169799"
         }
      },
      "body" : "I suppose the way it is currently written (using swap and move) it should be safe to remove both requirements (POD and 32-alignable). \n\nPrior versions of the code I think were unsafe for that use case.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-16T05:15:35Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169799",
      "id" : 88169799,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 152,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 8750868,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169799",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169876"
         }
      },
      "body" : "(I can do a squashme with just that unless you have other small feedbacks)\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-16T05:16:43Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88169876",
      "id" : 88169876,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 152,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 8750929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88169876",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@fanquake yeah it'll be tough, there's not much speed improvement from losing the erase locks until ~8 cores. What you could test is better memory efficiency by allocating smaller caches (2 4 8 16...) and comparing performance to a node running with that size and the old cache. I'd recommend running one node and peering your test nodes exclusively thought that to ensure nodes are getting the same messages for a given time. But if you're hardware limited that will be hard.",
      "created_at" : "2016-11-17T20:10:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-261355688",
      "id" : 261355688,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-17T20:10:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261355688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88608234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88608234"
         }
      },
      "body" : "The std::min should be a NOP. we're in an else(epoch_size > epoch_unused_count).\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:03:44Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88608234",
      "id" : 88608234,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 291,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88608234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609415"
         }
      },
      "body" : "nit: technically it can hold up to (~(uint32_t) 1) - 1, because invalid() uses ~(uint32_t) 1, though I think you meant to use 0.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:18:25Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609415",
      "id" : 88609415,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 121,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609480"
         }
      },
      "body" : "rehash has been removed in this version of the patch (and you might only list public methods? up to you).\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:19:21Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609480",
      "id" : 88609480,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 135,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609480",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609545"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609545"
         }
      },
      "body" : "I believe this also refers to an old/different version of this patch.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:20:20Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609545",
      "id" : 88609545,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 146,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609545",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609605"
         }
      },
      "body" : "Also now out-of-date: you're using 8 hashes.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:21:01Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609605",
      "id" : 88609605,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 156,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609668"
         }
      },
      "body" : "s/incremented/decremented/\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:21:47Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609668",
      "id" : 88609668,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 180,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609959"
         }
      },
      "body" : "nit: technically this is an off-by-one: because you check this prior to actually doing the insert you'll always do an \"expensive\" scan twice for the first (and all) epochs. Practically, you might just want to set epoch_heuristic_count to something like epoch_size + 10 by default, though I suppose it doesnt matter all that much.\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:25:36Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88609959",
      "id" : 88609959,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 267,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88609959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88610039"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88610039"
         }
      },
      "body" : "s/two/eight/\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-18T07:26:36Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with two hash locations.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r88610039",
      "id" : 88610039,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 346,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 7513925,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88610039",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "@JeremyRubin Care to have a look at @TheBlueMatt's comments above?",
      "created_at" : "2016-11-30T21:06:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-263995253",
      "id" : 263995253,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-30T21:06:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/263995253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90349719"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90349719"
         }
      },
      "body" : "You're right it's the same on x86, but it isn't for ARM. We want the operation to be relaxed, so release or acquire are over constrained.\r\n\r\nIf later changes want to change the memory model, they should do so then. It's hard to say if a full flush is better or worse than lots of release/acquires; that would require benchmarking.\r\n\r\natomic instruction mappings: https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:05:43Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90349719",
      "id" : 90349719,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 32,
      "path" : "src/cuckoocache.h",
      "position" : 33,
      "pull_request_review_id" : 10870128,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90349719",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350020"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350020"
         }
      },
      "body" : "I thought there was a reason I used `~(uint32_t) 1` rather than `~(uint32_t) 0`, but for the life of me can't recall it. Will change it to be that, but would appreciate you to review that there was no reason.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:07:36Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350020",
      "id" : 90350020,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 121,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10870434,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350020",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350121"
         }
      },
      "body" : " ",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:08:17Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with two hash locations.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350121",
      "id" : 90350121,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 346,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10870541,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350176"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350176"
         }
      },
      "body" : "\r\n",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:08:35Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350176",
      "id" : 90350176,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 84,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10870593,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350176",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350192"
         }
      },
      "body" : " ",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:08:43Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350192",
      "id" : 90350192,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 135,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10870610,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350215"
         }
      },
      "body" : " ",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:08:54Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90350215",
      "id" : 90350215,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 156,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10870631,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90350215",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90351639"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90351639"
         }
      },
      "body" : "I think it's correct? I'll try to clarify.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:19:06Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90351639",
      "id" : 90351639,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 146,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10871980,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90351639",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90352042"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90352042"
         }
      },
      "body" : " ",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:21:55Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90352042",
      "id" : 90352042,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 180,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10872345,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90352042",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90353115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90353115"
         }
      },
      "body" : " -- I fixed it, I think, by decrementing inside the if block. (didn't want to do postfix to stop the counter from underflowing)",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:28:35Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90353115",
      "id" : 90353115,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 267,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10873311,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90353115",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90353967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90353967"
         }
      },
      "body" : " ",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:34:46Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90353967",
      "id" : 90353967,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 291,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10874116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90353967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90354121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90354121"
         }
      },
      "body" : "We also do a std::swap on e so that's why we have a mutable copy.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-11-30T23:36:00Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) & hash_mask,\n+                hash_function.template operator()<1>(e) & hash_mask,\n+                hash_function.template operator()<2>(e) & hash_mask,\n+                hash_function.template operator()<3>(e) & hash_mask,\n+                hash_function.template operator()<4>(e) & hash_mask,\n+                hash_function.template operator()<5>(e) & hash_mask,\n+                hash_function.template operator()<6>(e) & hash_mask,\n+                hash_function.template operator()<7>(e) & hash_mask};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with two hash locations.\n+     *\n+     * It drops the last tried element if it runs out of depth before\n+     * encountering an open slot.\n+     *\n+     * Thus\n+     *\n+     * insert(x);\n+     * return contains(x, false);\n+     *\n+     * is not guaranteed to return true.\n+     *\n+     * @param e the element to insert\n+     * @post one of the following: All previously inserted elements and e are\n+     * now in the table, one previously inserted element is evicted from the\n+     * table, the entry attempted to be inserted is evicted.\n+     *\n+     */\n+    inline void insert(Element e)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90354121",
      "id" : 90354121,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 363,
      "path" : "src/cuckoocache.h",
      "position" : 368,
      "pull_request_review_id" : 10874268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90354121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Should be all addressed.",
      "created_at" : "2016-11-30T23:41:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-264032672",
      "id" : 264032672,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-30T23:41:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/264032672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90372345"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90372345"
         }
      },
      "body" : "std::swap is just as slow for uint256, though. Since there is no dynamically-allocated memory we cant speed it up, really.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-01T02:23:05Z",
      "diff_hunk" : "@@ -0,0 +1,451 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1 \n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) & hash_mask,\n+                hash_function.template operator()<1>(e) & hash_mask,\n+                hash_function.template operator()<2>(e) & hash_mask,\n+                hash_function.template operator()<3>(e) & hash_mask,\n+                hash_function.template operator()<4>(e) & hash_mask,\n+                hash_function.template operator()<5>(e) & hash_mask,\n+                hash_function.template operator()<6>(e) & hash_mask,\n+                hash_function.template operator()<7>(e) & hash_mask};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)1;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if ((--epoch_heuristic_counter) != 0)\n+            return;\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - std::min(epoch_size, epoch_unused_count)));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with two hash locations.\n+     *\n+     * It drops the last tried element if it runs out of depth before\n+     * encountering an open slot.\n+     *\n+     * Thus\n+     *\n+     * insert(x);\n+     * return contains(x, false);\n+     *\n+     * is not guaranteed to return true.\n+     *\n+     * @param e the element to insert\n+     * @post one of the following: All previously inserted elements and e are\n+     * now in the table, one previously inserted element is evicted from the\n+     * table, the entry attempted to be inserted is evicted.\n+     *\n+     */\n+    inline void insert(Element e)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90372345",
      "id" : 90372345,
      "original_commit_id" : "453aef404b8692294d9e659f456cc8370174432c",
      "original_position" : 363,
      "path" : "src/cuckoocache.h",
      "position" : 368,
      "pull_request_review_id" : 10891633,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90372345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90372617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90372617"
         }
      },
      "body" : "Oh, indeed, I believe I was mistaken.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-01T02:26:17Z",
      "diff_hunk" : "@@ -0,0 +1,452 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r90372617",
      "id" : 90372617,
      "original_commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "original_position" : 146,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 10891900,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/90372617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "LGTM at 88b58d3c8d840924c8cfb556db994f71dfe6ad13",
      "created_at" : "2016-12-01T02:27:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-264061238",
      "id" : 264061238,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-01T02:27:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/264061238",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "reACK \t\t\t88b58d3",
      "created_at" : "2016-12-05T17:09:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-264913529",
      "id" : 264913529,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-05T17:09:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/264913529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91376264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91376264"
         }
      },
      "body" : "I think this comment needs to be updated now that we have more than 2 hashes, right?  If I understand right, the algorithm now is:\r\n```\r\nSwap with the element one past the last one looked at.  Example:\r\n\r\n1) On first iter, always false so defaults to locs[0].\r\n2) Second iter, last_loc == locs[k] for some k, so will go to locs[k+1] (wrapping back to 0 if necessary).\r\n```",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-07T20:08:03Z",
      "diff_hunk" : "@@ -0,0 +1,457 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable.\n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten\n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t)0) - 1 elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read+Erase Operations:\n+ *      - contains(*, true)\n+ *\n+ *  Erase Operations:\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Erase caller must release all memory before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a movable and copyable type\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) ... h<7>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch might be aged\n+     * & an expensive scan should be done.  epoch_heuristic_counter is\n+     * decremented on insert and reset to the new number of inserts which would\n+     * cause the epoch to reach epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1\n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)0;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if (epoch_heuristic_counter != 0) {\n+            --epoch_heuristic_counter;\n+            return;\n+        }\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            // Ordinarily, we would have to sanity check std::min(epoch_size,\n+            // epoch_unused_count), but we already know that `epoch_unused_count\n+            // < epoch_size` in this branch\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - epoch_unused_count));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with eight hash locations.\n+     *\n+     * It drops the last tried element if it runs out of depth before\n+     * encountering an open slot.\n+     *\n+     * Thus\n+     *\n+     * insert(x);\n+     * return contains(x, false);\n+     *\n+     * is not guaranteed to return true.\n+     *\n+     * @param e the element to insert\n+     * @post one of the following: All previously inserted elements and e are\n+     * now in the table, one previously inserted element is evicted from the\n+     * table, the entry attempted to be inserted is evicted.\n+     *\n+     */\n+    inline void insert(Element e)\n+    {\n+        epoch_check();\n+        uint32_t last_loc = invalid();\n+        bool last_epoch = true;\n+        std::array<uint32_t, 8> locs = compute_hashes(e);\n+        // Make sure we have not already inserted this element\n+        // If we have, make sure that it does not get deleted\n+        for (uint32_t loc : locs)\n+            if (table[loc] == e) {\n+                please_keep(loc);\n+                epoch_flags[loc] = last_epoch;\n+                return;\n+            }\n+        for (uint8_t depth = 0; depth < depth_limit; ++depth) {\n+            // First try to insert to an empty slot, if one exists\n+            for (uint32_t loc : locs) {\n+                if (!collection_flags.bit_is_set(loc))\n+                    continue;\n+                table[loc] = std::move(e);\n+                please_keep(loc);\n+                epoch_flags[loc] = last_epoch;\n+                return;\n+            }\n+            /** Swap with the element at the location that was\n+            * not the last one looked at. Example:\n+            *\n+            * 1) On first iter, always false so defaults to locs[0]\n+            * 2) Second iter, last_loc == locs[0] so will go to locs[1]\n+            *",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91376264",
      "id" : 91376264,
      "original_commit_id" : "88b58d3c8d840924c8cfb556db994f71dfe6ad13",
      "original_position" : 398,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 11885055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91376264",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91377235"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91377235"
         }
      },
      "body" : "nit: random newline",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-07T20:12:49Z",
      "diff_hunk" : "@@ -0,0 +1,457 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <array>\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable.\n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten\n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t)0) - 1 elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read+Erase Operations:\n+ *      - contains(*, true)\n+ *\n+ *  Erase Operations:\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Erase caller must release all memory before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a movable and copyable type\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) ... h<7>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch might be aged\n+     * & an expensive scan should be done.  epoch_heuristic_counter is\n+     * decremented on insert and reset to the new number of inserts which would\n+     * cause the epoch to reach epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 90%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** hash_mask should be set to appropriately mask out a hash such that every\n+     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n+     * should be (1<<20)-1\n+     */\n+    uint32_t hash_mask;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {{hash_function.template operator()<0>(e) & hash_mask,\n+                 hash_function.template operator()<1>(e) & hash_mask,\n+                 hash_function.template operator()<2>(e) & hash_mask,\n+                 hash_function.template operator()<3>(e) & hash_mask,\n+                 hash_function.template operator()<4>(e) & hash_mask,\n+                 hash_function.template operator()<5>(e) & hash_mask,\n+                 hash_function.template operator()<6>(e) & hash_mask,\n+                 hash_function.template operator()<7>(e) & hash_mask}};\n+    }\n+\n+    /* end\n+     * @returns a constexpr index that can never be inserted to */\n+    constexpr uint32_t invalid() const\n+    {\n+        return ~(uint32_t)0;\n+    }\n+\n+    /** allow_erase marks the element at index n as discardable. Threadsafe\n+     * without any concurrent insert.\n+     * @param n the index to allow erasure of\n+     */\n+    inline void allow_erase(uint32_t n) const\n+    {\n+        collection_flags.bit_set(n);\n+    }\n+\n+    /** please_keep marks the element at index n as an entry that should be kept.\n+     * Threadsafe without any concurrent insert.\n+     * @param n the index to prioritize keeping\n+     */\n+    inline void please_keep(uint32_t n) const\n+    {\n+        collection_flags.bit_unset(n);\n+    }\n+\n+    /** epoch_check handles the changing of epochs for elements stored in the\n+     * cache. epoch_check should be run before every insert.\n+     *\n+     * First, epoch_check decrements and checks the cheap heuristic, and then does\n+     * a more expensive scan if the cheap heuristic runs out. If the expensive\n+     * scan suceeds, the epochs are aged and old elements are allow_erased. The\n+     * cheap heuristic is reset to retrigger after the worst case growth of the\n+     * current epoch's elements would exceed the epoch_size.\n+     */\n+    void epoch_check()\n+    {\n+        if (epoch_heuristic_counter != 0) {\n+            --epoch_heuristic_counter;\n+            return;\n+        }\n+        // count the number of elements from the latest epoch which\n+        // have not been erased.\n+        uint32_t epoch_unused_count = 0;\n+        for (uint32_t i = 0; i < size; ++i)\n+            epoch_unused_count += epoch_flags[i] &&\n+                                  !collection_flags.bit_is_set(i);\n+        // If there are more non-deleted entries in the current epoch than the\n+        // epoch size, then allow_erase on all elements in the old epoch (marked\n+        // false) and move all elements in the current epoch to the old epoch\n+        // but do not call allow_erase on their indices.\n+        if (epoch_unused_count >= epoch_size) {\n+            for (uint32_t i = 0; i < size; ++i)\n+                if (epoch_flags[i])\n+                    epoch_flags[i] = false;\n+                else\n+                    allow_erase(i);\n+            epoch_heuristic_counter = epoch_size;\n+        } else\n+            // reset the epoch_heuristic_counter to next do a scan when worst\n+            // case behavior (no intermittent erases) would exceed epoch size,\n+            // with a reasonable minimum scan size.\n+            // Ordinarily, we would have to sanity check std::min(epoch_size,\n+            // epoch_unused_count), but we already know that `epoch_unused_count\n+            // < epoch_size` in this branch\n+            epoch_heuristic_counter = std::max(1u, std::max(epoch_size / 16,\n+                        epoch_size - epoch_unused_count));\n+    }\n+\n+public:\n+    /** You must always construct a cache with some elements via a subsequent\n+     * call to setup or setup_bytes, otherwise operations may segfault.\n+     */\n+    cache() : table(), size(), collection_flags(0), epoch_flags(),\n+    epoch_heuristic_counter(), epoch_size(), depth_limit(0), hash_function()\n+    {\n+    }\n+\n+    /** setup initializes the container to store no more than new_size\n+     * elements. setup rounds down to a power of two size.\n+     *\n+     * setup should only be called once.\n+     *\n+     * @param new_size the desired number of elements to store\n+     * @returns the maximum number of elements storable\n+     **/\n+    uint32_t setup(uint32_t new_size)\n+    {\n+        // depth_limit must be at least one otherwise errors can occur.\n+        depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n+        size = 1 << depth_limit;\n+        hash_mask = size-1;\n+        table.resize(size);\n+        collection_flags.setup(size);\n+        epoch_flags.resize(size);\n+        // Set to 45% as described above\n+        epoch_size = std::max((uint32_t)1, (45 * size) / 100);\n+        // Initially set to wait for a whole epoch\n+        epoch_heuristic_counter = epoch_size;\n+        return size;\n+    }\n+\n+    /** setup_bytes is a convenience function which accounts for internal memory\n+     * usage when deciding how many elements to store. It isn't perfect because\n+     * it doesn't account for any overhead (struct size, MallocUsage, collection\n+     * and epoch flags). This was done to simplify selecting a power of two\n+     * size. In the expected use case, an extra two bits per entry should be\n+     * negligible compared to the size of the elements.\n+     *\n+     * @param bytes the approximate number of bytes to use for this data\n+     * structure.\n+     * @returns the maximum number of elements storable (see setup()\n+     * documentation for more detail)\n+     */\n+    uint32_t setup_bytes(size_t bytes)\n+    {\n+        return setup(bytes/sizeof(Element));\n+    }\n+\n+    /** insert loops at most depth_limit times trying to insert a hash\n+     * at various locations in the table via a variant of the Cuckoo Algorithm\n+     * with eight hash locations.\n+     *\n+     * It drops the last tried element if it runs out of depth before\n+     * encountering an open slot.\n+     *\n+     * Thus\n+     *\n+     * insert(x);\n+     * return contains(x, false);\n+     *\n+     * is not guaranteed to return true.\n+     *\n+     * @param e the element to insert\n+     * @post one of the following: All previously inserted elements and e are\n+     * now in the table, one previously inserted element is evicted from the\n+     * table, the entry attempted to be inserted is evicted.\n+     *\n+     */\n+    inline void insert(Element e)\n+    {\n+        epoch_check();\n+        uint32_t last_loc = invalid();\n+        bool last_epoch = true;\n+        std::array<uint32_t, 8> locs = compute_hashes(e);\n+        // Make sure we have not already inserted this element\n+        // If we have, make sure that it does not get deleted\n+        for (uint32_t loc : locs)\n+            if (table[loc] == e) {\n+                please_keep(loc);\n+                epoch_flags[loc] = last_epoch;\n+                return;\n+            }\n+        for (uint8_t depth = 0; depth < depth_limit; ++depth) {\n+            // First try to insert to an empty slot, if one exists\n+            for (uint32_t loc : locs) {\n+                if (!collection_flags.bit_is_set(loc))\n+                    continue;\n+                table[loc] = std::move(e);\n+                please_keep(loc);\n+                epoch_flags[loc] = last_epoch;\n+                return;\n+            }\n+            /** Swap with the element at the location that was\n+            * not the last one looked at. Example:\n+            *\n+            * 1) On first iter, always false so defaults to locs[0]\n+            * 2) Second iter, last_loc == locs[0] so will go to locs[1]\n+            *\n+            * This prevents moving the element we just put in.\n+            *\n+            * The swap is not a move -- we must switch onto the evicted element\n+            * for the next iteration.\n+            */\n+            last_loc = locs[(1 + (std::find(locs.begin(), locs.end(), last_loc) - locs.begin())) & 7];\n+            std::swap(table[last_loc], e);\n+            // Can't std::swap a std::vector<bool>::reference and a bool&.\n+            bool epoch = last_epoch;\n+            last_epoch = epoch_flags[last_loc];\n+            epoch_flags[last_loc] = epoch;\n+\n+            // Recompute the locs -- unfortunately happens one too many times!\n+            locs = compute_hashes(e);\n+        }\n+    }\n+\n+    /* contains iterates through the hash locations for a given element\n+     * and checks to see if it is present.\n+     *\n+     * contains does not check garbage collected state (in other words,\n+     * garbage is only collected when the space is needed), so:\n+     *\n+     * insert(x);\n+     * if (contains(x, true))\n+     *     return contains(x, false);\n+     * else\n+     *     return true;\n+     *\n+     * executed on a single thread will always return true!\n+     *\n+     * This is a great property for re-org performance for example.\n+     *\n+     * contains returns a bool set true if the element was found.\n+     *\n+     * @param e the element to check\n+     * @param erase\n+     *\n+     * @post if erase is true and the element is found, then the garbage collect\n+     * flag is set\n+     * @returns true if the element is found, false otherwise\n+     */\n+    inline bool contains(const Element& e, const bool erase) const\n+    {\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91377235",
      "id" : 91377235,
      "original_commit_id" : "88b58d3c8d840924c8cfb556db994f71dfe6ad13",
      "original_position" : 443,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 11885055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91377235",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91377959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91377959"
         }
      },
      "body" : "nit: \"matter\" -> \"matters\"",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-07T20:16:29Z",
      "diff_hunk" : "@@ -11,20 +11,29 @@\n #include \"uint256.h\"\n #include \"util.h\"\n \n+#include \"cuckoocache.h\"\n #include <boost/thread.hpp>\n-#include <boost/unordered_set.hpp>\n \n namespace {\n \n /**\n  * We're hashing a nonce into the entries themselves, so we don't need extra\n  * blinding in the set hash computation.\n+ *\n+ * This may exhibit platform endian dependent behavior but because these are\n+ * nonced hashes (random) and this state is only ever used locally it is safe.\n+ * All that matter is local consistency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91377959",
      "id" : 91377959,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 16,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 11885055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91377959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91382104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91382104"
         }
      },
      "body" : "nit: Can you clarify this comment -- what is the atomic operation you're referring to?\r\n\r\nAlso, it seems like this comment is here to explain why you moved the code from its old place to the new place (which is helpful for me to understand!), but it's perhaps not very helpful here in its current form to future code readers who haven't seen the previous implementation.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-07T20:39:04Z",
      "diff_hunk" : "@@ -56,58 +64,45 @@ class CSignatureCache\n     }\n \n     bool\n-    Get(const uint256& entry)\n+    Get(const uint256& entry, const bool erase)\n     {\n         boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n-        return setValid.count(entry);\n+        return setValid.contains(entry, erase);\n     }\n \n-    void Erase(const uint256& entry)\n+    void Set(uint256& entry)\n     {\n         boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n-        setValid.erase(entry);\n+        setValid.insert(entry);\n     }\n-\n-    void Set(const uint256& entry)\n+    uint32_t setup_bytes(size_t n)\n     {\n-        size_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n-        if (nMaxCacheSize <= 0) return;\n-\n-        boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n-        while (memusage::DynamicUsage(setValid) > nMaxCacheSize)\n-        {\n-            map_type::size_type s = GetRand(setValid.bucket_count());\n-            map_type::local_iterator it = setValid.begin(s);\n-            if (it != setValid.end(s)) {\n-                setValid.erase(*it);\n-            }\n-        }\n-\n-        setValid.insert(entry);\n+        return setValid.setup_bytes(n);\n     }\n };\n \n+// Initialized outisde of VerifySignature to avoid atomic operation per call",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91382104",
      "id" : 91382104,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 88,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 11885055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91382104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91412485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91412485"
         }
      },
      "body" : "I believe that a function local static initialized uses an atomic (perhaps even a locking!) operation under the hood for the case where concurrent callers enter the function initially (C++11 guarantees this to be safe).\r\n\r\nI also believe that this is not the case for a global static (initialized before concurrency is allowed).\r\n\r\nI'm not 100% certain the spec forces conformity on this point, but I think it is at least the case in most implementations.",
      "commit_id" : "67dac4e1937b9835d2c09402d35e0050467fbc6d",
      "created_at" : "2016-12-07T23:32:32Z",
      "diff_hunk" : "@@ -56,58 +64,45 @@ class CSignatureCache\n     }\n \n     bool\n-    Get(const uint256& entry)\n+    Get(const uint256& entry, const bool erase)\n     {\n         boost::shared_lock<boost::shared_mutex> lock(cs_sigcache);\n-        return setValid.count(entry);\n+        return setValid.contains(entry, erase);\n     }\n \n-    void Erase(const uint256& entry)\n+    void Set(uint256& entry)\n     {\n         boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n-        setValid.erase(entry);\n+        setValid.insert(entry);\n     }\n-\n-    void Set(const uint256& entry)\n+    uint32_t setup_bytes(size_t n)\n     {\n-        size_t nMaxCacheSize = GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n-        if (nMaxCacheSize <= 0) return;\n-\n-        boost::unique_lock<boost::shared_mutex> lock(cs_sigcache);\n-        while (memusage::DynamicUsage(setValid) > nMaxCacheSize)\n-        {\n-            map_type::size_type s = GetRand(setValid.bucket_count());\n-            map_type::local_iterator it = setValid.begin(s);\n-            if (it != setValid.end(s)) {\n-                setValid.erase(*it);\n-            }\n-        }\n-\n-        setValid.insert(entry);\n+        return setValid.setup_bytes(n);\n     }\n };\n \n+// Initialized outisde of VerifySignature to avoid atomic operation per call",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r91412485",
      "id" : 91412485,
      "original_commit_id" : "5ec14c8b4a4d00ee654bb342d3f37f09e0264cfa",
      "original_position" : 88,
      "path" : "src/script/sigcache.cpp",
      "position" : null,
      "pull_request_review_id" : 11921076,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-12-14T21:03:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/91412485",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@sdaftuar, https://github.com/bitcoin/bitcoin/pull/8895/commits/d4294ad41044eb9447de884736e8d45d8387b04f should fix your documentation concerns.\r\n\r\nRE: sigcache unit tests, I could whip something up, but I think it's a little bit hard to test meaningfully (i.e., beyond what other tests using the `CachingTransactionSignatureChecker` already cover) without opening up the anonymous namespace in `script/sigcache.cpp`. We can't detect actual cache hits v.s. misses with just the `CachingTransactionSignatureChecker::VerifySignature` as it just returns a `bool`. As this would require a bit of restructuring, it's probably easiest review that as a separate PR, if needed.",
      "created_at" : "2016-12-12T21:17:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-266555389",
      "id" : 266555389,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-12T21:17:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266555389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Tested ACK 88b58d3, and the comments in d4294ad look good too, thanks.\r\n\r\nRe: sigcache tests, I don't know the best way to address.  If I could come up with a test suite that exercised the logic sufficiently to make changes like this safer, then I'd happily suggest that, but it seems like a hard problem.  Still, after reviewing I'm comfortable enough with this PR to proceed without additional sigcache tests (and it's great that we have tests for the cuckoocache at least).\r\n",
      "created_at" : "2016-12-13T21:07:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-266862211",
      "id" : 266862211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-13T21:07:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266862211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "utACK. Please squash? :)",
      "created_at" : "2016-12-14T06:44:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-266956223",
      "id" : 266956223,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-14T06:44:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/266956223",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa Squashed down to just cache and testing commits.\r\n\r\nunsquashed version preserved at https://github.com/JeremyRubin/bitcoin/tree/cuckoocache-pull-request-unsquashed ",
      "created_at" : "2016-12-14T21:07:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-267156841",
      "id" : 267156841,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-12-14T21:07:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/267156841",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   }
]
