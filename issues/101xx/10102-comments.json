[
   {
      "body" : "Oh. Nice.\r\nI expected much more code to achieve this.\r\n\r\nConceptually I think this goes into the right direction, though, I'm not sure if this could end up being only a temporary in-between step that may end up being replaced.\r\nBecause, it may be more effective to split the Qt/d part completely and let them communicate over the p2p protocol (SPV and eventually RPC). More effective because it would also allow to run Qt independent from a trusted full node (if not trusted, use mechanism like full block SPV, etc.).\r\n\r\nThough, I'm aware that capnp has an RPC layer. But this would introduce another API (RPC / ZMQ / REST and then capnp RPC).\r\n\r\nI'm not saying this is the wrong direction, but we should be careful about adding another API.\r\n\r\nThree questions:\r\n- Would the performance be impractical if we would try to use the existing RPC API?\r\n- Could the capnp approach (or lets say IPC approach) be designed as a (or the) new API (\"JSON RPC v2\" and replacement for ZMQ)?\r\n- Does capnp provide a basic form of authentication? Would that even be required?",
      "created_at" : "2017-03-28T07:38:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289688689",
      "id" : 289688689,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T07:38:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289688689",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "> Would the performance be impractical if we would try to use the existing RPC API?\r\n\r\nReason this is currently using capnp is not performance but convenience. Capnp provides a high level API that supports bidirectional, synchronous, and asynchronous calls out of the box and allows me to easily explore implementation choices in bitcoin-qt without having to worry about low level protocol details, write a lot of parameter packing/unpacking boilerplate, and implement things like long polling.\r\n\r\nCapnp could definitely be replaced by JSON-RPC, though, and I've gone out of my way to support this by not calling capnp functions or using capnp types or headers anywhere except the `ipc/server.cpp` and `ipc/client.cpp` files. No code outside of these two files has to change in order to move to a different protocol.\r\n\r\n> Could the capnp approach (or lets say IPC approach) be designed as a (or the) new API (\"JSON RPC v2\" and replacement for ZMQ)?\r\n\r\nIt could, but I'm going out of my way right now specifically NOT to add yet another bitcoind public API that could add to the JSON-RPC/REST/ZMQ/-blocknotify/-walletnotify confusion. The IPC here doesn't happen over a TCP port or even a unix socket path but over an anonymous [socketpair](http://man7.org/linux/man-pages/man2/socketpair.2.html) using an inherited file descriptor. (I haven't done a windows implementation yet but [similar things](https://msdn.microsoft.com/en-us/library/ms683463(v=VS.85).aspx) are possible there).\r\n\r\nI'm trying to make the change completely internal for now and transparent to users. Bitcoin-qt should still be invoked the same way and behave the same way as before, starting its own node and wallet. It just will happen to do this internally now by forking a bitcoind executable rather than calling in-process functions. \r\n\r\nThis change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. Adding these features and supporting new public APIs might be things we want to do in the future, but they would involve downsides and complications that I'm trying to avoid here.\r\n\r\n> Does capnp provide a basic form of authentication? Would that even be required?\r\n\r\nIt's not required here because this change doesn't expose any new socket or endpoint, but it could be supported. Capnp's security model is based on [capabilities](https://capnproto.org/rpc.html#security), so to add authentication, you would just define a factory function that takes credentials as parameters and returns a reference to an object exposing the appropriate functionality.\r\n\r\n",
      "created_at" : "2017-03-28T09:58:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289721777",
      "id" : 289721777,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T09:58:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289721777",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "I'm really uncomfortable with using capn proto, but fine enough for some example testing stuff!\r\n\r\nI'm a fan of this general approach (ignoring the use of capn proto) and I think we should have done something like it a long time ago.",
      "created_at" : "2017-03-28T17:23:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289842646",
      "id" : 289842646,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T17:23:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289842646",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "strong concept ACK, but if is feasible, would prefer usage of the existing RPC instead of capn'proto",
      "created_at" : "2017-03-28T22:39:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289927205",
      "id" : 289927205,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T22:39:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289927205",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "Concept ACK, nice.\r\n\r\n> I'm really uncomfortable with using capn proto, but fine enough for some example testing stuff!\r\n\r\nPlease, let's not turn this into a discussion of serialization and RPC frameworks. To be honest that's been one of the things that's putting me off of doing work like this. If you want to suggest what framework to use, please make a thorough investigation of what method would be best to use for our specific use case, and propose that, but let's not start throwing random \"I'm not comfortable with X\" comments.\r\n\r\nWe already use google protocol buffers in the GUI for payment requests to in a way that would be the straightforward choice. I'm also happy you didn't choose some XML-based abomonation or ASN.1. But anyhow, not here. For this pull it's fine to use whatever RPC mechanism you're comfortable with. \r\n\r\n> This change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. \r\n\r\nI'm also perfectly fine with keeping the scope here to \"communication between GUI and bitcoind\". This is not the place for introducing another external interface. Might be an option at some point in the future, but for now process isolation is enough motivation.",
      "created_at" : "2017-03-29T06:53:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289999980",
      "id" : 289999980,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-29T07:24:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289999980",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618386"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618386"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yep I guess most of these calls should be turned into async calls and not wait on a response synchronously blocking the GUI. Not necessarily in the first iteration of this, of course.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T08:29:01Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618386",
      "id" : 108618386,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYxODM4Ng==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 273,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29659509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618386",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty nice. So the IPC endpoint exposes multiple \"objects\". It can also expose multiple instances of one class? (e.g. for multiwallet?).",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T08:31:06Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618794",
      "id" : 108618794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYxODc5NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 13,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29659918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618794",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108620012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108620012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should it pass through parameters? Most of the parameters to `bitcoin-qt` will actually be for the daemon. Or will you provide parameters in a later stage through IPC?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T08:37:27Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108620012",
      "id" : 108620012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMDAxMg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 166,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 29661133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108620012",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623210"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623210"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The thread group is completely remote in the case of IPC, isn't it? I guess this entire function should be done differently when IPC is used. E.g. send a `shutdown` command to the core, then have the `shutdownResult` event come from remote as response when done.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T08:52:59Z",
      "diff_hunk" : "@@ -298,9 +303,9 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        Interrupt(threadGroup);\n+        FIXME_IMPLEMENT_IPC(Interrupt(threadGroup));\n         threadGroup.join_all();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623210",
      "id" : 108623210,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMzIxMA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 68,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29664563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623210",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623907"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623907"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How would you handle `uiInterface` in this model, e.g. signals from the server to the client?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T08:56:29Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623907",
      "id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMzkwNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29665337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623907",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108631852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108631852"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Should it pass through parameters? Most of the parameters to bitcoin-qt will actually be for the daemon. Or will you provide parameters in a later stage through IPC?\r\n\r\nThe change I'm working on now (not yet pushed) provides the parameters over IPC. It adds an `ipc::Node::parseParameters` method in `client.h` which calls `ParseParameters()` in bitcoind.\r\n\r\n```diff\r\n+    //! Set command line arguments.\r\n+    void parseParameters(int argc, const char* const argv[]) const;\r\n+\r\n     //! Get help message string.\r\n     std::string helpMessage(HelpMessageMode mode) const;\r\n \r\n+    //! Start node.\r\n+    bool appInit() const;\r\n+\r\n+    //! Stop node.\r\n+    void appShutdown() const;\r\n+\r\n+    //! Return whether shutdown was requested.\r\n+    bool shutdownRequested() const;\r\n```\r\n\r\n`ParseParameters()` is also called on the `bitcoin-qt` side in current change. This gets the job done, but could be improved later, since really the `bitcoind` global variables set by `ParseParameters()` should not even be linked into `bitcoin-qt`.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T09:35:21Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108631852",
      "id" : 108631852,
      "in_reply_to_id" : 108620012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzMTg1Mg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 166,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108631852",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108636959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108636959"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> It can also expose multiple instances of one class?\r\n\r\nYes, the `ipc::Node::wallet()` method right now returns an `ipc::Wallet` interface wrapping pwalletMain, but it could support multiwallet by just adding an argument that indicates a different wallet object to return.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T09:59:11Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108636959",
      "id" : 108636959,
      "in_reply_to_id" : 108618794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzNjk1OQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 13,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108636959",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108637607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108637607"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> The thread group is completely remote in the case of IPC, isn't it?\r\n\r\nYes the change I'm working on now adds `threadGroup` and `scheduler` members to `NodeServer` in `ipc/server.cpp`, removing the current instances in `BitcoinCore`.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T10:02:14Z",
      "diff_hunk" : "@@ -298,9 +303,9 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        Interrupt(threadGroup);\n+        FIXME_IMPLEMENT_IPC(Interrupt(threadGroup));\n         threadGroup.join_all();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108637607",
      "id" : 108637607,
      "in_reply_to_id" : 108623210,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzNzYwNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 68,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108637607",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108640254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108640254"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> How would you handle uiInterface in this model, e.g. signals from the server to the client?\r\n\r\nThis line needs to change to `ipcNode.handleInitMessage(InitMessage)`. If you look at the `ipc::Node::handleInitMessage` implementation, it takes a std::function argument, creates a capnp `InitMessageCallback::Server` object that can invoke it, and sends a reference to that object over the IPC channel to `bitcoind`. `bitcoind` then calls `uiInterface.InitMessage.connect` with a handler that sends messages with the `InitMessageCallback` object.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T10:16:22Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108640254",
      "id" : 108640254,
      "in_reply_to_id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0MDI1NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108640254",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108643836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108643836"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Yep I guess most of these calls should be turned into async calls and not wait on a response synchronously blocking the GUI. Not necessarily in the first iteration of this, of course.\r\n\r\nAnother alternative in some of these cases is to consolidate many low level calls into fewer calls of a higher level interface.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T10:35:58Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108643836",
      "id" : 108643836,
      "in_reply_to_id" : 108618386,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0MzgzNg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 273,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108643836",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think that's not optional but a required element of making this asynchronous, otherwise there'd be a lot of roundtrips.\r\n\r\nEdit: Though ofcourse one of the things cap'n'proto advertises with is that there is 'zero roundtrip overhead', because of the promise pipelining, but we don't want to depend too strongly on that.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T10:58:28Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647650",
      "id" : 108647650,
      "in_reply_to_id" : 108618386,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0NzY1MA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 273,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29690453,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647650",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647949"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Cool. I like this auto-generated IPC stuff. Saves writing a lot of boilerplate.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T11:00:13Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647949",
      "id" : 108647949,
      "in_reply_to_id" : 108618794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0Nzk0OQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 13,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29690788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647949",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108648613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108648613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So the server then effectively calls an object on the client when the notification happens? No polling/waiting involved? That's great.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T11:04:37Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108648613",
      "id" : 108648613,
      "in_reply_to_id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0ODYxMw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29691510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108648613",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108649962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108649962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This locking (either of cs_main or wallet->cs_wallet) makes no sense when a remote core is used.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T11:12:56Z",
      "diff_hunk" : "@@ -679,17 +679,17 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);\n     const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n+    if (!wtx || wtx->isAbandoned() || FIXME_IMPLEMENT_IPC_VALUE(wtx->GetDepthInMainChain()) > 0 || FIXME_IMPLEMENT_IPC_VALUE(wtx->InMempool()))\n         return false;\n     return true;\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->AbandonTransaction(hash);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108649962",
      "id" : 108649962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0OTk2Mg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 258,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29692971,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108649962",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670193"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> So the server then effectively calls an object on the client when the notification happens? No polling/waiting involved? That's great.\r\n\r\nYes, though to be clear, there is still polling/waiting happening under the hood. It just gets handled by the capnp event loop, which waits for incoming IPC messages and dispatches to `InitMessageCallback::Server::call` and other server methods. The change I'm working on now (not yet pushed) spawns a new thread in ipc/client.cpp to run the event loop.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T13:06:38Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670193",
      "id" : 108670193,
      "in_reply_to_id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDE5Mw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670193",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670537"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI this is quite similar to how fd handles are passed in for the P2P and RPC port in my cloudabi port: https://github.com/laanwj/bitcoin/blob/2017_03_cabi_fs/src/httpserver.cpp#L357 https://github.com/laanwj/bitcoin/blob/2017_03_cabi_fs/src/init.cpp#L1356\r\n\r\nIt's a bit of a shame that argument parsing doesn't work here yet so this needs to use manual parsing using C functions :/",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T13:08:25Z",
      "diff_hunk" : "@@ -0,0 +1,102 @@\n+#include \"ipc/server.h\"\n+\n+#include \"init.h\"\n+#include \"ui_interface.h\"\n+#include \"wallet/wallet.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/async-io.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+class HandlerServer final : public messages::Handler::Server\n+{\n+public:\n+    HandlerServer(kj::AsyncIoContext& ioContext_, messages::InitMessageCallback::Client callback_)\n+        : ioContext(ioContext_),\n+          callback(std::move(callback_)),\n+          connection(uiInterface.InitMessage.connect(\n+              [this](const std::string& message) {\n+                  auto request = callback.callRequest();\n+                  request.setMessage(message);\n+                  auto promise = request.send();\n+                  promise.wait(ioContext.waitScope);\n+              })) {}\n+\n+    kj::Promise<void> disconnect(DisconnectContext context) override\n+    {\n+        connection.disconnect();\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+\n+    messages::InitMessageCallback::Client callback;\n+    boost::signals2::scoped_connection connection;\n+};\n+\n+class WalletServer final : public messages::Wallet::Server\n+{\n+public:\n+    WalletServer(CWallet& wallet_) : wallet(wallet_) {}\n+\n+    kj::Promise<void> getBalance(GetBalanceContext context) override\n+    {\n+        context.getResults().setValue(wallet.GetBalance());\n+        return kj::READY_NOW;\n+    }\n+\n+    CWallet& wallet;\n+};\n+\n+class NodeServer final : public messages::Node::Server\n+{\n+public:\n+    NodeServer(kj::AsyncIoContext& ioContext_) : ioContext(ioContext_) {}\n+    kj::Promise<void> helpMessage(HelpMessageContext context) override\n+    {\n+        context.getResults().setValue(HelpMessage(HelpMessageMode(context.getParams().getMode())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> handleInitMessage(HandleInitMessageContext context) override\n+    {\n+        context.getResults().setHandler(ipc::messages::Handler::Client(kj::heap<HandlerServer>(ioContext, context.getParams().getCallback())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> wallet(WalletContext context) override\n+    {\n+        context.getResults().setWallet(ipc::messages::Wallet::Client(kj::heap<WalletServer>(*pwalletMain)));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+};\n+\n+} // namespace\n+\n+bool StartServer(int argc, char* argv[], int& exitStatus)\n+{\n+    if (argc != 3 || strcmp(argv[1], \"-ipcfd\") != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670537",
      "id" : 108670537,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDUzNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 89,
      "path" : "src/ipc/server.cpp",
      "position" : null,
      "pull_request_review_id" : 29715391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670537",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670851"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> This locking (either of cs_main or wallet->cs_wallet) makes no sense when a remote core is used.\r\n\r\nYeah, the point of the FIXME_IMPLEMENT_IPC macro is really just to segfault and indicate places in the code which need to be updated to support IPC. Many of them are pretty nonsensical.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T13:09:53Z",
      "diff_hunk" : "@@ -679,17 +679,17 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);\n     const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n+    if (!wtx || wtx->isAbandoned() || FIXME_IMPLEMENT_IPC_VALUE(wtx->GetDepthInMainChain()) > 0 || FIXME_IMPLEMENT_IPC_VALUE(wtx->InMempool()))\n         return false;\n     return true;\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->AbandonTransaction(hash);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670851",
      "id" : 108670851,
      "in_reply_to_id" : 108649962,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDg1MQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 258,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670851",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108671594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108671594"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> It's a bit of a shame that argument parsing doesn't work here yet so this needs to use manual parsing using C functions :/\r\n\r\nI think I could change this to at least use GetArg like you are doing in your cloudabi code.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-29T13:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,102 @@\n+#include \"ipc/server.h\"\n+\n+#include \"init.h\"\n+#include \"ui_interface.h\"\n+#include \"wallet/wallet.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/async-io.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+class HandlerServer final : public messages::Handler::Server\n+{\n+public:\n+    HandlerServer(kj::AsyncIoContext& ioContext_, messages::InitMessageCallback::Client callback_)\n+        : ioContext(ioContext_),\n+          callback(std::move(callback_)),\n+          connection(uiInterface.InitMessage.connect(\n+              [this](const std::string& message) {\n+                  auto request = callback.callRequest();\n+                  request.setMessage(message);\n+                  auto promise = request.send();\n+                  promise.wait(ioContext.waitScope);\n+              })) {}\n+\n+    kj::Promise<void> disconnect(DisconnectContext context) override\n+    {\n+        connection.disconnect();\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+\n+    messages::InitMessageCallback::Client callback;\n+    boost::signals2::scoped_connection connection;\n+};\n+\n+class WalletServer final : public messages::Wallet::Server\n+{\n+public:\n+    WalletServer(CWallet& wallet_) : wallet(wallet_) {}\n+\n+    kj::Promise<void> getBalance(GetBalanceContext context) override\n+    {\n+        context.getResults().setValue(wallet.GetBalance());\n+        return kj::READY_NOW;\n+    }\n+\n+    CWallet& wallet;\n+};\n+\n+class NodeServer final : public messages::Node::Server\n+{\n+public:\n+    NodeServer(kj::AsyncIoContext& ioContext_) : ioContext(ioContext_) {}\n+    kj::Promise<void> helpMessage(HelpMessageContext context) override\n+    {\n+        context.getResults().setValue(HelpMessage(HelpMessageMode(context.getParams().getMode())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> handleInitMessage(HandleInitMessageContext context) override\n+    {\n+        context.getResults().setHandler(ipc::messages::Handler::Client(kj::heap<HandlerServer>(ioContext, context.getParams().getCallback())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> wallet(WalletContext context) override\n+    {\n+        context.getResults().setWallet(ipc::messages::Wallet::Client(kj::heap<WalletServer>(*pwalletMain)));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+};\n+\n+} // namespace\n+\n+bool StartServer(int argc, char* argv[], int& exitStatus)\n+{\n+    if (argc != 3 || strcmp(argv[1], \"-ipcfd\") != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108671594",
      "id" : 108671594,
      "in_reply_to_id" : 108670537,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MTU5NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 89,
      "path" : "src/ipc/server.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108671594",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085466"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085466"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, ideally bitcoin-qt would need only a very small subset of the bitcoind code.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-31T04:19:04Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085466",
      "id" : 109085466,
      "in_reply_to_id" : 108620012,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwOTA4NTQ2Ng==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 166,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 30164009,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085466",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, I understand that, but one of the problems with existing proposals for using RPC to communicate to the server had no way to handle asynchonous notifications, so needed to e.g. poll for new transactions every few seconds. This protocol clearly does support true bidirectional communication.\r\n\r\nAs for the capnp event loop, as most of the responses and notifications from the server involve updating the UI, couldn't we integrate that into Qt's event loop? Conceptually that'd be easier. Qt only allows GUI updates from a single thread, so if the capnp event loop is separete, everything will have to be separately ferried through Qt's signal mechanism to get to the GUI thread.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-03-31T04:23:28Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085760",
      "id" : 109085760,
      "in_reply_to_id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwOTA4NTc2MA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 30164306,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085760",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r110290288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/110290288"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> As for the capnp event loop, as most of the responses and notifications from the server involve updating the UI, couldn't we integrate that into Qt's event loop? \r\n\r\nIt should be possible to integrate the qt and capnp event loops (http://stackoverflow.com/questions/33131595/what-is-a-good-way-to-integrate-3rd-party-asynchronous-apis-with-capn-proto-rpc), but for now `StartClient` is just spawning an event loop thread, since this seems like the path of least resistance.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2017-04-06T23:34:25Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r110290288",
      "id" : 110290288,
      "in_reply_to_id" : 108623907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExMDI5MDI4OA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_position" : 142,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 31454791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/110290288",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Updated and rebased 0ca73bc13c3457cd5c3244abfa9fa586d9137117 -> 5e28c2fcc2757479d29ca83cd3256584ab908e48 ([pr/ipc.1](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.1) -> [pr/ipc.3](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.3)) to avoid a conflict. Main addition is an expanded [src/ipc/README.md](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/src/ipc/README.md) file.\r\n\r\nAgain it would be very helpful to have some code review for the main commit (5e28c2fcc2757479d29ca83cd3256584ab908e48 \"Add barebones IPC framework to bitcoin-qt and bitcoind\"). Giving feedback on the README file would be an easy place to start.",
      "created_at" : "2017-04-07T20:51:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-292648484",
      "id" : 292648484,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-10T22:06:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/292648484",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Updated 5e28c2fcc2757479d29ca83cd3256584ab908e48 -> dda375662d060ce42b5113247301e0289584e14d ([pr/ipc.3](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.3) -> [pr/ipc.4](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.4))\r\n\r\nThis implements two suggestions from @JeremyRubin:\r\n\r\n* It includes a small commit demonstrating what it looks like to add a single new method to the API:\r\n[`dda3756 Add ipc::Node::getNodeCount method`](https://github.com/bitcoin/bitcoin/commit/dda375662d060ce42b5113247301e0289584e14d). This should help give a clearer picture of the layers involved in implementing an IPC call.\r\n\r\n* Instead of adding Cap'n Proto code and modifying Qt code in a single commit, it includes a new early commit ([`1407a2b Add ipc::Node and ipc::Wallet interfaces`](https://github.com/bitcoin/bitcoin/commit/1407a2bb0b0a3ab21ae374b58980bb0dc53b12c5) that introduces new [`src/ipc/interfaces.h`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/interfaces.h)  and [`src/ipc/interfaces.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/interfaces.cpp) files and ports Qt code to use them without any Cap'n Proto stuff. This shows the separation between Qt updates and IPC implementation details better and makes it easier to see how a different IPC system could be substituted in for Cap'n Proto. This commit could even be made into a separate PR.\r\n",
      "created_at" : "2017-04-10T22:25:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-293096821",
      "id" : 293096821,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-10T22:25:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/293096821",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "@laanwj pointed out in IRC (https://botbot.me/freenode/bitcoin-core-dev/msg/83983170/) that this change could help make the GUI more responsive by preventing Qt event processing from getting blocked, which currently happens in the monolithic `bitcoin-qt` when the main GUI thread makes a call to a slow libbitcoin function, or waits a long time for a `cs_main` or `cs_wallet` lock.\r\n\r\nAt the time in IRC, I didn't think this change could directly help gui responsiveness, because although it does move libbitcoin and LOCK calls out of the `bitcoin-qt` process and into the `bitcoind` process, it just replaces these calls with blocking IPCs that make the GUI equally unresponsive when they tie up the main GUI thread.\r\n\r\nHowever, this doesn't have to be the case. The place where IPC calls currently block waiting for responses is the `return promise.get_future().get();` line in `ipc::util::Call::send` method here: https://github.com/ryanofsky/bitcoin/blob/pr/ipc.4/src/ipc/util.h#L166\r\n\r\nBut the `std::promise` object used in that line could easily be replaced with a Qt-aware promise object that processes GUI events while the promise is blocked. (The Qt-aware promise implementation would check if it is being used on the main GUI thread, and if so use a [local Qt event loop](https://doc.qt.io/archives/qq/qq27-responsive-guis.html#waitinginalocaleventloop) substituting\r\n`loop.exec()` for `std::future::get()` and `loop.quit()` for `std::promise::set_value()`.)\r\n\r\nThis would add more overhead and make the average IPC call a little slower. But it would avoid situations where an unexpectedly slow IPC call ties up the whole gui, so it might be worth doing anyway.",
      "created_at" : "2017-04-14T05:44:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294094610",
      "id" : 294094610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-14T05:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294094610",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "@ryanofsky Yes, integrating the IPC event loop and Qt event loop would help responsiveness.\r\nThough I remember there were some issues in some cases with recursively calling into the Qt event loop (e.g. things need to be reentrant, deleteLater stuff runs earlier than expected, to keep in mind).",
      "created_at" : "2017-04-14T08:00:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294111566",
      "id" : 294111566,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-14T08:00:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294111566",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@ryanofsky I'm not familiar with Qt or capnproto, but I don't understand what the move to a different process has to do with making things less blocking. Any changes in architecture that would result in less blocks should equally be possible within the same process.\r\n\r\n",
      "created_at" : "2017-04-17T12:23:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294474620",
      "id" : 294474620,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T12:23:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294474620",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> This change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. Adding these features and supporting new public APIs might be things we want to do in the future, but they would involve downsides and complications that I'm trying to avoid here.\r\n\r\nI don't understand the goal here. On itself, there seems little benefit in separating the GUI and the rest into separate processes if those two processes still depend on each other (this is different from separating the wallet from the node, for example, as there as security considerations there... but for that use case the easiest approach seems to just have a lightweight mode and running two instances).\r\n\r\nI think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background, but if that's not the intent, what is the purpose?",
      "created_at" : "2017-04-17T12:29:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294475317",
      "id" : 294475317,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T12:29:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294475317",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> Any changes in architecture that would result in less blocks should equally be possible within the same process.\r\n\r\nLet's say there are 50 places where bitcoin-qt calls a libbitcoin function. That means there are 50 places to update if you want bitcoin-qt handle to events while the function calls are executing. WIth the IPC framework, there is only one place you have to update instead of 50 places (if you want to do this).\r\n\r\n> On itself, there seems little benefit in separating the GUI and the rest into separate processes if those two processes still depend on each other.\r\n\r\nOk, so you think the benefits are small, and I think they are more significant.\r\n\r\n> I think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background,\r\n\r\nThis is trivial once bitcoin-qt is controlling bitcoind across a socket. I'm just implementing the socket part first, without introducing new UI features for now.",
      "created_at" : "2017-04-17T14:15:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294493467",
      "id" : 294493467,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T14:15:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294493467",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "> > I think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background,\r\n>\r\n> This is trivial once bitcoin-qt is controlling bitcoind across a socket. I'm just implementing the socket part first, without introducing new UI features for now.\r\n\r\nOk, that's what I was missing. It wasn't clear to me that this was a just first step towards a more useful separation.",
      "created_at" : "2017-04-17T18:48:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294557349",
      "id" : 294557349,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T18:48:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294557349",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "As of 8f78f085976bcb0f9093f0b1b4c3c65110ec44aa ([pr/ipc.7](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.7)), this change is much more complete & functional. You can also now monitor the IPC traffic going back and forth between `bitcoin-qt` and `bitcoind` by setting the `IPC_DEBUG` environment variable (`export IPC_DEBUG=1`)\r\n",
      "created_at" : "2017-04-27T18:01:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-297792312",
      "id" : 297792312,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-27T18:01:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/297792312",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r209425169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209425169"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For MacOS it's `brew install capnp` ",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-08-11T12:05:19Z",
      "diff_hunk" : "@@ -105,7 +105,7 @@ To build without GUI pass `--without-gui`.\n \n To build with Qt 5 you need the following:\n \n-    sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler\n+    sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler libcapnp-dev capnproto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r209425169",
      "id" : 209425169,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTQyNTE2OQ==",
      "original_commit_id" : "006286e7310353fbfd143f69e9a319b24bd49e75",
      "original_position" : 5,
      "path" : "doc/build-unix.md",
      "position" : 5,
      "pull_request_review_id" : 145444882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209425169",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated 85b23296891032875cbda7a3c70c3422ce04da15 -> 84af92e496f00608dff749e7b1372964cb20df42 ([pr/ipc.46](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.46) -> [pr/ipc.47](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.47)) with various cleanups and fixes for macos.\r\nUpdated 84af92e496f00608dff749e7b1372964cb20df42 -> ca294aa8c036bf62d808450a4555a0806ff7227b ([pr/ipc.47](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.47) -> [pr/ipc.48](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.48)) with fixes for appveyor / msvc.\r\n\r\n\r\nThanks for trying this out Sjors. The compiler errors & warnings you encountered should be fixed now, and I did some light ui testing on macos with `src/bitcoin-gui -regtest -printtoconsole -debug`\r\n\r\n",
      "created_at" : "2018-08-21T19:33:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-414794955",
      "id" : 414794955,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNDc5NDk1NQ==",
      "updated_at" : "2018-08-22T22:30:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/414794955",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Compile errors are gone now.\r\n\r\nThe `multiprocess=yes/no` line in `./configure` only showed up for me after running `./autogen.sh` again. This was without using the `--enable-multiprocess` argument.\r\n\r\nThe documentation suggests multiprocess isn't on by default, but it is:\r\n\r\n```\r\n./configure --disable-bench --disable-zmq --with-miniupnpc=no --with-incompatible-bdb --with-qrencode\r\n....\r\nOptions used to compile and link:\r\n  multiprocess  = yes\r\n```\r\n\r\nI do still see a few warnings that appear related to this change:\r\n\r\n```\r\ninterfaces/capnp/util.cpp:15:90: warning: 'syscall' is deprecated: first deprecated in macOS 10.12 - syscall(2) is unsupported; please switch to a supported interface. For SYS_kdebug_trace use kdebug_signpost(). [-Wdeprecated-declarations]\r\n    return strprintf(\"%s-%i/%s-%i\", exe_name ? exe_name : \"\", getpid(), thread_name, int(syscall(SYS_gettid)));\r\n                                                                                         ^\r\n/usr/include/unistd.h:745:6: note: 'syscall' has been explicitly marked deprecated here\r\nint      syscall(int, ...);\r\n         ^\r\n1 warning generated.\r\n```\r\n\r\nShould the test suite use these new binaries? In order to prevent the functional suite from taking forever to run, perhaps half of the default test suite nodes could use `bitcoind` and the other half `bitcoin-node`?\r\n\r\nThe `bitcoin-gui` executable is ignoring `testnet=1` in `bitcoin.conf`. `bitcoin-node` does honor it. When launched with `-testnet` it  correctly sees global options in `bitcoin.conf`., but it missed or incorrectly parses  options for `[test]`. E.g. if I set `dbcache=1000` under `[test]` the GUI shows this:\r\n\r\n<img width=\"383\" alt=\"schermafbeelding 2018-08-26 om 12 07 44\" src=\"https://user-images.githubusercontent.com/10217/44627135-d741cd80-a928-11e8-9c1a-c73151ab8da9.png\">\r\n\r\nShould the log file specify which process is generating each entry? Or should each process have its own log file, where the master process just logs \"started/stopped bitcoin-node process PID=....\"?\r\n\r\nI did some light GUI testing as well. Sending and receiving works. Using the console I'm getting the following error:\r\n\r\n<img width=\"594\" alt=\"schermafbeelding 2018-08-26 om 12 17 01\" src=\"https://user-images.githubusercontent.com/10217/44627206-060c7380-a92a-11e8-9cfe-84842cff0f66.png\">\r\n\r\n`getblockchaininfo` and even `getbalance` do work, so that's weird.\r\n\r\n`createwallet \"test\"` froze the app for me, and didn't create a file. When force quitting QT, it seems bitcoin-node keeps running. But then `bitcoin-cli help` just hangs. `bitcoin-cli stop` responds with `Bitcoin server stopping` but nothing happens in the log file and the process doesn't go away; I had to resort to `kill -9`.",
      "created_at" : "2018-08-26T10:26:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416028413",
      "id" : 416028413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjAyODQxMw==",
      "updated_at" : "2018-08-26T10:26:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416028413",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors, this is great! Thanks so much for testing this.\r\n\r\n> The documentation suggests multiprocess isn't on by default, but it is:\r\n\r\nSince `--enable-multiprocess` configure option only builds new executables and has no effect on existing ones, the default value is `auto` rather than `no`. This seems like the most convenient behavior, but I coudl change it or try to document it better.\r\n\r\n> I do still see a few warnings that appear related to this change:\r\n\r\nI also saw the syscall warning and plan to fix it. It's not serious problem, but a side effect seems to be that bad thread numbers are shown in the debug log.\r\n\r\n> Should the test suite use these new binaries? In order to prevent the functional suite from taking forever to run, perhaps half of the default test suite nodes could use bitcoind and the other half bitcoin-node?\r\n\r\nI'm planning on adding `--multiprocess` and `--gui` options to the python test framework to make it easier to switch between `bitcoin`, `bitcoin-qt`, `bitcoin-node`, and `bitcoin-gui` executables. All 4 of these should work, though some tests fail with `bitcoin-node` right now. I think default test mode should use `bitcoind` but travis should be configured to test other binaries, too.\r\n\r\n> The bitcoin-gui executable is ignoring testnet=1 in bitcoin.conf. bitcoin-node does honor it. When launched with -testnet it correctly sees global options in bitcoin.conf., but it missed or incorrectly parses options for [test].\r\n\r\nInteresting, this is not expected. Will debug.\r\n\r\n> Should the log file specify which process is generating each entry? Or should each process have its own log file, where the master process just logs \"started/stopped bitcoin-node process PID=....\"?\r\n\r\nEach process has its own log file and I extended the `combine_logs.py` script to be able to merge them. The log files just have simple suffixes right now so are named `debug.log` `debug.log.wallet` and `debug.log.gui`. The followup change I'm working on to add `-ipconnect` and `-ipcbind` options will allow multiple wallet and gui processes, so these names will no longer be unique and I'll have to add pid suffixes as well.\r\n\r\nWriting to a common log file would be another option, but it would require some kind of locking and syncing, so I don't think the complexity would be worth it.\r\n\r\n> I did some light GUI testing as well.\r\n\r\nThanks! I'll look into the various problems you reported and make fixes.",
      "created_at" : "2018-08-27T14:50:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416252818",
      "id" : 416252818,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjI1MjgxOA==",
      "updated_at" : "2018-08-27T14:50:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416252818",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I think default test mode should use bitcoind but travis should be configured to test other binaries, too.\r\n\r\nThat makes sense, we shouldn't force developers / users to compile the other binaries.\r\n\r\n> Writing to a common log file would be another option, but it would require some kind of locking and syncing, so I don't think the complexity would be worth it.\r\n\r\nMultiple log files seems fine by me, though when logging to console they would ideally be combined.",
      "created_at" : "2018-08-28T11:00:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416543491",
      "id" : 416543491,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjU0MzQ5MQ==",
      "updated_at" : "2018-08-28T11:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416543491",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: bookeeping",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-02T18:27:24Z",
      "diff_hunk" : "@@ -4,14 +4,16 @@ The following interfaces are defined here:\n \n * [`Chain`](chain.h)  used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`Chain::Client`](chain.h)  used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h)  used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n * [`Node`](node.h)  used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Wallet`](wallet.h)  used by GUI to access wallets. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Handler`](handler.h)  returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n \n-* [`Init`](init.h)  used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+* [`Init`](init.h)  used by multiprocess code to access other interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+\n+* [`Base`](base.h)  base interface class used by multiprocess code for bookeeping and cleanup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549056",
      "id" : 214549056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA1Ng==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 16,
      "path" : "src/interfaces/README.md",
      "position" : null,
      "pull_request_review_id" : 151629161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549056",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549080"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: destuction",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-02T18:28:32Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549080",
      "id" : 214549080,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA4MA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 44,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151629183,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549080",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549093"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549093"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: dont should be dont or do not :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-02T18:29:13Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549093",
      "id" : 214549093,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA5Mw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 46,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151629200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549093",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: halfs should be halves :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-02T18:30:30Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halfs at position index.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549127",
      "id" : 214549127,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTEyNw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 71,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 151629222,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549127",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741787"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741787"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: paramters",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-03T18:00:33Z",
      "diff_hunk" : "@@ -0,0 +1,61 @@\n+- [ ] BA rename X.name to X.client or (X.impl/X.classMethod/X.callsMethod/X.wraps/X.serverName) and change X.name modifier to affect both client & server declarations instead of just server to remove ChainNotifications client overloads\n+- [ ] BB Get rid of FunctionTraits::Fields, ProxyMethodTraits::Fields move to ClientInvoke\n+- [ ] BC unify readfield forms. can have single ReadDest class with ReadDest::Return typedef, with ReadField taking ReadDest, RestDestArg... arguments and returning ReadDest::Construct(constructor arg, ReadDestArg...) and Return type either being real destination type or a proxy that emplaces into a vector, or a proxy that updates an existing variable\n+   - could have ReadDest::Update(lambda) where lambda takes reference argument to object, this allows reading & updating for object types that can't be initialized by constructor. e.g. maps, sets, structs without unserializing constructors\n+   - designgoal is just to have one ReadField per type, not confusing mix of readfieldupdate/emplace and maze of overloads to fall back to one when another isn't available\n+   - other goal is to support return types. however i think this may be only useful for client side return values. server side value initialization in PassField could potentially use it to get rid of boost::optional, but this relies of type having move / copy constructor, even if it would be elided, and no guarantee of this for paramters",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741787",
      "id" : 214741787,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDc0MTc4Nw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 6,
      "path" : "src/interfaces/capnp/FIXME",
      "position" : null,
      "pull_request_review_id" : 151858055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741787",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: avaiable",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-03T18:02:09Z",
      "diff_hunk" : "@@ -0,0 +1,1559 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map;\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is avaiable.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741922",
      "id" : 214741922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDc0MTkyMg==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 779,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 151858200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741922",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214813508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214813508"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Couldn't `loop_ptr` potentially be a dead pointer here?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T07:38:55Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in\n+        // right sequence. Instead with this shutdown they get deleted in\n+        // EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+std::unique_ptr<interfaces::Init> SocketConnect(const char* exe_name, int fd)\n+{\n+    std::promise<messages::Init::Client> init_promise;\n+    EventLoop* loop_ptr = nullptr;\n+    std::thread thread([&]() {\n+        RenameThread(\"capnp-connect\");\n+        EventLoop loop(exe_name, std::move(thread));\n+        loop_ptr = &loop;\n+        auto connection = MakeUnique<Connection>(loop, fd);\n+        loop.m_task_set.add(connection->m_network.onDisconnect().then([&loop]() {\n+            LogIpc(loop, \"IPC client: unexpected network disconnect, shutting down.\");\n+            loop.shutdown();\n+        }));\n+        init_promise.set_value(connection->m_rpc_client.bootstrap(ServerVatId().vat_id).castAs<messages::Init>());\n+        loop.loop();\n+    });\n+    auto&& client = init_promise.get_future().get();\n+    auto proxy = MakeUnique<ProxyClient<messages::Init>>(kj::mv(client), *loop_ptr);\n+    proxy->addCloseHook(MakeUnique<ShutdownLoop>(*loop_ptr));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214813508",
      "id" : 214813508,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDgxMzUwOA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 73,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151943005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214813508",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949434"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T14:58:28Z",
      "diff_hunk" : "@@ -4,14 +4,16 @@ The following interfaces are defined here:\n \n * [`Chain`](chain.h)  used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`Chain::Client`](chain.h)  used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h)  used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n * [`Node`](node.h)  used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Wallet`](wallet.h)  used by GUI to access wallets. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Handler`](handler.h)  returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n \n-* [`Init`](init.h)  used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+* [`Init`](init.h)  used by multiprocess code to access other interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+\n+* [`Base`](base.h)  base interface class used by multiprocess code for bookeeping and cleanup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949434",
      "id" : 214949434,
      "in_reply_to_id" : 214549056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk0OTQzNA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 16,
      "path" : "src/interfaces/README.md",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949434",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949796"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949796"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T14:59:18Z",
      "diff_hunk" : "@@ -0,0 +1,61 @@\n+- [ ] BA rename X.name to X.client or (X.impl/X.classMethod/X.callsMethod/X.wraps/X.serverName) and change X.name modifier to affect both client & server declarations instead of just server to remove ChainNotifications client overloads\n+- [ ] BB Get rid of FunctionTraits::Fields, ProxyMethodTraits::Fields move to ClientInvoke\n+- [ ] BC unify readfield forms. can have single ReadDest class with ReadDest::Return typedef, with ReadField taking ReadDest, RestDestArg... arguments and returning ReadDest::Construct(constructor arg, ReadDestArg...) and Return type either being real destination type or a proxy that emplaces into a vector, or a proxy that updates an existing variable\n+   - could have ReadDest::Update(lambda) where lambda takes reference argument to object, this allows reading & updating for object types that can't be initialized by constructor. e.g. maps, sets, structs without unserializing constructors\n+   - designgoal is just to have one ReadField per type, not confusing mix of readfieldupdate/emplace and maze of overloads to fall back to one when another isn't available\n+   - other goal is to support return types. however i think this may be only useful for client side return values. server side value initialization in PassField could potentially use it to get rid of boost::optional, but this relies of type having move / copy constructor, even if it would be elided, and no guarantee of this for paramters",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949796",
      "id" : 214949796,
      "in_reply_to_id" : 214741787,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk0OTc5Ng==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 6,
      "path" : "src/interfaces/capnp/FIXME",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949796",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950179"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T15:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950179",
      "id" : 214950179,
      "in_reply_to_id" : 214549080,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1MDE3OQ==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 44,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950179",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T15:00:25Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950248",
      "id" : 214950248,
      "in_reply_to_id" : 214549093,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1MDI0OA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 46,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950248",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214957918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214957918"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T15:18:54Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halfs at position index.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214957918",
      "id" : 214957918,
      "in_reply_to_id" : 214549127,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1NzkxOA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 71,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214957918",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214958407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214958407"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Couldn't loop_ptr potentially be a dead pointer here?\r\n\r\nGood catch. It could happen if socket was immediately disconnected. Moved onDisconnect handler down to fix this.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-04T15:20:11Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in\n+        // right sequence. Instead with this shutdown they get deleted in\n+        // EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+std::unique_ptr<interfaces::Init> SocketConnect(const char* exe_name, int fd)\n+{\n+    std::promise<messages::Init::Client> init_promise;\n+    EventLoop* loop_ptr = nullptr;\n+    std::thread thread([&]() {\n+        RenameThread(\"capnp-connect\");\n+        EventLoop loop(exe_name, std::move(thread));\n+        loop_ptr = &loop;\n+        auto connection = MakeUnique<Connection>(loop, fd);\n+        loop.m_task_set.add(connection->m_network.onDisconnect().then([&loop]() {\n+            LogIpc(loop, \"IPC client: unexpected network disconnect, shutting down.\");\n+            loop.shutdown();\n+        }));\n+        init_promise.set_value(connection->m_rpc_client.bootstrap(ServerVatId().vat_id).castAs<messages::Init>());\n+        loop.loop();\n+    });\n+    auto&& client = init_promise.get_future().get();\n+    auto proxy = MakeUnique<ProxyClient<messages::Init>>(kj::mv(client), *loop_ptr);\n+    proxy->addCloseHook(MakeUnique<ShutdownLoop>(*loop_ptr));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214958407",
      "id" : 214958407,
      "in_reply_to_id" : 214813508,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1ODQwNw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_position" : 73,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214958407",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The bitcoin-gui executable is ignoring testnet=1 in bitcoin.conf\r\n\r\nThis is fixed now. It was caused by a bad rebase of this PR, which neglected to call `SetupServerArgs` in the gui process after it was introduced in #13190.\r\n\r\nUpdated 8d3df50476fa2f96cf2910238e5a2b3f8380b6e1 -> 5ce9a948c8ec47762d0a23d1cf7f2ce57386052b ([pr/ipc.54](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.54) -> [pr/ipc.55](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.55)) to add missing `SetupServerArgs` call.",
      "created_at" : "2018-09-05T14:53:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-418760970",
      "id" : 418760970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODc2MDk3MA==",
      "updated_at" : "2018-09-05T14:53:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418760970",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215417703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215417703"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`chainParams` unused?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-05T20:38:31Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215417703",
      "id" : 215417703,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQxNzcwMw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_position" : 300,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152678934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215417703",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215418823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215418823"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "perhaps change `int` to `size_t` to prevent comparison of integers with different sign warning?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-05T20:42:21Z",
      "diff_hunk" : "@@ -759,22 +763,44 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+// Wrapper to help add a single coin to CCoinsViewCache.\n+class CoinFill : private CCoinsView\n+{\n+public:\n+    CoinFill(CCoinsViewCache& cache, const COutPoint &output, Coin&& coin, CCoinsView &backend) : m_cache(cache), m_output(output), m_coin(std::move(coin)), m_backend(backend) {\n+        m_cache.SetBackend(*this);\n+        m_cache.AccessCoin(output);\n+    }\n+    ~CoinFill() {\n+        m_cache.SetBackend(m_backend);\n+    }\n+\n+    private:\n+    bool GetCoin(const COutPoint &output, Coin &coin) const override {\n+        assert(output == m_output);\n+        coin = std::move(m_coin);\n+        return true;\n+    }\n+    CCoinsViewCache& m_cache;\n+    const COutPoint& m_output;\n+    Coin&& m_coin;\n+    CCoinsView& m_backend;\n+};\n+\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n {\n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n+        std::vector<COutPoint> outputs;\n         for (const CTxIn& txin : mtx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+            outputs.emplace_back(txin.prevout);\n+        }\n+        std::vector<Coin> coins = chain.findCoins(outputs);\n+        for (int i = 0; i < coins.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215418823",
      "id" : 215418823,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQxODgyMw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_position" : 64,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 152680391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215418823",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423173"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> chainParams unused?\r\n\r\nWill fix, but this is part of the base PR #10973 (cb0c6b42a096980152a467b98f3c1250f62d4e7e), so it would be better to comment on that PR.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-05T20:57:04Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423173",
      "id" : 215423173,
      "in_reply_to_id" : 215417703,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyMzE3Mw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_position" : 300,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152685908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423173",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423702"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423702"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> perhaps change int to size_t to prevent comparison of integers with different sign warning?\r\n\r\nWill fix, but this change is part of the base PR #10973 (249bf5006184f81d77d40ee0ede0924c628bf33e), so it would be better to comment on that PR.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-05T20:58:49Z",
      "diff_hunk" : "@@ -759,22 +763,44 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+// Wrapper to help add a single coin to CCoinsViewCache.\n+class CoinFill : private CCoinsView\n+{\n+public:\n+    CoinFill(CCoinsViewCache& cache, const COutPoint &output, Coin&& coin, CCoinsView &backend) : m_cache(cache), m_output(output), m_coin(std::move(coin)), m_backend(backend) {\n+        m_cache.SetBackend(*this);\n+        m_cache.AccessCoin(output);\n+    }\n+    ~CoinFill() {\n+        m_cache.SetBackend(m_backend);\n+    }\n+\n+    private:\n+    bool GetCoin(const COutPoint &output, Coin &coin) const override {\n+        assert(output == m_output);\n+        coin = std::move(m_coin);\n+        return true;\n+    }\n+    CCoinsViewCache& m_cache;\n+    const COutPoint& m_output;\n+    Coin&& m_coin;\n+    CCoinsView& m_backend;\n+};\n+\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n {\n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n+        std::vector<COutPoint> outputs;\n         for (const CTxIn& txin : mtx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+            outputs.emplace_back(txin.prevout);\n+        }\n+        std::vector<Coin> coins = chain.findCoins(outputs);\n+        for (int i = 0; i < coins.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423702",
      "id" : 215423702,
      "in_reply_to_id" : 215418823,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyMzcwMg==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_position" : 64,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 152686532,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423702",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215424411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215424411"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah sorry. Will leave any new comments there.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-09-05T21:01:23Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215424411",
      "id" : 215424411,
      "in_reply_to_id" : 215417703,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyNDQxMQ==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_position" : 300,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152687429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215424411",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> createwallet \"test\" froze the app for me\r\n\r\nThis is fixed in pr/ipc.56",
      "created_at" : "2018-09-06T18:57:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-419204728",
      "id" : 419204728,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxOTIwNDcyOA==",
      "updated_at" : "2018-09-26T20:57:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/419204728",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "help\r\ngcc 7.3.0:\r\n```\r\n  CXX      interfaces/capnp/libbitcoin_util_a-messages.o\r\nIn file included from ../../src/interfaces/capnp/proxy.h:6:0,\r\n                 from ../../src/interfaces/capnp/messages.h:5,\r\n                 from ./interfaces/capnp/messages.capnp.proxy.h:6,\r\n                 from ../../src/interfaces/capnp/messages-impl.h:9,\r\n                 from ../../src/interfaces/capnp/messages.cpp:1:\r\n../../src/interfaces/capnp/proxy.h: In instantiation of struct interfaces::capnp::ListOutput<capnp::List<interfaces::capnp::messages::Pair<capnp::Text, capnp::List<capnp::Text> > > >:\r\n../../src/interfaces/capnp/proxy-impl.h:945:13:   required from void interfaces::capnp::BuildField(interfaces::capnp::TypeList<std::map<K, V, std::less<_Key>, std::allocator<std::pair<const _Key, _Tp> > > >, interfaces::capnp::Priority<1>, interfaces::capnp::InvokeContext&, Value&&, Output&&) [with KeyLocalType = std::__cxx11::basic_string<char>; ValueLocalType = std::vector<std::__cxx11::basic_string<char> >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]\r\n../../src/interfaces/capnp/proxy-impl.h:1060:15:   required from void interfaces::capnp::BuildField(interfaces::capnp::TypeList<const LocalType>, interfaces::capnp::Priority<0>, interfaces::capnp::InvokeContext&, Value&&, Output&&) [with LocalType = std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]\r\n../../src/interfaces/capnp/proxy-impl.h:1071:15:   required from void interfaces::capnp::BuildField(interfaces::capnp::TypeList<LocalType&>, interfaces::capnp::Priority<0>, interfaces::capnp::InvokeContext&, Value&&, Output&&, void*) [with LocalType = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]\r\n../../src/interfaces/capnp/proxy-impl.h:1098:15:   required from void interfaces::capnp::BuildOne(interfaces::capnp::TypeList<ValueLocalType>, interfaces::capnp::InvokeContext&, Value&&, Output&&, typename std::enable_if<(index < interfaces::capnp::ProxyType<LocalType>::fields)>::type*) [with long unsigned int index = 0; LocalType = interfaces::capnp::GlobalArgs; Value = const interfaces::capnp::GlobalArgs&; Output = interfaces::capnp::messages::GlobalArgs::Builder&; typename std::enable_if<(index < interfaces::capnp::ProxyType<LocalType>::fields)>::type = void]\r\n../../src/interfaces/capnp/proxy-impl.h:1119:16:   required from void interfaces::capnp::BuildField(interfaces::capnp::TypeList<LocalType>, interfaces::capnp::Priority<1>, interfaces::capnp::InvokeContext&, Value&&, Output&&, typename interfaces::capnp::ProxyType<LocalType>::Struct*) [with LocalType = interfaces::capnp::GlobalArgs; Value = const interfaces::capnp::GlobalArgs&; Output = interfaces::capnp::ValueField<interfaces::capnp::messages::GlobalArgs::Builder>; typename interfaces::capnp::ProxyType<LocalType>::Struct = interfaces::capnp::messages::GlobalArgs]\r\n../../src/interfaces/capnp/messages.cpp:52:109:   required from here\r\n../../src/interfaces/capnp/proxy.h:322:110: error: B is not a class or namespace\r\n     template<typename B = Builder, typename Arg> auto set(Arg&& arg) const -> AUTO_RETURN(this->m_builder.B::set(m_index, std::forward<Arg>(arg)))\r\n```",
      "created_at" : "2018-09-21T07:30:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-423441197",
      "id" : 423441197,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzQ0MTE5Nw==",
      "updated_at" : "2018-09-21T07:30:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423441197",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7310938?v=4",
         "events_url" : "https://api.github.com/users/fingera/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fingera/followers",
         "following_url" : "https://api.github.com/users/fingera/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fingera/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fingera",
         "id" : 7310938,
         "login" : "fingera",
         "node_id" : "MDQ6VXNlcjczMTA5Mzg=",
         "organizations_url" : "https://api.github.com/users/fingera/orgs",
         "received_events_url" : "https://api.github.com/users/fingera/received_events",
         "repos_url" : "https://api.github.com/users/fingera/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fingera/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fingera/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fingera"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the report @fingera. The gcc compile errors should be fixed now (I've been testing with clang more than gcc recently).\r\n\r\n---\r\n\r\nUpdated 5ce9a948c8ec47762d0a23d1cf7f2ce57386052b -> f896f063007aa3889caf9d14724357117eca78c1 ([pr/ipc.55](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.55) -> [pr/ipc.56](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.56)) to fix `createwallet` and other wallet RPCs that use `g_rpc_interfaces` global\r\nRebased f896f063007aa3889caf9d14724357117eca78c1 -> c1cbca095f1bf10ca4370bfe99b798a5d1e9f268 ([pr/ipc.56](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.56) -> [pr/ipc.57](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.57))\r\nRebased c1cbca095f1bf10ca4370bfe99b798a5d1e9f268 -> 382cfabf523cd209adeb3ed9c5fd5d69fea284ab ([pr/ipc.57](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.57) -> [pr/ipc.58](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.58)) with compile fixes for gcc\r\nRebased 382cfabf523cd209adeb3ed9c5fd5d69fea284ab -> ededfe8800fd2647851d4d42dd765cfcd8d69cde ([pr/ipc.58](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.58) -> [pr/ipc.59](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.59)) due to conflict with #12246 \r\nRebased ededfe8800fd2647851d4d42dd765cfcd8d69cde -> ee425e2ddff453a5436cffb1e16e5452d8e3892a ([pr/ipc.59](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.59) -> [pr/ipc.60](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.60)) on top of base PR tag [pr/wipc-sep.85](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.85)\r\nRebased ee425e2ddff453a5436cffb1e16e5452d8e3892a -> 10ad449bb7c6ea3c2fea9f9a32e54e960c5acfd5 ([pr/ipc.60](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.60) -> [pr/ipc.61](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.61)) on top of base PR tag [pr/wipc-sep.87](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.87)\r\nRebased 10ad449bb7c6ea3c2fea9f9a32e54e960c5acfd5 -> f2233bcfef4147e0268da581f797b1646b0d8447 ([pr/ipc.61](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.61) -> [pr/ipc.62](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.62)) on top of base PR tag [pr/wipc-sep.88](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.88)\r\nRebased f2233bcfef4147e0268da581f797b1646b0d8447 -> da8719d39614e2673047721f9a7ea8e96587b000 ([pr/ipc.62](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.62) -> [pr/ipc.63](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.63)) on top of base PR tag [pr/wipc-sep.89](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.89)\r\nRebased da8719d39614e2673047721f9a7ea8e96587b000 -> c5bc654324670631d32e530c4cf1dbf9af58841a ([pr/ipc.63](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.63) -> [pr/ipc.64](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.64)) on top of base PR tag [pr/wipc-sep.93](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.93) and fixing conflicts with #15101, #15114, and others\r\nRebased c5bc654324670631d32e530c4cf1dbf9af58841a -> cc23f7434c21e195609e4dff6b8839864a426715 ([pr/ipc.64](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.64) -> [pr/ipc.65](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.65)) on top of base PR tag [pr/wipc-sep.95](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.95) and fixing conflicts with #15153 \r\nRebased cc23f7434c21e195609e4dff6b8839864a426715 -> c5dadccc5da6247975ee3884687a680bc46a9327 ([pr/ipc.65](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.65) -> [pr/ipc.66](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.66)) on top of base PR tag [pr/wipc-sep.96](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.96) after #15288 merge\r\nRebased c5dadccc5da6247975ee3884687a680bc46a9327 -> 191e240ce66208eb17ca743a6928cb20aa56041e ([pr/ipc.66](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.66) -> [pr/ipc.67](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.67)) on top of base PR tag [pr/wipc-sep.97](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.97) fixing conflict with #15531\r\nRebased 191e240ce66208eb17ca743a6928cb20aa56041e -> 3440513a45e94a5f1f0c67ab7409439afbbef673 ([pr/ipc.67](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.67) -> [pr/ipc.68](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.68)) after #10973 merge",
      "created_at" : "2018-09-26T20:56:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-424866963",
      "id" : 424866963,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNDg2Njk2Mw==",
      "updated_at" : "2019-03-21T13:09:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/424866963",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15639](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15639.html) (bitcoin-wallet tool: Drop libbitcoin_server.a dependency by ryanofsky)\n* [#15638](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15638.html) (Move-only: Pull wallet code out of libbitcoin_server by ryanofsky)\n* [#15557](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15557.html) (Enhance `bumpfee` to include inputs when targeting a feerate by instagibbs)\n* [#15519](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15519.html) (Add Poly1305 implementation by jonasschnelli)\n* [#14032](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14032.html) (Add p2p layer encryption with ECDH/ChaCha20Poly1305 by jonasschnelli)\n* [#13949](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13949.html) (Introduce MempoolObserver interface to break \"policy/fees -> txmempool -> policy/fees\" circular dependency by Empact)\n* [#13582](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13582.html) (Extract AppInitLoadBlockIndex from AppInitMain by Empact)\n* [#10443](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/10443.html) (Add fee_est tool for debugging fee estimation code by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-09-27T21:14:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-425245284",
      "id" : 425245284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTI0NTI4NA==",
      "updated_at" : "2019-03-22T08:51:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425245284",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After upgrading to Mojave I'm having compile issues (as of ededfe8800fd2647851d4d42dd765cfcd8d69cde): \r\n```sh\r\nIn file included from interfaces/capnp/proxy-codegen.cpp:4:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/capnp/blob.h:28:\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/common.h:36:4: error: \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n  #error \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n   ^\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/common.h:39:6: error: \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n    #error \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n     ^\r\nIn file included from interfaces/capnp/proxy-codegen.cpp:5:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/capnp/schema-parser.h:30:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/kj/filesystem.h:28:\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/function.h:264:3: error: 'auto' return without trailing return type; deduced return types are a C++14 extension\r\n  auto operator()(Params&&... params) {\r\n  ^\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/function.h:268:3: error: 'auto' return without trailing return type; deduced return types are a C++14 extension\r\n  auto operator()(Params&&... params) const {\r\n  ^\r\ninterfaces/capnp/proxy-codegen.cpp:10:10: fatal error: 'interfaces/capnp/proxy.capnp.h' file not found\r\n```",
      "created_at" : "2018-09-28T10:29:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-425394087",
      "id" : 425394087,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTM5NDA4Nw==",
      "updated_at" : "2018-09-28T10:29:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425394087",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Compile works again for me. I do still get the `syscall` deprecated in macOS 10.12 warning I mentioned earlier. Some of the tests also throw a [compiler warning](https://gist.github.com/Sjors/fed61c30c76c746c8b0b12a51e92eeb0).\r\n\r\nrpc `help`, and `testnet=1` in `bitcoin.conf`, command override in settings screen work for me now.\r\n\r\n`createwallet` in the gui console crashes the gui. The node and wallet keep running, but won't shut down using `bitcoin-cli stop`.\r\n\r\nDon't forget to update `.gitignore`. Nit: should `bitcoin-gui` be in `src/qt` ?",
      "created_at" : "2018-10-09T07:16:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112",
      "id" : 428086112,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODA4NjExMg==",
      "updated_at" : "2018-10-09T07:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428086112",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for testing! I will test the createwallet method, fix git ignores, and clean up the disconnect handling so leftover processes won't stick around if one crashes.\r\n\r\nOn location of `bitcoin-gui`, all three executables are intentionally built in the same directory to make spawning processes simple. When `bitcoin-gui` launches `bitcoin-node`, it always looks for a `bitcoin-node` executable in the same directory. Same when `bitcoin-node` runs `bitcoin-wallet`. Trying to build and call executables in different directories would make things unnecessarily complicated, especially if the executables will eventually be installed in the same directory anyway.",
      "created_at" : "2018-10-09T07:54:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428096364",
      "id" : 428096364,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODA5NjM2NA==",
      "updated_at" : "2018-10-09T07:54:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428096364",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112\r\n> Don't forget to update .gitignore\r\n\r\nUpdated now.\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112, https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416028413 \r\n> I do still get the syscall deprecated in macOS 10.12 warning\r\n\r\nShould be fixed now. Worked around using `pthread_threadid_np`, according to http://elliotth.blogspot.com/2012/04/gettid-on-mac-os.html and https://github.com/google/glog/issues/182\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112\r\n> Some of the tests also throw a [compiler warning](https://gist.github.com/Sjors/fed61c30c76c746c8b0b12a51e92eeb0).\r\n\r\nDidn't look in much detail, but these are warnings about signed/unsigned comparisons from checks like: `BOOST_CHECK_EQUAL(reader.size(), 6);`. Could be fixed by changing `6` to `6u`, but I think these warnings must predate this PR.\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112 shutdown/hang issues. I'm planning to look into these next.",
      "created_at" : "2018-11-01T21:14:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-435189673",
      "id" : 435189673,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE4OTY3Mw==",
      "updated_at" : "2018-11-01T21:14:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435189673",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Pull request",
      "created_at" : "2018-11-02T00:00:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-435226828",
      "id" : 435226828,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTIyNjgyOA==",
      "updated_at" : "2018-11-02T00:00:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435226828",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/43362812?v=4",
         "events_url" : "https://api.github.com/users/ismail120572/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ismail120572/followers",
         "following_url" : "https://api.github.com/users/ismail120572/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ismail120572/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ismail120572",
         "id" : 43362812,
         "login" : "ismail120572",
         "node_id" : "MDQ6VXNlcjQzMzYyODEy",
         "organizations_url" : "https://api.github.com/users/ismail120572/orgs",
         "received_events_url" : "https://api.github.com/users/ismail120572/received_events",
         "repos_url" : "https://api.github.com/users/ismail120572/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ismail120572/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ismail120572/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ismail120572"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove trailing `;` :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T15:54:09Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423211",
      "id" : 230423211,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzIxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 25,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171164602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423211",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423257"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove trailing `;` :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T15:54:15Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };\n+    virtual IpcProtocol* getProtocol() { return nullptr; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423257",
      "id" : 230423257,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzI1Nw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 26,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171164647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423257",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423611"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`exe_path` is not a parameter? :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T15:55:04Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };\n+    virtual IpcProtocol* getProtocol() { return nullptr; };\n+};\n+\n+//! Return implementation of Init interface.\n+//! @param exe_path should be current executable path (argv[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423611",
      "id" : 230423611,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzYxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 30,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171165046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423611",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424211"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make this implicit conversion explicit since it changes signedness?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T15:56:41Z",
      "diff_hunk" : "@@ -2604,7 +2632,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     // enough, that fee sniping isn't a problem yet, but by implementing a fix\n     // now we ensure code won't be written that makes assumptions about\n     // nLockTime that preclude a fix later.\n-    txNew.nLockTime = chainActive.Height();\n+    txNew.nLockTime = locked_chain.getHeight().value_or(LOCKTIME_MAX);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424211",
      "id" : 230424211,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNDIxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 813,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171165827,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424211",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424730"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `explicit`? :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T15:58:17Z",
      "diff_hunk" : "@@ -50,6 +51,8 @@ namespace {\n \n class NodeImpl : public Node\n {\n+public:\n+    NodeImpl(Init& init) : m_init(init) { m_interfaces.chain = MakeChain(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424730",
      "id" : 230424730,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNDczMA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 13,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 171166476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424730",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230425311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230425311"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make `explicit`?\r\n\r\nApplies throughout this PR :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:00:02Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#ifndef BITCOIN_INTERFACES_BASE_H\n+#define BITCOIN_INTERFACES_BASE_H\n+\n+#include <cassert>\n+#include <memory>\n+\n+namespace interfaces {\n+\n+class Base;\n+\n+//! Close hook.\n+class CloseHook\n+{\n+public:\n+    virtual ~CloseHook() {}\n+\n+    //! Handle interface being disconnected.\n+    virtual void onClose(Base& interface, bool remote) {}\n+\n+    std::unique_ptr<CloseHook> m_next_hook;\n+};\n+\n+//! Close hook that encapsulate and deletes a moveable object.\n+template <typename T>\n+class Deleter : public CloseHook\n+{\n+public:\n+    Deleter(T&& value) : m_value(std::move(value)) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230425311",
      "id" : 230425311,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNTMxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 28,
      "path" : "src/interfaces/base.h",
      "position" : null,
      "pull_request_review_id" : 171167242,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230425311",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426764"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Always true?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:04:48Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764",
      "id" : 230426764,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNjc2NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 417,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : 417,
      "pull_request_review_id" : 171169113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426764",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426823"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Always true?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:04:58Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {\n+                    def << \"    typename M\" << method.getOrdinal() << \"::Result result;\\n\";\n+                }\n+                def << \"    clientInvoke(*this, &\" << message_namespace << \"::\" << node_name\n+                    << \"::Client::\" << method_name << \"Request\" << client_invoke.str() << \");\\n\";\n+                if (has_result) def << \"    return result;\\n\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823",
      "id" : 230426823,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNjgyMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 422,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : 422,
      "pull_request_review_id" : 171169185,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426823",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427113"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`ByteCast` not used?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:05:48Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    output.set(\n+        kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(&value, false /* owned */, invoke_context.loop));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.loop));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.loop.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),\n+            std::forward<NextFnArgs>(next_fn_args)...);\n+    }\n+\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList)\n+    {\n+        static_cast<Derived*>(this)->handleField(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), ParamList());\n+    }\n+};\n+\n+struct IterateFields : IterateFieldsHelper<IterateFields, 0>\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleField(Arg1&&, Arg2&&, ParamList)\n+    {\n+    }\n+};\n+\n+// template <typename Exception, typename Accessor>\n+// FIXME struct ClientException\n+// https://stackoverflow.com/a/7858971\n+\n+template <typename Exception, typename Accessor>\n+struct ClientException\n+{\n+    struct BuildParams : IterateFieldsHelper<BuildParams, 0>\n+    {\n+        template <typename Params, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Params& params, ParamList)\n+        {\n+        }\n+\n+        BuildParams(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, 0>\n+    {\n+        template <typename Results, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Results& results, ParamList)\n+        {\n+            StructField<Accessor, Results> input(results);\n+            if (input.has()) {\n+                ReadField(TypeList<Exception>(), invoke_context, input, ThrowEmplace<Exception>());\n+            }\n+        }\n+\n+        ReadResults(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+};\n+\n+template <typename Accessor, typename... Types>\n+struct ClientParam\n+{\n+    ClientParam(Types&... values) : m_values(values...) {}\n+\n+    struct BuildParams : IterateFieldsHelper<BuildParams, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callBuild<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <size_t I, typename... Args>\n+        auto callBuild(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            // FIXME: replace std::move below with std::forward\n+            callBuild<I + 1>(std::forward<Args>(args)..., std::move(std::get<I>(m_client_param->m_values)));\n+        }\n+\n+        template <size_t I, typename Params, typename ParamList, typename... Values>\n+        auto callBuild(ClientInvokeContext& invoke_context, Params& params, ParamList, Values&&... values) ->\n+            typename std::enable_if<(I == sizeof...(Types))>::type\n+        {\n+            MaybeBuildField(std::integral_constant<bool, Accessor::in>(), ParamList(), BuildFieldPriority(),\n+                invoke_context, std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+            MaybeSetWant(\n+                ParamList(), Priority<1>(), std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+        }\n+\n+        BuildParams(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callRead<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <int I, typename... Args>\n+        auto callRead(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            callRead<I + 1>(std::forward<Args>(args)..., std::get<I>(m_client_param->m_values));\n+        }\n+\n+        template <int I, typename Results, typename... Params, typename... Values>\n+        auto callRead(ClientInvokeContext& invoke_context, Results& results, TypeList<Params...>, Values&&... values)\n+            -> typename std::enable_if<I == sizeof...(Types)>::type\n+        {\n+            MaybeReadFieldUpdate(std::integral_constant<bool, Accessor::out>(), TypeList<Decay<Params>...>(),\n+                invoke_context, Make<StructField, Accessor>(results), std::forward<Values>(values)...);\n+        }\n+\n+        ReadResults(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    // FIXME: should be rvalue reference to fix callBuild above\n+    std::tuple<Types&...> m_values;\n+};\n+\n+template <typename Accessor, typename... Types>\n+ClientParam<Accessor, Types...> MakeClientParam(Types&... values)\n+{\n+    return {values...};\n+}\n+\n+//! Safely convert char pointer to kj pointer.\n+static inline kj::byte* ByteCast(char* c) { return reinterpret_cast<kj::byte*>(c); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427113",
      "id" : 230427113,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzExMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 1373,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171169519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427113",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427137"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:05:55Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    output.set(\n+        kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(&value, false /* owned */, invoke_context.loop));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.loop));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.loop.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),\n+            std::forward<NextFnArgs>(next_fn_args)...);\n+    }\n+\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList)\n+    {\n+        static_cast<Derived*>(this)->handleField(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), ParamList());\n+    }\n+};\n+\n+struct IterateFields : IterateFieldsHelper<IterateFields, 0>\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleField(Arg1&&, Arg2&&, ParamList)\n+    {\n+    }\n+};\n+\n+// template <typename Exception, typename Accessor>\n+// FIXME struct ClientException\n+// https://stackoverflow.com/a/7858971\n+\n+template <typename Exception, typename Accessor>\n+struct ClientException\n+{\n+    struct BuildParams : IterateFieldsHelper<BuildParams, 0>\n+    {\n+        template <typename Params, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Params& params, ParamList)\n+        {\n+        }\n+\n+        BuildParams(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, 0>\n+    {\n+        template <typename Results, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Results& results, ParamList)\n+        {\n+            StructField<Accessor, Results> input(results);\n+            if (input.has()) {\n+                ReadField(TypeList<Exception>(), invoke_context, input, ThrowEmplace<Exception>());\n+            }\n+        }\n+\n+        ReadResults(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+};\n+\n+template <typename Accessor, typename... Types>\n+struct ClientParam\n+{\n+    ClientParam(Types&... values) : m_values(values...) {}\n+\n+    struct BuildParams : IterateFieldsHelper<BuildParams, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callBuild<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <size_t I, typename... Args>\n+        auto callBuild(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            // FIXME: replace std::move below with std::forward\n+            callBuild<I + 1>(std::forward<Args>(args)..., std::move(std::get<I>(m_client_param->m_values)));\n+        }\n+\n+        template <size_t I, typename Params, typename ParamList, typename... Values>\n+        auto callBuild(ClientInvokeContext& invoke_context, Params& params, ParamList, Values&&... values) ->\n+            typename std::enable_if<(I == sizeof...(Types))>::type\n+        {\n+            MaybeBuildField(std::integral_constant<bool, Accessor::in>(), ParamList(), BuildFieldPriority(),\n+                invoke_context, std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+            MaybeSetWant(\n+                ParamList(), Priority<1>(), std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+        }\n+\n+        BuildParams(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callRead<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <int I, typename... Args>\n+        auto callRead(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            callRead<I + 1>(std::forward<Args>(args)..., std::get<I>(m_client_param->m_values));\n+        }\n+\n+        template <int I, typename Results, typename... Params, typename... Values>\n+        auto callRead(ClientInvokeContext& invoke_context, Results& results, TypeList<Params...>, Values&&... values)\n+            -> typename std::enable_if<I == sizeof...(Types)>::type\n+        {\n+            MaybeReadFieldUpdate(std::integral_constant<bool, Accessor::out>(), TypeList<Decay<Params>...>(),\n+                invoke_context, Make<StructField, Accessor>(results), std::forward<Values>(values)...);\n+        }\n+\n+        ReadResults(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    // FIXME: should be rvalue reference to fix callBuild above\n+    std::tuple<Types&...> m_values;\n+};\n+\n+template <typename Accessor, typename... Types>\n+ClientParam<Accessor, Types...> MakeClientParam(Types&... values)\n+{\n+    return {values...};\n+}\n+\n+//! Safely convert char pointer to kj pointer.\n+static inline kj::byte* ByteCast(char* c) { return reinterpret_cast<kj::byte*>(c); }\n+static inline const kj::byte* ByteCast(const char* c) { return reinterpret_cast<const kj::byte*>(c); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427137",
      "id" : 230427137,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzEzNw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 1374,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171169555,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427137",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427284"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427284"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not used?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:06:25Z",
      "diff_hunk" : "@@ -59,6 +62,10 @@ class NodeImpl : public Node\n     bool softSetBoolArg(const std::string& arg, bool value) override { return gArgs.SoftSetBoolArg(arg, value); }\n     void selectParams(const std::string& network) override { SelectParams(network); }\n     std::string getNetwork() override { return Params().NetworkIDString(); }\n+    std::string getArg(const std::string& arg, const std::string& default_value) override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427284",
      "id" : 230427284,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzI4NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 21,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 171169747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427284",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427503"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not used?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:07:03Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)\n+{\n+    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n+    LogIpc(m_loop, \"Uncaught exception in daemonized task.\");\n+}\n+\n+EventLoop::EventLoop(const char* exe_name, std::thread&& thread)\n+    : m_exe_name(exe_name), m_thread_map(nullptr), m_io_context(kj::setupAsyncIo()), m_thread(std::move(thread))\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+    m_wait_fd = fds[0];\n+    m_post_fd = fds[1];\n+}\n+\n+EventLoop::~EventLoop()\n+{\n+    KJ_ASSERT(!m_thread.joinable());\n+    KJ_ASSERT(m_wait_fd == -1);\n+    KJ_ASSERT(m_post_fd == -1);\n+    for (auto& fn : m_cleanup_fns) {\n+        fn();\n+    }\n+}\n+\n+void EventLoop::loop()\n+{\n+    kj::Own<kj::AsyncIoStream> wait_stream{\n+        m_io_context.lowLevelProvider->wrapSocketFd(m_wait_fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)};\n+    char buffer;\n+    for (;;) {\n+        size_t bytes = -1;\n+        wait_stream->read(&buffer, 0, 1).then([&](size_t s) { bytes = s; }).wait(m_io_context.waitScope);\n+        if (bytes == 0) {\n+            wait_stream = nullptr;\n+            m_wait_fd = -1;\n+            break;\n+        }\n+        m_post_fn();\n+        m_post_fn = nullptr;\n+        m_task_set.add(wait_stream->write(&buffer, 1));\n+    }\n+}\n+\n+void EventLoop::post(std::function<void()> fn)\n+{\n+    if (std::this_thread::get_id() == m_thread_id) {\n+        fn();\n+        return;\n+    }\n+    std::lock_guard<std::mutex> lock(m_post_mutex);\n+    m_post_fn = std::move(fn);\n+    char signal = '\\0';\n+    KJ_SYSCALL(write(m_post_fd, &signal, 1));\n+    KJ_SYSCALL(read(m_post_fd, &signal, 1));\n+}\n+\n+void EventLoop::shutdown()\n+{\n+    std::thread close_thread = std::move(m_thread);\n+    int close_fd = m_post_fd;\n+    m_post_fd = -1;\n+    KJ_SYSCALL(close(close_fd));\n+    if (close_thread.joinable()) {\n+        close_thread.join();\n+    }\n+}\n+\n+ProxyServer<ThreadMap>::ProxyServer(EventLoop& loop) : m_loop(loop) {}\n+\n+kj::Promise<void> ProxyServer<ThreadMap>::makeThread(MakeThreadContext context)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503",
      "id" : 230427503,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzUwMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 84,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : 250,
      "pull_request_review_id" : 171170014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427503",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427589"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not used?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:07:22Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+#include <interfaces/capnp/test/foo.h>\n+\n+#include <util.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace test {\n+namespace {\n+\n+class FooImpl : public FooInterface\n+{\n+public:\n+    int add(int a, int b) override { return a + b; }\n+    int mapSize(const std::map<std::string, std::string>& map) override { return map.size(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589",
      "id" : 230427589,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzU4OQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 14,
      "path" : "src/interfaces/capnp/test/foo.cpp",
      "position" : 14,
      "pull_request_review_id" : 171170127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427589",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427653"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not used?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:07:34Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653",
      "id" : 230427653,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzY1Mw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 14,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : 14,
      "pull_request_review_id" : 171170205,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427653",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427795"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing spaces around `=`",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:07:55Z",
      "diff_hunk" : "@@ -42,7 +52,7 @@ bool AppInitParameterInteraction();\n  * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitParameterInteraction should have been called.\n  */\n-bool AppInitSanityChecks();\n+bool AppInitSanityChecks(bool lock_data_dir=false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427795",
      "id" : 230427795,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzc5NQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 35,
      "path" : "src/init.h",
      "position" : null,
      "pull_request_review_id" : 171170363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427795",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing copyright header",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:08:19Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+#include <interfaces/base.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427926",
      "id" : 230427926,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzkyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 1,
      "path" : "src/interfaces/base.cpp",
      "position" : 5,
      "pull_request_review_id" : 171170517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427926",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427994"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing copyright header.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:08:33Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#ifndef BITCOIN_INTERFACES_BASE_H",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427994",
      "id" : 230427994,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzk5NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 1,
      "path" : "src/interfaces/base.h",
      "position" : 5,
      "pull_request_review_id" : 171170598,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427994",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428044"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing copyright header.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:08:43Z",
      "diff_hunk" : "@@ -0,0 +1,154 @@\n+#include <interfaces/capnp/ipc.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428044",
      "id" : 230428044,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODA0NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 1,
      "path" : "src/interfaces/capnp/ipc.cpp",
      "position" : 5,
      "pull_request_review_id" : 171170667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428044",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428192"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing whitespace before `{`.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:09:08Z",
      "diff_hunk" : "@@ -0,0 +1,154 @@\n+#include <interfaces/capnp/ipc.h>\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because\n+        // close/destruction sequence doesn't wait for server objects across\n+        // the pipe to shut down, so e.g. things like handlers don't get a\n+        // chance to get deleted in right sequence. Instead with this shutdown\n+        // they get deleted in EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+struct StreamContext\n+{\n+    kj::Own<kj::AsyncIoStream> stream;\n+    ::capnp::TwoPartyVatNetwork network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> rpc_system;\n+\n+    StreamContext(kj::Own<kj::AsyncIoStream>&& stream_, std::function<::capnp::Capability::Client()> make_client)\n+        : stream(kj::mv(stream_)), network(*stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          rpc_system(::capnp::makeRpcServer(network, make_client()))\n+    {\n+    }\n+};\n+\n+class IpcProtocolImpl : public IpcProtocol\n+{\n+public:\n+    IpcProtocolImpl(const char* exe_name, Init& init) : m_exe_name(exe_name), m_init(init) {}\n+    ~IpcProtocolImpl() noexcept(true){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428192",
      "id" : 230428192,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODE5Mg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 72,
      "path" : "src/interfaces/capnp/ipc.cpp",
      "position" : null,
      "pull_request_review_id" : 171170831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428192",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428604"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo: pipelining",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-02T16:10:25Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428604",
      "id" : 230428604,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODYwNA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 252,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171171348,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428604",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The optional `block_height` could be uninitialized here?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-04T21:23:52Z",
      "diff_hunk" : "@@ -1594,113 +1597,133 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n-    const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    WalletLogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double progress_begin;\n         double progress_end;\n         {\n-            LOCK(cs_main);\n-            progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            if (pindexStop == nullptr) {\n-                tip = chainActive.Tip();\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = chain().lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            progress_begin = chain().guessVerificationProgress(block_hash);\n+            if (stop_block.IsNull()) {\n+                progress_end = chain().guessVerificationProgress(tip_hash);\n             } else {\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), pindexStop);\n+                progress_end = chain().guessVerificationProgress(stop_block);\n             }\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested())\n+        while (block_height && !fAbortRescan && !ShutdownRequested())\n         {\n-            if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n+            if (*block_height % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, progress_current);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n-                LOCK2(cs_main, cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+            if (chain().findBlock(block_hash, &block) && !block.IsNull()) {\n+                auto locked_chain = chain().lock();\n+                LOCK(cs_wallet);\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    ret = block_hash;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                    SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n+                    SyncTransaction(block.vtx[posInBlock], block_hash, posInBlock, fUpdate);\n                 }\n             } else {\n-                ret = pindex;\n+                ret = block_hash;\n             }\n-            if (pindex == pindexStop) {\n+            if (block_hash == stop_block) {\n                 break;\n             }\n             {\n-                LOCK(cs_main);\n-                pindex = chainActive.Next(pindex);\n-                progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                if (pindexStop == nullptr && tip != chainActive.Tip()) {\n-                    tip = chainActive.Tip();\n+                const int prev_block_height = *block_height;\n+                const uint256 prev_block_hash = block_hash;\n+                const uint256 prev_tip_hash = tip_hash;\n+                block_height.reset();\n+                block_hash.SetNull();\n+                tip_hash.SetNull();\n+\n+                auto locked_chain = chain().lock();\n+                if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                    if (locked_chain->getBlockHeight(prev_block_hash) && prev_block_height < *tip_height) {\n+                        block_height = prev_block_height + 1;\n+                        block_hash = locked_chain->getBlockHash(*block_height);\n+                    }\n+                    tip_hash = locked_chain->getBlockHash(*tip_height);\n+                }\n+\n+                progress_current = chain().guessVerificationProgress(block_hash);\n+                if (stop_block.IsNull() && prev_tip_hash != tip_hash) {\n                     // in case the tip has changed, update progress max\n-                    progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+                    progress_end = chain().guessVerificationProgress(tip_hash);\n                 }\n             }\n         }\n-        if (pindex && fAbortRescan) {\n-            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-        } else if (pindex && ShutdownRequested()) {\n-            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+        if (!block_hash.IsNull() && fAbortRescan) {\n+            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", *block_height, progress_current);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605926",
      "id" : 230605926,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTkyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 417,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171380028,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605926",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605933"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-04T21:24:04Z",
      "diff_hunk" : "@@ -1594,113 +1597,133 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n-    const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    WalletLogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double progress_begin;\n         double progress_end;\n         {\n-            LOCK(cs_main);\n-            progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            if (pindexStop == nullptr) {\n-                tip = chainActive.Tip();\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = chain().lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            progress_begin = chain().guessVerificationProgress(block_hash);\n+            if (stop_block.IsNull()) {\n+                progress_end = chain().guessVerificationProgress(tip_hash);\n             } else {\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), pindexStop);\n+                progress_end = chain().guessVerificationProgress(stop_block);\n             }\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested())\n+        while (block_height && !fAbortRescan && !ShutdownRequested())\n         {\n-            if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n+            if (*block_height % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, progress_current);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n-                LOCK2(cs_main, cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+            if (chain().findBlock(block_hash, &block) && !block.IsNull()) {\n+                auto locked_chain = chain().lock();\n+                LOCK(cs_wallet);\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    ret = block_hash;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                    SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n+                    SyncTransaction(block.vtx[posInBlock], block_hash, posInBlock, fUpdate);\n                 }\n             } else {\n-                ret = pindex;\n+                ret = block_hash;\n             }\n-            if (pindex == pindexStop) {\n+            if (block_hash == stop_block) {\n                 break;\n             }\n             {\n-                LOCK(cs_main);\n-                pindex = chainActive.Next(pindex);\n-                progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                if (pindexStop == nullptr && tip != chainActive.Tip()) {\n-                    tip = chainActive.Tip();\n+                const int prev_block_height = *block_height;\n+                const uint256 prev_block_hash = block_hash;\n+                const uint256 prev_tip_hash = tip_hash;\n+                block_height.reset();\n+                block_hash.SetNull();\n+                tip_hash.SetNull();\n+\n+                auto locked_chain = chain().lock();\n+                if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                    if (locked_chain->getBlockHeight(prev_block_hash) && prev_block_height < *tip_height) {\n+                        block_height = prev_block_height + 1;\n+                        block_hash = locked_chain->getBlockHash(*block_height);\n+                    }\n+                    tip_hash = locked_chain->getBlockHash(*tip_height);\n+                }\n+\n+                progress_current = chain().guessVerificationProgress(block_hash);\n+                if (stop_block.IsNull() && prev_tip_hash != tip_hash) {\n                     // in case the tip has changed, update progress max\n-                    progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+                    progress_end = chain().guessVerificationProgress(tip_hash);\n                 }\n             }\n         }\n-        if (pindex && fAbortRescan) {\n-            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-        } else if (pindex && ShutdownRequested()) {\n-            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+        if (!block_hash.IsNull() && fAbortRescan) {\n+            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", *block_height, progress_current);\n+        } else if (!block_hash.IsNull() && ShutdownRequested()) {\n+            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", *block_height, progress_current);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605933",
      "id" : 230605933,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTkzMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 419,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171380036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605933",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783285"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653\r\n\r\n> Not used?\r\n\r\nNo, it's a overridden method called through the base class by the kj library.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-12T19:27:29Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783285",
      "id" : 232783285,
      "in_reply_to_id" : 230427653,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzI4NQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 14,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : 14,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783285",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783326"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503\r\n\r\n> Not used?\r\n\r\nNo, it's called by generated code.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-12T19:27:36Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)\n+{\n+    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n+    LogIpc(m_loop, \"Uncaught exception in daemonized task.\");\n+}\n+\n+EventLoop::EventLoop(const char* exe_name, std::thread&& thread)\n+    : m_exe_name(exe_name), m_thread_map(nullptr), m_io_context(kj::setupAsyncIo()), m_thread(std::move(thread))\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+    m_wait_fd = fds[0];\n+    m_post_fd = fds[1];\n+}\n+\n+EventLoop::~EventLoop()\n+{\n+    KJ_ASSERT(!m_thread.joinable());\n+    KJ_ASSERT(m_wait_fd == -1);\n+    KJ_ASSERT(m_post_fd == -1);\n+    for (auto& fn : m_cleanup_fns) {\n+        fn();\n+    }\n+}\n+\n+void EventLoop::loop()\n+{\n+    kj::Own<kj::AsyncIoStream> wait_stream{\n+        m_io_context.lowLevelProvider->wrapSocketFd(m_wait_fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)};\n+    char buffer;\n+    for (;;) {\n+        size_t bytes = -1;\n+        wait_stream->read(&buffer, 0, 1).then([&](size_t s) { bytes = s; }).wait(m_io_context.waitScope);\n+        if (bytes == 0) {\n+            wait_stream = nullptr;\n+            m_wait_fd = -1;\n+            break;\n+        }\n+        m_post_fn();\n+        m_post_fn = nullptr;\n+        m_task_set.add(wait_stream->write(&buffer, 1));\n+    }\n+}\n+\n+void EventLoop::post(std::function<void()> fn)\n+{\n+    if (std::this_thread::get_id() == m_thread_id) {\n+        fn();\n+        return;\n+    }\n+    std::lock_guard<std::mutex> lock(m_post_mutex);\n+    m_post_fn = std::move(fn);\n+    char signal = '\\0';\n+    KJ_SYSCALL(write(m_post_fd, &signal, 1));\n+    KJ_SYSCALL(read(m_post_fd, &signal, 1));\n+}\n+\n+void EventLoop::shutdown()\n+{\n+    std::thread close_thread = std::move(m_thread);\n+    int close_fd = m_post_fd;\n+    m_post_fd = -1;\n+    KJ_SYSCALL(close(close_fd));\n+    if (close_thread.joinable()) {\n+        close_thread.join();\n+    }\n+}\n+\n+ProxyServer<ThreadMap>::ProxyServer(EventLoop& loop) : m_loop(loop) {}\n+\n+kj::Promise<void> ProxyServer<ThreadMap>::makeThread(MakeThreadContext context)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783326",
      "id" : 232783326,
      "in_reply_to_id" : 230427503,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzMyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 84,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : 250,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783326",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783356"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589\r\n\r\n> Not used?\r\n\r\nNo, it's called by generated code.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-12T19:27:41Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+#include <interfaces/capnp/test/foo.h>\n+\n+#include <util.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace test {\n+namespace {\n+\n+class FooImpl : public FooInterface\n+{\n+public:\n+    int add(int a, int b) override { return a + b; }\n+    int mapSize(const std::map<std::string, std::string>& map) override { return map.size(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783356",
      "id" : 232783356,
      "in_reply_to_id" : 230427589,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzM1Ng==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 14,
      "path" : "src/interfaces/capnp/test/foo.cpp",
      "position" : 14,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783356",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783467"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783467"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764\r\n\r\n> Always true?\r\n\r\nhas_result is false for any method that doesn't have an output named result, which is true for any method that returns void.\r\n\r\n",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-12T19:28:04Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783467",
      "id" : 232783467,
      "in_reply_to_id" : 230426764,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzQ2Nw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 417,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : 417,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783467",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783489"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823\r\n\r\n> Always true?\r\n\r\nNo, see previous comment.",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2018-11-12T19:28:08Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {\n+                    def << \"    typename M\" << method.getOrdinal() << \"::Result result;\\n\";\n+                }\n+                def << \"    clientInvoke(*this, &\" << message_namespace << \"::\" << node_name\n+                    << \"::Client::\" << method_name << \"Request\" << client_invoke.str() << \");\\n\";\n+                if (has_result) def << \"    return result;\\n\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783489",
      "id" : 232783489,
      "in_reply_to_id" : 230426823,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzQ4OQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_position" : 422,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : 422,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783489",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250513986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250513986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shadows variable `params` in outer scope?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2019-01-24T09:02:50Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250513986",
      "id" : 250513986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxMzk4Ng==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_position" : 387,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : 396,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250513986",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2019-01-24T09:03:01Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514057",
      "id" : 250514057,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxNDA1Nw==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_position" : 388,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : 397,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514057",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514589"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `explicit`? Applies to all single parameter constructors in this PR :-)",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2019-01-24T09:04:49Z",
      "diff_hunk" : "@@ -0,0 +1,312 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halves at position index.\n+//!\n+//! Example:\n+//!   is_same<TypeList<int, double>, Split<2, TypeList<int, double, float, bool>>::First>\n+//!   is_same<TypeList<float, bool>, Split<2, TypeList<int, double, float, bool>>::Second>\n+template <std::size_t index, typename List, typename _First = TypeList<>, bool done = index == 0>\n+struct Split;\n+\n+//! Specialization of above (base case)\n+template <typename _Second, typename _First>\n+struct Split<0, _Second, _First, true>\n+{\n+    using First = _First;\n+    using Second = _Second;\n+};\n+\n+//! Specialization of above (recursive case)\n+template <std::size_t index, typename Type, typename... _Second, typename... _First>\n+struct Split<index, TypeList<Type, _Second...>, TypeList<_First...>, false>\n+{\n+    using _Next = Split<index - 1, TypeList<_Second...>, TypeList<_First..., Type>>;\n+    using First = typename _Next::First;\n+    using Second = typename _Next::Second;\n+};\n+\n+//! SFINAE helper, basically the same as to C++17's void_t, but allowing types other than void to be returned.\n+template <typename SfinaeExpr, typename Result_>\n+struct _Require\n+{\n+    using Result = Result_;\n+};\n+template <typename SfinaeExpr, typename Result = void>\n+using Require = typename _Require<SfinaeExpr, Result>::Result;\n+\n+//! Helper type for prioritizing overloaded function calls that would otherwise\n+//! be ambiguous.\n+//!\n+//! Example:\n+//!   auto foo(Priority<1>) -> std::enable_if<>;\n+//!   auto foo(Priority<0>) -> void;\n+//!\n+//!   foo(Priority<1>());   // Calls higher priority overload if enabled.\n+template <int priority>\n+struct Priority : Priority<priority - 1>\n+{\n+};\n+\n+//! Specialization of above (base case)\n+template <>\n+struct Priority<0>\n+{\n+};\n+\n+//! Construct a template class value by deducing template arguments from the\n+//! types of constructor arguments, so they don't need to be specified manually.\n+//!\n+//! Example:\n+//!   Make<std::pair>(5, true) // Constructs std::pair<int, bool>(5, true);\n+template <template <typename...> class Class, typename... Types, typename... Args>\n+Class<Types..., typename std::remove_reference<Args>::type...> Make(Args&&... args)\n+{\n+    return Class<Types..., typename std::remove_reference<Args>::type...>{std::forward<Args>(args)...};\n+}\n+\n+//! Generic utility functions used by capnp code. This mostly consists of\n+//! helpers that work around lack of C++14 functionality in C++11. This file\n+//! puts all C++14 workarounds in one place, so if/when bitcoin decides to\n+//! decides to upgrade to C++14, code can be accordingly simplified.\n+//!\n+//! C++14 has two features that really simplify generic programming. One is\n+//! auto-returning functions\n+//! (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions):\n+//!\n+//!    auto DoSomething(Arg arg) {\n+//!        return expression(arg);\n+//!    }\n+//!\n+//! which in c++11 has to be written:\n+//!\n+//!    auto DoSomething(Arg arg) -> decltype(expression(arg)) {\n+//!        return expression(arg);\n+//!    }\n+//!\n+//! Another is generic lambdas (http://en.cppreference.com/w/cpp/language/lambda):\n+//!\n+//!    [capture](auto arg) { do_something(arg); }\n+//!\n+//! which in c++11 has to be written like\n+//!\n+//!    struct DoSomething {\n+//!        Capture m_capture;\n+//!\n+//!        template<typename Arg>\n+//!        void operator()(Arg arg) {\n+//!            return do_something(arg);\n+//!        }\n+//!     };\n+\n+//! Functor wrapping std::get. Can be replaced with auto lambdas when we update\n+//! to C++14.\n+//!\n+//! Example:\n+//!   Get<3>()(a) // Equivalent to std::get<3>(a)\n+template <std::size_t I>\n+struct Get\n+{\n+    template <typename Tuple>\n+    auto operator()(Tuple&& tuple) -> decltype(std::get<I>(tuple))&\n+    {\n+        return std::get<I>(tuple);\n+    }\n+};\n+\n+//! Functor composing two other functors. Can be replaced with auto lambdas when\n+//! we update to C++14.\n+//!\n+//! Example:\n+//!   Make<Compose>(sin, atan2)(3, 4) == sin(atan2(3, 4))\n+template <typename Fn1, typename Fn2>\n+struct Compose\n+{\n+    Fn1&& fn1;\n+    Fn2&& fn2;\n+\n+    template <typename... Args>\n+    auto operator()(Args&&... args) -> AUTO_RETURN(this->fn1(this->fn2(std::forward<Args>(args)...)))\n+};\n+\n+//! Bound function. See Bind() below.\n+template <typename Fn, typename BindArgs, typename BoundArgs = TypeList<>>\n+struct BoundFn;\n+\n+//! Specialization of above for base case.\n+template <typename Fn, typename... BoundArgs>\n+struct BoundFn<Fn, TypeList<>, TypeList<BoundArgs...>>\n+{\n+    Fn&& m_fn;\n+\n+    template <typename... FreeArgs>\n+    auto operator()(BoundArgs&... bound_args, FreeArgs&&... free_args)\n+        -> AUTO_RETURN(this->m_fn(bound_args..., std::forward<FreeArgs>(free_args)...))\n+};\n+\n+//! Specialization of above for recursive case.\n+template <typename Fn, typename BindArg, typename... BindArgs, typename... BoundArgs>\n+struct BoundFn<Fn, TypeList<BindArg, BindArgs...>, TypeList<BoundArgs...>>\n+    : BoundFn<Fn, TypeList<BindArgs...>, TypeList<BoundArgs..., BindArg>>\n+{\n+    using Base = BoundFn<Fn, TypeList<BindArgs...>, TypeList<BoundArgs..., BindArg>>;\n+    BindArg& m_bind_arg;\n+\n+    BoundFn(Fn& fn, BindArg& bind_arg, BindArgs&... bind_args) : Base{fn, bind_args...}, m_bind_arg(bind_arg) {}\n+\n+    template <typename... FreeArgs>\n+    auto operator()(BoundArgs&... bound_args, FreeArgs&&... free_args) ->\n+        typename std::result_of<Base(BoundArgs&..., BindArg&, FreeArgs...)>::type\n+    {\n+        return Base::operator()(bound_args..., m_bind_arg, std::forward<FreeArgs>(free_args)...);\n+    }\n+};\n+\n+//! std::bind replacement. Unlike std::bind it doesn't copy the function object\n+//! or argument but instead takes rvalue references. This allows it to work with\n+//! uncopyable objects, but also limits its use to situations where objects\n+//! don't go out of scope. Uses of this can be replaced with auto lambdas when\n+//! we update to C++14.\n+//!\n+//! Example:\n+//!    Bind(atan2, 3)(4) == atan2(3, 4)\n+//!\n+//! Possible TODO: It might be nice to make binding more consistent with composing\n+//! and switch to calling syntax Make<Bind>(...) instead of Bind(...).\n+template <typename Fn, typename... BindArgs>\n+BoundFn<Fn, TypeList<BindArgs...>> Bind(Fn&& fn, BindArgs&... bind_args)\n+{\n+    return {fn, bind_args...};\n+}\n+\n+//! FIXME: Delete and replace with KJ_DEFER\n+//! Temporarily set reference to value in constructor, and restore previous\n+//! value in destructor.\n+//! Example:\n+//!\n+//!     int i = 3;\n+//!     {\n+//!        TempSetter t(i, 4);\n+//         ... i is 4 here ...\n+//!     }\n+//!     ... i is 3 again ...\n+template <typename T>\n+struct TempSetter\n+{\n+    template <typename U>\n+    TempSetter(T& ref, U&& value) : m_ref(ref), m_prev(std::move(ref))\n+    {\n+        m_ref = std::forward<U>(value);\n+    }\n+\n+    ~TempSetter() { m_ref = std::move(m_prev); }\n+\n+    T& m_ref;\n+    T m_prev;\n+};\n+\n+//! Return capnp type name with filename prefix removed.\n+template <typename T>\n+const char* TypeName()\n+{\n+    // DisplayName string looks like\n+    // \"interfaces/capnp/messages.capnp:ChainNotifications.resendWalletTransactions$Results\"\n+    // This discards the part of the string before the first ':' character.\n+    // Another alternative would be to use the displayNamePrefixLength field,\n+    // but this discards everything before the last '.' character, throwing away\n+    // the object name, which is useful.\n+    const char* display_name = ::capnp::Schema::from<T>().getProto().getDisplayName().cStr();\n+    const char* short_name = strchr(display_name, ':');\n+    return short_name ? short_name + 1 : display_name;\n+}\n+\n+//! Format current thread name as \"{exe_name}-{$pid}/{thread_name}-{$tid}\".\n+std::string ThreadName(const char* exe_name);\n+\n+//! Analog to std::lock_guard\n+template <typename Mutex>\n+struct UnlockGuard\n+{\n+    UnlockGuard(Mutex& mutex) : m_mutex(mutex) { m_mutex.unlock(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514589",
      "id" : 250514589,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxNDU4OQ==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_position" : 297,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514589",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250904863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250904863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are `arg1` and `arg2` guaranteed to be valid here? Could have been moved from on the call on the line before?",
      "commit_id" : "3440513a45e94a5f1f0c67ab7409439afbbef673",
      "created_at" : "2019-01-25T08:47:58Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    auto& request_threads = g_thread_context.request_threads;\n+                    auto request_thread = request_threads.find(server.m_connection);\n+                    if (request_thread == request_threads.end()) {\n+                        request_thread =\n+                            g_thread_context.request_threads\n+                                .emplace(std::piecewise_construct, std::forward_as_tuple(server.m_connection),\n+                                    std::forward_as_tuple(context_arg.getCallbackThread(), *server.m_connection))\n+                                .first;\n+                    } else {\n+                        // If recursive call, avoid remove request_threads map\n+                        // entry in KJ_DEFER below.\n+                        request_thread = request_threads.end();\n+                    }\n+                    KJ_DEFER(if (request_thread != request_threads.end()) request_threads.erase(request_thread));\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_connection->m_loop.sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_connection->m_loop.sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(server.m_connection->m_threads.getLocalServer(thread_client)\n+                            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                                KJ_IF_MAYBE(thread_server, perhaps)\n+                                {\n+                                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                                    LogIpc(server.m_connection->m_loop, \"IPC server post request  #%i {%s}\\n\", req,\n+                                        thread.m_thread_context.thread_name);\n+                                    thread.m_thread_context.waiter->post(std::move(invoke));\n+                                }\n+                                else\n+                                {\n+                                    LogIpc(server.m_connection->m_loop,\n+                                        \"IPC server error request #%i, missing thread to execute request\\n\", req);\n+                                    throw std::runtime_error(\"invalid thread handle\");\n+                                }\n+                            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+};\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, Connection& connection)\n+    : m_client(std::move(client)), m_connection(&connection)\n+{\n+    m_connection->m_loop.addClient();\n+    m_cleanup = m_connection->addCleanup([this]() {\n+        {\n+            typename Interface::Client(std::move(self().m_client));\n+        }\n+        m_connection->m_loop.removeClient();\n+        m_connection = nullptr;\n+    });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    // Two shutdown sequences are supported:\n+    //\n+    // - A normal sequence where client proxy objects are deleted by external\n+    //   code that no longer needs them\n+    //\n+    // - A garbage collection sequence where the connection or event loop shuts\n+    //   down while external code is still holding client references.\n+    //\n+    // The first case is handled here in destructor when m_loop is not null. The\n+    // second case is handled by the m_cleanup function, which sets m_loop to\n+    // null so nothing happens here.\n+    if (m_connection) {\n+        // Remove m_cleanup callback so it doesn't run and try to access\n+        // this object after it's already destroyed.\n+        m_connection->removeCleanup(m_cleanup);\n+\n+        // Destroy remote object, waiting for it to deleted server side.\n+        self().destroy();\n+\n+        m_connection->m_loop.sync([&]() {\n+            // Release client capability by move-assigning to temporary.\n+            {\n+                typename Interface::Client(std::move(self().m_client));\n+            }\n+            m_connection->m_loop.removeClient();\n+        });\n+    }\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::ProxyServerBase(Impl* impl, bool owned, EventLoop& loop, Connection* connection)\n+    : m_impl(impl), m_owned(owned), m_connection(connection)\n+{\n+    assert(impl != nullptr);\n+    AddClient(loop);\n+}\n+\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::ProxyServerBase(Impl* impl, bool owned, Connection& connection)\n+    : ProxyServerBase(impl, owned, connection.m_loop, &connection)\n+{\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::~ProxyServerBase()\n+{\n+    if (Impl* impl = m_impl) {\n+        // If impl is non-null, it means client was not destroyed\n+        // cleanly (was killed or disconnected). Since client isn't\n+        // providing thread to run destructor on, create a new thread.\n+        // Do not run destructor on current (event loop) thread since\n+        // destructors could be making IPC calls or doing expensive\n+        // cleanup.\n+        if (m_owned) {\n+            m_connection->addCleanup(MakeAsyncCallable(\n+                kj::mvCapture(std::thread{[impl]() { delete impl; }}, [](std::thread&& thread) { thread.join(); })));\n+        }\n+        m_impl = nullptr;\n+        m_owned = false;\n+    }\n+    RemoveClient(m_connection->m_loop);\n+}\n+\n+template <typename Interface, typename Impl>\n+void ProxyServerBase<Interface, Impl>::invokeDestroy()\n+{\n+    if (m_owned) delete m_impl;\n+    m_impl = nullptr;\n+    m_owned = false;\n+}\n+\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.connection));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.connection);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.connection));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.connection));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    // Set owned to false so proxy object doesn't attempt to delete interface\n+    // reference when it is discarded remotely, or on disconnect.\n+    output.set(kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(\n+        &value, false /* owned */, invoke_context.connection));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.connection));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.connection.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250904863",
      "id" : 250904863,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDkwNDg2Mw==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_position" : 1405,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : 1388,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "updated_at" : "2019-03-21T13:04:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250904863",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
