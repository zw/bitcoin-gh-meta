[
   {
      "body" : "Oh. Nice.\r\nI expected much more code to achieve this.\r\n\r\nConceptually I think this goes into the right direction, though, I'm not sure if this could end up being only a temporary in-between step that may end up being replaced.\r\nBecause, it may be more effective to split the Qt/d part completely and let them communicate over the p2p protocol (SPV and eventually RPC). More effective because it would also allow to run Qt independent from a trusted full node (if not trusted, use mechanism like full block SPV, etc.).\r\n\r\nThough, I'm aware that capnp has an RPC layer. But this would introduce another API (RPC / ZMQ / REST and then capnp RPC).\r\n\r\nI'm not saying this is the wrong direction, but we should be careful about adding another API.\r\n\r\nThree questions:\r\n- Would the performance be impractical if we would try to use the existing RPC API?\r\n- Could the capnp approach (or lets say IPC approach) be designed as a (or the) new API (\"JSON RPC v2\" and replacement for ZMQ)?\r\n- Does capnp provide a basic form of authentication? Would that even be required?",
      "created_at" : "2017-03-28T07:38:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289688689",
      "id" : 289688689,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T07:38:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289688689",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "> Would the performance be impractical if we would try to use the existing RPC API?\r\n\r\nReason this is currently using capnp is not performance but convenience. Capnp provides a high level API that supports bidirectional, synchronous, and asynchronous calls out of the box and allows me to easily explore implementation choices in bitcoin-qt without having to worry about low level protocol details, write a lot of parameter packing/unpacking boilerplate, and implement things like long polling.\r\n\r\nCapnp could definitely be replaced by JSON-RPC, though, and I've gone out of my way to support this by not calling capnp functions or using capnp types or headers anywhere except the `ipc/server.cpp` and `ipc/client.cpp` files. No code outside of these two files has to change in order to move to a different protocol.\r\n\r\n> Could the capnp approach (or lets say IPC approach) be designed as a (or the) new API (\"JSON RPC v2\" and replacement for ZMQ)?\r\n\r\nIt could, but I'm going out of my way right now specifically NOT to add yet another bitcoind public API that could add to the JSON-RPC/REST/ZMQ/-blocknotify/-walletnotify confusion. The IPC here doesn't happen over a TCP port or even a unix socket path but over an anonymous [socketpair](http://man7.org/linux/man-pages/man2/socketpair.2.html) using an inherited file descriptor. (I haven't done a windows implementation yet but [similar things](https://msdn.microsoft.com/en-us/library/ms683463(v=VS.85).aspx) are possible there).\r\n\r\nI'm trying to make the change completely internal for now and transparent to users. Bitcoin-qt should still be invoked the same way and behave the same way as before, starting its own node and wallet. It just will happen to do this internally now by forking a bitcoind executable rather than calling in-process functions. \r\n\r\nThis change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. Adding these features and supporting new public APIs might be things we want to do in the future, but they would involve downsides and complications that I'm trying to avoid here.\r\n\r\n> Does capnp provide a basic form of authentication? Would that even be required?\r\n\r\nIt's not required here because this change doesn't expose any new socket or endpoint, but it could be supported. Capnp's security model is based on [capabilities](https://capnproto.org/rpc.html#security), so to add authentication, you would just define a factory function that takes credentials as parameters and returns a reference to an object exposing the appropriate functionality.\r\n\r\n",
      "created_at" : "2017-03-28T09:58:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289721777",
      "id" : 289721777,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T09:58:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289721777",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "I'm really uncomfortable with using capn proto, but fine enough for some example testing stuff!\r\n\r\nI'm a fan of this general approach (ignoring the use of capn proto) and I think we should have done something like it a long time ago.",
      "created_at" : "2017-03-28T17:23:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289842646",
      "id" : 289842646,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T17:23:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289842646",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "strong concept ACK, but if is feasible, would prefer usage of the existing RPC instead of capn'proto",
      "created_at" : "2017-03-28T22:39:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289927205",
      "id" : 289927205,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-28T22:39:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289927205",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "Concept ACK, nice.\r\n\r\n> I'm really uncomfortable with using capn proto, but fine enough for some example testing stuff!\r\n\r\nPlease, let's not turn this into a discussion of serialization and RPC frameworks. To be honest that's been one of the things that's putting me off of doing work like this. If you want to suggest what framework to use, please make a thorough investigation of what method would be best to use for our specific use case, and propose that, but let's not start throwing random \"I'm not comfortable with X\" comments.\r\n\r\nWe already use google protocol buffers in the GUI for payment requests to in a way that would be the straightforward choice. I'm also happy you didn't choose some XML-based abomonation or ASN.1. But anyhow, not here. For this pull it's fine to use whatever RPC mechanism you're comfortable with. \r\n\r\n> This change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. \r\n\r\nI'm also perfectly fine with keeping the scope here to \"communication between GUI and bitcoind\". This is not the place for introducing another external interface. Might be an option at some point in the future, but for now process isolation is enough motivation.",
      "created_at" : "2017-03-29T06:53:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289999980",
      "id" : 289999980,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-03-29T07:24:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289999980",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618386"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618386"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yep I guess most of these calls should be turned into async calls and not wait on a response synchronously blocking the GUI. Not necessarily in the first iteration of this, of course.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T08:29:01Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618386",
      "id" : 108618386,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYxODM4Ng==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 757,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29659509,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618386",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty nice. So the IPC endpoint exposes multiple \"objects\". It can also expose multiple instances of one class? (e.g. for multiwallet?).",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T08:31:06Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108618794",
      "id" : 108618794,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYxODc5NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 33,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29659918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108618794",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108620012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108620012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should it pass through parameters? Most of the parameters to `bitcoin-qt` will actually be for the daemon. Or will you provide parameters in a later stage through IPC?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T08:37:27Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108620012",
      "id" : 108620012,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMDAxMg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 479,
      "original_position" : 166,
      "original_start_line" : null,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 29661133,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108620012",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623210"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623210"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The thread group is completely remote in the case of IPC, isn't it? I guess this entire function should be done differently when IPC is used. E.g. send a `shutdown` command to the core, then have the `shutdownResult` event come from remote as response when done.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T08:52:59Z",
      "diff_hunk" : "@@ -298,9 +303,9 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        Interrupt(threadGroup);\n+        FIXME_IMPLEMENT_IPC(Interrupt(threadGroup));\n         threadGroup.join_all();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623210",
      "id" : 108623210,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMzIxMA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 307,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29664563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623210",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623907"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623907"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How would you handle `uiInterface` in this model, e.g. signals from the server to the client?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T08:56:29Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108623907",
      "id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYyMzkwNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29665337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108623907",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108631852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108631852"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Should it pass through parameters? Most of the parameters to bitcoin-qt will actually be for the daemon. Or will you provide parameters in a later stage through IPC?\r\n\r\nThe change I'm working on now (not yet pushed) provides the parameters over IPC. It adds an `ipc::Node::parseParameters` method in `client.h` which calls `ParseParameters()` in bitcoind.\r\n\r\n```diff\r\n+    //! Set command line arguments.\r\n+    void parseParameters(int argc, const char* const argv[]) const;\r\n+\r\n     //! Get help message string.\r\n     std::string helpMessage(HelpMessageMode mode) const;\r\n \r\n+    //! Start node.\r\n+    bool appInit() const;\r\n+\r\n+    //! Stop node.\r\n+    void appShutdown() const;\r\n+\r\n+    //! Return whether shutdown was requested.\r\n+    bool shutdownRequested() const;\r\n```\r\n\r\n`ParseParameters()` is also called on the `bitcoin-qt` side in current change. This gets the job done, but could be improved later, since really the `bitcoind` global variables set by `ParseParameters()` should not even be linked into `bitcoin-qt`.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T09:35:21Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108631852",
      "id" : 108631852,
      "in_reply_to_id" : 108620012,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzMTg1Mg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 479,
      "original_position" : 166,
      "original_start_line" : null,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108631852",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108636959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108636959"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> It can also expose multiple instances of one class?\r\n\r\nYes, the `ipc::Node::wallet()` method right now returns an `ipc::Wallet` interface wrapping pwalletMain, but it could support multiwallet by just adding an argument that indicates a different wallet object to return.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T09:59:11Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108636959",
      "id" : 108636959,
      "in_reply_to_id" : 108618794,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzNjk1OQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 33,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108636959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108637607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108637607"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> The thread group is completely remote in the case of IPC, isn't it?\r\n\r\nYes the change I'm working on now adds `threadGroup` and `scheduler` members to `NodeServer` in `ipc/server.cpp`, removing the current instances in `BitcoinCore`.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T10:02:14Z",
      "diff_hunk" : "@@ -298,9 +303,9 @@ void BitcoinCore::shutdown()\n     try\n     {\n         qDebug() << __func__ << \": Running Shutdown in thread\";\n-        Interrupt(threadGroup);\n+        FIXME_IMPLEMENT_IPC(Interrupt(threadGroup));\n         threadGroup.join_all();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108637607",
      "id" : 108637607,
      "in_reply_to_id" : 108623210,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODYzNzYwNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 307,
      "original_position" : 68,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108637607",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108640254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108640254"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> How would you handle uiInterface in this model, e.g. signals from the server to the client?\r\n\r\nThis line needs to change to `ipcNode.handleInitMessage(InitMessage)`. If you look at the `ipc::Node::handleInitMessage` implementation, it takes a std::function argument, creates a capnp `InitMessageCallback::Server` object that can invoke it, and sends a reference to that object over the IPC channel to `bitcoind`. `bitcoind` then calls `uiInterface.InitMessage.connect` with a handler that sends messages with the `InitMessageCallback` object.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T10:16:22Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108640254",
      "id" : 108640254,
      "in_reply_to_id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0MDI1NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108640254",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108643836"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108643836"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Yep I guess most of these calls should be turned into async calls and not wait on a response synchronously blocking the GUI. Not necessarily in the first iteration of this, of course.\r\n\r\nAnother alternative in some of these cases is to consolidate many low level calls into fewer calls of a higher level interface.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T10:35:58Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108643836",
      "id" : 108643836,
      "in_reply_to_id" : 108618386,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0MzgzNg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 757,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29673898,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108643836",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think that's not optional but a required element of making this asynchronous, otherwise there'd be a lot of roundtrips.\r\n\r\nEdit: Though ofcourse one of the things cap'n'proto advertises with is that there is 'zero roundtrip overhead', because of the promise pipelining, but we don't want to depend too strongly on that.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T10:58:28Z",
      "diff_hunk" : "@@ -704,10 +704,10 @@ bool WalletModel::hdEnabled() const\n \n int WalletModel::getDefaultConfirmTarget() const\n {\n-    return nTxConfirmTarget;\n+    return FIXME_IMPLEMENT_IPC_VALUE(nTxConfirmTarget);\n }\n \n bool WalletModel::getDefaultWalletRbf() const\n {\n-    return fWalletRbf;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647650",
      "id" : 108647650,
      "in_reply_to_id" : 108618386,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0NzY1MA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 757,
      "original_position" : 273,
      "original_start_line" : null,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29690453,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647650",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647949"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Cool. I like this auto-generated IPC stuff. Saves writing a lot of boilerplate.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T11:00:13Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+@0xa4478fe5ad6d80f5;\n+\n+using Cxx = import \"/capnp/c++.capnp\";\n+$Cxx.namespace(\"ipc::messages\");\n+\n+interface Node {\n+    helpMessage @0 (mode :Int32) -> (value :Text);\n+    handleInitMessage @1 (callback: InitMessageCallback) -> (handler :Handler);\n+    wallet @2 () -> (wallet :Wallet);\n+}\n+\n+interface Wallet {\n+    getBalance @0 () -> (value :Int64);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108647949",
      "id" : 108647949,
      "in_reply_to_id" : 108618794,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0Nzk0OQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 33,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/ipc/messages.capnp",
      "position" : null,
      "pull_request_review_id" : 29690788,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108647949",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108648613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108648613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So the server then effectively calls an object on the client when the notification happens? No polling/waiting involved? That's great.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T11:04:37Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108648613",
      "id" : 108648613,
      "in_reply_to_id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0ODYxMw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29691510,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108648613",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108649962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108649962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This locking (either of cs_main or wallet->cs_wallet) makes no sense when a remote core is used.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T11:12:56Z",
      "diff_hunk" : "@@ -679,17 +679,17 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);\n     const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n+    if (!wtx || wtx->isAbandoned() || FIXME_IMPLEMENT_IPC_VALUE(wtx->GetDepthInMainChain()) > 0 || FIXME_IMPLEMENT_IPC_VALUE(wtx->InMempool()))\n         return false;\n     return true;\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->AbandonTransaction(hash);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108649962",
      "id" : 108649962,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY0OTk2Mg==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 692,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29692971,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108649962",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670193"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> So the server then effectively calls an object on the client when the notification happens? No polling/waiting involved? That's great.\r\n\r\nYes, though to be clear, there is still polling/waiting happening under the hood. It just gets handled by the capnp event loop, which waits for incoming IPC messages and dispatches to `InitMessageCallback::Server::call` and other server methods. The change I'm working on now (not yet pushed) spawns a new thread in ipc/client.cpp to run the event loop.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T13:06:38Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670193",
      "id" : 108670193,
      "in_reply_to_id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDE5Mw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670193",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670537"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI this is quite similar to how fd handles are passed in for the P2P and RPC port in my cloudabi port: https://github.com/laanwj/bitcoin/blob/2017_03_cabi_fs/src/httpserver.cpp#L357 https://github.com/laanwj/bitcoin/blob/2017_03_cabi_fs/src/init.cpp#L1356\r\n\r\nIt's a bit of a shame that argument parsing doesn't work here yet so this needs to use manual parsing using C functions :/",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T13:08:25Z",
      "diff_hunk" : "@@ -0,0 +1,102 @@\n+#include \"ipc/server.h\"\n+\n+#include \"init.h\"\n+#include \"ui_interface.h\"\n+#include \"wallet/wallet.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/async-io.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+class HandlerServer final : public messages::Handler::Server\n+{\n+public:\n+    HandlerServer(kj::AsyncIoContext& ioContext_, messages::InitMessageCallback::Client callback_)\n+        : ioContext(ioContext_),\n+          callback(std::move(callback_)),\n+          connection(uiInterface.InitMessage.connect(\n+              [this](const std::string& message) {\n+                  auto request = callback.callRequest();\n+                  request.setMessage(message);\n+                  auto promise = request.send();\n+                  promise.wait(ioContext.waitScope);\n+              })) {}\n+\n+    kj::Promise<void> disconnect(DisconnectContext context) override\n+    {\n+        connection.disconnect();\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+\n+    messages::InitMessageCallback::Client callback;\n+    boost::signals2::scoped_connection connection;\n+};\n+\n+class WalletServer final : public messages::Wallet::Server\n+{\n+public:\n+    WalletServer(CWallet& wallet_) : wallet(wallet_) {}\n+\n+    kj::Promise<void> getBalance(GetBalanceContext context) override\n+    {\n+        context.getResults().setValue(wallet.GetBalance());\n+        return kj::READY_NOW;\n+    }\n+\n+    CWallet& wallet;\n+};\n+\n+class NodeServer final : public messages::Node::Server\n+{\n+public:\n+    NodeServer(kj::AsyncIoContext& ioContext_) : ioContext(ioContext_) {}\n+    kj::Promise<void> helpMessage(HelpMessageContext context) override\n+    {\n+        context.getResults().setValue(HelpMessage(HelpMessageMode(context.getParams().getMode())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> handleInitMessage(HandleInitMessageContext context) override\n+    {\n+        context.getResults().setHandler(ipc::messages::Handler::Client(kj::heap<HandlerServer>(ioContext, context.getParams().getCallback())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> wallet(WalletContext context) override\n+    {\n+        context.getResults().setWallet(ipc::messages::Wallet::Client(kj::heap<WalletServer>(*pwalletMain)));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+};\n+\n+} // namespace\n+\n+bool StartServer(int argc, char* argv[], int& exitStatus)\n+{\n+    if (argc != 3 || strcmp(argv[1], \"-ipcfd\") != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670537",
      "id" : 108670537,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDUzNw==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 10,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/ipc/server.cpp",
      "position" : null,
      "pull_request_review_id" : 29715391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670537",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670851"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> This locking (either of cs_main or wallet->cs_wallet) makes no sense when a remote core is used.\r\n\r\nYeah, the point of the FIXME_IMPLEMENT_IPC macro is really just to segfault and indicate places in the code which need to be updated to support IPC. Many of them are pretty nonsensical.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T13:09:53Z",
      "diff_hunk" : "@@ -679,17 +679,17 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);\n     const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n+    if (!wtx || wtx->isAbandoned() || FIXME_IMPLEMENT_IPC_VALUE(wtx->GetDepthInMainChain()) > 0 || FIXME_IMPLEMENT_IPC_VALUE(wtx->InMempool()))\n         return false;\n     return true;\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    return wallet->AbandonTransaction(hash);\n+    LOCK2(FIXME_IMPLEMENT_IPC_VALUE(cs_main), wallet->cs_wallet);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108670851",
      "id" : 108670851,
      "in_reply_to_id" : 108649962,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MDg1MQ==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 692,
      "original_position" : 258,
      "original_start_line" : null,
      "path" : "src/qt/walletmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108670851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108671594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108671594"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> It's a bit of a shame that argument parsing doesn't work here yet so this needs to use manual parsing using C functions :/\r\n\r\nI think I could change this to at least use GetArg like you are doing in your cloudabi code.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-29T13:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,102 @@\n+#include \"ipc/server.h\"\n+\n+#include \"init.h\"\n+#include \"ui_interface.h\"\n+#include \"wallet/wallet.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/async-io.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+class HandlerServer final : public messages::Handler::Server\n+{\n+public:\n+    HandlerServer(kj::AsyncIoContext& ioContext_, messages::InitMessageCallback::Client callback_)\n+        : ioContext(ioContext_),\n+          callback(std::move(callback_)),\n+          connection(uiInterface.InitMessage.connect(\n+              [this](const std::string& message) {\n+                  auto request = callback.callRequest();\n+                  request.setMessage(message);\n+                  auto promise = request.send();\n+                  promise.wait(ioContext.waitScope);\n+              })) {}\n+\n+    kj::Promise<void> disconnect(DisconnectContext context) override\n+    {\n+        connection.disconnect();\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+\n+    messages::InitMessageCallback::Client callback;\n+    boost::signals2::scoped_connection connection;\n+};\n+\n+class WalletServer final : public messages::Wallet::Server\n+{\n+public:\n+    WalletServer(CWallet& wallet_) : wallet(wallet_) {}\n+\n+    kj::Promise<void> getBalance(GetBalanceContext context) override\n+    {\n+        context.getResults().setValue(wallet.GetBalance());\n+        return kj::READY_NOW;\n+    }\n+\n+    CWallet& wallet;\n+};\n+\n+class NodeServer final : public messages::Node::Server\n+{\n+public:\n+    NodeServer(kj::AsyncIoContext& ioContext_) : ioContext(ioContext_) {}\n+    kj::Promise<void> helpMessage(HelpMessageContext context) override\n+    {\n+        context.getResults().setValue(HelpMessage(HelpMessageMode(context.getParams().getMode())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> handleInitMessage(HandleInitMessageContext context) override\n+    {\n+        context.getResults().setHandler(ipc::messages::Handler::Client(kj::heap<HandlerServer>(ioContext, context.getParams().getCallback())));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::Promise<void> wallet(WalletContext context) override\n+    {\n+        context.getResults().setWallet(ipc::messages::Wallet::Client(kj::heap<WalletServer>(*pwalletMain)));\n+        return kj::READY_NOW;\n+    }\n+\n+    kj::AsyncIoContext& ioContext;\n+};\n+\n+} // namespace\n+\n+bool StartServer(int argc, char* argv[], int& exitStatus)\n+{\n+    if (argc != 3 || strcmp(argv[1], \"-ipcfd\") != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r108671594",
      "id" : 108671594,
      "in_reply_to_id" : 108670537,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODY3MTU5NA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 10,
      "original_position" : 89,
      "original_start_line" : null,
      "path" : "src/ipc/server.cpp",
      "position" : null,
      "pull_request_review_id" : 29714989,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108671594",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085466"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085466"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Right, ideally bitcoin-qt would need only a very small subset of the bitcoind code.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-31T04:19:04Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#include \"ipc/client.h\"\n+\n+#include \"bitcoin-config.h\"\n+\n+#pragma GCC diagnostic ignored \"-Wshadow\"\n+#include \"ipc/messages.capnp.h\"\n+#pragma GCC diagnostic pop\n+\n+#include <capnp/rpc-twoparty.h>\n+#include <kj/debug.h>\n+\n+#include <sys/resource.h>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+namespace ipc\n+{\n+\n+namespace\n+{\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId {\n+    capnp::word scratch[4]{};\n+    capnp::MallocMessageBuilder message{scratch};\n+    capnp::rpc::twoparty::VatId::Builder vatId{message.getRoot<capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vatId.setSide(capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+//! Return highest possible file descriptor.\n+size_t MaxFd()\n+{\n+    struct rlimit nofile;\n+    if (getrlimit(RLIMIT_NOFILE, &nofile) == 0) {\n+        return nofile.rlim_cur - 1;\n+    } else {\n+        return 1023;\n+    }\n+}\n+\n+//! Forwarder for handleInitMessage callback.\n+class InitMessageCallbackServer final : public messages::InitMessageCallback::Server\n+{\n+public:\n+    InitMessageCallbackServer(std::function<void(const std::string&)> callback_) : callback(std::move(callback_)) {}\n+\n+    kj::Promise<void> call(CallContext context) override\n+    {\n+        callback(context.getParams().getMessage());\n+        return kj::READY_NOW;\n+    }\n+\n+    std::function<void(const std::string&)> callback;\n+};\n+\n+} // namespace\n+\n+//! Friend factory class able to call private constructors of IPC objects.\n+class Factory\n+{\n+public:\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeUnique(Args&&... args)\n+    {\n+        return std::unique_ptr<T>(new T(std::forward<Args>(args)...));\n+    }\n+\n+    template <typename T, typename... Args>\n+    static std::unique_ptr<T> MakeImpl(Args&&... args)\n+    {\n+        return MakeUnique<T>(MakeUnique<typename T::Impl>(std::forward<Args>(args)...));\n+    }\n+};\n+\n+//! Handler private member struct.\n+struct Handler::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Handler::Client handlerClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Handler::Client handlerClient_) : ioContext(ioContext_), handlerClient(std::move(handlerClient_)) {}\n+};\n+\n+Handler::Handler(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Handler::~Handler() {}\n+\n+void Handler::disconnect() const\n+{\n+    auto request = impl->handlerClient.disconnectRequest();\n+    auto promise = request.send();\n+    promise.wait(impl->ioContext.waitScope);\n+}\n+\n+//! Wallet private member struct.\n+struct Wallet::Impl {\n+    kj::AsyncIoContext& ioContext;\n+    messages::Wallet::Client walletClient;\n+    Impl(kj::AsyncIoContext& ioContext_, messages::Wallet::Client walletClient_) : ioContext(ioContext_), walletClient(std::move(walletClient_)) {}\n+};\n+\n+Wallet::Wallet(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Wallet::~Wallet() {}\n+\n+CAmount Wallet::getBalance() const\n+{\n+    auto request = impl->walletClient.getBalanceRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+//! Node private member struct.\n+struct Node::Impl {\n+    kj::AsyncIoContext ioContext{kj::setupAsyncIo()};\n+    kj::Own<kj::AsyncIoStream> clientStream;\n+    capnp::TwoPartyVatNetwork clientNetwork{*clientStream, capnp::rpc::twoparty::Side::CLIENT, capnp::ReaderOptions()};\n+    capnp::RpcSystem<capnp::rpc::twoparty::VatId> rpcClient{capnp::makeRpcClient(clientNetwork)};\n+    messages::Node::Client nodeClient{rpcClient.bootstrap(ServerVatId().vatId).castAs<messages::Node>()};\n+\n+    Impl(int fd) : clientStream(ioContext.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)) {}\n+};\n+\n+Node::Node(std::unique_ptr<Impl> impl_) : impl(std::move(impl_)) {}\n+\n+Node::~Node() {}\n+\n+std::string Node::helpMessage(HelpMessageMode mode) const\n+{\n+    auto request = impl->nodeClient.helpMessageRequest();\n+    request.setMode(mode);\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return response.getValue();\n+}\n+\n+std::unique_ptr<Handler> Node::handleInitMessage(std::function<void(const std::string&)> callback) const\n+{\n+    auto request = impl->nodeClient.handleInitMessageRequest();\n+    request.setCallback(kj::heap<InitMessageCallbackServer>(std::move(callback)));\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Handler>(impl->ioContext, response.getHandler());\n+}\n+\n+std::unique_ptr<Wallet> Node::wallet() const\n+{\n+    auto request = impl->nodeClient.walletRequest();\n+    auto promise = request.send();\n+    auto response = promise.wait(impl->ioContext.waitScope);\n+    return Factory::MakeImpl<Wallet>(impl->ioContext, response.getWallet());\n+}\n+\n+std::unique_ptr<Node> StartClient()\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+\n+    if (fork() == 0) {\n+        int maxFd = MaxFd();\n+        for (int fd = 3; fd < maxFd; ++fd) {\n+            if (fd != fds[0]) {\n+                close(fd);\n+            }\n+        }\n+        if (execlp(BITCOIN_DAEMON_NAME, BITCOIN_DAEMON_NAME, \"-ipcfd\", std::to_string(fds[0]).c_str(), nullptr) != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085466",
      "id" : 109085466,
      "in_reply_to_id" : 108620012,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwOTA4NTQ2Ng==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 479,
      "original_position" : 166,
      "original_start_line" : null,
      "path" : "src/ipc/client.cpp",
      "position" : null,
      "pull_request_review_id" : 30164009,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085466",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085760"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085760"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, I understand that, but one of the problems with existing proposals for using RPC to communicate to the server had no way to handle asynchonous notifications, so needed to e.g. poll for new transactions every few seconds. This protocol clearly does support true bidirectional communication.\r\n\r\nAs for the capnp event loop, as most of the responses and notifications from the server involve updating the UI, couldn't we integrate that into Qt's event loop? Conceptually that'd be easier. Qt only allows GUI updates from a single thread, so if the capnp event loop is separete, everything will have to be separately ferried through Qt's signal mechanism to get to the GUI thread.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-03-31T04:23:28Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r109085760",
      "id" : 109085760,
      "in_reply_to_id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwOTA4NTc2MA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 30164306,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/109085760",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r110290288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/110290288"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> As for the capnp event loop, as most of the responses and notifications from the server involve updating the UI, couldn't we integrate that into Qt's event loop? \r\n\r\nIt should be possible to integrate the qt and capnp event loops (http://stackoverflow.com/questions/33131595/what-is-a-good-way-to-integrate-3rd-party-asynchronous-apis-with-capn-proto-rpc), but for now `StartClient` is just spawning an event loop thread, since this seems like the path of least resistance.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2017-04-06T23:34:25Z",
      "diff_hunk" : "@@ -676,7 +682,7 @@ int main(int argc, char *argv[])\n     app.createOptionsModel(IsArgSet(\"-resetguisettings\"));\n \n     // Subscribe to global signals from core\n-    uiInterface.InitMessage.connect(InitMessage);\n+    FIXME_IMPLEMENT_IPC_VALUE(uiInterface).InitMessage.connect(InitMessage);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r110290288",
      "id" : 110290288,
      "in_reply_to_id" : 108623907,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDExMDI5MDI4OA==",
      "original_commit_id" : "bf5f8ed6f0124d65af0198b473cb25513fe84325",
      "original_line" : 685,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/qt/bitcoin.cpp",
      "position" : null,
      "pull_request_review_id" : 31454791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/110290288",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Updated and rebased 0ca73bc13c3457cd5c3244abfa9fa586d9137117 -> 5e28c2fcc2757479d29ca83cd3256584ab908e48 ([pr/ipc.1](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.1) -> [pr/ipc.3](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.3)) to avoid a conflict. Main addition is an expanded [src/ipc/README.md](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/src/ipc/README.md) file.\r\n\r\nAgain it would be very helpful to have some code review for the main commit (5e28c2fcc2757479d29ca83cd3256584ab908e48 \"Add barebones IPC framework to bitcoin-qt and bitcoind\"). Giving feedback on the README file would be an easy place to start.",
      "created_at" : "2017-04-07T20:51:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-292648484",
      "id" : 292648484,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-10T22:06:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/292648484",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Updated 5e28c2fcc2757479d29ca83cd3256584ab908e48 -> dda375662d060ce42b5113247301e0289584e14d ([pr/ipc.3](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.3) -> [pr/ipc.4](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.4))\r\n\r\nThis implements two suggestions from @JeremyRubin:\r\n\r\n* It includes a small commit demonstrating what it looks like to add a single new method to the API:\r\n[`dda3756 Add ipc::Node::getNodeCount method`](https://github.com/bitcoin/bitcoin/commit/dda375662d060ce42b5113247301e0289584e14d). This should help give a clearer picture of the layers involved in implementing an IPC call.\r\n\r\n* Instead of adding Cap'n Proto code and modifying Qt code in a single commit, it includes a new early commit ([`1407a2b Add ipc::Node and ipc::Wallet interfaces`](https://github.com/bitcoin/bitcoin/commit/1407a2bb0b0a3ab21ae374b58980bb0dc53b12c5) that introduces new [`src/ipc/interfaces.h`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/interfaces.h)  and [`src/ipc/interfaces.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/ipc/interfaces.cpp) files and ports Qt code to use them without any Cap'n Proto stuff. This shows the separation between Qt updates and IPC implementation details better and makes it easier to see how a different IPC system could be substituted in for Cap'n Proto. This commit could even be made into a separate PR.\r\n",
      "created_at" : "2017-04-10T22:25:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-293096821",
      "id" : 293096821,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-10T22:25:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/293096821",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "@laanwj pointed out in IRC (https://botbot.me/freenode/bitcoin-core-dev/msg/83983170/) that this change could help make the GUI more responsive by preventing Qt event processing from getting blocked, which currently happens in the monolithic `bitcoin-qt` when the main GUI thread makes a call to a slow libbitcoin function, or waits a long time for a `cs_main` or `cs_wallet` lock.\r\n\r\nAt the time in IRC, I didn't think this change could directly help gui responsiveness, because although it does move libbitcoin and LOCK calls out of the `bitcoin-qt` process and into the `bitcoind` process, it just replaces these calls with blocking IPCs that make the GUI equally unresponsive when they tie up the main GUI thread.\r\n\r\nHowever, this doesn't have to be the case. The place where IPC calls currently block waiting for responses is the `return promise.get_future().get();` line in `ipc::util::Call::send` method here: https://github.com/ryanofsky/bitcoin/blob/pr/ipc.4/src/ipc/util.h#L166\r\n\r\nBut the `std::promise` object used in that line could easily be replaced with a Qt-aware promise object that processes GUI events while the promise is blocked. (The Qt-aware promise implementation would check if it is being used on the main GUI thread, and if so use a [local Qt event loop](https://doc.qt.io/archives/qq/qq27-responsive-guis.html#waitinginalocaleventloop) substituting\r\n`loop.exec()` for `std::future::get()` and `loop.quit()` for `std::promise::set_value()`.)\r\n\r\nThis would add more overhead and make the average IPC call a little slower. But it would avoid situations where an unexpectedly slow IPC call ties up the whole gui, so it might be worth doing anyway.",
      "created_at" : "2017-04-14T05:44:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294094610",
      "id" : 294094610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-14T05:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294094610",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "@ryanofsky Yes, integrating the IPC event loop and Qt event loop would help responsiveness.\r\nThough I remember there were some issues in some cases with recursively calling into the Qt event loop (e.g. things need to be reentrant, deleteLater stuff runs earlier than expected, to keep in mind).",
      "created_at" : "2017-04-14T08:00:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294111566",
      "id" : 294111566,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-14T08:00:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294111566",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@ryanofsky I'm not familiar with Qt or capnproto, but I don't understand what the move to a different process has to do with making things less blocking. Any changes in architecture that would result in less blocks should equally be possible within the same process.\r\n\r\n",
      "created_at" : "2017-04-17T12:23:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294474620",
      "id" : 294474620,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T12:23:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294474620",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> This change will not add any new command line or GUI options allowing bitcoin-qt to connect to bitcoinds other than the one it spawns internally. Adding these features and supporting new public APIs might be things we want to do in the future, but they would involve downsides and complications that I'm trying to avoid here.\r\n\r\nI don't understand the goal here. On itself, there seems little benefit in separating the GUI and the rest into separate processes if those two processes still depend on each other (this is different from separating the wallet from the node, for example, as there as security considerations there... but for that use case the easiest approach seems to just have a lightweight mode and running two instances).\r\n\r\nI think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background, but if that's not the intent, what is the purpose?",
      "created_at" : "2017-04-17T12:29:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294475317",
      "id" : 294475317,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T12:29:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294475317",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> Any changes in architecture that would result in less blocks should equally be possible within the same process.\r\n\r\nLet's say there are 50 places where bitcoin-qt calls a libbitcoin function. That means there are 50 places to update if you want bitcoin-qt handle to events while the function calls are executing. WIth the IPC framework, there is only one place you have to update instead of 50 places (if you want to do this).\r\n\r\n> On itself, there seems little benefit in separating the GUI and the rest into separate processes if those two processes still depend on each other.\r\n\r\nOk, so you think the benefits are small, and I think they are more significant.\r\n\r\n> I think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background,\r\n\r\nThis is trivial once bitcoin-qt is controlling bitcoind across a socket. I'm just implementing the socket part first, without introducing new UI features for now.",
      "created_at" : "2017-04-17T14:15:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294493467",
      "id" : 294493467,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T14:15:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294493467",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "> > I think it would be awesome if bitcoin-qt could be started and stopped independently to control a bitcoind process in the background,\r\n>\r\n> This is trivial once bitcoin-qt is controlling bitcoind across a socket. I'm just implementing the socket part first, without introducing new UI features for now.\r\n\r\nOk, that's what I was missing. It wasn't clear to me that this was a just first step towards a more useful separation.",
      "created_at" : "2017-04-17T18:48:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-294557349",
      "id" : 294557349,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-17T18:48:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294557349",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "As of 8f78f085976bcb0f9093f0b1b4c3c65110ec44aa ([pr/ipc.7](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.7)), this change is much more complete & functional. You can also now monitor the IPC traffic going back and forth between `bitcoin-qt` and `bitcoind` by setting the `IPC_DEBUG` environment variable (`export IPC_DEBUG=1`)\r\n",
      "created_at" : "2017-04-27T18:01:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-297792312",
      "id" : 297792312,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "updated_at" : "2017-04-27T18:01:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/297792312",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r209425169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209425169"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For MacOS it's `brew install capnp` ",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-08-11T12:05:19Z",
      "diff_hunk" : "@@ -105,7 +105,7 @@ To build without GUI pass `--without-gui`.\n \n To build with Qt 5 you need the following:\n \n-    sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler\n+    sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools libprotobuf-dev protobuf-compiler libcapnp-dev capnproto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r209425169",
      "id" : 209425169,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwOTQyNTE2OQ==",
      "original_commit_id" : "006286e7310353fbfd143f69e9a319b24bd49e75",
      "original_line" : 115,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "doc/build-unix.md",
      "position" : null,
      "pull_request_review_id" : 145444882,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/209425169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated 85b23296891032875cbda7a3c70c3422ce04da15 -> 84af92e496f00608dff749e7b1372964cb20df42 ([pr/ipc.46](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.46) -> [pr/ipc.47](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.47)) with various cleanups and fixes for macos.\r\nUpdated 84af92e496f00608dff749e7b1372964cb20df42 -> ca294aa8c036bf62d808450a4555a0806ff7227b ([pr/ipc.47](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.47) -> [pr/ipc.48](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.48)) with fixes for appveyor / msvc.\r\n\r\n\r\nThanks for trying this out Sjors. The compiler errors & warnings you encountered should be fixed now, and I did some light ui testing on macos with `src/bitcoin-gui -regtest -printtoconsole -debug`\r\n\r\n",
      "created_at" : "2018-08-21T19:33:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-414794955",
      "id" : 414794955,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNDc5NDk1NQ==",
      "updated_at" : "2018-08-22T22:30:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/414794955",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Compile errors are gone now.\r\n\r\nThe `multiprocess=yes/no` line in `./configure` only showed up for me after running `./autogen.sh` again. This was without using the `--enable-multiprocess` argument.\r\n\r\nThe documentation suggests multiprocess isn't on by default, but it is:\r\n\r\n```\r\n./configure --disable-bench --disable-zmq --with-miniupnpc=no --with-incompatible-bdb --with-qrencode\r\n....\r\nOptions used to compile and link:\r\n  multiprocess  = yes\r\n```\r\n\r\nI do still see a few warnings that appear related to this change:\r\n\r\n```\r\ninterfaces/capnp/util.cpp:15:90: warning: 'syscall' is deprecated: first deprecated in macOS 10.12 - syscall(2) is unsupported; please switch to a supported interface. For SYS_kdebug_trace use kdebug_signpost(). [-Wdeprecated-declarations]\r\n    return strprintf(\"%s-%i/%s-%i\", exe_name ? exe_name : \"\", getpid(), thread_name, int(syscall(SYS_gettid)));\r\n                                                                                         ^\r\n/usr/include/unistd.h:745:6: note: 'syscall' has been explicitly marked deprecated here\r\nint      syscall(int, ...);\r\n         ^\r\n1 warning generated.\r\n```\r\n\r\nShould the test suite use these new binaries? In order to prevent the functional suite from taking forever to run, perhaps half of the default test suite nodes could use `bitcoind` and the other half `bitcoin-node`?\r\n\r\nThe `bitcoin-gui` executable is ignoring `testnet=1` in `bitcoin.conf`. `bitcoin-node` does honor it. When launched with `-testnet` it  correctly sees global options in `bitcoin.conf`., but it missed or incorrectly parses  options for `[test]`. E.g. if I set `dbcache=1000` under `[test]` the GUI shows this:\r\n\r\n<img width=\"383\" alt=\"schermafbeelding 2018-08-26 om 12 07 44\" src=\"https://user-images.githubusercontent.com/10217/44627135-d741cd80-a928-11e8-9c1a-c73151ab8da9.png\">\r\n\r\nShould the log file specify which process is generating each entry? Or should each process have its own log file, where the master process just logs \"started/stopped bitcoin-node process PID=....\"?\r\n\r\nI did some light GUI testing as well. Sending and receiving works. Using the console I'm getting the following error:\r\n\r\n<img width=\"594\" alt=\"schermafbeelding 2018-08-26 om 12 17 01\" src=\"https://user-images.githubusercontent.com/10217/44627206-060c7380-a92a-11e8-9cfe-84842cff0f66.png\">\r\n\r\n`getblockchaininfo` and even `getbalance` do work, so that's weird.\r\n\r\n`createwallet \"test\"` froze the app for me, and didn't create a file. When force quitting QT, it seems bitcoin-node keeps running. But then `bitcoin-cli help` just hangs. `bitcoin-cli stop` responds with `Bitcoin server stopping` but nothing happens in the log file and the process doesn't go away; I had to resort to `kill -9`.",
      "created_at" : "2018-08-26T10:26:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416028413",
      "id" : 416028413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjAyODQxMw==",
      "updated_at" : "2018-08-26T10:26:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416028413",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors, this is great! Thanks so much for testing this.\r\n\r\n> The documentation suggests multiprocess isn't on by default, but it is:\r\n\r\nSince `--enable-multiprocess` configure option only builds new executables and has no effect on existing ones, the default value is `auto` rather than `no`. This seems like the most convenient behavior, but I coudl change it or try to document it better.\r\n\r\n> I do still see a few warnings that appear related to this change:\r\n\r\nI also saw the syscall warning and plan to fix it. It's not serious problem, but a side effect seems to be that bad thread numbers are shown in the debug log.\r\n\r\n> Should the test suite use these new binaries? In order to prevent the functional suite from taking forever to run, perhaps half of the default test suite nodes could use bitcoind and the other half bitcoin-node?\r\n\r\nI'm planning on adding `--multiprocess` and `--gui` options to the python test framework to make it easier to switch between `bitcoin`, `bitcoin-qt`, `bitcoin-node`, and `bitcoin-gui` executables. All 4 of these should work, though some tests fail with `bitcoin-node` right now. I think default test mode should use `bitcoind` but travis should be configured to test other binaries, too.\r\n\r\n> The bitcoin-gui executable is ignoring testnet=1 in bitcoin.conf. bitcoin-node does honor it. When launched with -testnet it correctly sees global options in bitcoin.conf., but it missed or incorrectly parses options for [test].\r\n\r\nInteresting, this is not expected. Will debug.\r\n\r\n> Should the log file specify which process is generating each entry? Or should each process have its own log file, where the master process just logs \"started/stopped bitcoin-node process PID=....\"?\r\n\r\nEach process has its own log file and I extended the `combine_logs.py` script to be able to merge them. The log files just have simple suffixes right now so are named `debug.log` `debug.log.wallet` and `debug.log.gui`. The followup change I'm working on to add `-ipconnect` and `-ipcbind` options will allow multiple wallet and gui processes, so these names will no longer be unique and I'll have to add pid suffixes as well.\r\n\r\nWriting to a common log file would be another option, but it would require some kind of locking and syncing, so I don't think the complexity would be worth it.\r\n\r\n> I did some light GUI testing as well.\r\n\r\nThanks! I'll look into the various problems you reported and make fixes.",
      "created_at" : "2018-08-27T14:50:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416252818",
      "id" : 416252818,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjI1MjgxOA==",
      "updated_at" : "2018-08-27T14:50:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416252818",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I think default test mode should use bitcoind but travis should be configured to test other binaries, too.\r\n\r\nThat makes sense, we shouldn't force developers / users to compile the other binaries.\r\n\r\n> Writing to a common log file would be another option, but it would require some kind of locking and syncing, so I don't think the complexity would be worth it.\r\n\r\nMultiple log files seems fine by me, though when logging to console they would ideally be combined.",
      "created_at" : "2018-08-28T11:00:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416543491",
      "id" : 416543491,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNjU0MzQ5MQ==",
      "updated_at" : "2018-08-28T11:00:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/416543491",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549056"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: bookeeping",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-02T18:27:24Z",
      "diff_hunk" : "@@ -4,14 +4,16 @@ The following interfaces are defined here:\n \n * [`Chain`](chain.h) â used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`Chain::Client`](chain.h) â used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h) â used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n * [`Node`](node.h) â used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Wallet`](wallet.h) â used by GUI to access wallets. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Handler`](handler.h) â returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n \n-* [`Init`](init.h) â used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+* [`Init`](init.h) â used by multiprocess code to access other interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+\n+* [`Base`](base.h) â base interface class used by multiprocess code for bookeeping and cleanup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549056",
      "id" : 214549056,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA1Ng==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 17,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/interfaces/README.md",
      "position" : null,
      "pull_request_review_id" : 151629161,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549080"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: destuction",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-02T18:28:32Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549080",
      "id" : 214549080,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA4MA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 44,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151629183,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549080",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549093"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549093"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: âdontâ should be âdonâtâ or âdo notâ :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-02T18:29:13Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549093",
      "id" : 214549093,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTA5Mw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 46,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151629200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549093",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549127"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: halfs should be halves :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-02T18:30:30Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halfs at position index.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214549127",
      "id" : 214549127,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0OTEyNw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 151629222,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214549127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741787"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741787"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: paramters",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-03T18:00:33Z",
      "diff_hunk" : "@@ -0,0 +1,61 @@\n+- [ ] BA rename X.name to X.client or (X.impl/X.classMethod/X.callsMethod/X.wraps/X.serverName) and change X.name modifier to affect both client & server declarations instead of just server to remove ChainNotifications client overloads\n+- [ ] BB Get rid of FunctionTraits::Fields, ProxyMethodTraits::Fields move to ClientInvoke\n+- [ ] BC unify readfield forms. can have single ReadDest class with ReadDest::Return typedef, with ReadField taking ReadDest, RestDestArg... arguments and returning ReadDest::Construct(constructor arg, ReadDestArg...) and Return type either being real destination type or a proxy that emplaces into a vector, or a proxy that updates an existing variable\n+   - could have ReadDest::Update(lambda) where lambda takes reference argument to object, this allows reading & updating for object types that can't be initialized by constructor. e.g. maps, sets, structs without unserializing constructors\n+   - designgoal is just to have one ReadField per type, not confusing mix of readfieldupdate/emplace and maze of overloads to fall back to one when another isn't available\n+   - other goal is to support return types. however i think this may be only useful for client side return values. server side value initialization in PassField could potentially use it to get rid of boost::optional, but this relies of type having move / copy constructor, even if it would be elided, and no guarantee of this for paramters",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741787",
      "id" : 214741787,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDc0MTc4Nw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/FIXME",
      "position" : null,
      "pull_request_review_id" : 151858055,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741787",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741922"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo found by `codespell`: avaiable",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-03T18:02:09Z",
      "diff_hunk" : "@@ -0,0 +1,1559 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map;\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is avaiable.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214741922",
      "id" : 214741922,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDc0MTkyMg==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 779,
      "original_position" : 779,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 151858200,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214741922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214813508"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214813508"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Couldn't `loop_ptr` potentially be a dead pointer here?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T07:38:55Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in\n+        // right sequence. Instead with this shutdown they get deleted in\n+        // EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+std::unique_ptr<interfaces::Init> SocketConnect(const char* exe_name, int fd)\n+{\n+    std::promise<messages::Init::Client> init_promise;\n+    EventLoop* loop_ptr = nullptr;\n+    std::thread thread([&]() {\n+        RenameThread(\"capnp-connect\");\n+        EventLoop loop(exe_name, std::move(thread));\n+        loop_ptr = &loop;\n+        auto connection = MakeUnique<Connection>(loop, fd);\n+        loop.m_task_set.add(connection->m_network.onDisconnect().then([&loop]() {\n+            LogIpc(loop, \"IPC client: unexpected network disconnect, shutting down.\");\n+            loop.shutdown();\n+        }));\n+        init_promise.set_value(connection->m_rpc_client.bootstrap(ServerVatId().vat_id).castAs<messages::Init>());\n+        loop.loop();\n+    });\n+    auto&& client = init_promise.get_future().get();\n+    auto proxy = MakeUnique<ProxyClient<messages::Init>>(kj::mv(client), *loop_ptr);\n+    proxy->addCloseHook(MakeUnique<ShutdownLoop>(*loop_ptr));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214813508",
      "id" : 214813508,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDgxMzUwOA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 71,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 151943005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214813508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949434"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949434"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T14:58:28Z",
      "diff_hunk" : "@@ -4,14 +4,16 @@ The following interfaces are defined here:\n \n * [`Chain`](chain.h) â used by wallet to access blockchain and mempool state. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n-* [`Chain::Client`](chain.h) â used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n+* [`ChainClient`](chain.h) â used by node to start & stop `Chain` clients. Added in [#10973](https://github.com/bitcoin/bitcoin/pull/10973).\n \n * [`Node`](node.h) â used by GUI to start & stop bitcoin node. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Wallet`](wallet.h) â used by GUI to access wallets. Added in [#10244](https://github.com/bitcoin/bitcoin/pull/10244).\n \n * [`Handler`](handler.h) â returned by `handleEvent` methods on interfaces above and used to manage lifetimes of event handlers.\n \n-* [`Init`](init.h) â used by multiprocess code to access interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+* [`Init`](init.h) â used by multiprocess code to access other interfaces above on startup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).\n+\n+* [`Base`](base.h) â base interface class used by multiprocess code for bookeeping and cleanup. Added in [#10102](https://github.com/bitcoin/bitcoin/pull/10102).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949434",
      "id" : 214949434,
      "in_reply_to_id" : 214549056,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk0OTQzNA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 17,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/interfaces/README.md",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949434",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949796"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949796"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T14:59:18Z",
      "diff_hunk" : "@@ -0,0 +1,61 @@\n+- [ ] BA rename X.name to X.client or (X.impl/X.classMethod/X.callsMethod/X.wraps/X.serverName) and change X.name modifier to affect both client & server declarations instead of just server to remove ChainNotifications client overloads\n+- [ ] BB Get rid of FunctionTraits::Fields, ProxyMethodTraits::Fields move to ClientInvoke\n+- [ ] BC unify readfield forms. can have single ReadDest class with ReadDest::Return typedef, with ReadField taking ReadDest, RestDestArg... arguments and returning ReadDest::Construct(constructor arg, ReadDestArg...) and Return type either being real destination type or a proxy that emplaces into a vector, or a proxy that updates an existing variable\n+   - could have ReadDest::Update(lambda) where lambda takes reference argument to object, this allows reading & updating for object types that can't be initialized by constructor. e.g. maps, sets, structs without unserializing constructors\n+   - designgoal is just to have one ReadField per type, not confusing mix of readfieldupdate/emplace and maze of overloads to fall back to one when another isn't available\n+   - other goal is to support return types. however i think this may be only useful for client side return values. server side value initialization in PassField could potentially use it to get rid of boost::optional, but this relies of type having move / copy constructor, even if it would be elided, and no guarantee of this for paramters",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214949796",
      "id" : 214949796,
      "in_reply_to_id" : 214741787,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk0OTc5Ng==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 6,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/FIXME",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214949796",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950179"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T15:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950179",
      "id" : 214950179,
      "in_reply_to_id" : 214549080,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1MDE3OQ==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 44,
      "original_position" : 44,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950179",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T15:00:25Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214950248",
      "id" : 214950248,
      "in_reply_to_id" : 214549093,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1MDI0OA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 46,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214950248",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214957918"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214957918"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T15:18:54Z",
      "diff_hunk" : "@@ -0,0 +1,295 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halfs at position index.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214957918",
      "id" : 214957918,
      "in_reply_to_id" : 214549127,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1NzkxOA==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214957918",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214958407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214958407"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Couldn't loop_ptr potentially be a dead pointer here?\r\n\r\nGood catch. It could happen if socket was immediately disconnected. Moved onDisconnect handler down to fix this.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-04T15:20:11Z",
      "diff_hunk" : "@@ -0,0 +1,94 @@\n+#include <interfaces/capnp/init.h>\n+\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because close/destuction\n+        // seuqnce doesn't wait for server objects across the pipe to shut down,\n+        // so e.g. things like handlers dont get a chance to get deleted in\n+        // right sequence. Instead with this shutdown they get deleted in\n+        // EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+std::unique_ptr<interfaces::Init> SocketConnect(const char* exe_name, int fd)\n+{\n+    std::promise<messages::Init::Client> init_promise;\n+    EventLoop* loop_ptr = nullptr;\n+    std::thread thread([&]() {\n+        RenameThread(\"capnp-connect\");\n+        EventLoop loop(exe_name, std::move(thread));\n+        loop_ptr = &loop;\n+        auto connection = MakeUnique<Connection>(loop, fd);\n+        loop.m_task_set.add(connection->m_network.onDisconnect().then([&loop]() {\n+            LogIpc(loop, \"IPC client: unexpected network disconnect, shutting down.\");\n+            loop.shutdown();\n+        }));\n+        init_promise.set_value(connection->m_rpc_client.bootstrap(ServerVatId().vat_id).castAs<messages::Init>());\n+        loop.loop();\n+    });\n+    auto&& client = init_promise.get_future().get();\n+    auto proxy = MakeUnique<ProxyClient<messages::Init>>(kj::mv(client), *loop_ptr);\n+    proxy->addCloseHook(MakeUnique<ShutdownLoop>(*loop_ptr));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r214958407",
      "id" : 214958407,
      "in_reply_to_id" : 214813508,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDk1ODQwNw==",
      "original_commit_id" : "2e8bee7b4761a3e61e5266b51d6f7298e2b1bad3",
      "original_line" : 71,
      "original_position" : 73,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/init.cpp",
      "position" : null,
      "pull_request_review_id" : 152108870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214958407",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The bitcoin-gui executable is ignoring testnet=1 in bitcoin.conf\r\n\r\nThis is fixed now. It was caused by a bad rebase of this PR, which neglected to call `SetupServerArgs` in the gui process after it was introduced in #13190.\r\n\r\nUpdated 8d3df50476fa2f96cf2910238e5a2b3f8380b6e1 -> 5ce9a948c8ec47762d0a23d1cf7f2ce57386052b ([pr/ipc.54](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.54) -> [pr/ipc.55](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.55)) to add missing `SetupServerArgs` call.",
      "created_at" : "2018-09-05T14:53:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-418760970",
      "id" : 418760970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODc2MDk3MA==",
      "updated_at" : "2018-09-05T14:53:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418760970",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215417703"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215417703"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`chainParams` unused?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-05T20:38:31Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215417703",
      "id" : 215417703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQxNzcwMw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_line" : 1634,
      "original_position" : 300,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152678934,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215417703",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215418823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215418823"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "perhaps change `int` to `size_t` to prevent comparison of integers with different sign warning?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-05T20:42:21Z",
      "diff_hunk" : "@@ -759,22 +763,44 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+// Wrapper to help add a single coin to CCoinsViewCache.\n+class CoinFill : private CCoinsView\n+{\n+public:\n+    CoinFill(CCoinsViewCache& cache, const COutPoint &output, Coin&& coin, CCoinsView &backend) : m_cache(cache), m_output(output), m_coin(std::move(coin)), m_backend(backend) {\n+        m_cache.SetBackend(*this);\n+        m_cache.AccessCoin(output);\n+    }\n+    ~CoinFill() {\n+        m_cache.SetBackend(m_backend);\n+    }\n+\n+    private:\n+    bool GetCoin(const COutPoint &output, Coin &coin) const override {\n+        assert(output == m_output);\n+        coin = std::move(m_coin);\n+        return true;\n+    }\n+    CCoinsViewCache& m_cache;\n+    const COutPoint& m_output;\n+    Coin&& m_coin;\n+    CCoinsView& m_backend;\n+};\n+\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n {\n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n+        std::vector<COutPoint> outputs;\n         for (const CTxIn& txin : mtx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+            outputs.emplace_back(txin.prevout);\n+        }\n+        std::vector<Coin> coins = chain.findCoins(outputs);\n+        for (int i = 0; i < coins.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215418823",
      "id" : 215418823,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQxODgyMw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_line" : 801,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 152680391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215418823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423173"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423173"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> chainParams unused?\r\n\r\nWill fix, but this is part of the base PR #10973 (cb0c6b42a096980152a467b98f3c1250f62d4e7e), so it would be better to comment on that PR.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-05T20:57:04Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423173",
      "id" : 215423173,
      "in_reply_to_id" : 215417703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyMzE3Mw==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_line" : 1634,
      "original_position" : 300,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152685908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423173",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423702"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423702"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> perhaps change int to size_t to prevent comparison of integers with different sign warning?\r\n\r\nWill fix, but this change is part of the base PR #10973 (249bf5006184f81d77d40ee0ede0924c628bf33e), so it would be better to comment on that PR.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-05T20:58:49Z",
      "diff_hunk" : "@@ -759,22 +763,44 @@ static UniValue combinerawtransaction(const JSONRPCRequest& request)\n     return EncodeHexTx(mergedTx);\n }\n \n-UniValue SignTransaction(CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n+// Wrapper to help add a single coin to CCoinsViewCache.\n+class CoinFill : private CCoinsView\n+{\n+public:\n+    CoinFill(CCoinsViewCache& cache, const COutPoint &output, Coin&& coin, CCoinsView &backend) : m_cache(cache), m_output(output), m_coin(std::move(coin)), m_backend(backend) {\n+        m_cache.SetBackend(*this);\n+        m_cache.AccessCoin(output);\n+    }\n+    ~CoinFill() {\n+        m_cache.SetBackend(m_backend);\n+    }\n+\n+    private:\n+    bool GetCoin(const COutPoint &output, Coin &coin) const override {\n+        assert(output == m_output);\n+        coin = std::move(m_coin);\n+        return true;\n+    }\n+    CCoinsViewCache& m_cache;\n+    const COutPoint& m_output;\n+    Coin&& m_coin;\n+    CCoinsView& m_backend;\n+};\n+\n+UniValue SignTransaction(interfaces::Chain& chain, CMutableTransaction& mtx, const UniValue& prevTxsUnival, CBasicKeyStore *keystore, bool is_temp_keystore, const UniValue& hashType)\n {\n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n     CCoinsViewCache view(&viewDummy);\n     {\n-        LOCK2(cs_main, mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n+        std::vector<COutPoint> outputs;\n         for (const CTxIn& txin : mtx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+            outputs.emplace_back(txin.prevout);\n+        }\n+        std::vector<Coin> coins = chain.findCoins(outputs);\n+        for (int i = 0; i < coins.size(); ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215423702",
      "id" : 215423702,
      "in_reply_to_id" : 215418823,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyMzcwMg==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_line" : 801,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 152686532,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215423702",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215424411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215424411"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah sorry. Will leave any new comments there.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-09-05T21:01:23Z",
      "diff_hunk" : "@@ -1587,113 +1590,134 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n     const CChainParams& chainParams = Params();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r215424411",
      "id" : 215424411,
      "in_reply_to_id" : 215417703,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQyNDQxMQ==",
      "original_commit_id" : "5ce9a948c8ec47762d0a23d1cf7f2ce57386052b",
      "original_line" : 1634,
      "original_position" : 300,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 152687429,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215424411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> createwallet \"test\" froze the app for me\r\n\r\nThis is fixed in pr/ipc.56",
      "created_at" : "2018-09-06T18:57:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-419204728",
      "id" : 419204728,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxOTIwNDcyOA==",
      "updated_at" : "2018-09-26T20:57:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/419204728",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "help\r\ngcc 7.3.0:\r\n```\r\n  CXX      interfaces/capnp/libbitcoin_util_a-messages.o\r\nIn file included from ../../src/interfaces/capnp/proxy.h:6:0,\r\n                 from ../../src/interfaces/capnp/messages.h:5,\r\n                 from ./interfaces/capnp/messages.capnp.proxy.h:6,\r\n                 from ../../src/interfaces/capnp/messages-impl.h:9,\r\n                 from ../../src/interfaces/capnp/messages.cpp:1:\r\n../../src/interfaces/capnp/proxy.h: In instantiation of Ã¢ÂÂstruct interfaces::capnp::ListOutput<capnp::List<interfaces::capnp::messages::Pair<capnp::Text, capnp::List<capnp::Text> > > >Ã¢ÂÂ:\r\n../../src/interfaces/capnp/proxy-impl.h:945:13:   required from Ã¢ÂÂvoid interfaces::capnp::BuildField(interfaces::capnp::TypeList<std::map<K, V, std::less<_Key>, std::allocator<std::pair<const _Key, _Tp> > > >, interfaces::capnp::Priority<1>, interfaces::capnp::InvokeContext&, Value&&, Output&&) [with KeyLocalType = std::__cxx11::basic_string<char>; ValueLocalType = std::vector<std::__cxx11::basic_string<char> >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]Ã¢ÂÂ\r\n../../src/interfaces/capnp/proxy-impl.h:1060:15:   required from Ã¢ÂÂvoid interfaces::capnp::BuildField(interfaces::capnp::TypeList<const LocalType>, interfaces::capnp::Priority<0>, interfaces::capnp::InvokeContext&, Value&&, Output&&) [with LocalType = std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]Ã¢ÂÂ\r\n../../src/interfaces/capnp/proxy-impl.h:1071:15:   required from Ã¢ÂÂvoid interfaces::capnp::BuildField(interfaces::capnp::TypeList<LocalType&>, interfaces::capnp::Priority<0>, interfaces::capnp::InvokeContext&, Value&&, Output&&, void*) [with LocalType = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >; Value = const std::map<std::__cxx11::basic_string<char>, std::vector<std::__cxx11::basic_string<char> > >&; Output = interfaces::capnp::StructField<interfaces::capnp::Accessor<interfaces::capnp::FieldOverrideArgs, 19>, interfaces::capnp::messages::GlobalArgs::Builder>&]Ã¢ÂÂ\r\n../../src/interfaces/capnp/proxy-impl.h:1098:15:   required from Ã¢ÂÂvoid interfaces::capnp::BuildOne(interfaces::capnp::TypeList<ValueLocalType>, interfaces::capnp::InvokeContext&, Value&&, Output&&, typename std::enable_if<(index < interfaces::capnp::ProxyType<LocalType>::fields)>::type*) [with long unsigned int index = 0; LocalType = interfaces::capnp::GlobalArgs; Value = const interfaces::capnp::GlobalArgs&; Output = interfaces::capnp::messages::GlobalArgs::Builder&; typename std::enable_if<(index < interfaces::capnp::ProxyType<LocalType>::fields)>::type = void]Ã¢ÂÂ\r\n../../src/interfaces/capnp/proxy-impl.h:1119:16:   required from Ã¢ÂÂvoid interfaces::capnp::BuildField(interfaces::capnp::TypeList<LocalType>, interfaces::capnp::Priority<1>, interfaces::capnp::InvokeContext&, Value&&, Output&&, typename interfaces::capnp::ProxyType<LocalType>::Struct*) [with LocalType = interfaces::capnp::GlobalArgs; Value = const interfaces::capnp::GlobalArgs&; Output = interfaces::capnp::ValueField<interfaces::capnp::messages::GlobalArgs::Builder>; typename interfaces::capnp::ProxyType<LocalType>::Struct = interfaces::capnp::messages::GlobalArgs]Ã¢ÂÂ\r\n../../src/interfaces/capnp/messages.cpp:52:109:   required from here\r\n../../src/interfaces/capnp/proxy.h:322:110: error: Ã¢ÂÂBÃ¢ÂÂ is not a class or namespace\r\n     template<typename B = Builder, typename Arg> auto set(Arg&& arg) const -> AUTO_RETURN(this->m_builder.B::set(m_index, std::forward<Arg>(arg)))\r\n```",
      "created_at" : "2018-09-21T07:30:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-423441197",
      "id" : 423441197,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzQ0MTE5Nw==",
      "updated_at" : "2018-09-21T07:30:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423441197",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7310938?v=4",
         "events_url" : "https://api.github.com/users/fingera/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fingera/followers",
         "following_url" : "https://api.github.com/users/fingera/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fingera/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fingera",
         "id" : 7310938,
         "login" : "fingera",
         "node_id" : "MDQ6VXNlcjczMTA5Mzg=",
         "organizations_url" : "https://api.github.com/users/fingera/orgs",
         "received_events_url" : "https://api.github.com/users/fingera/received_events",
         "repos_url" : "https://api.github.com/users/fingera/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fingera/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fingera/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fingera"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the report @fingera. The gcc compile errors should be fixed now (I've been testing with clang more than gcc recently).\r\n\r\n---\r\n\r\nUpdated 5ce9a948c8ec47762d0a23d1cf7f2ce57386052b -> f896f063007aa3889caf9d14724357117eca78c1 ([pr/ipc.55](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.55) -> [pr/ipc.56](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.56)) to fix `createwallet` and other wallet RPCs that use `g_rpc_interfaces` global\r\nRebased f896f063007aa3889caf9d14724357117eca78c1 -> c1cbca095f1bf10ca4370bfe99b798a5d1e9f268 ([pr/ipc.56](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.56) -> [pr/ipc.57](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.57))\r\nRebased c1cbca095f1bf10ca4370bfe99b798a5d1e9f268 -> 382cfabf523cd209adeb3ed9c5fd5d69fea284ab ([pr/ipc.57](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.57) -> [pr/ipc.58](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.58)) with compile fixes for gcc\r\nRebased 382cfabf523cd209adeb3ed9c5fd5d69fea284ab -> ededfe8800fd2647851d4d42dd765cfcd8d69cde ([pr/ipc.58](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.58) -> [pr/ipc.59](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.59)) due to conflict with #12246 \r\nRebased ededfe8800fd2647851d4d42dd765cfcd8d69cde -> ee425e2ddff453a5436cffb1e16e5452d8e3892a ([pr/ipc.59](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.59) -> [pr/ipc.60](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.60)) on top of base PR tag [pr/wipc-sep.85](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.85)\r\nRebased ee425e2ddff453a5436cffb1e16e5452d8e3892a -> 10ad449bb7c6ea3c2fea9f9a32e54e960c5acfd5 ([pr/ipc.60](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.60) -> [pr/ipc.61](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.61)) on top of base PR tag [pr/wipc-sep.87](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.87)\r\nRebased 10ad449bb7c6ea3c2fea9f9a32e54e960c5acfd5 -> f2233bcfef4147e0268da581f797b1646b0d8447 ([pr/ipc.61](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.61) -> [pr/ipc.62](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.62)) on top of base PR tag [pr/wipc-sep.88](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.88)\r\nRebased f2233bcfef4147e0268da581f797b1646b0d8447 -> da8719d39614e2673047721f9a7ea8e96587b000 ([pr/ipc.62](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.62) -> [pr/ipc.63](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.63)) on top of base PR tag [pr/wipc-sep.89](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.89)\r\nRebased da8719d39614e2673047721f9a7ea8e96587b000 -> c5bc654324670631d32e530c4cf1dbf9af58841a ([pr/ipc.63](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.63) -> [pr/ipc.64](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.64)) on top of base PR tag [pr/wipc-sep.93](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.93) and fixing conflicts with #15101, #15114, and others\r\nRebased c5bc654324670631d32e530c4cf1dbf9af58841a -> cc23f7434c21e195609e4dff6b8839864a426715 ([pr/ipc.64](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.64) -> [pr/ipc.65](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.65)) on top of base PR tag [pr/wipc-sep.95](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.95) and fixing conflicts with #15153 \r\nRebased cc23f7434c21e195609e4dff6b8839864a426715 -> c5dadccc5da6247975ee3884687a680bc46a9327 ([pr/ipc.65](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.65) -> [pr/ipc.66](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.66)) on top of base PR tag [pr/wipc-sep.96](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.96) after #15288 merge\r\nRebased c5dadccc5da6247975ee3884687a680bc46a9327 -> 191e240ce66208eb17ca743a6928cb20aa56041e ([pr/ipc.66](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.66) -> [pr/ipc.67](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.67)) on top of base PR tag [pr/wipc-sep.97](https://github.com/ryanofsky/bitcoin/commits/pr/wipc-sep.97) fixing conflict with #15531\r\nRebased 191e240ce66208eb17ca743a6928cb20aa56041e -> 3440513a45e94a5f1f0c67ab7409439afbbef673 ([pr/ipc.67](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.67) -> [pr/ipc.68](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.68)) after #10973 merge",
      "created_at" : "2018-09-26T20:56:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-424866963",
      "id" : 424866963,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNDg2Njk2Mw==",
      "updated_at" : "2019-03-21T13:09:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/424866963",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage\nFor detailed information about the code coverage, see the [test coverage report](https://corecheck.dev/bitcoin/bitcoin/pulls/10102).\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept NACK | [electorr](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-790538884) |\n| Concept ACK | [dcousens](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289927205), [laanwj](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-289999980), [jgarzik](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-573213164), [practicalswift](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-573397932), [hebasto](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595125863), [promag](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-715604162), [jamesob](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1290404224) |\n| Stale ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1013193492) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#28956](https://github.com/bitcoin/bitcoin/pull/28956) (Nuke adjusted time (attempt 2) by dergoegge)\n* [#28710](https://github.com/bitcoin/bitcoin/pull/28710) (Remove the legacy wallet and BDB dependency by achow101)\n* [#28514](https://github.com/bitcoin/bitcoin/pull/28514) (wallet: Fix wallet directory initialization by BrandonOdiwuor)\n* [#28451](https://github.com/bitcoin/bitcoin/pull/28451) (refactor: Remove unused SER_DISK, SER_NETWORK, CDataStream by maflcko)\n* [#28241](https://github.com/bitcoin/bitcoin/pull/28241) (Silent payment index (for light wallets and consistency check) by Sjors)\n* [#28122](https://github.com/bitcoin/bitcoin/pull/28122) (Silent Payments: Implement BIP352 by josibake)\n* [#28051](https://github.com/bitcoin/bitcoin/pull/28051) (Get rid of shutdown.cpp/shutdown.h, use SignalInterrupt directly by ryanofsky)\n* [#27600](https://github.com/bitcoin/bitcoin/pull/27600) (net: Add new permission `forceinbound` to evict a random unprotected connection if all slots are otherwise full by pinheadmz)\n* [#27375](https://github.com/bitcoin/bitcoin/pull/27375) (net: support unix domain sockets for -proxy and -onion by pinheadmz)\n* [#27052](https://github.com/bitcoin/bitcoin/pull/27052) (test: rpc: add last block announcement time to getpeerinfo result by LarryRuane)\n* [#25665](https://github.com/bitcoin/bitcoin/pull/25665) (refactor: Add util::Result failure values, multiple error and warning messages by ryanofsky)\n* [#25273](https://github.com/bitcoin/bitcoin/pull/25273) (wallet: Pass through transaction locktime and preset input sequences and scripts to CreateTransaction by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2018-09-27T21:14:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-425245284",
      "id" : 425245284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTI0NTI4NA==",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425245284/reactions"
      },
      "updated_at" : "2023-11-29T06:06:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425245284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After upgrading to Mojave I'm having compile issues (as of ededfe8800fd2647851d4d42dd765cfcd8d69cde): \r\n```sh\r\nIn file included from interfaces/capnp/proxy-codegen.cpp:4:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/capnp/blob.h:28:\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/common.h:36:4: error: \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n  #error \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n   ^\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/common.h:39:6: error: \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n    #error \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n     ^\r\nIn file included from interfaces/capnp/proxy-codegen.cpp:5:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/capnp/schema-parser.h:30:\r\nIn file included from /usr/local/Cellar/capnp/0.7.0/include/kj/filesystem.h:28:\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/function.h:264:3: error: 'auto' return without trailing return type; deduced return types are a C++14 extension\r\n  auto operator()(Params&&... params) {\r\n  ^\r\n/usr/local/Cellar/capnp/0.7.0/include/kj/function.h:268:3: error: 'auto' return without trailing return type; deduced return types are a C++14 extension\r\n  auto operator()(Params&&... params) const {\r\n  ^\r\ninterfaces/capnp/proxy-codegen.cpp:10:10: fatal error: 'interfaces/capnp/proxy.capnp.h' file not found\r\n```",
      "created_at" : "2018-09-28T10:29:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-425394087",
      "id" : 425394087,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTM5NDA4Nw==",
      "updated_at" : "2018-09-28T10:29:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425394087",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Compile works again for me. I do still get the `syscall` deprecated in macOS 10.12 warning I mentioned earlier. Some of the tests also throw a [compiler warning](https://gist.github.com/Sjors/fed61c30c76c746c8b0b12a51e92eeb0).\r\n\r\nrpc `help`, and `testnet=1` in `bitcoin.conf`, command override in settings screen work for me now.\r\n\r\n`createwallet` in the gui console crashes the gui. The node and wallet keep running, but won't shut down using `bitcoin-cli stop`.\r\n\r\nDon't forget to update `.gitignore`. Nit: should `bitcoin-gui` be in `src/qt` ?",
      "created_at" : "2018-10-09T07:16:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112",
      "id" : 428086112,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODA4NjExMg==",
      "updated_at" : "2018-10-09T07:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428086112",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for testing! I will test the createwallet method, fix git ignores, and clean up the disconnect handling so leftover processes won't stick around if one crashes.\r\n\r\nOn location of `bitcoin-gui`, all three executables are intentionally built in the same directory to make spawning processes simple. When `bitcoin-gui` launches `bitcoin-node`, it always looks for a `bitcoin-node` executable in the same directory. Same when `bitcoin-node` runs `bitcoin-wallet`. Trying to build and call executables in different directories would make things unnecessarily complicated, especially if the executables will eventually be installed in the same directory anyway.",
      "created_at" : "2018-10-09T07:54:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428096364",
      "id" : 428096364,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyODA5NjM2NA==",
      "updated_at" : "2018-10-09T07:54:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/428096364",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112\r\n> Don't forget to update .gitignore\r\n\r\nUpdated now.\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112, https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-416028413 \r\n> I do still get the syscall deprecated in macOS 10.12 warning\r\n\r\nShould be fixed now. Worked around using `pthread_threadid_np`, according to http://elliotth.blogspot.com/2012/04/gettid-on-mac-os.html and https://github.com/google/glog/issues/182\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112\r\n> Some of the tests also throw a [compiler warning](https://gist.github.com/Sjors/fed61c30c76c746c8b0b12a51e92eeb0).\r\n\r\nDidn't look in much detail, but these are warnings about signed/unsigned comparisons from checks like: `BOOST_CHECK_EQUAL(reader.size(), 6);`. Could be fixed by changing `6` to `6u`, but I think these warnings must predate this PR.\r\n\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-428086112 shutdown/hang issues. I'm planning to look into these next.",
      "created_at" : "2018-11-01T21:14:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-435189673",
      "id" : 435189673,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE4OTY3Mw==",
      "updated_at" : "2018-11-01T21:14:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435189673",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Pull request",
      "created_at" : "2018-11-02T00:00:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-435226828",
      "id" : 435226828,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTIyNjgyOA==",
      "updated_at" : "2018-11-02T00:00:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435226828",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/43362812?v=4",
         "events_url" : "https://api.github.com/users/ismail120572/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ismail120572/followers",
         "following_url" : "https://api.github.com/users/ismail120572/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ismail120572/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ismail120572",
         "id" : 43362812,
         "login" : "ismail120572",
         "node_id" : "MDQ6VXNlcjQzMzYyODEy",
         "organizations_url" : "https://api.github.com/users/ismail120572/orgs",
         "received_events_url" : "https://api.github.com/users/ismail120572/received_events",
         "repos_url" : "https://api.github.com/users/ismail120572/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ismail120572/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ismail120572/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ismail120572"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423211"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove trailing `;` :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T15:54:09Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423211",
      "id" : 230423211,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzIxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 25,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171164602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423257"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Remove trailing `;` :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T15:54:15Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };\n+    virtual IpcProtocol* getProtocol() { return nullptr; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423257",
      "id" : 230423257,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzI1Nw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 26,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171164647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423611"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423611"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`exe_path` is not a parameter? :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T15:55:04Z",
      "diff_hunk" : "@@ -0,0 +1,35 @@\n+#ifndef BITCOIN_INTERFACES_INIT_H\n+#define BITCOIN_INTERFACES_INIT_H\n+\n+#include <interfaces/base.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace interfaces {\n+\n+class Chain;\n+class ChainClient;\n+class IpcProcess;\n+class IpcProtocol;\n+class Node;\n+struct Config;\n+\n+//! Interface allowing multiprocess code to create other interfaces on startup.\n+class Init : public Base\n+{\n+public:\n+    virtual std::unique_ptr<Node> makeNode() = 0;\n+    virtual std::unique_ptr<ChainClient> makeWalletClient(Chain& chain, std::vector<std::string> wallet_filenames) = 0;\n+    virtual IpcProcess* getProcess() { return nullptr; };\n+    virtual IpcProtocol* getProtocol() { return nullptr; };\n+};\n+\n+//! Return implementation of Init interface.\n+//! @param exe_path should be current executable path (argv[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230423611",
      "id" : 230423611,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyMzYxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/interfaces/init.h",
      "position" : null,
      "pull_request_review_id" : 171165046,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230423611",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424211"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Make this implicit conversion explicit since it changes signedness?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T15:56:41Z",
      "diff_hunk" : "@@ -2604,7 +2632,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CTransac\n     // enough, that fee sniping isn't a problem yet, but by implementing a fix\n     // now we ensure code won't be written that makes assumptions about\n     // nLockTime that preclude a fix later.\n-    txNew.nLockTime = chainActive.Height();\n+    txNew.nLockTime = locked_chain.getHeight().value_or(LOCKTIME_MAX);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424211",
      "id" : 230424211,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNDIxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 2635,
      "original_position" : 813,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171165827,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424730"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be `explicit`? :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T15:58:17Z",
      "diff_hunk" : "@@ -50,6 +51,8 @@ namespace {\n \n class NodeImpl : public Node\n {\n+public:\n+    NodeImpl(Init& init) : m_init(init) { m_interfaces.chain = MakeChain(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230424730",
      "id" : 230424730,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNDczMA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 55,
      "original_position" : 13,
      "original_start_line" : null,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 171166476,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230424730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230425311"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230425311"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Make `explicit`?\r\n\r\nApplies throughout this PR :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:00:02Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#ifndef BITCOIN_INTERFACES_BASE_H\n+#define BITCOIN_INTERFACES_BASE_H\n+\n+#include <cassert>\n+#include <memory>\n+\n+namespace interfaces {\n+\n+class Base;\n+\n+//! Close hook.\n+class CloseHook\n+{\n+public:\n+    virtual ~CloseHook() {}\n+\n+    //! Handle interface being disconnected.\n+    virtual void onClose(Base& interface, bool remote) {}\n+\n+    std::unique_ptr<CloseHook> m_next_hook;\n+};\n+\n+//! Close hook that encapsulate and deletes a moveable object.\n+template <typename T>\n+class Deleter : public CloseHook\n+{\n+public:\n+    Deleter(T&& value) : m_value(std::move(value)) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230425311",
      "id" : 230425311,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNTMxMQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/interfaces/base.h",
      "position" : null,
      "pull_request_review_id" : 171167242,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230425311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426764"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Always true?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:04:48Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764",
      "id" : 230426764,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNjc2NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 422,
      "original_position" : 417,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : null,
      "pull_request_review_id" : 171169113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426823"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Always true?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:04:58Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {\n+                    def << \"    typename M\" << method.getOrdinal() << \"::Result result;\\n\";\n+                }\n+                def << \"    clientInvoke(*this, &\" << message_namespace << \"::\" << node_name\n+                    << \"::Client::\" << method_name << \"Request\" << client_invoke.str() << \");\\n\";\n+                if (has_result) def << \"    return result;\\n\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823",
      "id" : 230426823,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNjgyMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 422,
      "original_position" : 422,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : null,
      "pull_request_review_id" : 171169185,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230426823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427113"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427113"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`ByteCast` not used?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:05:48Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    output.set(\n+        kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(&value, false /* owned */, invoke_context.loop));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.loop));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.loop.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),\n+            std::forward<NextFnArgs>(next_fn_args)...);\n+    }\n+\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList)\n+    {\n+        static_cast<Derived*>(this)->handleField(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), ParamList());\n+    }\n+};\n+\n+struct IterateFields : IterateFieldsHelper<IterateFields, 0>\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleField(Arg1&&, Arg2&&, ParamList)\n+    {\n+    }\n+};\n+\n+// template <typename Exception, typename Accessor>\n+// FIXME struct ClientException\n+// https://stackoverflow.com/a/7858971\n+\n+template <typename Exception, typename Accessor>\n+struct ClientException\n+{\n+    struct BuildParams : IterateFieldsHelper<BuildParams, 0>\n+    {\n+        template <typename Params, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Params& params, ParamList)\n+        {\n+        }\n+\n+        BuildParams(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, 0>\n+    {\n+        template <typename Results, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Results& results, ParamList)\n+        {\n+            StructField<Accessor, Results> input(results);\n+            if (input.has()) {\n+                ReadField(TypeList<Exception>(), invoke_context, input, ThrowEmplace<Exception>());\n+            }\n+        }\n+\n+        ReadResults(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+};\n+\n+template <typename Accessor, typename... Types>\n+struct ClientParam\n+{\n+    ClientParam(Types&... values) : m_values(values...) {}\n+\n+    struct BuildParams : IterateFieldsHelper<BuildParams, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callBuild<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <size_t I, typename... Args>\n+        auto callBuild(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            // FIXME: replace std::move below with std::forward\n+            callBuild<I + 1>(std::forward<Args>(args)..., std::move(std::get<I>(m_client_param->m_values)));\n+        }\n+\n+        template <size_t I, typename Params, typename ParamList, typename... Values>\n+        auto callBuild(ClientInvokeContext& invoke_context, Params& params, ParamList, Values&&... values) ->\n+            typename std::enable_if<(I == sizeof...(Types))>::type\n+        {\n+            MaybeBuildField(std::integral_constant<bool, Accessor::in>(), ParamList(), BuildFieldPriority(),\n+                invoke_context, std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+            MaybeSetWant(\n+                ParamList(), Priority<1>(), std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+        }\n+\n+        BuildParams(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callRead<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <int I, typename... Args>\n+        auto callRead(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            callRead<I + 1>(std::forward<Args>(args)..., std::get<I>(m_client_param->m_values));\n+        }\n+\n+        template <int I, typename Results, typename... Params, typename... Values>\n+        auto callRead(ClientInvokeContext& invoke_context, Results& results, TypeList<Params...>, Values&&... values)\n+            -> typename std::enable_if<I == sizeof...(Types)>::type\n+        {\n+            MaybeReadFieldUpdate(std::integral_constant<bool, Accessor::out>(), TypeList<Decay<Params>...>(),\n+                invoke_context, Make<StructField, Accessor>(results), std::forward<Values>(values)...);\n+        }\n+\n+        ReadResults(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    // FIXME: should be rvalue reference to fix callBuild above\n+    std::tuple<Types&...> m_values;\n+};\n+\n+template <typename Accessor, typename... Types>\n+ClientParam<Accessor, Types...> MakeClientParam(Types&... values)\n+{\n+    return {values...};\n+}\n+\n+//! Safely convert char pointer to kj pointer.\n+static inline kj::byte* ByteCast(char* c) { return reinterpret_cast<kj::byte*>(c); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427113",
      "id" : 230427113,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzExMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 1373,
      "original_position" : 1373,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171169519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427137"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same here.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:05:55Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(*remote_thread);\n+    context.setCallbackThread(*local_thread);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    Optional<Thread::Client>& thread_client = g_thread_context.remote_threads[server.m_loop];\n+                    TempSetter<Optional<Thread::Client>> temp_setter(thread_client, context_arg.getCallbackThread());\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_loop->sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_loop->sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(\n+        server.m_loop->m_threads.getLocalServer(thread_client)\n+            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                KJ_IF_MAYBE(thread_server, perhaps)\n+                {\n+                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                    LogIpc(*server.m_loop, \"IPC server post request #%i {%s}\\n\", req, thread.m_waiter.m_name);\n+                    thread.m_waiter.post(std::move(invoke));\n+                }\n+                else\n+                {\n+                    LogIpc(*server.m_loop, \"IPC server error request #%i {%s}, missing thread to execute request\\n\");\n+                    throw std::runtime_error(\"invalid thread handle\");\n+                }\n+            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+    virtual void shutdown(EventLoop& loop) {}\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_client(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_client;\n+};\n+\n+template <typename Interface>\n+void destroyClient(ProxyClient<Interface>& proxy, bool remote)\n+{\n+    typename Interface::Client(std::move(proxy.m_client));\n+    proxy.Base::close(remote);\n+    proxy.m_loop = nullptr;\n+}\n+\n+// two shutdown sequences need to be supported, one where event loop thread exits before class is destroyed, one where\n+// class being destroyed shuts down event loop.\n+//\n+// event loop thread exits\n+//  Base::close callback called\n+//  std::move(m_client) to temporary\n+//  m_connection = nullptr\n+//  m_loop = nullptr\n+//\n+// class is destroyed\n+//  if m_loop:\n+//  m_loop->sync:\n+//    m_loop->removecleanup\n+//      std::move(m_client) to temporary\n+//      m_connection = nullptr\n+//      m_loop->shutdown\n+//      m_loop = nullptr\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, EventLoop& loop)\n+    : m_client(std::move(client)), m_loop(&loop)\n+{\n+    m_cleanup = loop.addCleanup([this]() { destroyClient(self(), true); });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    self().destroy();\n+    if (m_loop) {\n+        m_loop->sync([&]() {\n+            m_loop->removeCleanup(m_cleanup);\n+            destroyClient(self(), false /* remote */);\n+        });\n+    }\n+}\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.loop));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.loop);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.loop));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    output.set(\n+        kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(&value, false /* owned */, invoke_context.loop));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.loop));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.loop.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),\n+            std::forward<NextFnArgs>(next_fn_args)...);\n+    }\n+\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList)\n+    {\n+        static_cast<Derived*>(this)->handleField(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), ParamList());\n+    }\n+};\n+\n+struct IterateFields : IterateFieldsHelper<IterateFields, 0>\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList>\n+    void handleField(Arg1&&, Arg2&&, ParamList)\n+    {\n+    }\n+};\n+\n+// template <typename Exception, typename Accessor>\n+// FIXME struct ClientException\n+// https://stackoverflow.com/a/7858971\n+\n+template <typename Exception, typename Accessor>\n+struct ClientException\n+{\n+    struct BuildParams : IterateFieldsHelper<BuildParams, 0>\n+    {\n+        template <typename Params, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Params& params, ParamList)\n+        {\n+        }\n+\n+        BuildParams(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, 0>\n+    {\n+        template <typename Results, typename ParamList>\n+        void handleField(InvokeContext& invoke_context, Results& results, ParamList)\n+        {\n+            StructField<Accessor, Results> input(results);\n+            if (input.has()) {\n+                ReadField(TypeList<Exception>(), invoke_context, input, ThrowEmplace<Exception>());\n+            }\n+        }\n+\n+        ReadResults(ClientException* client_exception) : m_client_exception(client_exception) {}\n+        ClientException* m_client_exception;\n+    };\n+};\n+\n+template <typename Accessor, typename... Types>\n+struct ClientParam\n+{\n+    ClientParam(Types&... values) : m_values(values...) {}\n+\n+    struct BuildParams : IterateFieldsHelper<BuildParams, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callBuild<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <size_t I, typename... Args>\n+        auto callBuild(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            // FIXME: replace std::move below with std::forward\n+            callBuild<I + 1>(std::forward<Args>(args)..., std::move(std::get<I>(m_client_param->m_values)));\n+        }\n+\n+        template <size_t I, typename Params, typename ParamList, typename... Values>\n+        auto callBuild(ClientInvokeContext& invoke_context, Params& params, ParamList, Values&&... values) ->\n+            typename std::enable_if<(I == sizeof...(Types))>::type\n+        {\n+            MaybeBuildField(std::integral_constant<bool, Accessor::in>(), ParamList(), BuildFieldPriority(),\n+                invoke_context, std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+            MaybeSetWant(\n+                ParamList(), Priority<1>(), std::forward<Values>(values)..., Make<StructField, Accessor>(params));\n+        }\n+\n+        BuildParams(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    struct ReadResults : IterateFieldsHelper<ReadResults, sizeof...(Types)>\n+    {\n+        template <typename... Args>\n+        void handleField(Args&&... args)\n+        {\n+            callRead<0>(std::forward<Args>(args)...);\n+        }\n+\n+        template <int I, typename... Args>\n+        auto callRead(Args&&... args) -> typename std::enable_if<(I < sizeof...(Types))>::type\n+        {\n+            callRead<I + 1>(std::forward<Args>(args)..., std::get<I>(m_client_param->m_values));\n+        }\n+\n+        template <int I, typename Results, typename... Params, typename... Values>\n+        auto callRead(ClientInvokeContext& invoke_context, Results& results, TypeList<Params...>, Values&&... values)\n+            -> typename std::enable_if<I == sizeof...(Types)>::type\n+        {\n+            MaybeReadFieldUpdate(std::integral_constant<bool, Accessor::out>(), TypeList<Decay<Params>...>(),\n+                invoke_context, Make<StructField, Accessor>(results), std::forward<Values>(values)...);\n+        }\n+\n+        ReadResults(ClientParam* client_param) : m_client_param(client_param) {}\n+        ClientParam* m_client_param;\n+    };\n+\n+    // FIXME: should be rvalue reference to fix callBuild above\n+    std::tuple<Types&...> m_values;\n+};\n+\n+template <typename Accessor, typename... Types>\n+ClientParam<Accessor, Types...> MakeClientParam(Types&... values)\n+{\n+    return {values...};\n+}\n+\n+//! Safely convert char pointer to kj pointer.\n+static inline kj::byte* ByteCast(char* c) { return reinterpret_cast<kj::byte*>(c); }\n+static inline const kj::byte* ByteCast(const char* c) { return reinterpret_cast<const kj::byte*>(c); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427137",
      "id" : 230427137,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzEzNw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 1374,
      "original_position" : 1374,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171169555,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427137",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427284"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427284"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not used?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:06:25Z",
      "diff_hunk" : "@@ -59,6 +62,10 @@ class NodeImpl : public Node\n     bool softSetBoolArg(const std::string& arg, bool value) override { return gArgs.SoftSetBoolArg(arg, value); }\n     void selectParams(const std::string& network) override { SelectParams(network); }\n     std::string getNetwork() override { return Params().NetworkIDString(); }\n+    std::string getArg(const std::string& arg, const std::string& default_value) override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427284",
      "id" : 230427284,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzI4NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 65,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/interfaces/node.cpp",
      "position" : null,
      "pull_request_review_id" : 171169747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427503"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not used?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:07:03Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)\n+{\n+    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n+    LogIpc(m_loop, \"Uncaught exception in daemonized task.\");\n+}\n+\n+EventLoop::EventLoop(const char* exe_name, std::thread&& thread)\n+    : m_exe_name(exe_name), m_thread_map(nullptr), m_io_context(kj::setupAsyncIo()), m_thread(std::move(thread))\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+    m_wait_fd = fds[0];\n+    m_post_fd = fds[1];\n+}\n+\n+EventLoop::~EventLoop()\n+{\n+    KJ_ASSERT(!m_thread.joinable());\n+    KJ_ASSERT(m_wait_fd == -1);\n+    KJ_ASSERT(m_post_fd == -1);\n+    for (auto& fn : m_cleanup_fns) {\n+        fn();\n+    }\n+}\n+\n+void EventLoop::loop()\n+{\n+    kj::Own<kj::AsyncIoStream> wait_stream{\n+        m_io_context.lowLevelProvider->wrapSocketFd(m_wait_fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)};\n+    char buffer;\n+    for (;;) {\n+        size_t bytes = -1;\n+        wait_stream->read(&buffer, 0, 1).then([&](size_t s) { bytes = s; }).wait(m_io_context.waitScope);\n+        if (bytes == 0) {\n+            wait_stream = nullptr;\n+            m_wait_fd = -1;\n+            break;\n+        }\n+        m_post_fn();\n+        m_post_fn = nullptr;\n+        m_task_set.add(wait_stream->write(&buffer, 1));\n+    }\n+}\n+\n+void EventLoop::post(std::function<void()> fn)\n+{\n+    if (std::this_thread::get_id() == m_thread_id) {\n+        fn();\n+        return;\n+    }\n+    std::lock_guard<std::mutex> lock(m_post_mutex);\n+    m_post_fn = std::move(fn);\n+    char signal = '\\0';\n+    KJ_SYSCALL(write(m_post_fd, &signal, 1));\n+    KJ_SYSCALL(read(m_post_fd, &signal, 1));\n+}\n+\n+void EventLoop::shutdown()\n+{\n+    std::thread close_thread = std::move(m_thread);\n+    int close_fd = m_post_fd;\n+    m_post_fd = -1;\n+    KJ_SYSCALL(close(close_fd));\n+    if (close_thread.joinable()) {\n+        close_thread.join();\n+    }\n+}\n+\n+ProxyServer<ThreadMap>::ProxyServer(EventLoop& loop) : m_loop(loop) {}\n+\n+kj::Promise<void> ProxyServer<ThreadMap>::makeThread(MakeThreadContext context)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503",
      "id" : 230427503,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzUwMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 292,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : null,
      "pull_request_review_id" : 171170014,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427589"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not used?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:07:22Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+#include <interfaces/capnp/test/foo.h>\n+\n+#include <util.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace test {\n+namespace {\n+\n+class FooImpl : public FooInterface\n+{\n+public:\n+    int add(int a, int b) override { return a + b; }\n+    int mapSize(const std::map<std::string, std::string>& map) override { return map.size(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589",
      "id" : 230427589,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzU4OQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 13,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/test/foo.cpp",
      "position" : null,
      "pull_request_review_id" : 171170127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427653"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not used?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:07:34Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653",
      "id" : 230427653,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzY1Mw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 44,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : null,
      "pull_request_review_id" : 171170205,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427653",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427795"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing spaces around `=`",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:07:55Z",
      "diff_hunk" : "@@ -42,7 +52,7 @@ bool AppInitParameterInteraction();\n  * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitParameterInteraction should have been called.\n  */\n-bool AppInitSanityChecks();\n+bool AppInitSanityChecks(bool lock_data_dir=false);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427795",
      "id" : 230427795,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzc5NQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 55,
      "original_position" : 35,
      "original_start_line" : null,
      "path" : "src/init.h",
      "position" : null,
      "pull_request_review_id" : 171170363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427926"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing copyright header",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:08:19Z",
      "diff_hunk" : "@@ -0,0 +1,22 @@\n+#include <interfaces/base.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427926",
      "id" : 230427926,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzkyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 6,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/interfaces/base.cpp",
      "position" : null,
      "pull_request_review_id" : 171170517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427994"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing copyright header.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:08:33Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#ifndef BITCOIN_INTERFACES_BASE_H",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427994",
      "id" : 230427994,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyNzk5NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 5,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/interfaces/base.h",
      "position" : null,
      "pull_request_review_id" : 171170598,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230427994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428044"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing copyright header.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:08:43Z",
      "diff_hunk" : "@@ -0,0 +1,154 @@\n+#include <interfaces/capnp/ipc.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428044",
      "id" : 230428044,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODA0NA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 5,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/ipc.cpp",
      "position" : null,
      "pull_request_review_id" : 171170667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428192"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Missing whitespace before `{`.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:09:08Z",
      "diff_hunk" : "@@ -0,0 +1,154 @@\n+#include <interfaces/capnp/ipc.h>\n+\n+#include <bitcoin-config.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <chainparams.h>\n+#include <coins.h>\n+#include <future>\n+#include <interfaces/capnp/messages.capnp.h>\n+#include <interfaces/capnp/messages.capnp.proxy.h>\n+#include <interfaces/capnp/proxy-impl.h>\n+#include <interfaces/capnp/proxy.h>\n+#include <interfaces/node.h>\n+#include <key.h>\n+#include <kj/async-unix.h>\n+#include <kj/debug.h>\n+#include <mutex>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <pubkey.h>\n+#include <rpc/server.h>\n+#include <thread>\n+#include <univalue.h>\n+#include <wallet/wallet.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace {\n+\n+//! VatId for server side of IPC connection.\n+struct ServerVatId\n+{\n+    ::capnp::word scratch[4]{};\n+    ::capnp::MallocMessageBuilder message{scratch};\n+    ::capnp::rpc::twoparty::VatId::Builder vat_id{message.getRoot<::capnp::rpc::twoparty::VatId>()};\n+    ServerVatId() { vat_id.setSide(::capnp::rpc::twoparty::Side::SERVER); }\n+};\n+\n+class ShutdownLoop : public CloseHook\n+{\n+public:\n+    ShutdownLoop(EventLoop& loop) : m_loop(loop) {}\n+    void onClose(Base& interface, bool remote) override\n+    {\n+        // FIXME: Shutdown can cause segfault right now because\n+        // close/destruction sequence doesn't wait for server objects across\n+        // the pipe to shut down, so e.g. things like handlers don't get a\n+        // chance to get deleted in right sequence. Instead with this shutdown\n+        // they get deleted in EventLoop destructor which can cause segfault on\n+        // UnregisterValidationInterface.\n+        // if (!remote) m_loop.shutdown();\n+    }\n+    EventLoop& m_loop;\n+};\n+\n+struct StreamContext\n+{\n+    kj::Own<kj::AsyncIoStream> stream;\n+    ::capnp::TwoPartyVatNetwork network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> rpc_system;\n+\n+    StreamContext(kj::Own<kj::AsyncIoStream>&& stream_, std::function<::capnp::Capability::Client()> make_client)\n+        : stream(kj::mv(stream_)), network(*stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          rpc_system(::capnp::makeRpcServer(network, make_client()))\n+    {\n+    }\n+};\n+\n+class IpcProtocolImpl : public IpcProtocol\n+{\n+public:\n+    IpcProtocolImpl(const char* exe_name, Init& init) : m_exe_name(exe_name), m_init(init) {}\n+    ~IpcProtocolImpl() noexcept(true){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428192",
      "id" : 230428192,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODE5Mg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 59,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/ipc.cpp",
      "position" : null,
      "pull_request_review_id" : 171170831,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428604"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Typo: pipelining",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-02T16:10:25Z",
      "diff_hunk" : "@@ -0,0 +1,1567 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+class EventLoop;\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    //!\n+    //! @param[in]  thread  optional thread handle to join on destruction.\n+    EventLoop(const char* exe_name, std::thread&& thread = {});\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown.\n+    void loop();\n+\n+    //! Run callable on event loop thread. Does not return until callable completes.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        post(std::ref(callable));\n+    }\n+\n+    //! Send shutdown signal to event loop. Returns immediately.\n+    void shutdown();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    void post(std::function<void()> fn);\n+\n+    CleanupIt addCleanup(std::function<void()> fn)\n+    {\n+        return m_cleanup_fns.emplace(m_cleanup_fns.begin(), std::move(fn));\n+    }\n+\n+    void removeCleanup(CleanupIt it) { m_cleanup_fns.erase(it); }\n+\n+    const char* m_exe_name;\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+    kj::AsyncIoContext m_io_context;\n+    LoggingErrorHandler m_error_handler{*this};\n+    kj::TaskSet m_task_set{m_error_handler};\n+    std::thread m_thread;\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+    std::mutex m_post_mutex;\n+    std::function<void()> m_post_fn;\n+    CleanupList m_cleanup_fns;\n+    int m_wait_fd = -1;\n+    int m_post_fd = -1;\n+};\n+\n+\n+struct Waiter\n+{\n+    Waiter(EventLoop& loop) : m_loop(loop) {}\n+\n+    ~Waiter()\n+    {\n+        if (m_result.valid()) { // true if an external thread is calling wait\n+            std::unique_lock<std::mutex> lock(m_mutex);\n+            std::future<void> result = std::move(m_result);\n+            assert(!m_result.valid());\n+            m_cv.notify_all();\n+            lock.unlock();\n+            result.wait();\n+        }\n+    }\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be while loop, not if statement to avoid a\n+            // lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // between the unlock & lock lines in this loop in the case where a\n+            // capnp response is sent and a brand new request is received here\n+            // before this thread relocks.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    EventLoop& m_loop;\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::string m_name;\n+    std::function<void()> m_fn;\n+    std::future<void> m_result;\n+};\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(Waiter& waiter) : m_waiter(waiter) {}\n+\n+    kj::Promise<void> getName(GetNameContext context) override\n+    {\n+        context.getResults().setResult(m_waiter.m_name);\n+        return kj::READY_NOW;\n+    }\n+\n+    Waiter& m_waiter;\n+};\n+\n+struct ThreadContext\n+{\n+    std::unique_ptr<Waiter> waiter;\n+    std::map<EventLoop*, Optional<Thread::Client>> local_threads;\n+    std::map<EventLoop*, Optional<Thread::Client>> remote_threads;\n+\n+    ~ThreadContext()\n+    {\n+        // FIXME\n+        for (auto& thread : remote_threads) {\n+            if (thread.second) {\n+                thread.first->sync([&] { auto client = std::move(*thread.second); });\n+            }\n+        }\n+    }\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& client_thread;\n+    ClientInvokeContext(EventLoop& loop, ThreadContext& client_thread)\n+        : InvokeContext{loop}, client_thread{client_thread}\n+    {\n+    }\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    Optional<Thread::Client>& local_thread = invoke_context.client_thread.local_threads[&invoke_context.loop];\n+    if (!local_thread) {\n+        local_thread =\n+            invoke_context.loop.m_threads.add(kj::heap<ProxyServer<Thread>>(*invoke_context.client_thread.waiter));\n+    }\n+\n+    Optional<Thread::Client>& remote_thread = invoke_context.client_thread.remote_threads[&invoke_context.loop];\n+    if (!remote_thread) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing remote thread. This code will also never run at\n+        // all if the current thread is a remote thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // remote_thread to point to the calling thread.\n+        auto request = invoke_context.loop.m_thread_map.makeThreadRequest();\n+        request.setName(invoke_context.client_thread.waiter->m_name);\n+        remote_thread = request.send().getResult(); // Nonblocking due to capnp request piplineing.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230428604",
      "id" : 230428604,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDQyODYwNA==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 252,
      "original_position" : 252,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 171171348,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230428604",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605926"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The optional `block_height` could be uninitialized here?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-04T21:23:52Z",
      "diff_hunk" : "@@ -1594,113 +1597,133 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n-    const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    WalletLogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double progress_begin;\n         double progress_end;\n         {\n-            LOCK(cs_main);\n-            progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            if (pindexStop == nullptr) {\n-                tip = chainActive.Tip();\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = chain().lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            progress_begin = chain().guessVerificationProgress(block_hash);\n+            if (stop_block.IsNull()) {\n+                progress_end = chain().guessVerificationProgress(tip_hash);\n             } else {\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), pindexStop);\n+                progress_end = chain().guessVerificationProgress(stop_block);\n             }\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested())\n+        while (block_height && !fAbortRescan && !ShutdownRequested())\n         {\n-            if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n+            if (*block_height % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, progress_current);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n-                LOCK2(cs_main, cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+            if (chain().findBlock(block_hash, &block) && !block.IsNull()) {\n+                auto locked_chain = chain().lock();\n+                LOCK(cs_wallet);\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    ret = block_hash;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                    SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n+                    SyncTransaction(block.vtx[posInBlock], block_hash, posInBlock, fUpdate);\n                 }\n             } else {\n-                ret = pindex;\n+                ret = block_hash;\n             }\n-            if (pindex == pindexStop) {\n+            if (block_hash == stop_block) {\n                 break;\n             }\n             {\n-                LOCK(cs_main);\n-                pindex = chainActive.Next(pindex);\n-                progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                if (pindexStop == nullptr && tip != chainActive.Tip()) {\n-                    tip = chainActive.Tip();\n+                const int prev_block_height = *block_height;\n+                const uint256 prev_block_hash = block_hash;\n+                const uint256 prev_tip_hash = tip_hash;\n+                block_height.reset();\n+                block_hash.SetNull();\n+                tip_hash.SetNull();\n+\n+                auto locked_chain = chain().lock();\n+                if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                    if (locked_chain->getBlockHeight(prev_block_hash) && prev_block_height < *tip_height) {\n+                        block_height = prev_block_height + 1;\n+                        block_hash = locked_chain->getBlockHash(*block_height);\n+                    }\n+                    tip_hash = locked_chain->getBlockHash(*tip_height);\n+                }\n+\n+                progress_current = chain().guessVerificationProgress(block_hash);\n+                if (stop_block.IsNull() && prev_tip_hash != tip_hash) {\n                     // in case the tip has changed, update progress max\n-                    progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+                    progress_end = chain().guessVerificationProgress(tip_hash);\n                 }\n             }\n         }\n-        if (pindex && fAbortRescan) {\n-            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-        } else if (pindex && ShutdownRequested()) {\n-            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+        if (!block_hash.IsNull() && fAbortRescan) {\n+            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", *block_height, progress_current);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605926",
      "id" : 230605926,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTkyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 1859,
      "original_position" : 417,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171380028,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605933"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same here?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-04T21:24:04Z",
      "diff_hunk" : "@@ -1594,113 +1597,133 @@ int64_t CWallet::RescanFromTime(int64_t startTime, const WalletRescanReserver& r\n     // Find starting block. May be null if nCreateTime is greater than the\n     // highest blockchain timestamp, in which case there is nothing that needs\n     // to be scanned.\n-    CBlockIndex* startBlock = nullptr;\n+    uint256 start_block;\n     {\n-        LOCK(cs_main);\n-        startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n-        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n-    }\n-\n-    if (startBlock) {\n-        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, nullptr, reserver, update);\n-        if (failedBlock) {\n-            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        auto locked_chain = chain().lock();\n+        const Optional<int> start_height = locked_chain->findFirstBlockWithTime(startTime - TIMESTAMP_WINDOW);\n+        const Optional<int> tip_height = locked_chain->getHeight();\n+        WalletLogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, tip_height && start_height ? *tip_height - *start_height + 1 : 0);\n+        if (start_height) start_block = locked_chain->getBlockHash(*start_height);\n+    }\n+\n+    if (!start_block.IsNull()) {\n+        uint256 failed_block = ScanForWalletTransactions(start_block, {} /* stop block */, reserver, update);\n+        if (!failed_block.IsNull()) {\n+            int64_t time_max;\n+            if (!chain().findBlock(failed_block, nullptr /* CBlock */, nullptr /* time */, &time_max)) {\n+                throw std::logic_error(\"ScanForWalletTransactions returned invalid block hash\");\n+            }\n+            return time_max + TIMESTAMP_WINDOW + 1;\n         }\n     }\n     return startTime;\n }\n \n /**\n- * Scan the block chain (starting in pindexStart) for transactions\n+ * Scan the block chain (starting in start_block) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n  * exist in the wallet will be updated.\n  *\n  * Returns null if scan was successful. Otherwise, if a complete rescan was not\n  * possible (due to pruning or corruption), returns pointer to the most recent\n  * block that could not be scanned.\n  *\n- * If pindexStop is not a nullptr, the scan will stop at the block-index\n- * defined by pindexStop\n+ * If stop_block is not null, the scan will stop at the block-index\n+ * defined by stop_block\n  *\n- * Caller needs to make sure pindexStop (and the optional pindexStart) are on\n+ * Caller needs to make sure stop_block (and the optional start_block) are on\n  * the main chain after to the addition of any new keys you want to detect\n  * transactions for.\n  */\n-CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, CBlockIndex* pindexStop, const WalletRescanReserver &reserver, bool fUpdate)\n+uint256 CWallet::ScanForWalletTransactions(const uint256& start_block, const uint256& stop_block, const WalletRescanReserver &reserver, bool fUpdate)\n {\n     int64_t nNow = GetTime();\n-    const CChainParams& chainParams = Params();\n \n     assert(reserver.isReserved());\n-    if (pindexStop) {\n-        assert(pindexStop->nHeight >= pindexStart->nHeight);\n-    }\n \n-    CBlockIndex* pindex = pindexStart;\n-    CBlockIndex* ret = nullptr;\n+    uint256 block_hash = start_block;\n+    uint256 ret;\n \n-    if (pindex) WalletLogPrintf(\"Rescan started from block %d...\\n\", pindex->nHeight);\n+    WalletLogPrintf(\"Rescan started from block %s...\\n\", start_block.ToString());\n \n     {\n         fAbortRescan = false;\n         ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n-        CBlockIndex* tip = nullptr;\n+        uint256 tip_hash;\n+        Optional<int> block_height;\n         double progress_begin;\n         double progress_end;\n         {\n-            LOCK(cs_main);\n-            progress_begin = GuessVerificationProgress(chainParams.TxData(), pindex);\n-            if (pindexStop == nullptr) {\n-                tip = chainActive.Tip();\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+            auto locked_chain = chain().lock();\n+            if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                tip_hash = locked_chain->getBlockHash(*tip_height);\n+            }\n+            block_height = locked_chain->getBlockHeight(block_hash);\n+            progress_begin = chain().guessVerificationProgress(block_hash);\n+            if (stop_block.IsNull()) {\n+                progress_end = chain().guessVerificationProgress(tip_hash);\n             } else {\n-                progress_end = GuessVerificationProgress(chainParams.TxData(), pindexStop);\n+                progress_end = chain().guessVerificationProgress(stop_block);\n             }\n         }\n         double progress_current = progress_begin;\n-        while (pindex && !fAbortRescan && !ShutdownRequested())\n+        while (block_height && !fAbortRescan && !ShutdownRequested())\n         {\n-            if (pindex->nHeight % 100 == 0 && progress_end - progress_begin > 0.0) {\n+            if (*block_height % 100 == 0 && progress_end - progress_begin > 0.0) {\n                 ShowProgress(strprintf(\"%s \" + _(\"Rescanning...\"), GetDisplayName()), std::max(1, std::min(99, (int)((progress_current - progress_begin) / (progress_end - progress_begin) * 100))));\n             }\n             if (GetTime() >= nNow + 60) {\n                 nNow = GetTime();\n-                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+                WalletLogPrintf(\"Still rescanning. At block %d. Progress=%f\\n\", *block_height, progress_current);\n             }\n \n             CBlock block;\n-            if (ReadBlockFromDisk(block, pindex, Params().GetConsensus())) {\n-                LOCK2(cs_main, cs_wallet);\n-                if (pindex && !chainActive.Contains(pindex)) {\n+            if (chain().findBlock(block_hash, &block) && !block.IsNull()) {\n+                auto locked_chain = chain().lock();\n+                LOCK(cs_wallet);\n+                if (!locked_chain->getBlockHeight(block_hash)) {\n                     // Abort scan if current block is no longer active, to prevent\n                     // marking transactions as coming from the wrong block.\n-                    ret = pindex;\n+                    ret = block_hash;\n                     break;\n                 }\n                 for (size_t posInBlock = 0; posInBlock < block.vtx.size(); ++posInBlock) {\n-                    SyncTransaction(block.vtx[posInBlock], pindex, posInBlock, fUpdate);\n+                    SyncTransaction(block.vtx[posInBlock], block_hash, posInBlock, fUpdate);\n                 }\n             } else {\n-                ret = pindex;\n+                ret = block_hash;\n             }\n-            if (pindex == pindexStop) {\n+            if (block_hash == stop_block) {\n                 break;\n             }\n             {\n-                LOCK(cs_main);\n-                pindex = chainActive.Next(pindex);\n-                progress_current = GuessVerificationProgress(chainParams.TxData(), pindex);\n-                if (pindexStop == nullptr && tip != chainActive.Tip()) {\n-                    tip = chainActive.Tip();\n+                const int prev_block_height = *block_height;\n+                const uint256 prev_block_hash = block_hash;\n+                const uint256 prev_tip_hash = tip_hash;\n+                block_height.reset();\n+                block_hash.SetNull();\n+                tip_hash.SetNull();\n+\n+                auto locked_chain = chain().lock();\n+                if (Optional<int> tip_height = locked_chain->getHeight()) {\n+                    if (locked_chain->getBlockHeight(prev_block_hash) && prev_block_height < *tip_height) {\n+                        block_height = prev_block_height + 1;\n+                        block_hash = locked_chain->getBlockHash(*block_height);\n+                    }\n+                    tip_hash = locked_chain->getBlockHash(*tip_height);\n+                }\n+\n+                progress_current = chain().guessVerificationProgress(block_hash);\n+                if (stop_block.IsNull() && prev_tip_hash != tip_hash) {\n                     // in case the tip has changed, update progress max\n-                    progress_end = GuessVerificationProgress(chainParams.TxData(), tip);\n+                    progress_end = chain().guessVerificationProgress(tip_hash);\n                 }\n             }\n         }\n-        if (pindex && fAbortRescan) {\n-            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n-        } else if (pindex && ShutdownRequested()) {\n-            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", pindex->nHeight, progress_current);\n+        if (!block_hash.IsNull() && fAbortRescan) {\n+            WalletLogPrintf(\"Rescan aborted at block %d. Progress=%f\\n\", *block_height, progress_current);\n+        } else if (!block_hash.IsNull() && ShutdownRequested()) {\n+            WalletLogPrintf(\"Rescan interrupted by shutdown request at block %d. Progress=%f\\n\", *block_height, progress_current);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230605933",
      "id" : 230605933,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDYwNTkzMw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 1862,
      "original_position" : 419,
      "original_start_line" : null,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 171380036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230605933",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783285"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427653\r\n\r\n> Not used?\r\n\r\nNo, it's a overridden method called through the base class by the kj library.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-12T19:27:29Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783285",
      "id" : 232783285,
      "in_reply_to_id" : 230427653,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzI4NQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 44,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : null,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783285",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783326"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783326"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427503\r\n\r\n> Not used?\r\n\r\nNo, it's called by generated code.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-12T19:27:36Z",
      "diff_hunk" : "@@ -0,0 +1,113 @@\n+#include <interfaces/capnp/proxy-impl.h>\n+\n+#include <kj/async-prelude.h>\n+#include <kj/debug.h>\n+#include <stdlib.h>\n+#include <sys/socket.h>\n+#include <unistd.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+thread_local ThreadContext g_thread_context;\n+\n+void LoggingErrorHandler::taskFailed(kj::Exception&& exception)\n+{\n+    KJ_LOG(ERROR, \"Uncaught exception in daemonized task.\", exception);\n+    LogIpc(m_loop, \"Uncaught exception in daemonized task.\");\n+}\n+\n+EventLoop::EventLoop(const char* exe_name, std::thread&& thread)\n+    : m_exe_name(exe_name), m_thread_map(nullptr), m_io_context(kj::setupAsyncIo()), m_thread(std::move(thread))\n+{\n+    int fds[2];\n+    KJ_SYSCALL(socketpair(AF_UNIX, SOCK_STREAM, 0, fds));\n+    m_wait_fd = fds[0];\n+    m_post_fd = fds[1];\n+}\n+\n+EventLoop::~EventLoop()\n+{\n+    KJ_ASSERT(!m_thread.joinable());\n+    KJ_ASSERT(m_wait_fd == -1);\n+    KJ_ASSERT(m_post_fd == -1);\n+    for (auto& fn : m_cleanup_fns) {\n+        fn();\n+    }\n+}\n+\n+void EventLoop::loop()\n+{\n+    kj::Own<kj::AsyncIoStream> wait_stream{\n+        m_io_context.lowLevelProvider->wrapSocketFd(m_wait_fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)};\n+    char buffer;\n+    for (;;) {\n+        size_t bytes = -1;\n+        wait_stream->read(&buffer, 0, 1).then([&](size_t s) { bytes = s; }).wait(m_io_context.waitScope);\n+        if (bytes == 0) {\n+            wait_stream = nullptr;\n+            m_wait_fd = -1;\n+            break;\n+        }\n+        m_post_fn();\n+        m_post_fn = nullptr;\n+        m_task_set.add(wait_stream->write(&buffer, 1));\n+    }\n+}\n+\n+void EventLoop::post(std::function<void()> fn)\n+{\n+    if (std::this_thread::get_id() == m_thread_id) {\n+        fn();\n+        return;\n+    }\n+    std::lock_guard<std::mutex> lock(m_post_mutex);\n+    m_post_fn = std::move(fn);\n+    char signal = '\\0';\n+    KJ_SYSCALL(write(m_post_fd, &signal, 1));\n+    KJ_SYSCALL(read(m_post_fd, &signal, 1));\n+}\n+\n+void EventLoop::shutdown()\n+{\n+    std::thread close_thread = std::move(m_thread);\n+    int close_fd = m_post_fd;\n+    m_post_fd = -1;\n+    KJ_SYSCALL(close(close_fd));\n+    if (close_thread.joinable()) {\n+        close_thread.join();\n+    }\n+}\n+\n+ProxyServer<ThreadMap>::ProxyServer(EventLoop& loop) : m_loop(loop) {}\n+\n+kj::Promise<void> ProxyServer<ThreadMap>::makeThread(MakeThreadContext context)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783326",
      "id" : 232783326,
      "in_reply_to_id" : 230427503,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzMyNg==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 292,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy.cpp",
      "position" : null,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783326",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783356"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230427589\r\n\r\n> Not used?\r\n\r\nNo, it's called by generated code.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-12T19:27:41Z",
      "diff_hunk" : "@@ -0,0 +1,24 @@\n+#include <interfaces/capnp/test/foo.h>\n+\n+#include <util.h>\n+\n+namespace interfaces {\n+namespace capnp {\n+namespace test {\n+namespace {\n+\n+class FooImpl : public FooInterface\n+{\n+public:\n+    int add(int a, int b) override { return a + b; }\n+    int mapSize(const std::map<std::string, std::string>& map) override { return map.size(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783356",
      "id" : 232783356,
      "in_reply_to_id" : 230427589,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzM1Ng==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 13,
      "original_position" : 14,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/test/foo.cpp",
      "position" : null,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783467"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783467"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426764\r\n\r\n> Always true?\r\n\r\nhas_result is false for any method that doesn't have an output named result, which is true for any method that returns void.\r\n\r\n",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-12T19:28:04Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783467",
      "id" : 232783467,
      "in_reply_to_id" : 230426764,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzQ2Nw==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 422,
      "original_position" : 417,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : null,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783467",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783489"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r230426823\r\n\r\n> Always true?\r\n\r\nNo, see previous comment.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2018-11-12T19:28:08Z",
      "diff_hunk" : "@@ -0,0 +1,472 @@\n+#include <algorithm>\n+#include <boost/core/explicit_operator_bool.hpp>\n+#include <boost/optional/optional.hpp>\n+#include <capnp/blob.h>\n+#include <capnp/schema-parser.h>\n+#include <capnp/schema.capnp.h>\n+#include <capnp/schema.h>\n+#include <cctype>\n+#include <fstream>\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <kj/common.h>\n+#include <kj/string.h>\n+#include <map>\n+#include <memory>\n+#include <set>\n+#include <sstream>\n+#include <stdint.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+#include <capnp/schema-lite.h>\n+#include <iostream>\n+\n+#define PROXY_BIN \"interfaces/capnp/proxy-codegen\"\n+#define PROXY_DECL \"interfaces/capnp/proxy.h\"\n+#define PROXY_IMPL \"interfaces/capnp/proxy-impl.h\"\n+\n+constexpr uint64_t NAMESPACE_ANNOTATION_ID = 0xb9c6f99ebf805f2cull; // From c++.capnp\n+constexpr uint64_t PROXY_ANNOTATION_ID = 0xbaf188aa5b50aacfull;     // From proxy.capnp\n+constexpr uint64_t COUNT_ANNOTATION_ID = 0xd02682b319f69b38ull;     // From proxy.capnp\n+constexpr uint64_t EXCEPTION_ANNOTATION_ID = 0x996a183200992f88ull; // From proxy.capnp\n+constexpr uint64_t NAME_ANNOTATION_ID = 0xb594888f63f4dbb9ull;      // From proxy.capnp\n+constexpr uint64_t SKIP_ANNOTATION_ID = 0x824c08b82695d8ddull;      // From proxy.capnp\n+\n+template <typename Reader>\n+boost::optional<capnp::schema::Value::Reader> GetAnnotation(const Reader& reader, uint64_t id)\n+{\n+    for (const auto annotation : reader.getAnnotations()) {\n+        if (annotation.getId() == id) return annotation.getValue();\n+    }\n+    return {};\n+}\n+\n+using CharSlice = kj::ArrayPtr<const char>;\n+\n+// Overload for any type with a string .begin(), like kj::StringPtr and kj::ArrayPtr<char>.\n+template <class OutputStream, class Array, const char* Enable = decltype(std::declval<Array>().begin())()>\n+OutputStream& operator<<(OutputStream& os, const Array& array)\n+{\n+    os.write(array.begin(), array.size());\n+    return os;\n+}\n+\n+struct Format\n+{\n+    template <typename Value>\n+    Format& operator<<(Value&& value)\n+    {\n+        m_os << value;\n+        return *this;\n+    }\n+    operator std::string() { return m_os.str(); }\n+    std::ostringstream m_os;\n+};\n+\n+std::string Cap(kj::StringPtr str)\n+{\n+    std::string result = str;\n+    if (!result.empty() && 'a' <= result[0] && result[0] <= 'z') result[0] -= 'a' - 'A';\n+    return result;\n+}\n+\n+bool BoxedType(const ::capnp::Type& type)\n+{\n+    return !(type.isVoid() || type.isBool() || type.isInt8() || type.isInt16() || type.isInt32() || type.isInt64() ||\n+             type.isUInt8() || type.isUInt16() || type.isUInt32() || type.isUInt64() || type.isFloat32() ||\n+             type.isFloat64() || type.isEnum());\n+}\n+\n+void Generate(kj::StringPtr input_schema, kj::StringPtr import_path, kj::StringPtr output_stem)\n+{\n+    capnp::SchemaParser parser;\n+    auto file_schema = parser.parseDiskFile(input_schema, input_schema, {import_path});\n+\n+    const std::string stem = output_stem;\n+    std::ofstream cpp(stem + \".capnp.proxy.c++\");\n+    cpp << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    cpp << \"#include <\" << stem << \".capnp.proxy-impl.h>\\n\";\n+    cpp << \"#include <\" << PROXY_IMPL << \">\\n\\n\";\n+    cpp << \"namespace interfaces {\\n\";\n+    cpp << \"namespace capnp {\\n\";\n+\n+    std::string guard = stem;\n+    std::transform(guard.begin(), guard.end(), guard.begin(), [](unsigned char c) {\n+        return ('0' <= c && c <= '9') ? c : ('A' <= c && c <= 'Z') ? c : ('a' <= c && c <= 'z') ? c - 'a' + 'A' : '_';\n+    });\n+\n+    std::ofstream impl(stem + \".capnp.proxy-impl.h\");\n+    impl << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    impl << \"#ifndef \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\";\n+    impl << \"#define \" << guard << \"_CAPNP_PROXY_IMPL_H\\n\\n\";\n+    impl << \"#include <\" << stem << \".capnp.proxy.h>\\n\";\n+    impl << \"#include <\" << stem << \"-impl.h>\\n\\n\";\n+    impl << \"namespace interfaces {\\n\";\n+    impl << \"namespace capnp {\\n\";\n+\n+    std::ofstream h(stem + \".capnp.proxy.h\");\n+    h << \"// Generated by \" PROXY_BIN \" from \" << input_schema << \"\\n\\n\";\n+    h << \"#ifndef \" << guard << \"_CAPNP_PROXY_H\\n\";\n+    h << \"#define \" << guard << \"_CAPNP_PROXY_H\\n\\n\";\n+    h << \"#include <\" << stem << \".h>\\n\";\n+    h << \"#include <\" << PROXY_DECL << \">\\n\\n\";\n+    h << \"namespace interfaces {\\n\";\n+    h << \"namespace capnp {\\n\";\n+\n+    kj::StringPtr message_namespace;\n+    if (auto value = GetAnnotation(file_schema.getProto(), NAMESPACE_ANNOTATION_ID)) {\n+        message_namespace = value->getText();\n+    }\n+\n+\n+    std::ostringstream methods;\n+    std::set<kj::StringPtr> accessors_done;\n+    std::ostringstream accessors;\n+    std::ostringstream dec;\n+    std::ostringstream def;\n+\n+    auto add_accessor = [&](kj::StringPtr name) {\n+        if (!accessors_done.insert(name).second) return;\n+        std::string cap = Cap(name);\n+        accessors << \"struct Field\" << cap << \"\\n\";\n+        accessors << \"{\\n\";\n+        accessors << \"    template<typename S> static auto get(S&& s) -> AUTO_RETURN(s.get\" << cap << \"())\\n\";\n+        accessors << \"    template<typename S> static bool has(S&& s) { return s.has\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S, typename A> static void set(S&& s, A&& a) { s.set\" << cap\n+                  << \"(std::forward<A>(a)); }\\n\";\n+        accessors << \"    template<typename S, typename... A> static auto init(S&& s, A&&... a) -> AUTO_RETURN(s.init\"\n+                  << cap << \"(std::forward<A>(a)...))\\n\";\n+        accessors << \"    template<typename S> static bool getWant(S&& s) { return s.getWant\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setWant(S&& s) { s.setWant\" << cap << \"(true); }\\n\";\n+        accessors << \"    template<typename S> static bool getHas(S&& s) { return s.getHas\" << cap << \"(); }\\n\";\n+        accessors << \"    template<typename S> static void setHas(S&& s) { s.setHas\" << cap << \"(true); }\\n\";\n+        accessors << \"};\\n\";\n+    };\n+\n+    for (const auto node_nested : file_schema.getProto().getNestedNodes()) {\n+        kj::StringPtr node_name = node_nested.getName();\n+        const auto& node = file_schema.getNested(node_name);\n+        kj::StringPtr proxied_class_type;\n+        if (auto proxy = GetAnnotation(node.getProto(), PROXY_ANNOTATION_ID)) {\n+            proxied_class_type = proxy->getText();\n+        }\n+\n+        if (node.getProto().isStruct()) {\n+            const auto& struc = node.asStruct();\n+            std::ostringstream generic_name;\n+            generic_name << node_name;\n+            dec << \"template<\";\n+            bool first_param = true;\n+            for (const auto param : node.getProto().getParameters()) {\n+                if (first_param) {\n+                    first_param = false;\n+                    generic_name << \"<\";\n+                } else {\n+                    dec << \", \";\n+                    generic_name << \", \";\n+                }\n+                dec << \"typename \" << param.getName();\n+                generic_name << \"\" << param.getName();\n+            }\n+            if (!first_param) generic_name << \">\";\n+            dec << \">\\n\";\n+            dec << \"struct ProxyStruct<\" << message_namespace << \"::\" << generic_name.str() << \">\\n\";\n+            dec << \"{\\n\";\n+            dec << \"    using Struct = \" << message_namespace << \"::\" << generic_name.str() << \";\\n\";\n+            for (const auto field : struc.getFields()) {\n+                auto field_name = field.getProto().getName();\n+                add_accessor(field_name);\n+                dec << \"    using \" << Cap(field_name) << \"Accessor = Accessor<Field\" << Cap(field_name)\n+                    << \", FIELD_IN | FIELD_OUT\";\n+                if (BoxedType(field.getType())) dec << \" | FIELD_BOXED\";\n+                dec << \">;\\n\";\n+            }\n+            dec << \"    using Accessors = std::tuple<\";\n+            size_t i = 0;\n+            for (const auto field : struc.getFields()) {\n+                if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                    continue;\n+                }\n+                if (i) dec << \", \";\n+                dec << Cap(field.getProto().getName()) << \"Accessor\";\n+                ++i;\n+            }\n+            dec << \">;\\n\";\n+            dec << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+            dec << \"};\\n\";\n+\n+            if (proxied_class_type.size()) {\n+                impl << \"template<>\\n\";\n+                impl << \"struct ProxyType<\" << proxied_class_type << \">\\n\";\n+                impl << \"{\\n\";\n+                impl << \"public:\\n\";\n+                impl << \"    using Struct = \" << message_namespace << \"::\" << node_name << \";\\n\";\n+                size_t i = 0;\n+                for (const auto field : struc.getFields()) {\n+                    if (GetAnnotation(field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        continue;\n+                    }\n+                    auto field_name = field.getProto().getName();\n+                    auto member_name = field_name;\n+                    if (auto name = GetAnnotation(field.getProto(), NAME_ANNOTATION_ID)) {\n+                        member_name = name->getText();\n+                    }\n+                    impl << \"    static auto get(std::integral_constant<size_t, \" << i << \">) -> AUTO_RETURN(\"\n+                         << \"&\" << proxied_class_type << \"::\" << member_name << \")\\n\";\n+                    ++i;\n+                }\n+                impl << \"    static constexpr size_t fields = \" << i << \";\\n\";\n+                impl << \"};\\n\";\n+            }\n+        }\n+\n+        if (proxied_class_type.size() && node.getProto().isInterface()) {\n+            const auto& interface = node.asInterface();\n+\n+            std::ostringstream client;\n+            client << \"template<>\\nstruct ProxyClient<\" << message_namespace << \"::\" << node_name << \"> : \";\n+            client << \"public ProxyClientCustom<\" << message_namespace << \"::\" << node_name << \", \"\n+                   << proxied_class_type << \">\\n{\\n\";\n+            client << \"public:\\n\";\n+            client << \"    using ProxyClientCustom::ProxyClientCustom;\\n\";\n+            client << \"    ~ProxyClient();\\n\";\n+\n+            std::ostringstream server;\n+            server << \"template<>\\nstruct ProxyServer<\" << message_namespace << \"::\" << node_name << \"> : public \"\n+                   << \"ProxyServerCustom<\" << message_namespace << \"::\" << node_name << \", \" << proxied_class_type\n+                   << \">\\n{\\n\";\n+            server << \"public:\\n\";\n+            server << \"    using ProxyServerCustom::ProxyServerCustom;\\n\";\n+            server << \"    ~ProxyServer();\\n\";\n+\n+            std::ostringstream client_construct;\n+            std::ostringstream client_destroy;\n+\n+            for (const auto method : interface.getMethods()) {\n+                kj::StringPtr method_name = method.getProto().getName();\n+                kj::StringPtr proxied_method_name = method_name;\n+                if (auto name = GetAnnotation(method.getProto(), NAME_ANNOTATION_ID)) {\n+                    proxied_method_name = name->getText();\n+                }\n+\n+                const std::string method_prefix = Format() << message_namespace << \"::\" << node_name\n+                                                           << \"::\" << Cap(method_name);\n+                bool is_construct = method_name == \"construct\";\n+                bool is_destroy = method_name == \"destroy\";\n+\n+                struct Field\n+                {\n+                    boost::optional<::capnp::StructSchema::Field> param;\n+                    boost::optional<::capnp::StructSchema::Field> result;\n+                    int args = 0;\n+                    bool retval = false;\n+                    bool optional = false;\n+                    bool requested = false;\n+                    bool skip = false;\n+                    kj::StringPtr exception;\n+                };\n+\n+                std::vector<Field> fields;\n+                std::map<kj::StringPtr, int> field_idx; // name -> args index\n+                bool has_result = false;\n+\n+                auto add_field = [&](const ::capnp::StructSchema::Field& schema_field, bool param) {\n+                    if (GetAnnotation(schema_field.getProto(), SKIP_ANNOTATION_ID)) {\n+                        return;\n+                    }\n+\n+                    auto field_name = schema_field.getProto().getName();\n+                    auto inserted = field_idx.emplace(field_name, fields.size());\n+                    if (inserted.second) {\n+                        fields.emplace_back();\n+                    }\n+                    auto& field = fields[inserted.first->second];\n+                    (param ? field.param : field.result) = schema_field;\n+\n+                    if (!param && field_name == \"result\") {\n+                        field.retval = true;\n+                        has_result = true;\n+                    }\n+\n+                    if (auto value = GetAnnotation(schema_field.getProto(), EXCEPTION_ANNOTATION_ID)) {\n+                        field.exception = value->getText();\n+                    }\n+\n+                    boost::optional<int> count;\n+                    if (auto value = GetAnnotation(schema_field.getProto(), COUNT_ANNOTATION_ID)) {\n+                        count = value->getInt32();\n+                    } else if (schema_field.getType().isStruct()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asStruct().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    } else if (schema_field.getType().isInterface()) {\n+                        if (auto value =\n+                                GetAnnotation(schema_field.getType().asInterface().getProto(), COUNT_ANNOTATION_ID)) {\n+                            count = value->getInt32();\n+                        }\n+                    }\n+\n+\n+                    if (inserted.second && !field.retval && !field.exception.size()) {\n+                        if (count) {\n+                            field.args = *count;\n+                        } else {\n+                            field.args = 1;\n+                        }\n+                    }\n+                };\n+\n+                for (const auto schema_field : method.getParamType().getFields()) {\n+                    add_field(schema_field, true);\n+                }\n+                for (const auto schema_field : method.getResultType().getFields()) {\n+                    add_field(schema_field, false);\n+                }\n+                for (auto& field : field_idx) {\n+                    auto has_field = field_idx.find(\"has\" + Cap(field.first));\n+                    if (has_field != field_idx.end()) {\n+                        fields[has_field->second].skip = true;\n+                        fields[field.second].optional = true;\n+                    }\n+                    auto want_field = field_idx.find(\"want\" + Cap(field.first));\n+                    if (want_field != field_idx.end() && fields[want_field->second].param) {\n+                        fields[want_field->second].skip = true;\n+                        fields[field.second].requested = true;\n+                    }\n+                }\n+\n+                if (!is_construct && !is_destroy) {\n+                    methods << \"template<>\\n\";\n+                    methods << \"struct ProxyMethod<\" << method_prefix << \"Params>\\n\";\n+                    methods << \"{\\n\";\n+                    methods << \"    static constexpr auto impl = &\" << proxied_class_type\n+                            << \"::\" << proxied_method_name << \";\\n\";\n+                    methods << \"};\\n\\n\";\n+                }\n+\n+                std::ostringstream client_args;\n+                std::ostringstream client_invoke;\n+                std::ostringstream server_invoke_start;\n+                std::ostringstream server_invoke_end;\n+                int argc = 0;\n+                for (const auto& field : fields) {\n+                    if (field.skip) continue;\n+\n+                    auto field_name = field.param ? field.param->getProto().getName() :\n+                                                    field.result ? field.result->getProto().getName() : \"\";\n+                    auto field_type = field.param ? field.param->getType() : field.result->getType();\n+\n+                    std::ostringstream field_flags;\n+                    field_flags << (!field.param ? \"FIELD_OUT\" : field.result ? \"FIELD_IN | FIELD_OUT\" : \"FIELD_IN\");\n+                    if (field.optional) field_flags << \" | FIELD_OPTIONAL\";\n+                    if (field.requested) field_flags << \" | FIELD_REQUESTED\";\n+                    if (BoxedType(field_type)) field_flags << \" | FIELD_BOXED\";\n+\n+                    add_accessor(field_name);\n+\n+                    for (int i = 0; i < field.args; ++i) {\n+                        if (argc > 0) client_args << \",\";\n+                        client_args << \"M\" << method.getOrdinal() << \"::Param<\" << argc << \"> \" << field_name;\n+                        if (field.args > 1) client_args << i;\n+                        ++argc;\n+                    }\n+                    client_invoke << \", \";\n+\n+                    if (field.exception.size()) {\n+                        client_invoke << \"ClientException<\" << field.exception << \", \";\n+                    } else {\n+                        client_invoke << \"MakeClientParam<\";\n+                    }\n+\n+                    client_invoke << \"Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+\n+                    if (field.retval || field.args == 1) {\n+                        client_invoke << field_name;\n+                    } else {\n+                        for (int i = 0; i < field.args; ++i) {\n+                            if (i > 0) client_invoke << \", \";\n+                            client_invoke << field_name << i;\n+                        }\n+                    }\n+                    client_invoke << \")\";\n+\n+                    if (field.exception.size()) {\n+                        server_invoke_start << \"Make<ServerExcept, \" << field.exception;\n+                    } else if (field.retval) {\n+                        server_invoke_start << \"Make<ServerRet\";\n+                    } else {\n+                        server_invoke_start << \"MakeServerField<\" << field.args;\n+                    }\n+                    server_invoke_start << \", Accessor<Field\" << Cap(field_name) << \", \" << field_flags.str() << \">>(\";\n+                    server_invoke_end << \")\";\n+                }\n+\n+                client << \"    using M\" << method.getOrdinal() << \" = ProxyClientMethodTraits<\" << method_prefix\n+                       << \"Params>;\\n\";\n+                client << \"    typename M\" << method.getOrdinal() << \"::Result \" << method_name << \"(\"\n+                       << client_args.str() << \")\";\n+                client << \";\\n\";\n+                def << \"ProxyClient<\" << message_namespace << \"::\" << node_name << \">::M\" << method.getOrdinal()\n+                    << \"::Result ProxyClient<\" << message_namespace << \"::\" << node_name << \">::\" << method_name << \"(\"\n+                    << client_args.str() << \") {\\n\";\n+                if (has_result) {\n+                    def << \"    typename M\" << method.getOrdinal() << \"::Result result;\\n\";\n+                }\n+                def << \"    clientInvoke(*this, &\" << message_namespace << \"::\" << node_name\n+                    << \"::Client::\" << method_name << \"Request\" << client_invoke.str() << \");\\n\";\n+                if (has_result) def << \"    return result;\\n\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r232783489",
      "id" : 232783489,
      "in_reply_to_id" : 230426823,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjc4MzQ4OQ==",
      "original_commit_id" : "ee425e2ddff453a5436cffb1e16e5452d8e3892a",
      "original_line" : 422,
      "original_position" : 422,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-codegen.cpp",
      "position" : null,
      "pull_request_review_id" : 174057775,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232783489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250513986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250513986"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Shadows variable `params` in outer scope?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2019-01-24T09:02:50Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250513986",
      "id" : 250513986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxMzk4Ng==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_line" : 396,
      "original_position" : 387,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250513986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514057"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same here?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2019-01-24T09:03:01Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514057",
      "id" : 250514057,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxNDA1Nw==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_line" : 397,
      "original_position" : 388,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514057",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514589"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be `explicit`? Applies to all single parameter constructors in this PR :-)",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2019-01-24T09:04:49Z",
      "diff_hunk" : "@@ -0,0 +1,312 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_UTIL_H\n+#define BITCOIN_INTERFACES_CAPNP_UTIL_H\n+\n+#include <capnp/schema.h>\n+\n+#include <future>\n+#include <list>\n+#include <mutex>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+// C++11 workaround for C++14 auto return functions\n+// (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions)\n+#define AUTO_DO_RETURN(pre, x) \\\n+    decltype(x)                \\\n+    {                          \\\n+        pre;                   \\\n+        return x;              \\\n+    }\n+\n+#define AUTO_RETURN(x) AUTO_DO_RETURN(, x)\n+\n+//! Shortcut for std::decay.\n+template <typename T>\n+using Decay = typename std::decay<T>::type;\n+\n+//! Empty object that discards any arguments it is initialized with. Useful as\n+//! function argument, to avoid having to write a template function when don't\n+//! care about values of generic arguments.\n+struct Discard\n+{\n+    template <typename... Args>\n+    Discard(Args&&...)\n+    {\n+    }\n+};\n+\n+//! Invoke callable `fn()` that may return void. If it does return void, replace\n+//! return value with value of `ret()`. This is useful for avoiding code\n+//! duplication and branching in generic code that forwards calls to functions.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<std::is_same<void, decltype(fn())>::value, decltype(ret())>::type\n+{\n+    fn();\n+    return ret();\n+}\n+\n+//! Overload of above for non-void `fn()` case.\n+template <typename Fn, typename Ret>\n+auto ReplaceVoid(Fn&& fn, Ret&& ret) ->\n+    typename std::enable_if<!std::is_same<void, decltype(fn())>::value, decltype(fn())>::type\n+{\n+    return fn();\n+}\n+\n+//! Type holding a list of types.\n+//!\n+//! Example:\n+//!   TypeList<int, bool, void>\n+template <typename... Types>\n+struct TypeList\n+{\n+    static constexpr size_t size = sizeof...(Types);\n+};\n+\n+//! Split TypeList into two halves at position index.\n+//!\n+//! Example:\n+//!   is_same<TypeList<int, double>, Split<2, TypeList<int, double, float, bool>>::First>\n+//!   is_same<TypeList<float, bool>, Split<2, TypeList<int, double, float, bool>>::Second>\n+template <std::size_t index, typename List, typename _First = TypeList<>, bool done = index == 0>\n+struct Split;\n+\n+//! Specialization of above (base case)\n+template <typename _Second, typename _First>\n+struct Split<0, _Second, _First, true>\n+{\n+    using First = _First;\n+    using Second = _Second;\n+};\n+\n+//! Specialization of above (recursive case)\n+template <std::size_t index, typename Type, typename... _Second, typename... _First>\n+struct Split<index, TypeList<Type, _Second...>, TypeList<_First...>, false>\n+{\n+    using _Next = Split<index - 1, TypeList<_Second...>, TypeList<_First..., Type>>;\n+    using First = typename _Next::First;\n+    using Second = typename _Next::Second;\n+};\n+\n+//! SFINAE helper, basically the same as to C++17's void_t, but allowing types other than void to be returned.\n+template <typename SfinaeExpr, typename Result_>\n+struct _Require\n+{\n+    using Result = Result_;\n+};\n+template <typename SfinaeExpr, typename Result = void>\n+using Require = typename _Require<SfinaeExpr, Result>::Result;\n+\n+//! Helper type for prioritizing overloaded function calls that would otherwise\n+//! be ambiguous.\n+//!\n+//! Example:\n+//!   auto foo(Priority<1>) -> std::enable_if<>;\n+//!   auto foo(Priority<0>) -> void;\n+//!\n+//!   foo(Priority<1>());   // Calls higher priority overload if enabled.\n+template <int priority>\n+struct Priority : Priority<priority - 1>\n+{\n+};\n+\n+//! Specialization of above (base case)\n+template <>\n+struct Priority<0>\n+{\n+};\n+\n+//! Construct a template class value by deducing template arguments from the\n+//! types of constructor arguments, so they don't need to be specified manually.\n+//!\n+//! Example:\n+//!   Make<std::pair>(5, true) // Constructs std::pair<int, bool>(5, true);\n+template <template <typename...> class Class, typename... Types, typename... Args>\n+Class<Types..., typename std::remove_reference<Args>::type...> Make(Args&&... args)\n+{\n+    return Class<Types..., typename std::remove_reference<Args>::type...>{std::forward<Args>(args)...};\n+}\n+\n+//! Generic utility functions used by capnp code. This mostly consists of\n+//! helpers that work around lack of C++14 functionality in C++11. This file\n+//! puts all C++14 workarounds in one place, so if/when bitcoin decides to\n+//! decides to upgrade to C++14, code can be accordingly simplified.\n+//!\n+//! C++14 has two features that really simplify generic programming. One is\n+//! auto-returning functions\n+//! (http://en.cppreference.com/w/cpp/language/template_argument_deduction#auto-returning_functions):\n+//!\n+//!    auto DoSomething(Arg arg) {\n+//!        return expression(arg);\n+//!    }\n+//!\n+//! which in c++11 has to be written:\n+//!\n+//!    auto DoSomething(Arg arg) -> decltype(expression(arg)) {\n+//!        return expression(arg);\n+//!    }\n+//!\n+//! Another is generic lambdas (http://en.cppreference.com/w/cpp/language/lambda):\n+//!\n+//!    [capture](auto arg) { do_something(arg); }\n+//!\n+//! which in c++11 has to be written like\n+//!\n+//!    struct DoSomething {\n+//!        Capture m_capture;\n+//!\n+//!        template<typename Arg>\n+//!        void operator()(Arg arg) {\n+//!            return do_something(arg);\n+//!        }\n+//!     };\n+\n+//! Functor wrapping std::get. Can be replaced with auto lambdas when we update\n+//! to C++14.\n+//!\n+//! Example:\n+//!   Get<3>()(a) // Equivalent to std::get<3>(a)\n+template <std::size_t I>\n+struct Get\n+{\n+    template <typename Tuple>\n+    auto operator()(Tuple&& tuple) -> decltype(std::get<I>(tuple))&\n+    {\n+        return std::get<I>(tuple);\n+    }\n+};\n+\n+//! Functor composing two other functors. Can be replaced with auto lambdas when\n+//! we update to C++14.\n+//!\n+//! Example:\n+//!   Make<Compose>(sin, atan2)(3, 4) == sin(atan2(3, 4))\n+template <typename Fn1, typename Fn2>\n+struct Compose\n+{\n+    Fn1&& fn1;\n+    Fn2&& fn2;\n+\n+    template <typename... Args>\n+    auto operator()(Args&&... args) -> AUTO_RETURN(this->fn1(this->fn2(std::forward<Args>(args)...)))\n+};\n+\n+//! Bound function. See Bind() below.\n+template <typename Fn, typename BindArgs, typename BoundArgs = TypeList<>>\n+struct BoundFn;\n+\n+//! Specialization of above for base case.\n+template <typename Fn, typename... BoundArgs>\n+struct BoundFn<Fn, TypeList<>, TypeList<BoundArgs...>>\n+{\n+    Fn&& m_fn;\n+\n+    template <typename... FreeArgs>\n+    auto operator()(BoundArgs&... bound_args, FreeArgs&&... free_args)\n+        -> AUTO_RETURN(this->m_fn(bound_args..., std::forward<FreeArgs>(free_args)...))\n+};\n+\n+//! Specialization of above for recursive case.\n+template <typename Fn, typename BindArg, typename... BindArgs, typename... BoundArgs>\n+struct BoundFn<Fn, TypeList<BindArg, BindArgs...>, TypeList<BoundArgs...>>\n+    : BoundFn<Fn, TypeList<BindArgs...>, TypeList<BoundArgs..., BindArg>>\n+{\n+    using Base = BoundFn<Fn, TypeList<BindArgs...>, TypeList<BoundArgs..., BindArg>>;\n+    BindArg& m_bind_arg;\n+\n+    BoundFn(Fn& fn, BindArg& bind_arg, BindArgs&... bind_args) : Base{fn, bind_args...}, m_bind_arg(bind_arg) {}\n+\n+    template <typename... FreeArgs>\n+    auto operator()(BoundArgs&... bound_args, FreeArgs&&... free_args) ->\n+        typename std::result_of<Base(BoundArgs&..., BindArg&, FreeArgs...)>::type\n+    {\n+        return Base::operator()(bound_args..., m_bind_arg, std::forward<FreeArgs>(free_args)...);\n+    }\n+};\n+\n+//! std::bind replacement. Unlike std::bind it doesn't copy the function object\n+//! or argument but instead takes rvalue references. This allows it to work with\n+//! uncopyable objects, but also limits its use to situations where objects\n+//! don't go out of scope. Uses of this can be replaced with auto lambdas when\n+//! we update to C++14.\n+//!\n+//! Example:\n+//!    Bind(atan2, 3)(4) == atan2(3, 4)\n+//!\n+//! Possible TODO: It might be nice to make binding more consistent with composing\n+//! and switch to calling syntax Make<Bind>(...) instead of Bind(...).\n+template <typename Fn, typename... BindArgs>\n+BoundFn<Fn, TypeList<BindArgs...>> Bind(Fn&& fn, BindArgs&... bind_args)\n+{\n+    return {fn, bind_args...};\n+}\n+\n+//! FIXME: Delete and replace with KJ_DEFER\n+//! Temporarily set reference to value in constructor, and restore previous\n+//! value in destructor.\n+//! Example:\n+//!\n+//!     int i = 3;\n+//!     {\n+//!        TempSetter t(i, 4);\n+//         ... i is 4 here ...\n+//!     }\n+//!     ... i is 3 again ...\n+template <typename T>\n+struct TempSetter\n+{\n+    template <typename U>\n+    TempSetter(T& ref, U&& value) : m_ref(ref), m_prev(std::move(ref))\n+    {\n+        m_ref = std::forward<U>(value);\n+    }\n+\n+    ~TempSetter() { m_ref = std::move(m_prev); }\n+\n+    T& m_ref;\n+    T m_prev;\n+};\n+\n+//! Return capnp type name with filename prefix removed.\n+template <typename T>\n+const char* TypeName()\n+{\n+    // DisplayName string looks like\n+    // \"interfaces/capnp/messages.capnp:ChainNotifications.resendWalletTransactions$Results\"\n+    // This discards the part of the string before the first ':' character.\n+    // Another alternative would be to use the displayNamePrefixLength field,\n+    // but this discards everything before the last '.' character, throwing away\n+    // the object name, which is useful.\n+    const char* display_name = ::capnp::Schema::from<T>().getProto().getDisplayName().cStr();\n+    const char* short_name = strchr(display_name, ':');\n+    return short_name ? short_name + 1 : display_name;\n+}\n+\n+//! Format current thread name as \"{exe_name}-{$pid}/{thread_name}-{$tid}\".\n+std::string ThreadName(const char* exe_name);\n+\n+//! Analog to std::lock_guard\n+template <typename Mutex>\n+struct UnlockGuard\n+{\n+    UnlockGuard(Mutex& mutex) : m_mutex(mutex) { m_mutex.unlock(); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250514589",
      "id" : 250514589,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDUxNDU4OQ==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_line" : 297,
      "original_position" : 297,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/util.h",
      "position" : null,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250514589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250904863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250904863"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Are `arg1` and `arg2` guaranteed to be valid here? Could have been moved from on the call on the line before?",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2019-01-25T08:47:58Z",
      "diff_hunk" : "@@ -0,0 +1,1733 @@\n+#ifndef BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+#define BITCOIN_INTERFACES_CAPNP_PROXY_IMPL_H\n+\n+#include <interfaces/capnp/proxy.h>\n+\n+#include <interfaces/capnp/proxy.capnp.h>\n+#include <interfaces/capnp/util.h>\n+#include <interfaces/ipc.h>\n+#include <optional.h>\n+#include <serialize.h> // For CharCast\n+#include <util/system.h>\n+\n+#include <algorithm>\n+#include <boost/exception/diagnostic_information.hpp>\n+#include <boost/optional.hpp>\n+#include <capnp/capability.h>\n+#include <capnp/common.h>\n+#include <capnp/orphan.h>\n+#include <capnp/pretty-print.h>\n+#include <capnp/rpc-twoparty.h>\n+#include <capnp/schema.h>\n+#include <fstream>\n+#include <functional>\n+#include <future>\n+#include <iostream>\n+#include <kj/async-inl.h>\n+#include <kj/async-io.h>\n+#include <kj/async.h>\n+#include <kj/common.h>\n+#include <kj/debug.h>\n+#include <kj/exception.h>\n+#include <kj/memory.h>\n+#include <kj/string.h>\n+#include <list>\n+#include <memory>\n+#include <mutex>\n+#include <set>\n+#include <stdio.h>\n+#include <string>\n+#include <sys/types.h>\n+#include <thread>\n+#include <tuple>\n+#include <type_traits>\n+#include <unistd.h>\n+#include <utility>\n+\n+namespace interfaces {\n+namespace capnp {\n+\n+//! Invoke callable and save return value or exception state in promise.\n+template <typename T, typename Callable>\n+void SetPromise(std::promise<T>& promise, Callable&& callable)\n+{\n+    try {\n+        promise.set_value(callable());\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Invoke void callable and save exception state in promise.\n+template <typename Callable>\n+void SetPromise(std::promise<void>& promise, Callable&& callable)\n+{\n+    try {\n+        callable();\n+        promise.set_value();\n+    } catch (...) {\n+        promise.set_exception(std::current_exception());\n+    }\n+}\n+\n+//! Handler for kj::TaskSet failed task events.\n+class LoggingErrorHandler : public kj::TaskSet::ErrorHandler\n+{\n+public:\n+    LoggingErrorHandler(EventLoop& loop) : m_loop(loop) {}\n+    void taskFailed(kj::Exception&& exception) override;\n+    EventLoop& m_loop;\n+};\n+\n+struct Connection;\n+\n+//! Event loop implementation.\n+//!\n+//! Based on https://groups.google.com/d/msg/capnproto/TuQFF1eH2-M/g81sHaTAAQAJ\n+class EventLoop\n+{\n+public:\n+    //! Construct event loop object.\n+    EventLoop(const char* exe_name);\n+    ~EventLoop();\n+\n+    //! Run event loop. Does not return until shutdown. This should only be\n+    //! called once from the m_thread_id thread. This will block until\n+    //! m_shutdown is true and the m_num_clients reference count is 0.\n+    void loop();\n+\n+    //! Run function on event loop thread. Does not return until function completes.\n+    //! Must be called while the loop() function is active.\n+    void post(const std::function<void()>& fn);\n+\n+    //! Wrapper around EventLoop::post that takes advantage of the\n+    //! fact that callable will not go out of scope to avoid requirement that it\n+    //! be copyable.\n+    template <typename Callable>\n+    void sync(Callable&& callable)\n+    {\n+        return post(std::ref(callable));\n+    }\n+\n+    //! Run function asynchronously on worker thread. This is only used when\n+    //! there is a broken connection, leaving behind ProxyServerBase objects\n+    //! that need to be destroyed, in which case server ProxyServerBase::m_impl\n+    //! destructors don't have a dedicated thread to work and on shouldn't tie\n+    //! up the eventloop thread because it may need to do I/O on their behalf.\n+    void async(std::function<void()> fn);\n+\n+    //! Send shutdown signal to event loop. Returns immediately without waiting\n+    //! for shutdown.\n+    void shutdown();\n+\n+    //! Add/remove remote client reference counts.\n+    void addClient();\n+    void removeClient();\n+\n+    //! Requires m_mutex\n+    bool done() { return m_shutdown && m_async_fns.empty() && m_num_clients == 0; }\n+\n+    //! Process name included in thread names so combined debug output from\n+    //! multiple processes is easier to understand.\n+    const char* m_exe_name;\n+\n+    //! ID of the event loop thread\n+    std::thread::id m_thread_id = std::this_thread::get_id();\n+\n+    //! Handle of an async worker thread. Joined on destruction. Unset if async\n+    //! method has not been called.\n+    std::thread m_async_thread;\n+\n+    //! Callback function to run on event loop thread during post() or sync() call.\n+    const std::function<void()>* m_post_fn = nullptr;\n+\n+    //! Callback functions to run on async thread.\n+    std::list<std::function<void()>> m_async_fns;\n+\n+    //! Pipe read handle used to wake up the event loop thread.\n+    int m_wait_fd = -1;\n+\n+    //! Pipe write handle used to wake up the event loop thread.\n+    int m_post_fd = -1;\n+\n+    //! Whether shutdown method was called.\n+    bool m_shutdown = false;\n+\n+    //! Number of clients holding references to ProxyServerBase objects that\n+    //! reference this event loop.\n+    int m_num_clients = 0;\n+\n+    //! Mutex and condition variable used to post tasks to event loop and async\n+    //! thread.\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+\n+    //! Capnp IO context.\n+    kj::AsyncIoContext m_io_context;\n+\n+    //! Capnp error handler. Needs to outlive m_task_set.\n+    LoggingErrorHandler m_error_handler{*this};\n+\n+    //! Capnp list of pending promises.\n+    Optional<kj::TaskSet> m_task_set;\n+\n+    //! List of connections.\n+    std::list<Connection> m_connections;\n+};\n+\n+//! Single element task queue used to handle recursive capnp calls. (If server\n+//! makes an callback into the client in the middle of a request, while client\n+//! thread is blocked waiting for server response, this is what allows the\n+//! client to run the request in the same thread, the same way code would run in\n+//! single process, with the callback sharing same thread stack as the original\n+//! call.\n+struct Waiter\n+{\n+    Waiter() = default;\n+\n+    template <typename Fn>\n+    void post(Fn&& fn)\n+    {\n+        std::unique_lock<std::mutex> lock(m_mutex);\n+        assert(!m_fn);\n+        m_fn = std::move(fn);\n+        m_cv.notify_all();\n+    }\n+\n+    template <class Predicate>\n+    void wait(std::unique_lock<std::mutex>& lock, Predicate pred)\n+    {\n+        m_cv.wait(lock, [&] {\n+            // Important for this to be \"while (m_fn)\", not \"if (m_fn)\" to avoid\n+            // a lost-wakeup bug. A new m_fn and m_cv notification might be set\n+            // after then fn() call and before the lock.lock() call in this loop\n+            // in the case where a capnp response is sent and a brand new\n+            // request is immediately received.\n+            while (m_fn) {\n+                auto fn = std::move(m_fn);\n+                m_fn = nullptr;\n+                lock.unlock();\n+                fn();\n+                lock.lock();\n+            }\n+            bool done = pred();\n+            return done;\n+        });\n+    }\n+\n+    std::mutex m_mutex;\n+    std::condition_variable m_cv;\n+    std::function<void()> m_fn;\n+};\n+\n+struct ThreadContext;\n+\n+template <>\n+struct ProxyServer<Thread> final : public Thread::Server\n+{\n+public:\n+    ProxyServer(ThreadContext& thread_context, std::thread&& thread);\n+    ~ProxyServer();\n+    kj::Promise<void> getName(GetNameContext context) override;\n+    ThreadContext& m_thread_context;\n+    std::thread m_thread;\n+};\n+\n+struct Connection\n+{\n+    Connection(EventLoop& loop, int fd)\n+        : m_loop(loop),\n+          m_stream(loop.m_io_context.lowLevelProvider->wrapSocketFd(fd, kj::LowLevelAsyncIoProvider::TAKE_OWNERSHIP)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::CLIENT, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcClient(m_network))\n+    {\n+    }\n+    Connection(EventLoop& loop,\n+        kj::Own<kj::AsyncIoStream>&& stream_,\n+        std::function<::capnp::Capability::Client()> make_client)\n+        : m_loop(loop), m_stream(kj::mv(stream_)),\n+          m_network(*m_stream, ::capnp::rpc::twoparty::Side::SERVER, ::capnp::ReaderOptions()),\n+          m_rpc_system(::capnp::makeRpcServer(m_network, make_client()))\n+    {\n+    }\n+    ~Connection();\n+\n+    //! Register synchronous cleanup function to run on event loop thread (with\n+    //! access to capnp thread local variables) after shutdown is called.\n+    //! Cleanup functions will run with m_mutex locked right before event loop exits, so shouldn't block or schedule\n+    //! any new i/o.\n+    CleanupIt addCleanup(std::function<void()> fn);\n+    void removeCleanup(CleanupIt it);\n+\n+    EventLoop& m_loop;\n+    kj::Own<kj::AsyncIoStream> m_stream;\n+    ::capnp::TwoPartyVatNetwork m_network;\n+    ::capnp::RpcSystem<::capnp::rpc::twoparty::VatId> m_rpc_system;\n+\n+    // ThreadMap interface client, used to create a remote server thread when an\n+    // client IPC call is being made for the first time from a new thread.\n+    ::interfaces::capnp::ThreadMap::Client m_thread_map{nullptr};\n+\n+    //! Collection of server-side IPC worker threads (ProxyServer<Thread> objects previously returned by\n+    //! ThreadMap.makeThread) used to service requests to clients.\n+    ::capnp::CapabilityServerSet<Thread> m_threads;\n+\n+    //! Cleanup functions to run during event loop shutdown.\n+    std::list<std::function<void()>> m_cleanup_fns;\n+};\n+\n+struct ThreadContext\n+{\n+    //! Identifying string for debug.\n+    std::string thread_name;\n+\n+    //! Waiter object used allow client threads blocked waiting for a server\n+    //! response to execute callbacks made from the client's corresponding\n+    //! server thread.\n+    std::unique_ptr<Waiter> waiter = nullptr;\n+\n+    //! When client is making a request a to server, this is the\n+    //! `callbackThread` argument it passes in the request, used by the server\n+    //! in case it needs to make callbacks into the client that need to execute\n+    //! while the client is waiting. This will be set to a local thread object.\n+    std::map<Connection*, ProxyClient<Thread>> callback_threads;\n+\n+    //! When client is making a request to a server, this is the `thread`\n+    //! argument it passes in the request, used to control which thread on\n+    //! server will be responsible for executing it. If client call is being\n+    //! made from a local thread, this will be a remote thread object returned\n+    //! by makeThread. If a client call is being made from a thread currently\n+    //! handling a server request, this will be set to the `callbackThread`\n+    //! request thread argument passed in that request.\n+    std::map<Connection*, ProxyClient<Thread>> request_threads;\n+\n+    //! Whether this thread is a capnp event loop thread. Not really used except\n+    //! to assert false if there's an attempt to execute a blocking operation\n+    //! which could deadlock the thread.\n+    bool loop_thread = false;\n+};\n+\n+struct ClientInvokeContext : InvokeContext\n+{\n+    ThreadContext& thread_context;\n+    ClientInvokeContext(Connection& connection, ThreadContext& thread_context)\n+        : InvokeContext{connection}, thread_context{thread_context}\n+    {\n+    }\n+};\n+\n+template <>\n+struct ProxyClient<Thread> : public ProxyClientBase<Thread, Base>\n+{\n+    using ProxyClientBase::ProxyClientBase;\n+    // https://stackoverflow.com/questions/22357887/comparing-two-mapiterators-why-does-it-need-the-copy-constructor-of-stdpair\n+    ProxyClient(const ProxyClient&) = delete;\n+};\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    ClientInvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.init()), Context::Builder>::value>::type* enable = nullptr)\n+{\n+    auto& connection = invoke_context.connection;\n+    auto& thread_context = invoke_context.thread_context;\n+    auto& request_threads = thread_context.request_threads;\n+    auto& callback_threads = thread_context.callback_threads;\n+\n+    auto callback_thread = callback_threads.find(&connection);\n+    if (callback_thread == callback_threads.end()) {\n+        callback_thread = callback_threads\n+                           .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                               std::forward_as_tuple(connection.m_threads.add(\n+                                                         kj::heap<ProxyServer<Thread>>(thread_context, std::thread{})),\n+                                   connection))\n+                           .first;\n+    }\n+\n+    auto request_thread = request_threads.find(&connection);\n+    if (request_thread == request_threads.end()) {\n+        // This code will only run if IPC client call is being made for the\n+        // first time on a new thread. After the first call, subsequent calls\n+        // will use the existing request thread. This code will also never run at\n+        // all if the current thread is a request thread created for a different\n+        // IPC client, because in that case PassField code (below) will have set\n+        // request_thread to point to the calling thread.\n+        auto request = connection.m_thread_map.makeThreadRequest();\n+        request.setName(thread_context.thread_name);\n+        request_thread = request_threads\n+                            .emplace(std::piecewise_construct, std::forward_as_tuple(&connection),\n+                                std::forward_as_tuple(request.send().getResult(), connection))\n+                            .first; // Nonblocking due to capnp request pipelining.\n+    }\n+\n+    auto context = output.init();\n+    context.setThread(request_thread->second.m_client);\n+    context.setCallbackThread(callback_thread->second.m_client);\n+}\n+\n+extern thread_local ThreadContext g_thread_context;\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, const Args&... args) ->\n+    typename std::enable_if<\n+        std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), Context::Reader>::value,\n+        kj::Promise<typename ServerContext::CallContext>>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    Context::Reader context_arg = Accessor::get(params);\n+    auto future = kj::newPromiseAndFulfiller<typename ServerContext::CallContext>();\n+    auto& server = server_context.proxy_server;\n+    int req = server_context.req;\n+    auto invoke = MakeAsyncCallable(kj::mvCapture(future.fulfiller,\n+        kj::mvCapture(server_context.call_context,\n+            [&server, req, fn, args...](typename ServerContext::CallContext call_context,\n+                kj::Own<kj::PromiseFulfiller<typename ServerContext::CallContext>> fulfiller) {\n+                const auto& params = call_context.getParams();\n+                Context::Reader context_arg = Accessor::get(params);\n+                ServerContext server_context{server, call_context, req};\n+                {\n+                    auto& request_threads = g_thread_context.request_threads;\n+                    auto request_thread = request_threads.find(server.m_connection);\n+                    if (request_thread == request_threads.end()) {\n+                        request_thread =\n+                            g_thread_context.request_threads\n+                                .emplace(std::piecewise_construct, std::forward_as_tuple(server.m_connection),\n+                                    std::forward_as_tuple(context_arg.getCallbackThread(), *server.m_connection))\n+                                .first;\n+                    } else {\n+                        // If recursive call, avoid remove request_threads map\n+                        // entry in KJ_DEFER below.\n+                        request_thread = request_threads.end();\n+                    }\n+                    KJ_DEFER(if (request_thread != request_threads.end()) request_threads.erase(request_thread));\n+                    fn.invoke(server_context, args...);\n+                }\n+                KJ_IF_MAYBE(exception, kj::runCatchingExceptions([&]() {\n+                    server.m_connection->m_loop.sync([&] {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->fulfill(kj::mv(call_context));\n+                    });\n+                }))\n+                {\n+                    server.m_connection->m_loop.sync([&]() {\n+                        auto fulfiller_dispose = kj::mv(fulfiller);\n+                        fulfiller_dispose->reject(kj::mv(*exception));\n+                    });\n+                }\n+            })));\n+\n+    auto thread_client = context_arg.getThread();\n+    return JoinPromises(server.m_connection->m_threads.getLocalServer(thread_client)\n+                            .then([&server, invoke, req](kj::Maybe<Thread::Server&> perhaps) {\n+                                KJ_IF_MAYBE(thread_server, perhaps)\n+                                {\n+                                    const auto& thread = static_cast<ProxyServer<Thread>&>(*thread_server);\n+                                    LogIpc(server.m_connection->m_loop, \"IPC server post request  #%i {%s}\\n\", req,\n+                                        thread.m_thread_context.thread_name);\n+                                    thread.m_thread_context.waiter->post(std::move(invoke));\n+                                }\n+                                else\n+                                {\n+                                    LogIpc(server.m_connection->m_loop,\n+                                        \"IPC server error request #%i, missing thread to execute request\\n\", req);\n+                                    throw std::runtime_error(\"invalid thread handle\");\n+                                }\n+                            }),\n+        kj::mv(future.promise));\n+}\n+\n+class SyncDestroy\n+{\n+    virtual ~SyncDestroy() {}\n+};\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::ProxyClientBase(typename Interface::Client client, Connection& connection)\n+    : m_client(std::move(client)), m_connection(&connection)\n+{\n+    m_connection->m_loop.addClient();\n+    m_cleanup = m_connection->addCleanup([this]() {\n+        {\n+            typename Interface::Client(std::move(self().m_client));\n+        }\n+        m_connection->m_loop.removeClient();\n+        m_connection = nullptr;\n+    });\n+    self().construct();\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyClientBase<Interface, Impl>::~ProxyClientBase() noexcept\n+{\n+    // Two shutdown sequences are supported:\n+    //\n+    // - A normal sequence where client proxy objects are deleted by external\n+    //   code that no longer needs them\n+    //\n+    // - A garbage collection sequence where the connection or event loop shuts\n+    //   down while external code is still holding client references.\n+    //\n+    // The first case is handled here in destructor when m_loop is not null. The\n+    // second case is handled by the m_cleanup function, which sets m_loop to\n+    // null so nothing happens here.\n+    if (m_connection) {\n+        // Remove m_cleanup callback so it doesn't run and try to access\n+        // this object after it's already destroyed.\n+        m_connection->removeCleanup(m_cleanup);\n+\n+        // Destroy remote object, waiting for it to deleted server side.\n+        self().destroy();\n+\n+        m_connection->m_loop.sync([&]() {\n+            // Release client capability by move-assigning to temporary.\n+            {\n+                typename Interface::Client(std::move(self().m_client));\n+            }\n+            m_connection->m_loop.removeClient();\n+        });\n+    }\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::ProxyServerBase(Impl* impl, bool owned, EventLoop& loop, Connection* connection)\n+    : m_impl(impl), m_owned(owned), m_connection(connection)\n+{\n+    assert(impl != nullptr);\n+    AddClient(loop);\n+}\n+\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::ProxyServerBase(Impl* impl, bool owned, Connection& connection)\n+    : ProxyServerBase(impl, owned, connection.m_loop, &connection)\n+{\n+}\n+\n+template <typename Interface, typename Impl>\n+ProxyServerBase<Interface, Impl>::~ProxyServerBase()\n+{\n+    if (Impl* impl = m_impl) {\n+        // If impl is non-null, it means client was not destroyed\n+        // cleanly (was killed or disconnected). Since client isn't\n+        // providing thread to run destructor on, create a new thread.\n+        // Do not run destructor on current (event loop) thread since\n+        // destructors could be making IPC calls or doing expensive\n+        // cleanup.\n+        if (m_owned) {\n+            m_connection->addCleanup(MakeAsyncCallable(\n+                kj::mvCapture(std::thread{[impl]() { delete impl; }}, [](std::thread&& thread) { thread.join(); })));\n+        }\n+        m_impl = nullptr;\n+        m_owned = false;\n+    }\n+    RemoveClient(m_connection->m_loop);\n+}\n+\n+template <typename Interface, typename Impl>\n+void ProxyServerBase<Interface, Impl>::invokeDestroy()\n+{\n+    if (m_owned) delete m_impl;\n+    m_impl = nullptr;\n+    m_owned = false;\n+}\n+\n+\n+template <typename Value>\n+class Emplace\n+{\n+    Value& m_value;\n+\n+    template <typename T, typename... Params>\n+    static T& call(boost::optional<T>& value, Params&&... params)\n+    {\n+        value.emplace(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::vector<T>& value, Params&&... params)\n+    {\n+        value.emplace_back(std::forward<Params>(params)...);\n+        return value.back();\n+    }\n+\n+    template <typename T, typename... Params>\n+    static const T& call(std::set<T>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename K, typename V, typename... Params>\n+    static std::pair<const K, V>& call(std::map<K, V>& value, Params&&... params)\n+    {\n+        return *value.emplace(std::forward<Params>(params)...).first;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::shared_ptr<T>& value, Params&&... params)\n+    {\n+        value = std::make_shared<T>(std::forward<Params>(params)...);\n+        return *value;\n+    }\n+\n+    template <typename T, typename... Params>\n+    static T& call(std::reference_wrapper<T>& value, Params&&... params)\n+    {\n+        value.get().~T();\n+        new (&value.get()) T(std::forward<Params>(params)...);\n+        return value.get();\n+    }\n+\n+public:\n+    static constexpr bool emplace = true;\n+\n+    Emplace(Value& value) : m_value(value) {}\n+\n+    // Needs to be declared after m_value for compiler to understand declaration.\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(Emplace::call(this->m_value, std::forward<Params>(params)...))\n+};\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<boost::optional<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, input, *value);\n+    } else {\n+        ReadField(TypeList<LocalType>(), invoke_context, input, Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<LocalType*>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    if (value) {\n+        ReadFieldUpdate(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), *value);\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::shared_ptr<const LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    if (!input.has()) {\n+        value.reset();\n+        return;\n+    }\n+    ReadField(TypeList<LocalType>(), invoke_context, std::forward<Input>(input), Emplace<DestValue>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::vector<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    value.reserve(data.size());\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename LocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::set<LocalType>>, InvokeContext& invoke_context, Input&& input, DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<LocalType>(), invoke_context, Make<ValueField>(item), Emplace<DestValue>(value));\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename DestValue>\n+void ReadFieldUpdate(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    DestValue&& value)\n+{\n+    auto data = input.get();\n+    value.clear();\n+    for (auto item : data) {\n+        ReadField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), invoke_context, Make<ValueField>(item),\n+            Emplace<DestValue>(value));\n+    }\n+}\n+\n+// FIXME: Misnamed. Really just forward_as_tuple function object.\n+template <typename Fn>\n+struct TupleEmplace\n+{\n+    static constexpr bool emplace = true;\n+    Fn& m_fn;\n+    template <typename... Params>\n+    auto operator()(Params&&... params) -> AUTO_RETURN(this->m_fn(std::forward_as_tuple(params...)))\n+};\n+\n+template <typename Fn>\n+TupleEmplace<Fn> MakeTupleEmplace(Fn&& fn)\n+{\n+    return {fn};\n+}\n+\n+template <typename Exception>\n+struct ThrowEmplace\n+{\n+    static constexpr bool emplace = true;\n+\n+    template <typename... Params>\n+    void operator()(Params&&... params)\n+    {\n+        throw Exception(std::forward<Params>(params)...);\n+    }\n+};\n+\n+template <>\n+struct ThrowEmplace<std::exception> : ThrowEmplace<std::runtime_error>\n+{\n+};\n+\n+// Emplace function that when called with tuple of key constructor arguments\n+// reads value from pair and calls piecewise construct.\n+template <typename ValueLocalType, typename Input, typename Emplace>\n+struct PairValueEmplace\n+{\n+    InvokeContext& m_context;\n+    Input& m_input;\n+    Emplace& m_emplace;\n+    template <typename KeyTuple>\n+\n+    // FIXME Should really return reference to emplaced key object.\n+    void operator()(KeyTuple&& key_tuple)\n+    {\n+        const auto& pair = m_input.get();\n+        using ValueAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::ValueAccessor;\n+        ReadField(TypeList<ValueLocalType>(), m_context, Make<StructField, ValueAccessor>(pair),\n+            MakeTupleEmplace(Make<Compose>(Get<1>(), Bind(m_emplace, std::piecewise_construct, key_tuple))));\n+    }\n+};\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    /* This could be simplified a lot with c++14 generic lambdas. All it is doing is:\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<ValueField>(input.get().getKey()), [&](auto&&... key_args)\n+    { ReadField(TypeList<ValueLocalType>(), invoke_context, Make<ValueField>(input.get().getValue()), [&](auto&&...\n+    value_args)\n+    {\n+            emplace(std::piecewise_construct, std::forward_as_tuple(key_args...),\n+    std::forward_as_tuple(value_args...));\n+        })\n+    });\n+    */\n+    const auto& pair = input.get();\n+    using KeyAccessor = typename ProxyStruct<typename Decay<decltype(pair)>::Reads>::KeyAccessor;\n+    ReadField(TypeList<KeyLocalType>(), invoke_context, Make<StructField, KeyAccessor>(pair),\n+        MakeTupleEmplace(PairValueEmplace<ValueLocalType, Input, Emplace>{invoke_context, input, emplace}));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Input, typename Tuple>\n+void ReadFieldUpdate(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Tuple&& tuple)\n+{\n+    const auto& pair = input.get();\n+    using Struct = ProxyStruct<typename Decay<decltype(pair)>::Reads>;\n+    ReadFieldUpdate(TypeList<KeyLocalType>(), invoke_context, Make<StructField, typename Struct::KeyAccessor>(pair),\n+        std::get<0>(tuple));\n+    ReadFieldUpdate(TypeList<ValueLocalType>(), invoke_context,\n+        Make<StructField, typename Struct::ValueAccessor>(pair), std::get<1>(tuple));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_enum<LocalType>::value>::type* enable = 0)\n+{\n+    emplace(static_cast<LocalType>(input.get()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_integral<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    if (value < std::numeric_limits<LocalType>::min() || value > std::numeric_limits<LocalType>::max()) {\n+        throw std::range_error(\"out of bound int received\");\n+    }\n+    emplace(static_cast<LocalType>(value));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<std::is_floating_point<LocalType>::value>::type* enable = 0)\n+{\n+    auto value = input.get();\n+    static_assert(std::is_same<LocalType, decltype(value)>::value, \"floating point type mismatch\");\n+    emplace(value);\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::string>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(CharCast(data.begin()), data.size());\n+}\n+\n+template <typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::exception>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    auto data = input.get();\n+    emplace(std::string(CharCast(data.begin()), data.size()));\n+}\n+\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::unique_ptr<LocalType>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename Decay<decltype(input.get())>::Calls* enable = nullptr)\n+{\n+    using Interface = typename Decay<decltype(input.get())>::Calls;\n+    if (input.has()) {\n+        emplace(MakeUnique<ProxyClient<Interface>>(std::move(input.get()), invoke_context.connection));\n+    }\n+}\n+\n+// Callback class is needed because c++11 doesn't support auto lambda parameters.\n+// It's equivalent c++14: [invoke_context](auto&& params) {\n+// invoke_context->call(std::forward<decltype(params)>(params)...)\n+template <typename InvokeContext>\n+struct Callback\n+{\n+    InvokeContext m_proxy;\n+\n+    template <typename... CallParams>\n+    auto operator()(CallParams&&... params) -> AUTO_RETURN(this->m_proxy->call(std::forward<CallParams>(params)...))\n+};\n+\n+template <typename FnR, typename... FnParams, typename Input, typename Emplace>\n+void ReadFieldNew(TypeList<std::function<FnR(FnParams...)>>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace)\n+{\n+    if (input.has()) {\n+        using Interface = typename Decay<decltype(input.get())>::Calls;\n+        auto client = std::make_shared<ProxyClient<Interface>>(input.get(), invoke_context.connection);\n+        emplace(Callback<decltype(client)>{std::move(client)});\n+    }\n+};\n+\n+template <typename Value>\n+struct RefEmplace\n+{\n+    RefEmplace(Value& value) : m_value(value) {}\n+\n+    template <typename... Params>\n+    Value& operator()(Params&&... params)\n+    {\n+        return m_value = Value(std::forward<Params>(params)...);\n+    }\n+    Value& m_value;\n+};\n+\n+template <typename Param, typename Enable = void>\n+struct IsEmplace : std::false_type\n+{\n+};\n+\n+template <typename Param>\n+struct IsEmplace<Param, typename std::enable_if<Param::emplace>::type> : public std::true_type\n+{\n+};\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    decltype(ReadFieldNew(TypeList<Decay<LocalType>>(),\n+        invoke_context,\n+        std::forward<Input>(input),\n+        std::declval<Emplace<decltype(std::ref(value))>>()))* enable = nullptr)\n+{\n+    auto ref = std::ref(value);\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, Emplace<decltype(ref)>(ref));\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename std::enable_if<index != ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    const auto& struc = input.get();\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    ReadFieldUpdate(\n+        TypeList<Decay<decltype(field_value)>>(), invoke_context, Make<StructField, Accessor>(struc), field_value);\n+    ReadOne<index + 1>(param, invoke_context, input, value);\n+}\n+\n+template <size_t index, typename LocalType, typename Input, typename Value>\n+void ReadOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input& input,\n+    Value& value,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Input, typename Value>\n+void ReadFieldUpdate(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Value&& value,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    ReadOne<0>(param, invoke_context, input, value);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is available.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    decltype(\n+        ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace)))* enable =\n+        nullptr)\n+{\n+    ReadFieldNew(TypeList<Decay<LocalType>>(), invoke_context, input, std::forward<Emplace>(emplace));\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates non-const object.\n+// Call emplace first to create empty value, then ReadFieldUpdate into the new object.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    Emplace&& emplace,\n+    typename std::enable_if<!std::is_void<decltype(emplace())>::value &&\n+                            !std::is_const<typename std::remove_reference<decltype(emplace())>::type>::value>::type*\n+        enable = nullptr)\n+{\n+    auto&& ref = emplace();\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, ref);\n+}\n+\n+// ReadField calling Emplace when ReadFieldNew is not available, and emplace creates const object.\n+// Initialize temporary with ReadFieldUpdate then std::move into emplace.\n+template <typename LocalType, typename Input, typename Emplace>\n+void ReadFieldImpl(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Input&& input, Emplace&& emplace)\n+{\n+    Decay<LocalType> temp;\n+    ReadFieldUpdate(TypeList<Decay<LocalType>>(), invoke_context, input, temp);\n+    emplace(std::move(temp));\n+}\n+\n+template <typename LocalTypes, typename Input, typename... Values>\n+void ReadField(LocalTypes, InvokeContext& invoke_context, Input&& input, Values&&... values)\n+{\n+    ReadFieldImpl(LocalTypes(), Priority<2>(), invoke_context, input, std::forward<Values>(values)...);\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<1>, InvokeContext& invoke_context, ::capnp::Void, Output&& output)\n+{\n+}\n+\n+template <typename Value, typename Output>\n+void BuildField(TypeList<std::string>, Priority<1>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    auto result = output.init(value.size());\n+    memcpy(result.begin(), value.data(), value.size());\n+}\n+\n+//! Adapter to convert ProxyCallback object call to function object call.\n+template <typename Result, typename... Args>\n+class ProxyCallbackImpl : public ProxyCallback<std::function<Result(Args...)>>\n+{\n+    using Fn = std::function<Result(Args...)>;\n+    Fn m_fn;\n+\n+public:\n+    ProxyCallbackImpl(Fn fn) : m_fn(std::move(fn)) {}\n+    Result call(Args&&... args) override { return m_fn(std::forward<Args>(args)...); }\n+};\n+\n+template <typename Value, typename FnR, typename... FnParams, typename Output>\n+void BuildField(TypeList<std::function<FnR(FnParams...)>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        using Callback = ProxyCallbackImpl<FnR, FnParams...>;\n+        output.set(kj::heap<ProxyServer<Interface>>(\n+            new Callback(std::forward<Value>(value)), true /* owned */, invoke_context.connection));\n+    }\n+}\n+\n+template <typename Impl, typename Value, typename Output>\n+void BuildField(TypeList<std::unique_ptr<Impl>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename Decay<decltype(output.get())>::Calls* enable = nullptr)\n+{\n+    if (value) {\n+        using Interface = typename decltype(output.get())::Calls;\n+        output.set(kj::heap<ProxyServer<Interface>>(value.release(), true /* owned */, invoke_context.connection));\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType*>, Priority<3>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        // FIXME std::move probably wrong\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(*value), output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::shared_ptr<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::vector<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dedup with set handler below\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::move(elem),\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::set<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::map<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    // FIXME dededup with vector handler above\n+    auto list = output.init(value.size());\n+    size_t i = 0;\n+    for (const auto& elem : value) {\n+        BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>(), BuildFieldPriority(), invoke_context, elem,\n+            ListOutput<typename decltype(list)::Builds>(list, i));\n+        ++i;\n+    }\n+}\n+template <typename Value>\n+::capnp::Void BuildPrimitive(InvokeContext& invoke_context, Value&&, TypeList<::capnp::Void>)\n+{\n+    return {};\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_enum<Value>::value>::type* enable = nullptr)\n+{\n+    return static_cast<LocalType>(value);\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_integral<Value>::value, int>::type* enable = nullptr)\n+{\n+    static_assert(\n+        std::numeric_limits<LocalType>::lowest() <= std::numeric_limits<Value>::lowest(), \"mismatched integral types\");\n+    static_assert(\n+        std::numeric_limits<LocalType>::max() >= std::numeric_limits<Value>::max(), \"mismatched integral types\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Value>\n+LocalType BuildPrimitive(InvokeContext& invoke_context,\n+    const Value& value,\n+    TypeList<LocalType>,\n+    typename std::enable_if<std::is_floating_point<Value>::value>::type* enable = nullptr)\n+{\n+    static_assert(std::is_same<Value, LocalType>::value,\n+        \"mismatched floating point types. please fix message.capnp type declaration to match wrapped interface\");\n+    return value;\n+}\n+\n+template <typename LocalType, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    LocalType&& value,\n+    Output&& output,\n+    typename decltype(output.get())::Calls* enable = nullptr)\n+{\n+    // Set owned to false so proxy object doesn't attempt to delete interface\n+    // reference when it is discarded remotely, or on disconnect.\n+    output.set(kj::heap<ProxyServer<typename decltype(output.get())::Calls>>(\n+        &value, false /* owned */, invoke_context.connection));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<boost::optional<LocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    if (value) {\n+        output.setHas();\n+        // FIXME: should std::move value if destvalue is rref?\n+        BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, *value, output);\n+    }\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<std::exception>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    const std::exception& value,\n+    Output&& output)\n+{\n+    BuildField(TypeList<std::string>(), BuildFieldPriority(), invoke_context, std::string(value.what()), output);\n+}\n+\n+// FIXME: Overload on output type instead of value type and switch to std::get and merge with next overload\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::pair<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, value.first,\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, value.second,\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename KeyLocalType, typename ValueLocalType, typename Value, typename Output>\n+void BuildField(TypeList<std::tuple<KeyLocalType, ValueLocalType>>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output)\n+{\n+    auto pair = output.init();\n+    using KeyAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::KeyAccessor;\n+    using ValueAccessor = typename ProxyStruct<typename decltype(pair)::Builds>::ValueAccessor;\n+    BuildField(TypeList<KeyLocalType>(), BuildFieldPriority(), invoke_context, std::get<0>(value),\n+        Make<StructField, KeyAccessor>(pair));\n+    BuildField(TypeList<ValueLocalType>(), BuildFieldPriority(), invoke_context, std::get<1>(value),\n+        Make<StructField, ValueAccessor>(pair));\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<const LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&>,\n+    Priority<0>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    void* enable = nullptr)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType&&>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    BuildField(TypeList<LocalType>(), BuildFieldPriority(), invoke_context, std::forward<Value>(value), output);\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType>, Priority<0>, InvokeContext& invoke_context, Value&& value, Output&& output)\n+{\n+    output.set(BuildPrimitive(invoke_context, std::forward<Value>(value), TypeList<decltype(output.get())>()));\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename std::enable_if < index<ProxyType<LocalType>::fields>::type * enable = nullptr)\n+{\n+    using Index = std::integral_constant<size_t, index>;\n+    using Struct = typename ProxyType<LocalType>::Struct;\n+    using Accessor = typename std::tuple_element<index, typename ProxyStruct<Struct>::Accessors>::type;\n+    auto&& field_output = Make<StructField, Accessor>(output);\n+    auto&& field_value = value.*ProxyType<LocalType>::get(Index());\n+    BuildField(TypeList<decltype(field_value)>(), BuildFieldPriority(), invoke_context, field_value, field_output);\n+    BuildOne<index + 1>(param, invoke_context, value, output);\n+}\n+\n+template <size_t index, typename LocalType, typename Value, typename Output>\n+void BuildOne(TypeList<LocalType> param,\n+    InvokeContext& invoke_context,\n+    Value& value,\n+    Output& output,\n+    typename std::enable_if<index == ProxyType<LocalType>::fields>::type* enable = nullptr)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void BuildField(TypeList<LocalType> local_type,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Value&& value,\n+    Output&& output,\n+    typename ProxyType<LocalType>::Struct* enable = nullptr)\n+{\n+    BuildOne<0>(local_type, invoke_context, value, output.init());\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void PassField(TypeList<LocalType*>, ServerContext& server_context, const Fn& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    bool want = input.want();\n+    if (want) {\n+        MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context, input,\n+            Emplace<decltype(param)>(param));\n+        if (!param) param.emplace();\n+    }\n+    fn.invoke(server_context, std::forward<Args>(args)..., param ? &*param : nullptr);\n+    auto&& results = server_context.call_context.getResults();\n+    if (want) {\n+        MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+            invoke_context, *param, Make<StructField, Accessor>(results));\n+    }\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<LocalType&>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> Require<typename decltype(Accessor::get(server_context.call_context.getParams()))::Calls>\n+{\n+    // Just drop argument if it is a reference to an interface client, because\n+    // it would be unclear when the the client should be released. Server will\n+    // need to provide a custom invokeMethod overload in order to access the\n+    // client, and can arrange for it to be disposed at the appropriate time.\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+}\n+\n+template <typename... Args>\n+void MaybeBuildField(std::true_type, Args&&... args)\n+{\n+    BuildField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeBuildField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadField(std::true_type, Args&&... args)\n+{\n+    ReadField(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadField(std::false_type, Args&&...)\n+{\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::true_type, Args&&... args)\n+{\n+    ReadFieldUpdate(std::forward<Args>(args)...);\n+}\n+template <typename... Args>\n+void MaybeReadFieldUpdate(std::false_type, Args&&...)\n+{\n+}\n+\n+template <typename LocalType, typename Value, typename Output>\n+void MaybeSetWant(TypeList<LocalType*>, Priority<1>, Value&& value, Output&& output)\n+{\n+    if (value) {\n+        output.setWant();\n+    }\n+}\n+\n+template <typename LocalTypes, typename... Args>\n+void MaybeSetWant(LocalTypes, Priority<0>, Args&&...)\n+{\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+void DefaultPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+{\n+    InvokeContext& invoke_context = server_context;\n+    boost::optional<Decay<LocalType>> param;\n+    const auto& params = server_context.call_context.getParams();\n+    MaybeReadField(std::integral_constant<bool, Accessor::in>(), TypeList<LocalType>(), invoke_context,\n+        Make<StructField, Accessor>(params), Emplace<decltype(param)>(param));\n+    if (!param) param.emplace();\n+    fn.invoke(server_context, std::forward<Args>(args)..., static_cast<LocalType&&>(*param));\n+    auto&& results = server_context.call_context.getResults();\n+    MaybeBuildField(std::integral_constant<bool, Accessor::out>(), TypeList<LocalType>(), BuildFieldPriority(),\n+        invoke_context, *param, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Output>\n+void BuildField(TypeList<>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Output&& output,\n+    typename std::enable_if<std::is_same<decltype(output.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    output.set(kj::heap<ProxyServer<ThreadMap>>(invoke_context.connection));\n+}\n+\n+template <typename Input>\n+void ReadFieldUpdate(TypeList<>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    typename std::enable_if<std::is_same<decltype(input.get()), ThreadMap::Client>::value>::type* enable = nullptr)\n+{\n+    invoke_context.connection.m_thread_map = input.get();\n+}\n+\n+template <typename Accessor, typename ServerContext, typename Fn, typename... Args>\n+auto PassField(TypeList<>, ServerContext& server_context, const Fn& fn, Args&&... args) -> typename std::enable_if<\n+    std::is_same<decltype(Accessor::get(server_context.call_context.getParams())), ThreadMap::Client>::value>::type\n+{\n+    const auto& params = server_context.call_context.getParams();\n+    const auto& input = Make<StructField, Accessor>(params);\n+    ReadFieldUpdate(TypeList<>(), server_context, input);\n+    fn.invoke(server_context, std::forward<Args>(args)...);\n+    auto&& results = server_context.call_context.getResults();\n+    BuildField(TypeList<>(), BuildFieldPriority(), server_context, Make<StructField, Accessor>(results));\n+}\n+\n+template <typename Derived, size_t N = 0>\n+struct IterateFieldsHelper\n+{\n+    template <typename Arg1, typename Arg2, typename ParamList, typename NextFn, typename... NextFnArgs>\n+    void handleChain(Arg1&& arg1, Arg2&& arg2, ParamList, NextFn&& next_fn, NextFnArgs&&... next_fn_args)\n+    {\n+        using S = Split<N, ParamList>;\n+        handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::First());\n+        next_fn.handleChain(std::forward<Arg1>(arg1), std::forward<Arg2>(arg2), typename S::Second(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r250904863",
      "id" : 250904863,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI1MDkwNDg2Mw==",
      "original_commit_id" : "c5bc654324670631d32e530c4cf1dbf9af58841a",
      "original_line" : 1388,
      "original_position" : 1405,
      "original_start_line" : null,
      "path" : "src/interfaces/capnp/proxy-impl.h",
      "position" : null,
      "pull_request_review_id" : 195914245,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/250904863",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "codegen seems broken for me: (gcc 7.4.0). I get random errors of these kind:\r\n\r\nerr1\r\n```\r\n  CXX      wallet/libbitcoin_wallet_tool_a-wallettool.o\r\n  GEN      interfaces/capnp/test/foo.capnp.c++\r\n*** Uncaught exception ***\r\nkj/filesystem.c++:315: failed: expected parts.size() > 0; can't use \"..\" to break out of starting directory\r\nstack: 7ffbcf3c71a0 7ffbcf3c9829 4098e3 7ffbcf55904d 7ffbcf559082 7ffbcf53208f 7ffbcf534296 7ffbcf5510a4 7ffbcf558893 7ffbcf558901 7ffbcf558c57 7ffbcf532974 7ffbcf532724 7ffbcf533921 7ffbcf5399fc 7ffbcf542aa5 7ffbcf5436d6 7ffbcf555452 7ffbcf55662a 7ffbcf55679f 7ffbcf55a606 7ffbcf55aa53 412466 412770 7ffbcf3e4c28 7ffbcf3e5d1a\r\nmake[2]: *** [Makefile:17337: interfaces/capnp/test/foo.capnp.c++] Error 1\r\nmake[2]: *** Waiting for unfinished jobs....\r\nGenerated test/data/base58_encode_decode.json.h\r\nGenerated test/data/key_io_invalid.json.h\r\nGenerated test/data/blockfilters.json.h\r\nGenerated test/data/key_io_valid.json.h\r\nIn file included from interfaces/capnp/config_bitcoin-node.cpp:1:0:\r\n./interfaces/capnp/config.h:4:10: fatal error: interfaces/capnp/node.capnp.h: No such file or directory\r\n #include <interfaces/capnp/node.capnp.h>\r\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ncompilation terminated.\r\nmake[2]: *** [Makefile:12585: interfaces/capnp/bitcoin_node-config_bitcoin-node.o] Error 1\r\nIn file included from interfaces/capnp/config_bitcoin-wallet.cpp:1:0:\r\n./interfaces/capnp/config.h:4:10: fatal error: interfaces/capnp/node.capnp.h: No such file or directory\r\n #include <interfaces/capnp/node.capnp.h>\r\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\nerr 2\r\n\r\n```\r\n  CXX      interfaces/capnp/proxy_codegen-proxy-codegen.o\r\nIn file included from /nix/store/69fkv7ql25r8j496bbchnsvbp42izv8q-capnproto-0.7.0/include/capnp/blob.h:28:0,\r\n                 from interfaces/capnp/proxy-codegen.cpp:4:\r\n/nix/store/69fkv7ql25r8j496bbchnsvbp42izv8q-capnproto-0.7.0/include/kj/common.h:36:4: error: #error \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n   #error \"This code requires C++14. Either your compiler does not support it or it is not enabled.\"\r\n    ^~~~~\r\n/nix/store/69fkv7ql25r8j496bbchnsvbp42izv8q-capnproto-0.7.0/include/kj/common.h:39:6: error: #error \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n     #error \"Pass -std=c++14 on the compiler command line to enable C++14.\"\r\n      ^~~~~\r\ninterfaces/capnp/proxy-codegen.cpp:10:10: fatal error: interfaces/capnp/proxy.capnp.h: No such file or directory\r\n #include <interfaces/capnp/proxy.capnp.h>\r\n          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\n",
      "created_at" : "2019-05-26T01:09:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-495959606",
      "id" : 495959606,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5NTk1OTYwNg==",
      "updated_at" : "2019-05-26T01:09:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/495959606",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/45598?v=4",
         "events_url" : "https://api.github.com/users/jb55/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jb55/followers",
         "following_url" : "https://api.github.com/users/jb55/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jb55/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jb55",
         "id" : 45598,
         "login" : "jb55",
         "node_id" : "MDQ6VXNlcjQ1NTk4",
         "organizations_url" : "https://api.github.com/users/jb55/orgs",
         "received_events_url" : "https://api.github.com/users/jb55/received_events",
         "repos_url" : "https://api.github.com/users/jb55/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jb55/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jb55/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jb55"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-495959606\r\n\r\n@jb55 this looks like it's caused by changes between capnproto 0.7.0 and 0.6.1: https://github.com/capnproto/capnproto/issues/772. I don't think it should be too be hard to add compatibility with 0.7.0, but I haven't tried it yet myself.",
      "created_at" : "2019-05-27T07:41:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-496113026",
      "id" : 496113026,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5NjExMzAyNg==",
      "updated_at" : "2019-05-27T07:41:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/496113026",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-495959606\r\n\r\n@jb55 Will try to update this PR shortly, but I posted build fixes for capnp 0.7.0 in 792963e32ceb081971935cf1aa10f88f9d3f3a1a ([ipc-work.276](https://github.com/ryanofsky/bitcoin/commits/ipc-work.276))",
      "created_at" : "2019-05-28T14:15:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-496535417",
      "id" : 496535417,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ5NjUzNTQxNw==",
      "updated_at" : "2019-05-28T14:15:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/496535417",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "concept ACK ",
      "created_at" : "2020-01-10T21:30:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-573213164",
      "id" : 573213164,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MzIxMzE2NA==",
      "updated_at" : "2020-01-10T21:30:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/573213164",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/494411?v=4",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "node_id" : "MDQ6VXNlcjQ5NDQxMQ==",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Very strong concept ACK!\r\n\r\nHas this PR reached a level where it could be assigned a milestone? :)",
      "created_at" : "2020-01-12T09:39:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-573397932",
      "id" : 573397932,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU3MzM5NzkzMg==",
      "updated_at" : "2020-01-12T09:39:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/573397932",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Can you clarify if the stuff in `src/interfaces/capnp/*.{h,cpp}` is automatically generated or manual? If automatic, I would prefer to leave it out of the repo and have `make` produce them. Other than those files, I like how this PR is looking a lot leaner than it used to. The first 5 non-base commits can be separate PRs, leaving only 3.\r\n\r\nSeparating libmultiprocess into its own project also seems like a good call, even though it's quite small. I think we can kick any bike shedding about capnproto alternatives down the road while this feature is optional and marked experimental.",
      "created_at" : "2020-02-28T13:27:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-592511915",
      "id" : 592511915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5MjUxMTkxNQ==",
      "updated_at" : "2020-02-28T14:44:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/592511915",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Can you clarify if the stuff in `src/interfaces/capnp/*.{h,cpp}` is automatically generated or manual?\r\n\r\nThis is manual code, but it needs to be better documented and have boilerplate removed. It's all dealing with lifetime and serialization issues for specific classes and structs that were difficult to share between processes for one reason or another. There's a lot of boilerplate because I just dealt with corner cases individually as they came up, and refactoring should make it smaller.\r\n\r\nThe code in `src/interfaces/capnp/*.{h,cpp}` is the least stable part of this PR, but it isn't really where the core functionality is implemented. That's more in the `src/interfaces/*.{h,cpp}`, particularly in the new `Init`, `LocalInit`, `IpcProcess`, and `IpcProtocol` classes",
      "created_at" : "2020-03-02T19:08:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-593566300",
      "id" : 593566300,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5MzU2NjMwMA==",
      "updated_at" : "2020-03-02T19:08:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593566300",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2020-03-05T09:35:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595125863",
      "id" : 595125863,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NTEyNTg2Mw==",
      "updated_at" : "2020-03-05T09:35:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595125863",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Testing on Linux Mint 19.3:\r\n\r\nan attempt to shutdown `bitcoin-node` using `Ctrl+C` causes an error:\r\n```\r\n$ ./src/bitcoin-node -testnet\r\n...\r\n2020-03-05T11:21:53Z [init] Shutdown: In progress...\r\n2020-03-05T11:21:53Z [addcon] addcon thread exit\r\nterminate called after throwing an instance of 'std::logic_error'\r\n  what():  clientInvoke call made after disconnect\r\nAborted (core dumped)\r\n```\r\n\r\nNo such error during `bitcoin-gui` shutdown.",
      "created_at" : "2020-03-05T11:26:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595180635",
      "id" : 595180635,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NTE4MDYzNQ==",
      "updated_at" : "2020-03-05T11:26:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595180635",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595180635\r\n\r\n> Testing on Linux Mint 19.3:\r\n> \r\n> an attempt to shutdown `bitcoin-node` using `Ctrl+C` causes an error:\r\n\r\nI can add a \"Known Issues\" section to the [doc](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/doc/multiprocess.md) and mention this. This PR isn't adding signal handlers to spawned `bitcoin-node` and `bitcoin-wallet` processes so ctrl-c can kill them immediately and trigger sudden disconnects and IPC errors. I think adding simple signal handlers would be a good thing to do in a followup PR, and also in general recovering from sudden IPC disconnects is something that should be improved later.\r\n\r\nIn the meantime clean shutdowns with `bitcoin-cli stop` should work here if new code is working properly\r\n\r\n---\r\n\r\nRebased 20ee129209ccf9f6e84893fe27a4dee99e7b5d5c -> 8c7f94f9dbc9c257afd7986068f0eeca7ee038a1 ([pr/ipc.87](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.87) -> [pr/ipc.88](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.88)) on ipc-build.8\r\nRebased 8c7f94f9dbc9c257afd7986068f0eeca7ee038a1 -> 805addc1c2d06131c19675ceb342b7a91ddfebaa ([pr/ipc.88](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.88) -> [pr/ipc.89](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.89)) on ipc-build.9 with unique_ptr build fixes\r\nRebased 805addc1c2d06131c19675ceb342b7a91ddfebaa -> 406278a8b8e68b79e3366629a52acb87ee671500 ([pr/ipc.89](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.89) -> [pr/ipc.90](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.90)) on ipc-build.10 with chain wallet include fix\r\nUpdated 406278a8b8e68b79e3366629a52acb87ee671500 -> 908619d8b1f3490a06b3248bc0acd847818f24ed ([pr/ipc.90](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.90) -> [pr/ipc.91](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.91), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.90..pr/ipc.91)) with make distdir fix\r\nUpdated 908619d8b1f3490a06b3248bc0acd847818f24ed -> 665348c7c54c934e247e18bfcf0f5b5435cc11d3 ([pr/ipc.91](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.91) -> [pr/ipc.92](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.92), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.91..pr/ipc.92)) with disable wallet compile fix\r\nUpdated 665348c7c54c934e247e18bfcf0f5b5435cc11d3 -> adbf158a4c02d0dd8f488feae343c39f83e85383 ([pr/ipc.92](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.92) -> [pr/ipc.93](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.93), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.92..pr/ipc.93)) with another disable wallet fix\r\nRebased adbf158a4c02d0dd8f488feae343c39f83e85383 -> 51c895d0169fc4c18a662b8cfc2b7526b2211d29 ([pr/ipc.93](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.93) -> [pr/ipc.94](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.94)) on ipc-build.11\r\nUpdated 51c895d0169fc4c18a662b8cfc2b7526b2211d29 -> b6066d2b491fb32563b9b69a82f4736b68df9cc7 ([pr/ipc.94](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.94) -> [pr/ipc.95](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.95), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.94..pr/ipc.95)) with travis/appveyor build fixes\r\nRebased b6066d2b491fb32563b9b69a82f4736b68df9cc7 -> d22e3f28d58f2ffd6df1eeaad4625eac673b7b0b ([`pr/ipc.95`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.95) -> [`pr/ipc.96`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.96)) on pr/ipc-build.12 splitting commits and fixing various rebase conflicts\r\nSquashed d22e3f28d58f2ffd6df1eeaad4625eac673b7b0b -> 4a0f0fd6a1a3d38cf5115d21ff0242964f0bba09 ([`pr/ipc.96`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.96) -> [`pr/ipc.97`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.97), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.96...pr/ipc.97)) fixing commit order\r\nRebased 4a0f0fd6a1a3d38cf5115d21ff0242964f0bba09 -> bdd677c32ff38987fa71ae848b6565637c97550d ([`pr/ipc.97`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.97) -> [`pr/ipc.98`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.98)) due to conflict with #16963\r\nRebased bdd677c32ff38987fa71ae848b6565637c97550d -> 2017cca9cff0b0c5bb7a59921ec7b5aece63ac8c ([`pr/ipc.98`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.98) -> [`pr/ipc.99`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.99)) with travis/appveyor fixes on top of pr/ipc-count.1, pr/ipc-txup.1\r\nRebased 2017cca9cff0b0c5bb7a59921ec7b5aece63ac8c -> 004a611351a2a5bf81a4cfb706d0458576a54dc7 ([`pr/ipc.99`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.99) -> [`pr/ipc.100`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.100)) fixing minor conflicts\r\nRebased 004a611351a2a5bf81a4cfb706d0458576a54dc7 -> 7dd8e269cc5ebb479f63aedea0c9994e89671a60 ([`pr/ipc.100`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.100) -> [`pr/ipc.101`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.101), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.100-rebase..pr/ipc.101)) due to conflicts in base prs\r\nUpdated 7dd8e269cc5ebb479f63aedea0c9994e89671a60 -> 8f7b2b772d2a8941b34b54c5e3c345309eed83de ([`pr/ipc.101`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.101) -> [`pr/ipc.102`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.102), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.101..pr/ipc.102)) on ipc-build.16, also lowercasing walletnotifications and adding boost::optional read/build overloads after they are removed from libmultiprocess\r\nRebased 8f7b2b772d2a8941b34b54c5e3c345309eed83de -> b70b060230eb792f9ce089b047e2ec01292372e7 ([`pr/ipc.102`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.102) -> [`pr/ipc.103`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.103), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.102-rebase..pr/ipc.103)) due to conflicts with #18249, #18241, and #18249\r\nRebased b70b060230eb792f9ce089b047e2ec01292372e7 -> 0ffff86cffbd1048a435c55e9b6d19f4e0200fb2 ([`pr/ipc.103`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.103) -> [`pr/ipc.104`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.104), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.103-rebase..pr/ipc.104)) for various conficts and with ReadFieldUpdate/ReadFieldNew merge\r\nRebased 0ffff86cffbd1048a435c55e9b6d19f4e0200fb2 -> 67eb575c5b071ea802bd2fa02b9022b92dd8d9f8 ([`pr/ipc.104`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.104) -> [`pr/ipc.105`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.105), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.104-rebase..pr/ipc.105)) with msvc test_bitcoin-qt build fix, centos c++ old compiler fix, updated libmultiprocess fixing ThrowFn exception reading\r\nUpdated 67eb575c5b071ea802bd2fa02b9022b92dd8d9f8 -> 4d153cc8a61610da91488e2f250dac74c87fad32 ([`pr/ipc.105`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.105) -> [`pr/ipc.106`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.106), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.105..pr/ipc.106)) with feature_config_args fix\r\nRebased 4d153cc8a61610da91488e2f250dac74c87fad32 -> 9e4ccac3a842e060b5862c73f4bb8cb2d741cb98 ([`pr/ipc.106`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.106) -> [`pr/ipc.107`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.107), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.106-rebase..pr/ipc.107)) after #16367 merge and with shared_ptr callback support needed after #18338\r\nUpdated 9e4ccac3a842e060b5862c73f4bb8cb2d741cb98 -> eb8a19ce9e7ed863f3271f37d2d8684dac1c283b ([`pr/ipc.107`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.107) -> [`pr/ipc.108`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.108), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.107..pr/ipc.108)) with multiwallet urlencode test fix\r\nRebased eb8a19ce9e7ed863f3271f37d2d8684dac1c283b -> 0ba0b3052ca916085fc5e93f5c26f9e4f14fa17d ([`pr/ipc.108`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.108) -> [`pr/ipc.109`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.109), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.108-rebase..pr/ipc.109)) with support for FoundBlock passing in #17954 and after IPC build revert #18588\r\nRebased 0ba0b3052ca916085fc5e93f5c26f9e4f14fa17d -> aa38570fa5f1ceee5883a8170da60206051e05fd ([`pr/ipc.109`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.109) -> [`pr/ipc.110`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.110), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.109-rebase..pr/ipc.110)) due to conflicts with #18571, #16426, and #17781\r\nRebased aa38570fa5f1ceee5883a8170da60206051e05fd -> fd810d2ae759091dadf39d1d6af3bf267e66bbfd ([`pr/ipc.110`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.110) -> [`pr/ipc.111`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.111), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.110-rebase..pr/ipc.111)) after base prs merged and many conflicts with other PRs resolved",
      "created_at" : "2020-03-05T17:33:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595353238",
      "id" : 595353238,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NTM1MzIzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-06-04T10:49:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/595353238",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Now that #17905 is merged this seems to be the fourth step in the multiprocess transformation.\r\n\r\nWhat things need to happen in your view for this to proceed? From my view this seems like the step where we need to decide to use capnproto or not, and if not, what sort of replacement library. Personally I think using capnproto is a decent idea, as it's a well maintained project, and can save us from a lot of the common bugs we might otherwise run into if we rolled our own. OTOH it's a big codebase so we might want to tread carefully.\r\n\r\nIn particular, it seems that we're using CapnProto in a *very* limited way. CapnProto is designed to be usable as a layer between untrusted peers (e.g., at the network consensus layer). This isn't what's going on here. In our usage here it's only between trusted node components. Even without CapnProto, if your wallet user wants to mess with your node they can do some heavy damage, so I don't really see a *new* attack surface. In fact, I see less attack surface because now if someone pops your node handling network stuff they can't get to your private keys. That seems like a major improvement over the status quo, even at the expense of a new, complex, library.\r\n\r\nCurious to hear what other's think and if we can move ahead with capnproto.",
      "created_at" : "2020-05-01T20:07:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-622544686",
      "id" : 622544686,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyMjU0NDY4Ng==",
      "updated_at" : "2020-05-01T20:07:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/622544686",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "when it was last mentioned on IRC, the idea was to merge it as experimental with capnproto, with plans to eventually replace it when that makes sense.",
      "created_at" : "2020-05-01T20:13:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-622547262",
      "id" : 622547262,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyMjU0NzI2Mg==",
      "updated_at" : "2020-05-01T20:13:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/622547262",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/45598?v=4",
         "events_url" : "https://api.github.com/users/jb55/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jb55/followers",
         "following_url" : "https://api.github.com/users/jb55/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jb55/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jb55",
         "id" : 45598,
         "login" : "jb55",
         "node_id" : "MDQ6VXNlcjQ1NTk4",
         "organizations_url" : "https://api.github.com/users/jb55/orgs",
         "received_events_url" : "https://api.github.com/users/jb55/received_events",
         "repos_url" : "https://api.github.com/users/jb55/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jb55/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jb55/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jb55"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r433880214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433880214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in commit b737e5397af4cedde1aec47f5b4e87c2521efdd0\r\n\r\nOut of scope for this pr, but I am wondering if it wouldn't be easier to compile an increased rpc timeout factor into the test config file. This way, all tests are updated when compiled with ipc and it would avoid having to update them manually and individually.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2020-06-02T13:36:57Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n         self.extra_args = [['-acceptnonstdtxn=1']]  # This is a consensus block test, we don't care about tx policy\n+        self.rpc_timeout = 1920",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r433880214",
      "id" : 433880214,
      "line" : 86,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4MDIxNA==",
      "original_commit_id" : "b737e5397af4cedde1aec47f5b4e87c2521efdd0",
      "original_line" : 86,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/feature_block.py",
      "position" : 4,
      "pull_request_review_id" : 422682747,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/433880214",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The test suite passes, but I get quite a few warnings when building on macOS 10.15.4 : https://gist.github.com/Sjors/b7b2dc026a39741b019f15e98751cf57#file-make-1-log\r\n\r\nWhen launching `src/bitcoin-gui` I get an error message: `Error: Error reading configuration file:`. It trips over unknown setting names, even for a different network (e.g. `-signer` which is for an unmerged PR).  `src/qt/bitcoin-qt` and `src/bitcoin-node` do not have this problem; they report unrecognised options in the log.\r\n\r\nIf I stop `bitcoin-gui` with `ctrl+c` it's not always very graceful, e.g. I got:\r\n\r\n```\r\n^C\r\nlibc++abi.dylib: terminating with uncaught exception of type interfaces::IpcException: kj::Exception: capnp/rpc.c++:2092: disconnected: Peer disconnected.                                                                    \r\nstack: 1084bf30a 106e09f40 106e0c090`\r\n```\r\n\r\nIf I stop early it's also not very happy:\r\n```\r\n2020-06-02T14:06:07Z Using obfuscation key for /Users/sjors/Library/Application Support/Bitcoin/testnet3/blocks/index: 0000000000000000\r\n^C2020-06-02T14:06:10Z Shutdown requested. Exiting.\r\n\r\nAssertion failed: (nThreadsServicingQueue == 0), function ~CScheduler, file scheduler.cpp, line 18\r\n```\r\n\r\n`bitcoin-node` doesn't have the same config file issue, but it hits similar asserts when existing with ctrl+c. I added an example log: https://gist.github.com/Sjors/b7b2dc026a39741b019f15e98751cf57#file-bitcoin-node-log",
      "created_at" : "2020-06-02T14:16:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-637572032",
      "id" : 637572032,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNzU3MjAzMg==",
      "updated_at" : "2020-06-02T14:16:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/637572032",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors \r\nsee also https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595180635, https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-595353238",
      "created_at" : "2020-06-02T14:33:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-637582520",
      "id" : 637582520,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNzU4MjUyMA==",
      "updated_at" : "2020-06-02T14:33:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/637582520",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks, I'll look into the settings bug, and adding a sigint handler since multiple people reported this\r\n\r\n---\r\n\r\nRebased fd810d2ae759091dadf39d1d6af3bf267e66bbfd -> 5f8b1d3bca82490872fddcb6ff6e1b6ecf4a66e5 ([`pr/ipc.111`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.111) -> [`pr/ipc.112`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.112), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.111..pr/ipc.112)) on top of #19160 pr/ipc-echo.3\r\nRebased 5f8b1d3bca82490872fddcb6ff6e1b6ecf4a66e5 -> 37061a71acdd55d95359d898a3f5e8ff00cd7019 ([`pr/ipc.112`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.112) -> [`pr/ipc.113`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.113), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.112-rebase..pr/ipc.113)) on top of #19160 pr/ipc-echo.4\r\nRebased 37061a71acdd55d95359d898a3f5e8ff00cd7019 -> 7b8d8908582a8a968d9f601745283d7c7bb2eaf4 ([`pr/ipc.113`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.113) -> [`pr/ipc.114`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.114), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.113-rebase..pr/ipc.114)) due to silent merge conflicts with #17938 (destination hash types) and #18027 (fillPSBT), on top of #19160 pr/ipc-echo.5\r\nUpdated 7b8d8908582a8a968d9f601745283d7c7bb2eaf4 -> 93bc1db49596bb69e9e53630af53cc1c94a20f25 ([`pr/ipc.114`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.114) -> [`pr/ipc.115`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.115), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.114..pr/ipc.115)) to fix travis include errors\r\nRebased 93bc1db49596bb69e9e53630af53cc1c94a20f25 -> 7f6afc5d43bffe729443b605328ec5054bb2c806 ([`pr/ipc.115`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.115) -> [`pr/ipc.116`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.116), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.115-rebase..pr/ipc.116)) on top of #19160 pr/ipc-echo.6 due to silent conflict with #19219\r\nRebased 7f6afc5d43bffe729443b605328ec5054bb2c806 -> 081cf6c40b51a2f456703620b87c27d303dcdf67 ([`pr/ipc.116`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.116) -> [`pr/ipc.117`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.117), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.116-rebase..pr/ipc.117)) due to conflicts with #19098\r\nUpdated 081cf6c40b51a2f456703620b87c27d303dcdf67 -> 3076c8c41a627adb2bc7fc6722c50fcaf34ccfdd ([`pr/ipc.117`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.117) -> [`pr/ipc.118`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.118), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.117..pr/ipc.118)) to fix wallet_dump assert_debug_log test error https://travis-ci.org/github/bitcoin/bitcoin/jobs/707823975\r\nRebased 3076c8c41a627adb2bc7fc6722c50fcaf34ccfdd -> 3da29016799095b10c7fa5aa0368cdf0cb784846 ([`pr/ipc.118`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.118) -> [`pr/ipc.119`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.119), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.118-rebase..pr/ipc.119)) on top of #19160 pr/ipc-echo.7\r\nRebased 3da29016799095b10c7fa5aa0368cdf0cb784846 -> 56d577bc1d79cfb3e0a78f49f42abcce0727ea16 ([`pr/ipc.119`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.119) -> [`pr/ipc.120`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.120), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.119-rebase..pr/ipc.120)) due to conflicts with #18571 and #15935\r\nRebased 56d577bc1d79cfb3e0a78f49f42abcce0727ea16 -> 060a1b55396f4ab142781a39e3f98baaa31ddedd ([`pr/ipc.120`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.120) -> [`pr/ipc.121`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.121), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.120-rebase..pr/ipc.121)) due to conflict with #19326\r\nRebased 060a1b55396f4ab142781a39e3f98baaa31ddedd -> 49c22b589a2c2d63acd0434c6424880e134ec085 ([`pr/ipc.121`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.121) -> [`pr/ipc.122`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.122), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.121-rebase..pr/ipc.122)) due to conflict with #19098\r\nUpdated 49c22b589a2c2d63acd0434c6424880e134ec085 -> 4e3dae7a584650485b1c328577be5b58c99258c4 ([`pr/ipc.122`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.122) -> [`pr/ipc.123`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.123), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.122..pr/ipc.123)) to fix test errors https://travis-ci.org/github/bitcoin/bitcoin/builds/717076622 https://ci.appveyor.com/project/DrahtBot/bitcoin/builds/34606581 https://cirrus-ci.com/task/4522962420236288 https://cirrus-ci.com/task/5648862327078912\r\nRebased 4e3dae7a584650485b1c328577be5b58c99258c4 -> 21529efc39ae143a3f4b2a1dd4f697c638fc88a5 ([`pr/ipc.123`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.123) -> [`pr/ipc.124`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.124), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.123-rebase..pr/ipc.124)) due to conflicts with #19011 and #15937 on top of #19160 pr/ipc-echo.11\r\nRebased 21529efc39ae143a3f4b2a1dd4f697c638fc88a5 -> fa6f80a699aa2f9f001090cd60bf0a02d545f8cb ([`pr/ipc.124`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.124) -> [`pr/ipc.125`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.125), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.124-rebase..pr/ipc.125)) on top of #19160 pr/ipc-echo.7 with fixes for travis errors https://travis-ci.org/github/bitcoin/bitcoin/jobs/721173746#L3338",
      "created_at" : "2020-06-02T15:08:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-637604238",
      "id" : 637604238,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYzNzYwNDIzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-27T04:52:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/637604238",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r434125730"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/434125730"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> in commit [b737e53](https://github.com/bitcoin/bitcoin/commit/b737e5397af4cedde1aec47f5b4e87c2521efdd0)\r\n> \r\n> Out of scope for this pr, but I am wondering if it wouldn't be easier to compile an increased rpc timeout factor into the test config file. This way, all tests are updated when compiled with ipc and it would avoid having to update them manually and individually.\r\n\r\nThat's a good idea, I didn't know about the timeout factor and it'd probably better to increase that if there are other timeouts outside this test. Some IPC performance problems are actually very easy to fix after you know they exist, though, so there might be some argument for increasing timeouts selectively instead of globally to identify these places, at least to start out with before it becomes a burden.",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2020-06-02T19:28:00Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n         self.extra_args = [['-acceptnonstdtxn=1']]  # This is a consensus block test, we don't care about tx policy\n+        self.rpc_timeout = 1920",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r434125730",
      "id" : 434125730,
      "in_reply_to_id" : 433880214,
      "line" : 86,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNTczMA==",
      "original_commit_id" : "b737e5397af4cedde1aec47f5b4e87c2521efdd0",
      "original_line" : 86,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/feature_block.py",
      "position" : 4,
      "pull_request_review_id" : 422992806,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/434125730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-07-30T16:28:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-666507306",
      "id" : 666507306,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjUwNzMwNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T16:28:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666507306",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-03T16:27:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-668117123",
      "id" : 668117123,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2ODExNzEyMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-03T16:27:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/668117123",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-07T10:10:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-670442201",
      "id" : 670442201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3MDQ0MjIwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-07T10:10:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/670442201",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-14T08:50:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-673966947",
      "id" : 673966947,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY3Mzk2Njk0Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-14T08:50:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/673966947",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-26T09:04:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-680755789",
      "id" : 680755789,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MDc1NTc4OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-26T09:04:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/680755789",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "How can I start buying bitcoin?\n\nSent from Yahoo Mail on Android \n \n  On Sat, 21 Jul 2018 at 0:41, DrahtBot<notifications@github.com> wrote:   Needs rebase\nâ\nYou are receiving this because you are subscribed to this thread.\nReply to this email directly, view it on GitHub, or mute the thread.\n   \n",
      "created_at" : "2020-08-26T21:48:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-681141482",
      "id" : 681141482,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MTE0MTQ4Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-26T21:48:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/681141482",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/35436317?v=4",
         "events_url" : "https://api.github.com/users/Pankylove99/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Pankylove99/followers",
         "following_url" : "https://api.github.com/users/Pankylove99/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Pankylove99/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Pankylove99",
         "id" : 35436317,
         "login" : "Pankylove99",
         "node_id" : "MDQ6VXNlcjM1NDM2MzE3",
         "organizations_url" : "https://api.github.com/users/Pankylove99/orgs",
         "received_events_url" : "https://api.github.com/users/Pankylove99/received_events",
         "repos_url" : "https://api.github.com/users/Pankylove99/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Pankylove99/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Pankylove99/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Pankylove99"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-08-31T10:19:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-683693850",
      "id" : 683693850,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4MzY5Mzg1MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-08-31T10:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/683693850",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for continuing to work on this.  Cloning and building to test now.\r\n\r\nMulti-process isolation boundaries have been needed for... 10 years or so. ",
      "created_at" : "2020-09-13T20:29:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-691721122",
      "id" : 691721122,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTcyMTEyMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-13T20:29:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691721122",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/494411?v=4",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "node_id" : "MDQ6VXNlcjQ5NDQxMQ==",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Thanks for continuing to work on this. Cloning and building to test now.\r\n\r\nThanks! Some instructions are at https://github.com/ryanofsky/bitcoin/blob/pr/ipc/doc/multiprocess.md#installation in case that's helpful. \r\n\r\n---\r\n\r\nRebased fa6f80a699aa2f9f001090cd60bf0a02d545f8cb -> 9bb2b0fc428877b5af7e472ca492b09ecdb72394 ([`pr/ipc.125`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.125) -> [`pr/ipc.126`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.126), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.125-rebase..pr/ipc.126)) on top of #19160 pr/ipc-echo.13 due to conflict with #19099\r\nUpdated 9bb2b0fc428877b5af7e472ca492b09ecdb72394 -> e9523ebd6e312422c2a891d3004678ba4459d87f ([`pr/ipc.126`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.126) -> [`pr/ipc.127`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.127), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.126..pr/ipc.127)) with libmultiprocess extends support https://github.com/chaincodelabs/libmultiprocess/pull/38\r\nUpdated e9523ebd6e312422c2a891d3004678ba4459d87f -> dd71ab2683c5b69dbacf03f7144cb87e016442f2 ([`pr/ipc.127`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.127) -> [`pr/ipc.128`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.128), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.127..pr/ipc.128)) to fix travis errors from missing include https://travis-ci.org/github/bitcoin/bitcoin/jobs/726837187 https://travis-ci.org/github/bitcoin/bitcoin/jobs/726837186 https://travis-ci.org/github/bitcoin/bitcoin/jobs/726837185\r\nUpdated dd71ab2683c5b69dbacf03f7144cb87e016442f2 -> 3724d0a48c2a82b015738a71cc3580bb48ffdd84 ([`pr/ipc.128`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.128) -> [`pr/ipc.129`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.129), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.128..pr/ipc.129)) to fix travis missing make dependency error https://travis-ci.org/github/bitcoin/bitcoin/jobs/726899109\r\nRebased 3724d0a48c2a82b015738a71cc3580bb48ffdd84 -> 8605bae0a5cd4aa1a66a6b3020b23de077cf9121 ([`pr/ipc.129`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.129) -> [`pr/ipc.130`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.130), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.129-rebase..pr/ipc.130)) due to silent conflicts with #15454 and #19572 on top of #19160 pr/ipc-echo.14\r\nRebased 8605bae0a5cd4aa1a66a6b3020b23de077cf9121 -> 5bd02e8581c4d9fecbaed6f93b4f95920c5cb024 ([`pr/ipc.130`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.130) -> [`pr/ipc.131`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.131), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.130-rebase..pr/ipc.131)) due to conflict with #19725 on top of #19160 pr/ipc-echo.14\r\nRebased 5bd02e8581c4d9fecbaed6f93b4f95920c5cb024 -> d779c4af435b6d06f29afd07772eb348a0ed94f9 ([`pr/ipc.131`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.131) -> [`pr/ipc.132`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.132), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.131-rebase..pr/ipc.132)) on top of #19160 pr/ipc-echo.16 for cmake depends fix\r\nUpdated d779c4af435b6d06f29afd07772eb348a0ed94f9 -> 8f155d7afc41760a36972ae353a76d876cf4445f ([`pr/ipc.132`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.132) -> [`pr/ipc.133`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.133), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.132..pr/ipc.133)) to fix c++11/c++17 constexpr linkage error https://travis-ci.org/github/bitcoin/bitcoin/jobs/731908474#L3044",
      "created_at" : "2020-09-13T20:43:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-691722739",
      "id" : 691722739,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MTcyMjczOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T01:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/691722739",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-18T00:23:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-694572357",
      "id" : 694572357,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NDU3MjM1Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-18T00:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/694572357",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-26T17:23:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-699523774",
      "id" : 699523774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5OTUyMzc3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-26T17:23:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/699523774",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Outstanding work and effort! Not sure if it was mentioned, but while testing I've noticed it takes way longer to load big wallets. But this is something we could improve in different ways, not in the context of this PR.\r\n\r\nConcept ACK.\r\n\r\n",
      "created_at" : "2020-10-23T21:45:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-715604162",
      "id" : 715604162,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcxNTYwNDE2Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-23T21:45:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/715604162",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-10-27T10:05:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-717130127",
      "id" : 717130127,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcxNzEzMDEyNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-27T10:05:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/717130127",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-12-02T13:17:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-737224422",
      "id" : 737224422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDczNzIyNDQyMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-02T13:17:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/737224422",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased 8f155d7afc41760a36972ae353a76d876cf4445f -> e3b965e13216acc111bf0241fb14e55c63612a10 ([`pr/ipc.133`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.133) -> [`pr/ipc.134`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.134), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.133-rebase..pr/ipc.134)) on top of #19160 pr/ipc-echo.19\r\nRebased e3b965e13216acc111bf0241fb14e55c63612a10 -> 62f68cb14e6c8702d14bb34680a6abddf9342b5e ([`pr/ipc.134`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.134) -> [`pr/ipc.135`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.135), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.134-rebase..pr/ipc.135)) on top of #19160 pr/ipc-echo.22 with FoundBlock fixes after #19425 and silent conflict fix after #18766\r\nUpdated 62f68cb14e6c8702d14bb34680a6abddf9342b5e -> b5d2ae65b2d870a02e157846236160f35ad6608c ([`pr/ipc.135`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.135) -> [`pr/ipc.136`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.136), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.135..pr/ipc.136)) to fix unique_ptr forward include errors https://cirrus-ci.com/task/5058230931947520 https://ci.appveyor.com/project/DrahtBot/bitcoin/builds/36782415\r\nUpdated b5d2ae65b2d870a02e157846236160f35ad6608c -> a4aaf6993b63b545a341094201011f663ed92fbc ([`pr/ipc.136`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.136) -> [`pr/ipc.137`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.137), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.136..pr/ipc.137)) with build tweaks to fix appveyor object name error https://ci.appveyor.com/project/DrahtBot/bitcoin/builds/36786087 and cirrus missing make header error https://cirrus-ci.com/task/5234663356628992?command=ci#L2602\r\nRebased a4aaf6993b63b545a341094201011f663ed92fbc -> 1e3bfe692e978966ad1607b7f3d3679508d39644 ([`pr/ipc.137`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.137) -> [`pr/ipc.138`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.138), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.137-rebase..pr/ipc.138)) on top of #19160 pr/ipc-echo.23 including https://github.com/chaincodelabs/libmultiprocess/pull/41 to fix build errors caused by #20588\r\nRebased 1e3bfe692e978966ad1607b7f3d3679508d39644 -> 011a8cd6f84c4163c6550dfa3fad696b4458a9c7 ([`pr/ipc.138`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.138) -> [`pr/ipc.139`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.139), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.138-rebase..pr/ipc.139)) on top of #19160 pr/ipc-echo.24 due to (mostly silent) conflicts with #18077, #19829, #20671, #20736, #20755, #20786\r\nRebased 011a8cd6f84c4163c6550dfa3fad696b4458a9c7 -> 03501ab4b74e45a68ef9fa6a8d51ef99695f7588 ([`pr/ipc.139`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.139) -> [`pr/ipc.140`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.140), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.139-rebase..pr/ipc.140)) on top of #21035 pr/argmap.1 to fix CI failure https://cirrus-ci.com/task/5469433013469184?command=ci#L2275\r\nRebased 03501ab4b74e45a68ef9fa6a8d51ef99695f7588 -> 1f789912f3dae5aecdce157d0eefdb22c2b5a61c ([`pr/ipc.140`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.140) -> [`pr/ipc.141`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.141), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.140-rebase..pr/ipc.141)) due to silent conflict with #20464 (https://cirrus-ci.com/task/6558387276087296)\r\nRebased 1f789912f3dae5aecdce157d0eefdb22c2b5a61c -> ce6e283ed2fc91994dd23b930feb2a768b0062ad ([`pr/ipc.141`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.141) -> [`pr/ipc.142`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.142), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.141-rebase..pr/ipc.142)) due to silent conflict with #21051\r\nRebased ce6e283ed2fc91994dd23b930feb2a768b0062ad -> 585585c28f69cc232c2f9e6d1ae96c8d3a11eb5a ([`pr/ipc.142`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.142) -> [`pr/ipc.143`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.143), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.142-rebase..pr/ipc.143)) on top of #19060 pr/ipc-echo.26 due to silent conflict with #20721\r\n",
      "created_at" : "2020-12-11T18:19:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-743349730",
      "id" : 743349730,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0MzM0OTczMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-20T21:10:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/743349730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-12-16T15:58:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-746529497",
      "id" : 746529497,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NjUyOTQ5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-16T15:58:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/746529497",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-07T15:08:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-756173542",
      "id" : 756173542,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NjE3MzU0Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-07T15:08:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/756173542",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-02T12:00:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-788858033",
      "id" : 788858033,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4ODg1ODAzMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-02T12:00:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/788858033",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "NACK\r\nThis is using a library produced by an outside entity that\r\naddresses a specific use case of bitcoin.\r\nGood intentions and all, bait-and-switch is a thing.\r\n20 years into the future we have a company having control \r\nof a part of the bitcoin code which does not get the same level\r\nof audit as the bitcoin code itself but neither as external libraries\r\nwhich are not targeted at bitcoin like zmq. \r\n",
      "created_at" : "2021-03-04T11:16:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-790538884",
      "id" : 790538884,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MDUzODg4NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-04T11:16:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/790538884",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/80039708?v=4",
         "events_url" : "https://api.github.com/users/electorr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/electorr/followers",
         "following_url" : "https://api.github.com/users/electorr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/electorr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/electorr",
         "id" : 80039708,
         "login" : "electorr",
         "node_id" : "MDQ6VXNlcjgwMDM5NzA4",
         "organizations_url" : "https://api.github.com/users/electorr/orgs",
         "received_events_url" : "https://api.github.com/users/electorr/received_events",
         "repos_url" : "https://api.github.com/users/electorr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/electorr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/electorr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/electorr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-790538884\r\n\r\nConcerns about external libraries (including zmq) are legitimate and this is a reason multiprocess support is optional and will always be optional. Just like you can build versions of bitcoin without GUI or wallet support, and just like we distribute separate `bitcoin-qt` and `bitcoind` binaries so you can choose whether or not to use [Qt](https://www.qt.io/), you will always be able to build bitcoin without multiprocess support. Also, you can also choose whether to use multiprocess binaries.\r\n\r\nMultiprocess support is disabled by default in this PR (toggled by the [`--enable-multiprocess`](https://github.com/ryanofsky/bitcoin/blob/ipc-export/doc/multiprocess.md) option), and even when it is enabled it just creates new `bitcoin-gui`, `bitcoin-node`, and `bitcoin-wallet` binaries without any effect on existing `bitcoind` and `bitcoin-qt` binaries.\r\n\r\nBeyond the ability to disable multiprocess support, there is also the ability to enable it and replace it with a different implementation. For example, if you want multiprocess support, but would prefer not to rely on the external [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess) library, you could implement a class overriding [`interfaces::Ipc`](https://github.com/ryanofsky/bitcoin/blob/ipc-export/src/interfaces/ipc.h) with methods `spawnProcess`, `serveProcess`, `connectAddress`, `listenAddress` that use a different IPC protocol or are implemented with different libraries.\r\n\r\n---\r\n\r\nRebased 585585c28f69cc232c2f9e6d1ae96c8d3a11eb5a -> a43b55a381b023800f9f5f68a2a56a1e374ab19f ([`pr/ipc.143`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.143) -> [`pr/ipc.144`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.144), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.143-rebase..pr/ipc.144)) on #19160 pr/ipc-echo.27 due to conflicts with #20685 and #21015\r\nRebased a43b55a381b023800f9f5f68a2a56a1e374ab19f -> 26bc68baf4d221bfd45cb4c61556fd5851376e84 ([`pr/ipc.144`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.144) -> [`pr/ipc.145`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.145), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.144-rebase..pr/ipc.145)) due to conflict with bitcoin-core/gui#233\r\nRebased 26bc68baf4d221bfd45cb4c61556fd5851376e84 -> 667affafa4b1a086746de9ef17c459e40380829b ([`pr/ipc.145`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.145) -> [`pr/ipc.146`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.146), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.145-rebase..pr/ipc.146)) due to conflicts with #21007 and #21404\r\n",
      "created_at" : "2021-03-04T14:39:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-790664616",
      "id" : 790664616,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MDY2NDYxNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-23T05:53:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/790664616",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-08T20:05:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-793038275",
      "id" : 793038275,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzAzODI3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-08T20:05:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793038275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-11T14:57:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-796796810",
      "id" : 796796810,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5Njc5NjgxMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-11T14:57:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/796796810",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r592825932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/592825932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Please [use `std::make_unique` in new code](https://github.com/bitcoin/bitcoin/blob/master/src/util/memory.h#L13).",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2021-03-12T00:28:11Z",
      "diff_hunk" : "@@ -0,0 +1,49 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+#include <interfaces/init.h>\n+#include <interfaces/ipc.h>\n+#include <ipc/context.h>\n+#include <logging.h>\n+#include <tinyformat.h>\n+#include <util/memory.h>\n+#include <util/time.h>\n+\n+#include <functional>\n+#include <memory>\n+#include <stdexcept>\n+#include <string>\n+#include <utility>\n+\n+namespace ipc {\n+namespace capnp {\n+void SetupNodeClient(ipc::Context& context);\n+} // namespace capnp\n+} // namespace ipc\n+\n+namespace init {\n+namespace {\n+const char* EXE_NAME = \"bitcoin-gui\";\n+\n+class BitcoinGuiInit : public interfaces::Init\n+{\n+public:\n+    BitcoinGuiInit(const char* arg0)\n+        : m_ipc(interfaces::MakeIpc(EXE_NAME, arg0, *this))\n+    {\n+        ipc::capnp::SetupNodeClient(m_ipc->context());\n+    }\n+    interfaces::Ipc* ipc() override { return m_ipc.get(); }\n+    std::unique_ptr<interfaces::Ipc> m_ipc;\n+};\n+} // namespace\n+} // namespace init\n+\n+namespace interfaces {\n+std::unique_ptr<Init> MakeGuiInit(int argc, char* argv[])\n+{\n+    return MakeUnique<init::BitcoinGuiInit>(argc > 0 ? argv[0] : \"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r592825932",
      "id" : 592825932,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MjgyNTkzMg==",
      "original_commit_id" : "26bc68baf4d221bfd45cb4c61556fd5851376e84",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/init/bitcoin-gui.cpp",
      "position" : null,
      "pull_request_review_id" : 610354892,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-04-30T13:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/592825932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've been following the instructions in `doc/multiprocess.md`, especially the ones in ##Installation\r\n\r\n```\r\ncd <BITCOIN_SOURCE_DIRECTORY>\r\nmake -C depends NO_QT=1 MULTIPROCESS=1\r\n./configure --prefix=$PWD/depends/x86_64-pc-linux-gnu\r\nmake\r\nsrc/bitcoin-node -regtest -printtoconsole -debug=ipc\r\nBITCOIND=bitcoin-node test/functional/test_runner.py\r\n```\r\n\r\nBut I'm hitting linker failures likewise :\r\n```\r\n/home/user/Bitcoin/bitcoin/src/ipc/capnp/node.cpp:112: undefined reference to `mp::ProxyClient<ipc::capnp::messages::Node>::customWalletClient()'\r\n/usr/bin/ld: libbitcoin_ipc.a(libbitcoin_ipc_a-node.o): in function `mp::ProxyClientBase<ipc::capnp::messages::Node, interfaces::Node>::ProxyClientBase(ipc::capnp::messages::Node::Client, mp::Connection*, bool)::{lambda()#2}::operator()() const':\r\n/home/user/Bitcoin/bitcoin/depends/x86_64-pc-linux-gnu/include/mp/proxy-io.h:392: undefined reference to `mp::ProxyClient<ipc::capnp::messages::Node>::destroy()'\r\n/usr/bin/ld: libbitcoin_ipc.a(libbitcoin_ipc_a-init.capnp.proxy-client.o): in function `mp::ProxyClientBase<ipc::capnp::messages::WalletClient, interfaces::WalletClient>::ProxyClientBase(ipc::capnp::messages::WalletClient::Client, mp::Connection*, bool)::{lambda()#2}::operator()() const':\r\n```\r\n\r\nI'm investigating further, it might be local env config ?\r\n\r\nEDIT: I'm building well #19160 branch",
      "created_at" : "2021-03-26T14:40:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-808272413",
      "id" : 808272413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwODI3MjQxMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-26T14:48:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/808272413",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-808272413\r\n\r\nThanks for the bug report. So far I'm not able to reproduce the problem. Just checking out the current PR and following the instructions builds successfully for me (and also seems to be working on CI).\r\n\r\nIt's possible there are old build outputs on your system and using `git-clean` could help. Otherwise it'd be great if you opened a new issue https://github.com/chaincodelabs/libmultiprocess/issues/new including the complete error message (maybe with `make V=1` to be able to see the linker command line). From the snippet above, it's not clear what executable is actually being linked or if the symbol should be expected to be defined there.\r\n\r\nIn the future feel free to post any questions or issues related to multiprocess stuff to https://github.com/chaincodelabs/libmultiprocess/issues/new. Even though libmultiprocess isn't bitcoin-specific, the issue tracker is a pretty quiet and reasonable place for discussion, even if issues are tangential. This PR thread is long and it's hard to have ongoing discussion about specific topics here.",
      "created_at" : "2021-03-26T18:01:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-808415410",
      "id" : 808415410,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwODQxNTQxMA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-26T18:04:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/808415410",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Tried to run `bitcoin-gui` and hit an assert:\r\n\r\n    bitcoin-gui: logging.cpp:274: void BCLog::Logger::LogPrintStr(const string&, const string&, const string&, int): Assertion `m_fileout != nullptr' failed.\r\n\r\n***\r\n\r\nI am not really a fan of overloading `bitcoin-wallet` to serve as the wallet process. Currently (in master) it is used solely as the wallet tool. It seems really weird to me that with this PR it's behavior is completely different depending on whether it is given `-ipcfd`. I would rather that the wallet process is a new binary instead of overloading the current `bitcoin-wallet`.\r\n\r\n***\r\n\r\nThe last commit seems to be extremely monolithic. It would be nice to break it up into several smaller commits if possible.",
      "created_at" : "2021-03-29T19:45:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-809662747",
      "id" : 809662747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwOTY2Mjc0Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-29T19:58:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/809662747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for checking this!\r\n\r\n> Tried to run `bitcoin-gui` and hit an assert:\r\n\r\nI'll look into this some more, but feel free to post an issue https://github.com/chaincodelabs/libmultiprocess/issues/new just because it's easier to dig into bugs outside this long PR thread. I wonder if you are using a bitcoin.conf file or have log options defined that could be relevant to this.\r\n\r\n> I am not really a fan of overloading `bitcoin-wallet` to serve as the wallet process. Currently (in master) it is used solely as the wallet tool. It seems really weird to me that with this PR it's behavior is completely different depending on whether it is given `-ipcfd`. I would rather that the wallet process is a new binary instead of overloading the current `bitcoin-wallet`.\r\n\r\nThe idea here is to have one wallet tool instead of multiple tools. This is described a little in #19460 (feel free to follow up there). `-ipcfd` is an internal argument that users shouldn't care about, but #19460 adds an `-ipcconnect` option to control whether `bitcoin-wallet` tries to connect to the `bitcoin-node` IPC socket. The idea would be that\r\n\r\n```sh\r\nbitcoin-wallet -noipcconnect    -wallet=mywallet listtransactions  # List limited transaction info\r\nbitcoin-wallet -ipcconnect      -wallet=mywallet listtransactions  # List full transaction info\r\nbitcoin-wallet -ipcconnect=auto -wallet=mywallet listtransactions  # List available transaction info\r\n\r\nbitcoin-wallet -noipcconnect    -wallet=mywallet serve # Run limited RPC server\r\nbitcoin-wallet -ipcconnect      -wallet=mywallet serve # Run full RPC server\r\nbitcoin-wallet -ipcconnect=auto -wallet=mywallet serve # Run full server if possible, but fall back to limited\r\n```\r\n\r\nDefault `-ipcconnect` option value might be a discussion point but in #19460 it is `auto`.\r\n\r\n> The last commit seems to be extremely monolithic. It would be nice to break it up into several smaller commits if possible.\r\n\r\nYes, that's the plan. It needs to be split up and also has a few hacks that need to be removed. (Some of the hacks in fact are related to logging and could be responsible for the issue you reported).",
      "created_at" : "2021-03-29T22:23:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-809752196",
      "id" : 809752196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwOTc1MjE5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-29T22:23:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/809752196",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-30T11:14:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-810136328",
      "id" : 810136328,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgxMDEzNjMyOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-30T11:14:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/810136328",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-809662747\r\n\r\n> Tried to run `bitcoin-gui` and hit an assert:\r\n> \r\n> ```\r\n> bitcoin-gui: logging.cpp:274: void BCLog::Logger::LogPrintStr(const string&, const string&, const string&, int): Assertion `m_fileout != nullptr' failed.\r\n> ```\r\n\r\nThanks, reproduced and fixed this now. I missed it because I'd had been testing ahead of this PR on the #19461 branch. Backporting some changes from #19461 fixed it.\r\n\r\n---\r\n\r\nRebased 667affafa4b1a086746de9ef17c459e40380829b -> e6e53b5955a184a672d8c74ac25f787f2ae46482 ([`pr/ipc.146`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.146) -> [`pr/ipc.147`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.147), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.146-rebase..pr/ipc.147)) fixing gui assert failure reported by achow in https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-809662747 and silent merge conflict after #21366\r\nRebased e6e53b5955a184a672d8c74ac25f787f2ae46482 -> 6e7a814da00c9f8ecaf7c57921515e61e0a037b6 ([`pr/ipc.147`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.147) -> [`pr/ipc.148`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.148), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.147-rebase..pr/ipc.148)) due to silent conflict with #21574 and to fix fuzz timeout https://cirrus-ci.com/task/6058699123851264 #21639",
      "created_at" : "2021-04-08T02:47:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-815405696",
      "id" : 815405696,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgxNTQwNTY5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-09T18:36:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/815405696",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-04-27T11:18:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-827529265",
      "id" : 827529265,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgyNzUyOTI2NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-04-27T11:18:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/827529265",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Base pr #19160 was merged, and I split up the big commit into smaller commits, so I think this is definitely in a reviewable state now, even though there still are some small remaining things I would like to clean up where there are todos in the comments.\r\n\r\n---\r\n\r\nRebased 6e7a814da00c9f8ecaf7c57921515e61e0a037b6 -> 68fe5860cc786962b1de94295aac41574b46159c ([`pr/ipc.148`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.148) -> [`pr/ipc.149`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.149), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.148-rebase..pr/ipc.149)) after #19160 merge, splitting up commits and making some minor cleanups.\r\nRebased 68fe5860cc786962b1de94295aac41574b46159c -> 21064594fd96a1ac20aeae175bb9edba431d1321 ([`pr/ipc.149`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.149) -> [`pr/ipc.150`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.150), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.149-rebase..pr/ipc.150)) due to conflict with bitcoin-core/gui#4 and #22156, on top of bitcoin-core/gui#360 + #22215 + #22217 + #22218 + #22219\r\nRebased 21064594fd96a1ac20aeae175bb9edba431d1321 -> 334f1f90c951ef89a32a8f857a612f249c07c534 ([`pr/ipc.150`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.150) -> [`pr/ipc.151`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.151), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.150-rebase..pr/ipc.151)) due to silent conflict with bitcoin-core/gui#4 causing cirrus failure https://cirrus-ci.com/task/6103801187794944\r\nUpdated 334f1f90c951ef89a32a8f857a612f249c07c534 -> 3515e22d78c7361fe06107721d3bf9616f909aaf ([`pr/ipc.151`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.151) -> [`pr/ipc.152`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.152), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.151..pr/ipc.152)) to fix external signer cirrus error https://cirrus-ci.com/task/6579691483037696\r\nRebased 3515e22d78c7361fe06107721d3bf9616f909aaf -> a7c4732716bfd51540d6b070b2b8d9d6e1048aed ([`pr/ipc.152`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.152) -> [`pr/ipc.153`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.153), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.152-rebase..pr/ipc.153)) due to conflict with #21935\r\nRebased a7c4732716bfd51540d6b070b2b8d9d6e1048aed -> e3d3a183e094aa5acd54ff387fede6c16486523f ([`pr/ipc.153`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.153) -> [`pr/ipc.154`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.154), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.153-rebase..pr/ipc.154)) due to conflict with #22323\r\nRebased e3d3a183e094aa5acd54ff387fede6c16486523f -> 24dd84afd4414cbb20bb937bb95cfa661d1e2b78 ([`pr/ipc.154`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.154) -> [`pr/ipc.155`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.155), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.154-rebase..pr/ipc.155)) due to conflict with #22320\r\nRebased 24dd84afd4414cbb20bb937bb95cfa661d1e2b78 -> 1326c4a9a443e4169822eab569be68e53c58de36 ([`pr/ipc.155`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.155) -> [`pr/ipc.156`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.156), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.155-rebase..pr/ipc.156)) due to conflict with #22339",
      "created_at" : "2021-04-30T13:46:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-830106573",
      "id" : 830106573,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgzMDEwNjU3Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-01T19:01:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/830106573",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-06-09T07:49:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-857471327",
      "id" : 857471327,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg1NzQ3MTMyNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-09T07:49:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/857471327",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-06-23T13:13:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-866824624",
      "id" : 866824624,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NjgyNDYyNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-23T13:13:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866824624",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-06-24T12:13:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-867588256",
      "id" : 867588256,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NzU4ODI1Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-24T12:13:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/867588256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-06-28T03:23:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-869321708",
      "id" : 869321708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2OTMyMTcwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-28T03:23:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/869321708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased 1326c4a9a443e4169822eab569be68e53c58de36 -> 3f2ca2a484a7f040c41d2e29e8bb9e615050694e ([`pr/ipc.156`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.156) -> [`pr/ipc.157`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.157), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.156-rebase..pr/ipc.157)) on top of #22218 pr/ipc-ctx.2 with comment improvements that were discussed in https://github.com/bitcoin/bitcoin/pull/22218#pullrequestreview-702107209 and https://github.com/bitcoin/bitcoin/commit/2516d397d54b021e37d6e7628655fe7c54d2fb06#commitcomment-53226160\r\nRebased 3f2ca2a484a7f040c41d2e29e8bb9e615050694e -> bc918ffaaaf108a9bf49325cef7773ba3797feb4 ([`pr/ipc.157`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.157) -> [`pr/ipc.158`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.158), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.157-rebase..pr/ipc.158)) due to merge conflicts with #20354 #22387 and #21528 and silent conflict with #22570",
      "created_at" : "2021-07-09T17:17:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-877336363",
      "id" : 877336363,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg3NzMzNjM2Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-18T01:08:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/877336363",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r668050651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/668050651"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Make bitcoin-gui spawn a bitcoin-node process\" (2516d397d54b021e37d6e7628655fe7c54d2fb06):\r\n\r\nre: https://github.com/bitcoin/bitcoin/commit/2516d397d54b021e37d6e7628655fe7c54d2fb06#r53368428\r\n\r\n> IIUC, it's going to be call at the first invocation on the server from the client as it's dependent on the whole `serverInvoke()`/`MakeServerField()`/etc call chain ? Sometimes it's hard to follow which objects are defined in `bitcoin`, which ones are in `libmultiprocess` and which ones are dynamically generated by `mpgen`. Though i agree it's fine for now, we can improve with time.\r\n\r\n`init_process` is bitcoin-specific and libmultiprocess can't access it or reference it, and it isn't related to IPC method invocation (`serverInvoke` is a libmultiprocess internal function that bitcoin code shouldn't access and doesn't reference which translates an incoming IPC method call from a remote process to a C++ method call on a local object.)\r\n\r\n`init_process` is a hack to deal with the fact that bitcoin code uses a bunch of global variables that depend on the `gArgs` global variable and they need to be initialized at some point.\r\n\r\nWhen bitcoin is running with wallet & node & gui code in the same process, global variables only have to be initialized once by existing init code. But if the node process spawns a wallet process, or if the GUI process spawns a node process, then there are multiple copies of the global variables in different processes, and they have to be newly initialized in each spawned process, and existing init code is no longer sufficient. That is why the `GlobalArgs` class and `init_process` callback are introduced. `GlobalArgs` transfers `gArgs` state from the parent process to the child process and `init_process` sets up logging and other global variables that depend on `gArgs`.\r\n\r\nIdeally there would be no global variables shared between node wallet and GUI code (they would move into `NodeContext` and `WalletContext` objects) and the `init_process` hack could go away. Short of that, I maybe rename `init_process` or you could think of it as something like `init_bitcoin_shared_global_variables_in_newly_spawned_child_process_after_transferring_gargs`",
      "commit_id" : "3f2ca2a484a7f040c41d2e29e8bb9e615050694e",
      "created_at" : "2021-07-12T15:49:50Z",
      "diff_hunk" : "@@ -26,6 +39,15 @@ class BitcoinNodeInit : public interfaces::Init\n     {\n         m_node.args = &gArgs;\n         m_node.init = this;\n+        // Extra initialization code that runs when a bitcoin-node process is\n+        // spawned by a bitcoin-gui process, after the ArgsManager configuration\n+        // is transferred from the parent process to the child process.\n+        m_ipc->context().init_process = [this] {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r668050651",
      "id" : 668050651,
      "line" : 45,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2ODA1MDY1MQ==",
      "original_commit_id" : "7df963de8020b81dba8fee36d617505eb3a44a87",
      "original_line" : 45,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "src/init/bitcoin-node.cpp",
      "position" : 37,
      "pull_request_review_id" : 704274991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-07-12T15:49:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/668050651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-07-14T11:03:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-879798949",
      "id" : 879798949,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg3OTc5ODk0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-07-14T11:03:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/879798949",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r690922929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690922929"
         }
      },
      "author_association" : "MEMBER",
      "body" : "When you are re-introducing this, it might be good to cleanup the complexity in this method or maybe just use the existing json serialization?",
      "commit_id" : "bc918ffaaaf108a9bf49325cef7773ba3797feb4",
      "created_at" : "2021-08-18T05:56:02Z",
      "diff_hunk" : "@@ -533,6 +533,24 @@ class CSubNet\n     friend bool operator==(const CSubNet& a, const CSubNet& b);\n     friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n     friend bool operator<(const CSubNet& a, const CSubNet& b);\n+\n+    SERIALIZE_METHODS(CSubNet, obj)\n+    {\n+        READWRITE(obj.network);\n+        if (obj.network.IsIPv4()) {\n+            // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n+            // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n+            // serialized form.\n+            unsigned char dummy[12] = {0};\n+            READWRITE(dummy);\n+            READWRITE(MakeSpan(obj.netmask).first(4));\n+        } else {\n+            READWRITE(obj.netmask);\n+        }\n+        READWRITE(obj.valid);\n+        // Mark invalid if the result doesn't pass sanity checking.\n+        SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r690922929",
      "id" : 690922929,
      "line" : 552,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDkyMjkyOQ==",
      "original_commit_id" : "aa05f698fec48392c379c9858c2543aebba8ce2b",
      "original_line" : 552,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/netaddress.h",
      "position" : 20,
      "pull_request_review_id" : 732458257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-18T05:56:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690922929",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r699472210"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699472210"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r690922929\r\n\r\n> When you are re-introducing this, it might be good to cleanup the complexity in this method or maybe just use the existing json serialization?\r\n\r\nThanks, exposed json functions in #22848, and now using it in this PR",
      "commit_id" : "d7c617e3580195398bbc34f1efcde548a834427e",
      "created_at" : "2021-08-31T16:06:18Z",
      "diff_hunk" : "@@ -533,6 +533,24 @@ class CSubNet\n     friend bool operator==(const CSubNet& a, const CSubNet& b);\n     friend bool operator!=(const CSubNet& a, const CSubNet& b) { return !(a == b); }\n     friend bool operator<(const CSubNet& a, const CSubNet& b);\n+\n+    SERIALIZE_METHODS(CSubNet, obj)\n+    {\n+        READWRITE(obj.network);\n+        if (obj.network.IsIPv4()) {\n+            // Before commit 102867c587f5f7954232fb8ed8e85cda78bb4d32, CSubNet used the last 4 bytes of netmask\n+            // to store the relevant bytes for an IPv4 mask. For compatibility reasons, keep doing so in\n+            // serialized form.\n+            unsigned char dummy[12] = {0};\n+            READWRITE(dummy);\n+            READWRITE(MakeSpan(obj.netmask).first(4));\n+        } else {\n+            READWRITE(obj.netmask);\n+        }\n+        READWRITE(obj.valid);\n+        // Mark invalid if the result doesn't pass sanity checking.\n+        SER_READ(obj, if (obj.valid) obj.valid = obj.SanityCheck());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r699472210",
      "id" : 699472210,
      "in_reply_to_id" : 690922929,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5OTQ3MjIxMA==",
      "original_commit_id" : "aa05f698fec48392c379c9858c2543aebba8ce2b",
      "original_line" : 552,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/netaddress.h",
      "position" : null,
      "pull_request_review_id" : 742928169,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-31T16:17:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/699472210",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-09-01T09:27:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-910105616",
      "id" : 910105616,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5842PxwQ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-01T09:27:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/910105616",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-09-24T13:55:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-926644812",
      "id" : 926644812,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5843O3pM",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-24T13:55:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/926644812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased a56f8ebeb93e6016b2719644a1212c5a34a44396 -> 884d3e1dfa0d46472cd26093142331e51fb9f2ae ([`pr/ipc.160`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.160) -> [`pr/ipc.161`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.161), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.160-rebase..pr/ipc.161)) due to conflicts with #12677, #23065, #22818, #23060, #17211, and #22951\r\n",
      "created_at" : "2021-10-06T03:40:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-935367772",
      "id" : 935367772,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5843wJRc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/935367772/reactions"
      },
      "updated_at" : "2021-10-06T03:40:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/935367772",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-10-15T09:41:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-944152580",
      "id" : 944152580,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5844RqAE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/944152580/reactions"
      },
      "updated_at" : "2021-10-15T09:41:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/944152580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased 884d3e1dfa0d46472cd26093142331e51fb9f2ae -> b9b40ae00e6eef8487e197aff2a9a4a0d07bee12 ([`pr/ipc.161`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.161) -> [`pr/ipc.162`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.162), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.161-rebase..pr/ipc.162)) due to conflict with #22937\r\nRebased b9b40ae00e6eef8487e197aff2a9a4a0d07bee12 -> eb01cec5c5e71f2dfa4b413ee3759bb78ecf8566 ([`pr/ipc.162`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.162) -> [`pr/ipc.163`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.163), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.162-rebase..pr/ipc.163)) after merge of #23006\r\nUpdated eb01cec5c5e71f2dfa4b413ee3759bb78ecf8566 -> 03869abd23949dc4d4315d2b647acd5696f5a0db ([`pr/ipc.163`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.163) -> [`pr/ipc.164`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.164), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.163..pr/ipc.164)) dropping ArgsManager private member hack\r\nRebased 03869abd23949dc4d4315d2b647acd5696f5a0db -> 4004e0b4a6e52016f36e0054d869ffdf9e719a1e ([`pr/ipc.164`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.164) -> [`pr/ipc.165`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.165), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.164-rebase..pr/ipc.165)) due to conflicts due to conflicts with #23345 and #23474\r\nRebased 4004e0b4a6e52016f36e0054d869ffdf9e719a1e -> 4b255e1e938d254231d4455a1d4bf61794ba1511 ([`pr/ipc.165`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.165) -> [`pr/ipc.166`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.166), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.165-rebase..pr/ipc.166)) due to conflict with #22364\r\nUpdated 4b255e1e938d254231d4455a1d4bf61794ba1511 -> eef402d2913fdb9f13af73f9fbc789611cf60360 ([`pr/ipc.166`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.166) -> [`pr/ipc.167`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.167), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.166..pr/ipc.167)) to fix silent conflict with #23591",
      "created_at" : "2021-10-25T19:20:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-951233376",
      "id" : 951233376,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5844sqtg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/951233376/reactions"
      },
      "updated_at" : "2021-11-29T22:30:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/951233376",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-10-26T15:24:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-952051496",
      "id" : 952051496,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5844vyco",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/952051496/reactions"
      },
      "updated_at" : "2021-10-26T15:24:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/952051496",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-11-15T17:27:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-969140789",
      "id" : 969140789,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5845w-o1",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/969140789/reactions"
      },
      "updated_at" : "2021-11-15T17:27:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/969140789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-11-22T11:06:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-975408172",
      "id" : 975408172,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5846I4ws",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/975408172/reactions"
      },
      "updated_at" : "2021-11-22T11:06:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/975408172",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765500474"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765500474"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In that case it may be good to add comments that the long timeout is due to IPC. ",
      "commit_id" : "eef402d2913fdb9f13af73f9fbc789611cf60360",
      "created_at" : "2021-12-09T07:43:58Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n         self.extra_args = [['-acceptnonstdtxn=1']]  # This is a consensus block test, we don't care about tx policy\n+        self.rpc_timeout = 1920",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765500474",
      "id" : 765500474,
      "in_reply_to_id" : 433880214,
      "line" : 89,
      "node_id" : "PRRC_kwDOABII584toJw6",
      "original_commit_id" : "b737e5397af4cedde1aec47f5b4e87c2521efdd0",
      "original_line" : 89,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/feature_block.py",
      "position" : 4,
      "pull_request_review_id" : 827293918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765500474/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T08:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765500474",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765515682"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765515682"
         }
      },
      "author_association" : "MEMBER",
      "body" : "eae99d609c7a08fde35e723967d078904ad1cd05  That seems a different Bitcoin Core PR... however there have been a few VectorReader merges recently.",
      "commit_id" : "eef402d2913fdb9f13af73f9fbc789611cf60360",
      "created_at" : "2021-12-09T08:06:02Z",
      "diff_hunk" : "@@ -0,0 +1,281 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CAPNP_COMMON_TYPES_H\n+#define BITCOIN_IPC_CAPNP_COMMON_TYPES_H\n+\n+#include <chainparams.h>\n+#include <consensus/validation.h>\n+#include <ipc/capnp/common.capnp.proxy.h>\n+#include <mp/proxy-types.h>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <wallet/coincontrol.h>\n+\n+namespace ipc {\n+namespace capnp {\n+//! Convert kj::StringPtr to std::string.\n+inline std::string ToString(const kj::StringPtr& str) { return {str.cStr(), str.size()}; }\n+\n+//! Convert kj::ArrayPtr to std::string.\n+inline std::string ToString(const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    return {reinterpret_cast<const char*>(data.begin()), data.size()};\n+}\n+\n+//! Convert array object to kj::ArrayPtr.\n+template <typename Array>\n+inline kj::ArrayPtr<const kj::byte> ToArray(const Array& array)\n+{\n+    return {reinterpret_cast<const kj::byte*>(array.data()), array.size()};\n+}\n+\n+//! Convert base_blob to kj::ArrayPtr.\n+template <typename Blob>\n+inline kj::ArrayPtr<const kj::byte> FromBlob(const Blob& blob)\n+{\n+    return {blob.begin(), blob.size()};\n+}\n+\n+//! Convert kj::ArrayPtr to base_blob\n+template <typename Blob>\n+inline Blob ToBlob(kj::ArrayPtr<const kj::byte> data)\n+{\n+    // TODO: Avoid temp vector.\n+    return Blob(std::vector<unsigned char>(data.begin(), data.begin() + data.size()));\n+}\n+\n+//! Serialize bitcoin value.\n+template <typename T>\n+CDataStream Serialize(const T& value)\n+{\n+    CDataStream stream(SER_NETWORK, CLIENT_VERSION);\n+    value.Serialize(stream);\n+    return stream;\n+}\n+\n+//! Deserialize bitcoin value.\n+template <typename T>\n+T Unserialize(T& value, const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    // Could optimize, it unnecessarily copies the data into a temporary vector.\n+    CDataStream stream({data.begin(), data.end()}, SER_NETWORK, CLIENT_VERSION);\n+    value.Unserialize(stream);\n+    return value;\n+}\n+\n+//! Deserialize bitcoin value.\n+template <typename T>\n+T Unserialize(const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    T value;\n+    Unserialize(value, data);\n+    return value;\n+}\n+\n+template <typename T>\n+using Deserializable = std::is_constructible<T, ::deserialize_type, ::CDataStream&>;\n+\n+template <typename T>\n+struct Unserializable\n+{\n+private:\n+    template <typename C>\n+    static std::true_type test(decltype(std::declval<C>().Unserialize(std::declval<C&>()))*);\n+    template <typename>\n+    static std::false_type test(...);\n+\n+public:\n+    static constexpr bool value = decltype(test<T>(nullptr))::value;\n+};\n+\n+template <typename T>\n+struct Serializable\n+{\n+private:\n+    template <typename C>\n+    static std::true_type test(decltype(std::declval<C>().Serialize(std::declval<C&>()))*);\n+    template <typename>\n+    static std::false_type test(...);\n+\n+public:\n+    static constexpr bool value = decltype(test<T>(nullptr))::value;\n+};\n+} // namespace capnp\n+} // namespace ipc\n+\n+namespace mp {\n+//!@{\n+//! Functions to serialize / deserialize bitcoin objects that don't\n+//! already provide their own serialization.\n+void CustomBuildMessage(InvokeContext& invoke_context,\n+                        const UniValue& univalue,\n+                        ipc::capnp::messages::UniValue::Builder&& builder);\n+void CustomReadMessage(InvokeContext& invoke_context,\n+                       const ipc::capnp::messages::UniValue::Reader& reader,\n+                       UniValue& univalue);\n+//!@}\n+\n+template <typename LocalType, typename Reader, typename ReadDest>\n+decltype(auto) CustomReadField(\n+    TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Reader&& reader,\n+    ReadDest&& read_dest,\n+    decltype(CustomReadMessage(invoke_context, reader.get(), std::declval<LocalType&>()))* enable = nullptr)\n+{\n+    return read_dest.update([&](auto& value) { CustomReadMessage(invoke_context, reader.get(), value); });\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto CustomPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> decltype(CustomPassMessage(server_context,\n+                                  Accessor::get(server_context.call_context.getParams()),\n+                                  Accessor::init(server_context.call_context.getResults()),\n+                                  nullptr))\n+{\n+    CustomPassMessage(server_context, Accessor::get(server_context.call_context.getParams()),\n+                      Accessor::init(server_context.call_context.getResults()),\n+                      [&](LocalType param) { fn.invoke(server_context, std::forward<Args>(args)..., param); });\n+}\n+\n+template <typename LocalType, typename Input, typename ReadDest>\n+decltype(auto) CustomReadField(\n+    TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    ReadDest&& read_dest,\n+    typename std::enable_if<ipc::capnp::Deserializable<LocalType>::value>::type* enable = nullptr)\n+{\n+    assert(input.has());\n+    auto data = input.get();\n+    // Note: stream copy here is unnecessary, and can be avoided in the future\n+    // when `VectorReader` from #12254 is added.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765515682",
      "id" : 765515682,
      "line" : 169,
      "node_id" : "PRRC_kwDOABII584toNei",
      "original_commit_id" : "eae99d609c7a08fde35e723967d078904ad1cd05",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/ipc/capnp/common-types.h",
      "position" : 169,
      "pull_request_review_id" : 827293918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765515682/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T08:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765515682",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765524867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765524867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "0a2a04655abf572005b7fefb474f47dce0480d32 : what is this?",
      "commit_id" : "eef402d2913fdb9f13af73f9fbc789611cf60360",
      "created_at" : "2021-12-09T08:12:58Z",
      "diff_hunk" : "@@ -0,0 +1,16 @@\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+@0xebd8f46e2f369076;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765524867",
      "id" : 765524867,
      "line" : 5,
      "node_id" : "PRRC_kwDOABII584toPuD",
      "original_commit_id" : "0a2a04655abf572005b7fefb474f47dce0480d32",
      "original_line" : 5,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/ipc/capnp/handler.capnp",
      "position" : 5,
      "pull_request_review_id" : 827293918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765524867/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T08:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765524867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771624998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771624998"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765515682\r\n\r\n> [eae99d6](https://github.com/bitcoin/bitcoin/commit/eae99d609c7a08fde35e723967d078904ad1cd05) That seems a different Bitcoin Core PR... however there have been a few VectorReader merges recently.\r\n\r\nThanks, switched to SpanReader which was introduced in #23653.\r\n",
      "commit_id" : "69fd898bb1b598293ac54e9125809ee667b82c83",
      "created_at" : "2021-12-17T18:49:29Z",
      "diff_hunk" : "@@ -0,0 +1,281 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_IPC_CAPNP_COMMON_TYPES_H\n+#define BITCOIN_IPC_CAPNP_COMMON_TYPES_H\n+\n+#include <chainparams.h>\n+#include <consensus/validation.h>\n+#include <ipc/capnp/common.capnp.proxy.h>\n+#include <mp/proxy-types.h>\n+#include <net_processing.h>\n+#include <netbase.h>\n+#include <util/translation.h>\n+#include <validation.h>\n+#include <wallet/coincontrol.h>\n+\n+namespace ipc {\n+namespace capnp {\n+//! Convert kj::StringPtr to std::string.\n+inline std::string ToString(const kj::StringPtr& str) { return {str.cStr(), str.size()}; }\n+\n+//! Convert kj::ArrayPtr to std::string.\n+inline std::string ToString(const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    return {reinterpret_cast<const char*>(data.begin()), data.size()};\n+}\n+\n+//! Convert array object to kj::ArrayPtr.\n+template <typename Array>\n+inline kj::ArrayPtr<const kj::byte> ToArray(const Array& array)\n+{\n+    return {reinterpret_cast<const kj::byte*>(array.data()), array.size()};\n+}\n+\n+//! Convert base_blob to kj::ArrayPtr.\n+template <typename Blob>\n+inline kj::ArrayPtr<const kj::byte> FromBlob(const Blob& blob)\n+{\n+    return {blob.begin(), blob.size()};\n+}\n+\n+//! Convert kj::ArrayPtr to base_blob\n+template <typename Blob>\n+inline Blob ToBlob(kj::ArrayPtr<const kj::byte> data)\n+{\n+    // TODO: Avoid temp vector.\n+    return Blob(std::vector<unsigned char>(data.begin(), data.begin() + data.size()));\n+}\n+\n+//! Serialize bitcoin value.\n+template <typename T>\n+CDataStream Serialize(const T& value)\n+{\n+    CDataStream stream(SER_NETWORK, CLIENT_VERSION);\n+    value.Serialize(stream);\n+    return stream;\n+}\n+\n+//! Deserialize bitcoin value.\n+template <typename T>\n+T Unserialize(T& value, const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    // Could optimize, it unnecessarily copies the data into a temporary vector.\n+    CDataStream stream({data.begin(), data.end()}, SER_NETWORK, CLIENT_VERSION);\n+    value.Unserialize(stream);\n+    return value;\n+}\n+\n+//! Deserialize bitcoin value.\n+template <typename T>\n+T Unserialize(const kj::ArrayPtr<const kj::byte>& data)\n+{\n+    T value;\n+    Unserialize(value, data);\n+    return value;\n+}\n+\n+template <typename T>\n+using Deserializable = std::is_constructible<T, ::deserialize_type, ::CDataStream&>;\n+\n+template <typename T>\n+struct Unserializable\n+{\n+private:\n+    template <typename C>\n+    static std::true_type test(decltype(std::declval<C>().Unserialize(std::declval<C&>()))*);\n+    template <typename>\n+    static std::false_type test(...);\n+\n+public:\n+    static constexpr bool value = decltype(test<T>(nullptr))::value;\n+};\n+\n+template <typename T>\n+struct Serializable\n+{\n+private:\n+    template <typename C>\n+    static std::true_type test(decltype(std::declval<C>().Serialize(std::declval<C&>()))*);\n+    template <typename>\n+    static std::false_type test(...);\n+\n+public:\n+    static constexpr bool value = decltype(test<T>(nullptr))::value;\n+};\n+} // namespace capnp\n+} // namespace ipc\n+\n+namespace mp {\n+//!@{\n+//! Functions to serialize / deserialize bitcoin objects that don't\n+//! already provide their own serialization.\n+void CustomBuildMessage(InvokeContext& invoke_context,\n+                        const UniValue& univalue,\n+                        ipc::capnp::messages::UniValue::Builder&& builder);\n+void CustomReadMessage(InvokeContext& invoke_context,\n+                       const ipc::capnp::messages::UniValue::Reader& reader,\n+                       UniValue& univalue);\n+//!@}\n+\n+template <typename LocalType, typename Reader, typename ReadDest>\n+decltype(auto) CustomReadField(\n+    TypeList<LocalType>,\n+    Priority<2>,\n+    InvokeContext& invoke_context,\n+    Reader&& reader,\n+    ReadDest&& read_dest,\n+    decltype(CustomReadMessage(invoke_context, reader.get(), std::declval<LocalType&>()))* enable = nullptr)\n+{\n+    return read_dest.update([&](auto& value) { CustomReadMessage(invoke_context, reader.get(), value); });\n+}\n+\n+template <typename Accessor, typename LocalType, typename ServerContext, typename Fn, typename... Args>\n+auto CustomPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn, Args&&... args)\n+    -> decltype(CustomPassMessage(server_context,\n+                                  Accessor::get(server_context.call_context.getParams()),\n+                                  Accessor::init(server_context.call_context.getResults()),\n+                                  nullptr))\n+{\n+    CustomPassMessage(server_context, Accessor::get(server_context.call_context.getParams()),\n+                      Accessor::init(server_context.call_context.getResults()),\n+                      [&](LocalType param) { fn.invoke(server_context, std::forward<Args>(args)..., param); });\n+}\n+\n+template <typename LocalType, typename Input, typename ReadDest>\n+decltype(auto) CustomReadField(\n+    TypeList<LocalType>,\n+    Priority<1>,\n+    InvokeContext& invoke_context,\n+    Input&& input,\n+    ReadDest&& read_dest,\n+    typename std::enable_if<ipc::capnp::Deserializable<LocalType>::value>::type* enable = nullptr)\n+{\n+    assert(input.has());\n+    auto data = input.get();\n+    // Note: stream copy here is unnecessary, and can be avoided in the future\n+    // when `VectorReader` from #12254 is added.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771624998",
      "id" : 771624998,
      "in_reply_to_id" : 765515682,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584t_hAm",
      "original_commit_id" : "eae99d609c7a08fde35e723967d078904ad1cd05",
      "original_line" : 158,
      "original_position" : 158,
      "original_start_line" : null,
      "path" : "src/ipc/capnp/common-types.h",
      "position" : null,
      "pull_request_review_id" : 835544043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771624998/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T21:29:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771624998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771625201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771625201"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765524867\r\n\r\n> [0a2a046](https://github.com/bitcoin/bitcoin/commit/0a2a04655abf572005b7fefb474f47dce0480d32) : what is this?\r\n\r\nThis is a required part of every .capnp file. It's basically a UUID that acts like a namespace for types defined in the file. It is generated by running [`capnp id`](https://capnproto.org/capnp-tool.html), and is used as a form of namespacing to ensure that even if types from different files or different projects have the same names, their binary representations won't conflict and there wont be any ambiguities in the protocol if objects from different files are serialized together.\r\n\r\nI could add a comment like `# Random unique identifier for this Cap'n Proto schema file generated by \"capnp id\"` to the top of every `.capnp` file if that would be helpful. Opting not to for now since it seems maybe too verbose like writing `/* This is an include guard to prevent this header from being included twice. */` in a C header.",
      "commit_id" : "69fd898bb1b598293ac54e9125809ee667b82c83",
      "created_at" : "2021-12-17T18:49:44Z",
      "diff_hunk" : "@@ -0,0 +1,16 @@\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+@0xebd8f46e2f369076;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771625201",
      "id" : 771625201,
      "in_reply_to_id" : 765524867,
      "line" : 5,
      "node_id" : "PRRC_kwDOABII584t_hDx",
      "original_commit_id" : "0a2a04655abf572005b7fefb474f47dce0480d32",
      "original_line" : 5,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/ipc/capnp/handler.capnp",
      "position" : 5,
      "pull_request_review_id" : 835544043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771625201/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T21:29:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771625201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771635772"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771635772"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#discussion_r765500474\r\n\r\n> In that case it may be good to add comments that the long timeout is due to IPC.\r\n\r\nI'm happy to add a specific comment if you want to suggest one, but I can't think of what would be appropriate to say here about IPC. IPC does slow things down generally, like running on a slow machine, and I think it's expected that if you run code in a new environment, you may need to adjust some parameters that didn't have enough tolerance.\r\n\r\nIt's true that there are a lot of places where we can change application code to have better performance over IPC (basically just places IPC methods are called in a repeatedly and we can reduce the number of round trips), but it wouldn't seem seem appropriate to put comments about it here in the middle of this one test.",
      "commit_id" : "69fd898bb1b598293ac54e9125809ee667b82c83",
      "created_at" : "2021-12-17T19:07:05Z",
      "diff_hunk" : "@@ -83,6 +83,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.setup_clean_chain = True\n         self.extra_args = [['-acceptnonstdtxn=1']]  # This is a consensus block test, we don't care about tx policy\n+        self.rpc_timeout = 1920",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r771635772",
      "id" : 771635772,
      "in_reply_to_id" : 433880214,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII584t_jo8",
      "original_commit_id" : "b737e5397af4cedde1aec47f5b4e87c2521efdd0",
      "original_line" : 94,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "test/functional/feature_block.py",
      "position" : 4,
      "pull_request_review_id" : 835544043,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771635772/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-17T21:29:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/771635772",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated 8a18a12a23277c64e2af05867607ed4471b1a692 -> c9d036fbbbcaa8ed2f152e96199a1a8c4e9af61a ([`pr/ipc.168`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.168) -> [`pr/ipc.169`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.169), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.168..pr/ipc.169)) to address Sjors review comments fixing compile warnings, resolving common-types.h todos, and cleaning comon-types.h up in general\r\nRebased c9d036fbbbcaa8ed2f152e96199a1a8c4e9af61a -> 5b01b969d983a18c1c9b355561881e5cd2cceba9 ([`pr/ipc.169`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.169) -> [`pr/ipc.170`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.170), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.169-rebase..pr/ipc.170)) due to conflicts with #23842 and bitcoin-core/gui#459\r\nRebased 5b01b969d983a18c1c9b355561881e5cd2cceba9 -> 8ae8971c4add0e7d576da1ec42e78677e1a4bc29 ([`pr/ipc.170`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.170) -> [`pr/ipc.171`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.171), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.170-rebase..pr/ipc.171)) updating libmultiprocess to fix CI failure https://github.com/bitcoin/bitcoin/pull/10102/checks?check_run_id=4671391974 https://github.com/chaincodelabs/libmultiprocess/pull/65 and fixing python conflict with #23737\r\nRebased 8ae8971c4add0e7d576da1ec42e78677e1a4bc29 -> d1b4509566cbd04e22eb4532dbb02cfa2c7431b2 ([`pr/ipc.171`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.171) -> [`pr/ipc.172`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.172), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.171-rebase..pr/ipc.172)) due to conflicts with #23828 and #23737 which caused feature_init failures https://cirrus-ci.com/task/6140731099185152?logs=ci#L3687 https://cirrus-ci.com/task/6476143623667712?logs=ci#L4499 https://cirrus-ci.com/task/4626904987729920?logs=ci#L3459 https://cirrus-ci.com/task/4801360519495680?logs=ci#L2542 https://cirrus-ci.com/task/4852867377922048?logs=ci#L7675 https://cirrus-ci.com/task/5210661306236928?logs=ci#L5807\r\nRebased d1b4509566cbd04e22eb4532dbb02cfa2c7431b2 -> 69fd898bb1b598293ac54e9125809ee667b82c83 ([`pr/ipc.172`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.172) -> [`pr/ipc.173`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.173), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.172-rebase..pr/ipc.173)) due to conflicts with #23497, #24039, and #24026\r\n",
      "created_at" : "2021-12-22T18:24:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-999778541",
      "id" : 999778541,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5847l2jt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/999778541/reactions"
      },
      "updated_at" : "2022-01-13T21:05:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/999778541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-12-23T14:52:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1000355184",
      "id" : 1000355184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5847oDVw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1000355184/reactions"
      },
      "updated_at" : "2021-12-23T14:52:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1000355184",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-01-03T08:41:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1003941136",
      "id" : 1003941136,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII58471u0Q",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1003941136/reactions"
      },
      "updated_at" : "2022-01-03T08:41:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1003941136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-01-06T14:15:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1006623973",
      "id" : 1006623973,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5847_9zl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1006623973/reactions"
      },
      "updated_at" : "2022-01-06T14:15:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1006623973",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-01-11T10:40:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1009833334",
      "id" : 1009833334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5848MNV2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1009833334/reactions"
      },
      "updated_at" : "2022-01-11T10:40:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1009833334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "tACK 69fd898bb1b598293ac54e9125809ee667b82c83 modulo crash :-(\r\n\r\nI updated multiprocess and flood of warnings disappeared.\r\n\r\nPerhaps you missed something during rebase on https://github.com/bitcoin-core/gui/pull/459. I'm able to consistently crash the bitcoin-gui (or the wallet process) when generating a new Taproot address. Let me know if you can't reproduce it, in which case I'll try to get a debugger to work again on macOS.\r\n\r\nWallet log:\r\n```\r\n2022-01-14T14:45:54Z [] {bitcoin-wallet-75194/0x11292c600} IPC server recv request  #546 Wallet.setAddressReceiveRequest$Params (context = (thread = <external capability>, callbackThread = <external capability>), dest = (), id = \"8\", value = \"\\\\001\\\\000\\\\000\\\\000\\\\b\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\242\\\\214\\\\341a\\\\001\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\\\\000\")\r\n2022-01-14T14:45:54Z [] {bitcoin-wallet-75194/0x11292c600} IPC server post request  #546 {bitcoin-wallet-75194/0x70000f53d000 (from bitcoin-node-75191/0x70000186b000 (from bitcoin-gui-75190/0x11ace6600))}\r\n```\r\n\r\nGui log:\r\n```\r\n2022-01-14T14:45:54Z [main] GUI: Qt has caught an exception thrown from an event handler. Throwing\r\nexceptions from an event handler is not supported in Qt.\r\nYou must not let any exception whatsoever propagate through Qt code.\r\nIf that is not possible, in Qt 5 you must at least reimplement\r\nQCoreApplication::notify() and catch all exceptions there.\r\n\r\n2022-01-14T14:45:54Z [main] \r\n\r\n************************\r\nEXCEPTION: N3ipc9ExceptionE       \r\nkj::Exception: capnp/rpc.c++:2413: disconnected: Peer disconnected.\r\nstack: 10d1734ea 10d184242 10cd33590 10cd33ec0       \r\nbitcoin in Runaway exception       \r\n```\r\n\r\nI also get an exception when I quit (Command + q) the gui immediately after launch, e.g. while it's still loading wallets and such. Combined log:\r\n\r\n```\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server recv request  #202 Chain.destroy$Params (context = (thread = <external capability>, callbackThread = <external capability>))\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server post request  #202 {bitcoin-node-75387/0x70000b480000 (from bitcoin-gui-75385/b-qt-init-0x7000103c3000)}\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server send response #202 Chain.destroy$Results ()\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x70000744f000 (from bitcoin-node-75387/0x70000b480000 (from bitcoin-gui-75385/b-qt-init-0x7000103c3000))} IPC client recv Chain.destroy$Results ()\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server destroyN2mp11ProxyServerIN3ipc5capnp8messages5ChainEEE\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} IPC server send response #19 ChainClient.destroy$Results ()\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x70000b480000 (from bitcoin-gui-75385/b-qt-init-0x7000103c3000)} IPC client recv ChainClient.destroy$Results ()\r\n2022-01-14T14:49:48Z [shutoff] {bitcoin-node-75387/0x70000b480000 (from bitcoin-gui-75385/b-qt-init-0x7000103c3000)} IPC client destroy N2mp11ProxyClientIN3ipc5capnp8messages4InitEEE\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} IPC server destroyN2mp11ProxyServerIN3ipc5capnp8messages12WalletLoaderEEE\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} IPC server: socket disconnected.\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} IPC server destroyN2mp11ProxyServerIN3ipc5capnp8messages4InitEEE\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} EventLoop::loop done, cancelling event listeners.\r\n2022-01-14T14:49:48Z [] {bitcoin-wallet-75389/0x11c07a600} EventLoop::loop bye.\r\n2022-01-14T14:49:48Z [shutoff] Process bitcoin-wallet pid 75389 exited with status 0\r\n2022-01-14T14:49:48Z [shutoff] Shutdown: done\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server send response #116 Node.appShutdown$Results ()\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server recv request  #203 Node.appShutdown$Params (context = (thread = <external capability>, callbackThread = <external capability>))\r\n2022-01-14T14:49:48Z [] {bitcoin-node-75387/0x10aba1600} IPC server post request  #203 {bitcoin-node-75387/0x70000b480000 (from bitcoin-gui-75385/b-qt-init-0x7000103c3000)}\r\n2022-01-14T14:49:48Z [shutoff] Shutdown: In progress...\r\nAssertion failed: (\"node.args\" && check), function operator(), file init.cpp, line 203.\r\n2022-01-14T14:49:48Z [qt-init] \r\n\r\n************************\r\nEXCEPTION: N3ipc9ExceptionE       \r\nkj::Exception: capnp/rpc.c++:2413: disconnected: Peer disconnected.\r\nstack: 1057544ea 105765242 105221a30 105222360       \r\nbitcoin in Runaway exception       \r\n```",
      "created_at" : "2022-01-14T14:51:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1013193492",
      "id" : 1013193492,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5848ZBsU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1013193492/reactions"
      },
      "updated_at" : "2022-01-14T14:51:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1013193492",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r784906151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/784906151"
         }
      },
      "author_association" : "MEMBER",
      "body" : "cdd239245c30e167a853a75ba37ace42ad5376a3 nit: it's a bit odd to introduce this here, since this commit doesn't use it.",
      "commit_id" : "69fd898bb1b598293ac54e9125809ee667b82c83",
      "created_at" : "2022-01-14T14:53:59Z",
      "diff_hunk" : "@@ -276,6 +276,32 @@ auto CustomPassField(TypeList<LocalType>, ServerContext& server_context, Fn&& fn\n                       Accessor::init(server_context.call_context.getResults()),\n                       [&](LocalType param) { fn.invoke(server_context, std::forward<Args>(args)..., param); });\n }\n+\n+//! Generic ::capnp::Data field builder for any class that a Span can be\n+//! constructed from, particularly BaseHash and base_blob classes and\n+//! subclasses. It's not currently possible to make a generic ::capnp::Data\n+//! ReadField function for these classes because they all have inconsistent\n+//! constructors. For example the PKHash class has a constructor specifically\n+//! expecting a uint160 argument, and there's no way a generic CustomReadField\n+//! implementation would be able to detect the required argument type. This\n+//! could be cleaned up in the future by adding Span constructors to all these\n+//! classes and writing a ::capnp::Data CustomReadField function that is called\n+//! for any class with a single-argument Span constructor.\n+template <typename LocalType, typename Value, typename Output>\n+void CustomBuildField(",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r784906151",
      "id" : 784906151,
      "line" : 291,
      "node_id" : "PRRC_kwDOABII584uyLen",
      "original_commit_id" : "cdd239245c30e167a853a75ba37ace42ad5376a3",
      "original_line" : 291,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/ipc/capnp/common-types.h",
      "position" : 16,
      "pull_request_review_id" : 853007151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/784906151/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-14T15:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/784906151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-01-31T18:50:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1026098053",
      "id" : 1026098053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII5849KQOF",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1026098053/reactions"
      },
      "updated_at" : "2022-01-31T18:50:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1026098053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r848720128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/848720128"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's unclear to me what need to be updated in `ipc/capnp/node.cpp` in case of new members added to `CNodeStateStats` ? Also for better clarity the object wrapper could be quoted `NodeStateStats`. Here and for `CNodeStats` and `proxyType` comments.",
      "commit_id" : "69fd898bb1b598293ac54e9125809ee667b82c83",
      "created_at" : "2022-04-12T18:00:16Z",
      "diff_hunk" : "@@ -32,6 +32,9 @@ struct CNodeStateStats {\n     uint64_t m_addr_processed = 0;\n     uint64_t m_addr_rate_limited = 0;\n     bool m_addr_relay_enabled{false};\n+    // Note: If you add fields to this struct, you should also consider updating\n+    // the getpeerinfo RPC (in rpc/net.cpp), and the IPC serialization code (in\n+    // ipc/capnp/node.cpp and ipc/capnp/node.capnp).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#discussion_r848720128",
      "id" : 848720128,
      "line" : 37,
      "node_id" : "PRRC_kwDOABII584ylnEA",
      "original_commit_id" : "a5116a57a99f10ba971a67672bf1bf415d14385f",
      "original_line" : 37,
      "original_position" : 6,
      "original_start_line" : null,
      "path" : "src/net_processing.h",
      "position" : 6,
      "pull_request_review_id" : 939949614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10102",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/848720128/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-04-12T18:19:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/848720128",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-08-30T16:37:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1231906223",
      "id" : 1231906223,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585JbWWv",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1231906223/reactions"
      },
      "updated_at" : "2022-08-30T16:37:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1231906223",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Checked changes since review and tested 05e236772da0ed9396ce269b5fe8384b0de8e775 on macOS 12.5.1 using depends.\r\n\r\nThe receive address labels have disappeared in GUI, probably because it can no longer see which address the payment was received on. See e.g. this descriptor wallet:\r\n\r\n<img width=\"832\" alt=\"Schermafbeelding 2022-09-09 om 15 09 30\" src=\"https://user-images.githubusercontent.com/10217/189357508-e90338c0-4e78-4643-9d4f-2e68e8e0d7dd.png\">\r\n\r\nIt _does_ still show labels for \"sent to\".\r\n\r\nI still get a crash when generating a taproot address in the GUI:\r\n\r\n```\r\n2022-09-09T13:12:37Z [main] GUI: AddressTablePriv::updateEntry: Warning: Got CT_NEW, but entry is already in model\r\nlibc++abi: terminating with uncaught exception of type std::out_of_range: map::at:  key not found\r\nlibc++abi: terminating with uncaught exception of type ipc::Exception: kj::Exception: capnp/rpc.c++:2092: disconnected: Peer disconnected.\r\nstack: 104d0b010 10181cab0 10181ced0\r\nzsh: segmentation fault  src/bitcoin-gui\r\n```\r\n\r\nWhen shutting down the GUI very quickly after starting, it shuts down cleanly now.",
      "created_at" : "2022-09-09T13:14:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1241962069",
      "id" : 1241962069,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KBtZV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1241962069/reactions"
      },
      "updated_at" : "2022-09-09T13:14:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1241962069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1241962069\r\n\r\nð Thanks for testing! I've followed up with some fixes.\r\n\r\nTaproot crash was caused by failing to serialize `WitnessV1Taproot` variant of `CTxDestination`. I fixed the problem and added an assertion to make the cause more obvious if `CTxDestination` is expanded again. I also tested sending and receiving and fixed problems with `CScript` and `Coin` serialization that were causing similar crashes. It does look like send and receive labels are displayed correctly in the transaction list now, but I'm not sure if this is because I fixed something, or am just not reproducing the bug. if you see more problems I'd like to know, and thanks again for testing!\r\n\r\nUpdated 05e236772da0ed9396ce269b5fe8384b0de8e775 -> d0bea139b7a4a158eea6fec62285646a826a62b9 ([`pr/ipc.176`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.176) -> [`pr/ipc.177`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.177), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.176..pr/ipc.177)) with fixes",
      "created_at" : "2022-09-12T15:51:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1243940989",
      "id" : 1243940989,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KJQh9",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1243940989/reactions"
      },
      "updated_at" : "2022-09-12T15:51:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1243940989",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky linter complains: `Unrecognized address type. Serialization not implemented for`",
      "created_at" : "2022-09-13T07:04:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1244987658",
      "id" : 1244987658,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KNQEK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1244987658/reactions"
      },
      "updated_at" : "2022-09-13T07:04:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1244987658",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @ryanofsky linter complains: `Unrecognized address type. Serialization not implemented for`\r\n\r\nThanks, fixed now.\r\n\r\nUpdated d0bea139b7a4a158eea6fec62285646a826a62b9 -> d6277e015c2cca0f6e890989024b7edef52da1cb ([`pr/ipc.177`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.177) -> [`pr/ipc.178`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.178), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.177..pr/ipc.178)) fixing Unrecognized address type strprintf",
      "created_at" : "2022-09-13T19:21:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1245857542",
      "id" : 1245857542,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KQkcG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1245857542/reactions"
      },
      "updated_at" : "2022-09-13T19:21:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1245857542",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Is this the current multiprocess pull to review? (If yes, will review. It builds cleanly for me. Thanks!)",
      "created_at" : "2022-09-14T12:21:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1246682860",
      "id" : 1246682860,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KTt7s",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1246682860/reactions"
      },
      "updated_at" : "2022-09-14T12:21:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1246682860",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jonatack also have been curious about this -- it might make sense to open a new PR for it since GH's UX kinda craps the bed on being able to look at other's reviews once it's like this\r\n<img width=\"188\" alt=\"image\" src=\"https://user-images.githubusercontent.com/886523/190208093-a11b1998-13af-46e0-bbb8-4d41b47e74bb.png\">\r\n",
      "created_at" : "2022-09-14T16:18:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1247005196",
      "id" : 1247005196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KU8oM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247005196/reactions"
      },
      "updated_at" : "2022-09-14T16:18:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247005196",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Is this the current multiprocess pull to review? (If yes, will review. It builds cleanly for me. Thanks!)\r\n\r\nYes this is working, and up to date, and split up into commits that should make it easier to review. I think all the information needed to review is covered or linked to in the PR description, and it's safe to ignore the older comment threads. But I can open a new PR if github's UX makes it difficult to review or comment on this one.",
      "created_at" : "2022-09-14T21:12:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1247308215",
      "id" : 1247308215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KWGm3",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247308215/reactions"
      },
      "updated_at" : "2022-09-14T21:16:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247308215",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@JeremyRubin if that helps, I wrote a script to expand PR comments: https://gist.github.com/aureleoules/6bafcf3e255bfd528ef4e3d034f87dbc. Takes a bit of time to run on this PR though.",
      "created_at" : "2022-09-15T08:30:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1247765688",
      "id" : 1247765688,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585KX2S4",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247765688/reactions"
      },
      "updated_at" : "2022-09-15T08:30:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1247765688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased a1b6968c4c2adb978a04386a2154f3f1b32b711b -> d8a971115bcd058606d5185fcc5be46c82bb3b2a ([`pr/ipc.180`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.180) -> [`pr/ipc.181`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.181), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.180-rebase..pr/ipc.181)) due to silent conflict with #25737\r\nSquashed d8a971115bcd058606d5185fcc5be46c82bb3b2a -> f8d5af9518b02ee017a90a6e5aede3dff8e62a00 ([`pr/ipc.181`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.181) -> [`pr/ipc.182`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.182), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.181..pr/ipc.182))\r\n",
      "created_at" : "2022-09-26T16:40:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1258327138",
      "id" : 1258327138,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585LAIxi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1258327138/reactions"
      },
      "updated_at" : "2022-09-26T18:46:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1258327138",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "libmultiprocess seems like it would better fit as a subtree (a la leveldb, secp256k1, etc.) rather than a dependency given that it is slightly more difficult to install than all of our other dependencies. It also should probably be moved under the bitcoin-core org.",
      "created_at" : "2022-10-17T19:14:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1281351101",
      "id" : 1281351101,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585MX929",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1281351101/reactions"
      },
      "updated_at" : "2022-10-17T19:14:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1281351101",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, will review this week.",
      "created_at" : "2022-10-25T11:32:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1290404224",
      "id" : 1290404224,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585M6gGA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1290404224/reactions"
      },
      "updated_at" : "2022-10-25T11:32:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1290404224",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-12-06T11:42:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1339195479",
      "id" : 1339195479,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585P0oBX",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1339195479/reactions"
      },
      "updated_at" : "2022-12-06T11:42:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1339195479",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Not sure if related or not:\r\n\r\n\r\n```\r\n  File \"/tmp/cirrus-ci-build/ci/scratch/build/bitcoin-i686-pc-linux-gnu/test/functional/wallet_backup.py\", line 217, in run_test\r\n    assert_equal(res0_rpc.getbalance(), balance0)\r\n  File \"/tmp/cirrus-ci-build/ci/scratch/build/bitcoin-i686-pc-linux-gnu/test/functional/test_framework/util.py\", line 56, in assert_equal\r\n    raise AssertionError(\"not(%s)\" % \" == \".join(str(arg) for arg in (thing1, thing2) + args))\r\nAssertionError: not(47.89978700 == 46.19956280)\r\n```\r\n\r\nhttps://cirrus-ci.com/task/4576796809625600",
      "created_at" : "2023-01-21T09:35:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1399216846",
      "id" : 1399216846,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585TZlrO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1399216846/reactions"
      },
      "updated_at" : "2023-01-21T09:35:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1399216846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1399216846\r\n\r\n> Not sure if related or not:\r\n\r\nYes, the IPC serialization code wasn't setting the `interfaces::FoundBlock.found` field, which caused wallets not to sync correctly after #26679. (The serialization bug present before #26679, but didn't have an effect until new code tried to use the missing field.)\r\n\r\n---\r\n\r\nRebased f8d5af9518b02ee017a90a6e5aede3dff8e62a00 -> 05e44e7fd41b32d57379bb6a87c4bebb4a166f9c ([`pr/ipc.182`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.182) -> [`pr/ipc.183`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.183), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.182-rebase..pr/ipc.183)) due to conflicts with #25957, #26752, #26672, and #26238\r\nRebased 05e44e7fd41b32d57379bb6a87c4bebb4a166f9c -> 5e90c75de0d13aedb7e7c06ebe5aa55b11bb398d ([`pr/ipc.183`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.183) -> [`pr/ipc.184`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.184), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.183-rebase..pr/ipc.184)) fixing wallet_backup.py CI failure https://cirrus-ci.com/task/4576796809625600?logs=ci#L2695 caused by IPC FoundBlock bug exposed by #26679, and fixing wallet_fast_rescan.py failure caused by silent conflict with #25957\r\nRebased 5e90c75de0d13aedb7e7c06ebe5aa55b11bb398d -> 80926e1b4e63d241ac8b4922b2a2a3204a9c5859 ([`pr/ipc.184`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.184) -> [`pr/ipc.185`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.185), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.184-rebase..pr/ipc.185)) to fix silent conflict with bitcoin-core/gui#697",
      "created_at" : "2023-02-13T17:37:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1428374812",
      "id" : 1428374812,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585VI0Uc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428374812/reactions"
      },
      "updated_at" : "2023-02-13T18:24:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428374812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-03-11T10:52:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1464884486",
      "id" : 1464884486,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585XUF0G",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1464884486/reactions"
      },
      "updated_at" : "2023-03-11T10:52:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1464884486",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-04-11T01:51:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1502574560",
      "id" : 1502574560,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585Zj3fg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1502574560/reactions"
      },
      "updated_at" : "2023-04-11T01:51:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1502574560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-04-21T10:43:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1517635912",
      "id" : 1517635912,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585adUlI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517635912/reactions"
      },
      "updated_at" : "2023-04-21T10:43:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517635912",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Building c86da22175e5bbe40e03624689bd3d4cc1508ba1 fails when configured without a wallet, but with gui.\r\n\r\nIntel macOS 13.3.1 with capnp 0.10.3 via homebrew and libmultiprocess 1af83d15239ccfa7e47b8764029320953dd7fdf1.\r\n\r\n```\r\n./configure --enable-suppress-external-warnings  --enable-c++20  --with-gui --enable-multiprocess --disable-bench --disable-tests --disable-external-signer --disable-fuzz-binary --disable-wallet\r\n...\r\nmake\r\n...\r\n  CXXLD    bitcoin-gui\r\nUndefined symbols for architecture x86_64:\r\n  \"wallet::CCoinControl::CCoinControl()\", referenced from:\r\n      void mp::PassField<mp::Accessor<mp::wallet_fields::CoinControl, 17>, wallet::CCoinControl const&, mp::ServerInvokeContext<mp::ProxyServer<ipc::capnp::messages::Wallet>, capnp::CallContext<ipc::capnp::messages::Wallet::CreateTransactionParams, ipc::capnp::messages::Wallet::CreateTransactionResults>>, mp::ServerField<1, mp::Accessor<mp::wallet_fields::Sign, 1>, mp::ServerField<1, mp::Accessor<mp::wallet_fields::ChangePos, 3>, mp::ServerField<1, mp::Accessor<mp::wallet_fields::Fee, 2>, mp::ServerRet<mp::Accessor<mp::wallet_fields::Result, 18>, mp::ServerCall>>>> const&, mp::TypeList<bool, int&, long long&>, std::__1::vector<wallet::CRecipient, std::__1::allocator<wallet::CRecipient>> const&>(mp::Priority<0>, mp::TypeList<wallet::CCoinControl const&>, mp::ServerInvokeContext<mp::ProxyServer<ipc::capnp::messages::Wallet>, capnp::CallContext<ipc::capnp::messages::Wallet::CreateTransactionParams, ipc::capnp::messages::Wallet::CreateTransactionResults>>&, mp::ServerField<1, mp::Accessor<mp::wallet_fields::Sign, 1>, mp::ServerField<1, mp::Accessor<mp::wallet_fields::ChangePos, 3>, mp::ServerField<1, mp::Accessor<mp::wallet_fields::Fee, 2>, mp::ServerRet<mp::Accessor<mp::wallet_fields::Result, 18>, mp::ServerCall>>>> const&, mp::TypeList<bool, int&, long long&>&&, std::__1::vector<wallet::CRecipient, std::__1::allocator<wallet::CRecipient>> const&) in libbitcoin_ipc.a(libbitcoin_ipc_a-wallet.capnp.proxy-server.o)\r\n...\r\n```\r\n\r\nWith the wallet enabled it builds fine (and connecting my GUI over SSH to a daemon with the followup PR still works great).",
      "created_at" : "2023-04-28T18:10:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1527920697",
      "id" : 1527920697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585bEjg5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527920697/reactions"
      },
      "updated_at" : "2023-04-28T18:10:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527920697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I was able to reproduce the crash I found [here](https://github.com/bitcoin/bitcoin/pull/19461#issuecomment-1536056897) using only this PR.\r\n\r\nDetails: running Ubuntu 23.04, libmultiprocess at fc28a48f01af9730be3b49585e718e11c5eea0c5 and capnproto 0.10.4 compiled from source (because of https://github.com/chaincodelabs/libmultiprocess/issues/68#issuecomment-1527856219). \r\n\r\n```\r\n./configure --enable-werror --enable-suppress-external-warnings --without-gui --enable-multiprocess\r\nâ¦\r\nsrc/bitcoin-node\r\nâ¦\r\n\r\n2023-05-05T10:45:36Z New outbound peer connected: version: 70016, blocks=788360, peer=1 (outbound-full-relay)\r\n^C2023-05-05T10:45:41Z [rpc] Interrupting HTTP RPC server\r\n2023-05-05T10:45:41Z [rpc] Interrupting RPC\r\n2023-05-05T10:45:41Z tor: Thread interrupt\r\n2023-05-05T10:45:41Z dnsseed thread exit\r\n2023-05-05T10:45:41Z addcon thread exit\r\n2023-05-05T10:45:41Z torcontrol thread exit\r\n2023-05-05T10:45:41Z Shutdown: In progress...\r\n2023-05-05T10:45:41Z [rpc] Stopping HTTP RPC server\r\n2023-05-05T10:45:41Z [rpc] Stopping RPC\r\n2023-05-05T10:45:41Z [rpc] RPC stopped.\r\nterminate called after throwing an instance of 'ipc::Exception'\r\n  what():  kj::Exception: kj/async-io-unix.c++:498: disconnected: ::read(fd, buffer, maxBytes): Connection reset by peer\r\nstack: 7f689c7ae644 7f689c7bdeab 7f689c74d1b5 7f689c7a4db0 7f689c91e720 7f689c917c20 7f689c91bdf0 7f689c97fb30 7f689c97a220 7f689c96fcc0 7f689c96b800 7f689c95b5d0 7f689c95c084 7f689c958610 55678261ed80 556782623610\r\nAborted (core dumped)\r\n```\r\n\r\nSo it happens without any client connecting, or even listening for one. I sanity checked that master at 6c7ebcc14b7908a67a8f8764b398e76c8fb4fe8b works fine when configured with `--enable-multiprocess`.\r\n\r\nRunning `bitcoind` does not have this issue.",
      "created_at" : "2023-05-05T10:51:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1536075360",
      "id" : 1536075360,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585bjqZg",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1536075360/reactions"
      },
      "updated_at" : "2023-05-05T10:51:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1536075360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ran the same commit again with `-debug=ipc` to get more useful log info. ([log](https://gist.github.com/Sjors/c2b227d5c7d210524b9ca7d78b93c2ed))\r\n\r\nI also tried disabling the indexes to simplify the setup, but that didn't prevent the issue.\r\n\r\nI also tried running with `-listen=0` and `-connect=0` so that it had no peers, but that made no difference either.",
      "created_at" : "2023-05-08T13:44:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1538386300",
      "id" : 1538386300,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585bsel8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1538386300/reactions"
      },
      "updated_at" : "2023-05-08T13:49:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1538386300",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks @Sjors. I've tried a lot of things and have not been able to reproduce the crash exactly, but the log you posted was  helpful, and I could reproduce similar error output by adding an extra call from bitcoin-node to bitcoin-wallet that sleeps in bitcoin-wallet, and then manual killing `bitcoin-wallet` process. When I do that I see similar `kj::Exception` errors on the bitcoin-node main thread and bitcoin-node b-capnp-loop thread like in your log.  In your log the exact errors are `kj/async-io-unix.c++:498: disconnected: ::read(fd, buffer, maxBytes): Connection reset by peer` while in my case they are `kj::Exception: capnp/rpc.c++:2421: disconnected: Peer disconnected.` But maybe this is a macos vs linux platform difference, because otherwise the errors seem identical. \r\n\r\nThe upshot of this is that I think somehow `bitcoin-wallet` process is crashing on shutdown and causing the `bitcoin-node` unexpected network disconnect errors. Could debug this by:\r\n\r\n- Seeing if `~/.bitcoin/debug.log.wallet` has more information\r\n- Attaching to `bitcoin-wallet` process with GDB before it crashes with `gdb src/bitcoin-wallet <bitcoin-wallet pid>`\r\n- Running `bitcoin-node` under GDB to see what wallet method it is calling when the wallet crashes. From the IPC log it seems to be calling ChainClient.flush, but if you run `gdb -ex 'catch throw' -ex run --args src/bitcoin-node -debug=ipc` it might be possible to get a more complete stack trace\r\n\r\nI should look more into WalletLoaderImpl::flush method to see what that could be doing to cause a crash, too.",
      "created_at" : "2023-05-11T22:40:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1544783273",
      "id" : 1544783273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585cE4Wp",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1544783273/reactions"
      },
      "updated_at" : "2023-05-11T22:40:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1544783273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "jmy blocks",
      "created_at" : "2023-06-05T02:50:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1575959653",
      "id" : 1575959653,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585d7zxl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1575959653/reactions"
      },
      "updated_at" : "2023-06-05T02:50:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1575959653",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/101337020?v=4",
         "events_url" : "https://api.github.com/users/MikeBH9944/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MikeBH9944/followers",
         "following_url" : "https://api.github.com/users/MikeBH9944/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MikeBH9944/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MikeBH9944",
         "id" : 101337020,
         "login" : "MikeBH9944",
         "node_id" : "U_kgDOBgpHvA",
         "organizations_url" : "https://api.github.com/users/MikeBH9944/orgs",
         "received_events_url" : "https://api.github.com/users/MikeBH9944/received_events",
         "repos_url" : "https://api.github.com/users/MikeBH9944/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MikeBH9944/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MikeBH9944/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MikeBH9944"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "m",
      "created_at" : "2023-06-05T02:50:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1575959693",
      "id" : 1575959693,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585d7zyN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1575959693/reactions"
      },
      "updated_at" : "2023-06-05T02:50:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1575959693",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/101337020?v=4",
         "events_url" : "https://api.github.com/users/MikeBH9944/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MikeBH9944/followers",
         "following_url" : "https://api.github.com/users/MikeBH9944/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MikeBH9944/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MikeBH9944",
         "id" : 101337020,
         "login" : "MikeBH9944",
         "node_id" : "U_kgDOBgpHvA",
         "organizations_url" : "https://api.github.com/users/MikeBH9944/orgs",
         "received_events_url" : "https://api.github.com/users/MikeBH9944/received_events",
         "repos_url" : "https://api.github.com/users/MikeBH9944/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MikeBH9944/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MikeBH9944/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MikeBH9944"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-06-20T19:32:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1599388796",
      "id" : 1599388796,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585fVLx8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1599388796/reactions"
      },
      "updated_at" : "2023-06-20T19:32:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1599388796",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--13523179cfe9479db18ec6c5d236f789-->\nThere hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? â¡ï¸ Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? â¡ï¸ Please close.\n* Did the author lose interest or time to work on this? â¡ï¸ Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
      "created_at" : "2023-09-19T01:07:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1724683463",
      "id" : 1724683463,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585mzJTH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1724683463/reactions"
      },
      "updated_at" : "2023-09-19T01:07:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1724683463",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> This PR is part of the [process separation project](https://github.com/bitcoin/bitcoin/projects/10).\n> \n> ---\n> \n> This PR adds an `--enable-multiprocess` configure option which builds new `bitcoin-node`, `bitcoin-wallet`, and `bitcoin-gui` executables with relevant functionality isolated into different processes. See [doc/design/multiprocess.md](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/doc/design/multiprocess.md) for usage details and future plans.\n> \n> The change is implemented by adding a new [`Init`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/init.h) interface that spawns new wallet and node subprocesses that can be controlled over a [socketpair](http://man7.org/linux/man-pages/man2/socketpair.2.html) by calling [`Node`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/node.h), [`Wallet`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/wallet.h), and [`ChainClient`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc/src/interfaces/chain.h) methods. When running with split processes, you can see the IPC messages going back and forth in `-debug=1` output. Followup PR's #19460 and #19461 add `-ipcbind` and `-ipcconnect` options that allow more flexibility in how processes are connected.\n> \n> The IPC protocol used is Cap'n Proto, but this could be swapped out for another protocol. Cap'n Proto types and libraries are only accessed in the [src/ipc/capnp/](https://github.com/ryanofsky/bitcoin/tree/pr/ipc/src/ipc/capnp) directory, and not in any public headers or other parts of bitcoin code.\n> \n> ---\n> \n> Slides from a presentation describing this change are available on [google drive](https://docs.google.com/presentation/d/1AeJ-7gD-dItUgs5yH-HoEzLvXaEWe_2ZiGUUxYIXcws/edit). Demo code used in the presentation was from an older version this PR (tag [ipc.21](https://github.com/ryanofsky/bitcoin/releases/tag/pr%2Fipc.21), [commits](https://github.com/ryanofsky/bitcoin/compare/master...pr/ipc.21)).\n> \n\n",
      "created_at" : "2023-09-19T05:32:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1724856075",
      "id" : 1724856075,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585mzzcL",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1724856075/reactions"
      },
      "updated_at" : "2023-09-19T05:32:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1724856075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/140899125?v=4",
         "events_url" : "https://api.github.com/users/atangangabbieian4/events{/privacy}",
         "followers_url" : "https://api.github.com/users/atangangabbieian4/followers",
         "following_url" : "https://api.github.com/users/atangangabbieian4/following{/other_user}",
         "gists_url" : "https://api.github.com/users/atangangabbieian4/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/atangangabbieian4",
         "id" : 140899125,
         "login" : "atangangabbieian4",
         "node_id" : "U_kgDOCGXzNQ",
         "organizations_url" : "https://api.github.com/users/atangangabbieian4/orgs",
         "received_events_url" : "https://api.github.com/users/atangangabbieian4/received_events",
         "repos_url" : "https://api.github.com/users/atangangabbieian4/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/atangangabbieian4/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/atangangabbieian4/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/atangangabbieian4"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased 1e5d7da989c6a6cab843472675d409bbae34ac3a -> 1ea5d5964bb38f817fb629df0d5f20dfb4d938f1 ([`pr/ipc.190`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.190) -> [`pr/ipc.191`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.191), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.190-rebase..pr/ipc.191)) due to various conflicts\r\n",
      "created_at" : "2023-09-20T00:50:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1726726316",
      "id" : 1726726316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585m68Cs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1726726316/reactions"
      },
      "updated_at" : "2023-09-20T00:50:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1726726316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "CI looks a bit red",
      "created_at" : "2023-09-21T10:55:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1729331997",
      "id" : 1729331997,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585nE4Md",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729331997/reactions"
      },
      "updated_at" : "2023-09-21T10:55:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729331997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> CI looks a bit red\r\n\r\nThanks. I need to do some more work. There is a problem with the util::Result workaround 79c557f97e096f2a393d35e9eafd2bf13da201be. Also a silent merge conflict with https://github.com/bitcoin-core/gui/pull/738",
      "created_at" : "2023-09-21T11:37:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1729392924",
      "id" : 1729392924,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585nFHEc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729392924/reactions"
      },
      "updated_at" : "2023-09-21T11:37:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1729392924",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-10-02T11:16:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1742830508",
      "id" : 1742830508,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585n4Xus",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1742830508/reactions"
      },
      "updated_at" : "2023-10-02T11:16:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1742830508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased d898e962d7f7a3a084158530ae0ec135212cd872 -> f4f3d7b029cdb9d9d6b8ed2e5cf92313f76a3c69 ([`pr/ipc.199`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.199) -> [`pr/ipc.200`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.200), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.199-rebase..pr/ipc.200)) due to conflicts with #27596, #28508, and #28556",
      "created_at" : "2023-10-20T16:40:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1773058372",
      "id" : 1773058372,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585prrlE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1773058372/reactions"
      },
      "updated_at" : "2023-10-20T16:40:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1773058372",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-13T14:42:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1808294107",
      "id" : 1808294107,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585ryGDb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1808294107/reactions"
      },
      "updated_at" : "2023-11-13T14:42:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1808294107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased 18d382f4f8a74612ae0e91efd8a2b83bb665e081 -> 87e3a3b694abc4e0cf8241e31905d3f604c611cf ([`pr/ipc.201`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.201) -> [`pr/ipc.202`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.202), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.201-rebase..pr/ipc.202)) on top of base PR #28921, also fixing conflicts with #28438 and #28503\r\nRebased 87e3a3b694abc4e0cf8241e31905d3f604c611cf -> 7ba123f1b47a4a790370c9a5975b1e0b4026a241 ([`pr/ipc.202`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.202) -> [`pr/ipc.203`](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.203), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/ipc.202-rebase..pr/ipc.203)) on top of base PR #28929 to simplify serialization code\r\n",
      "created_at" : "2023-11-21T19:39:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1821568461",
      "id" : 1821568461,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585sku3N",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1821568461/reactions"
      },
      "updated_at" : "2023-11-23T01:38:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1821568461",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-28T12:44:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1829771167",
      "id" : 1829771167,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585tEBef",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1829771167/reactions"
      },
      "updated_at" : "2023-11-28T12:44:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1829771167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-11-30T18:00:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10102#issuecomment-1834287433",
      "id" : 1834287433,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10102",
      "node_id" : "IC_kwDOABII585tVQFJ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1834287433/reactions"
      },
      "updated_at" : "2023-11-30T18:00:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1834287433",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
