{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "CONTRIBUTOR",
   "body" : "This PR supersedes #14387 and is an alternative to #14397. \r\n\r\n# Summary\r\nPreviously, \"no duplicate inputs\" was checked on a per transaction basis, with this PR, they are checked block wide. This PR also checks that long chains are in valid order, which was previously implicitly checked only. The resulting code is also more performant. \r\n\r\n# Benefits\r\n1) **Stricter Invariants** This PR checks stricter properties. Before this PR, a block might pass checkblock with duplicate inputs spent across transactions and invalid longchain order. Enforcing stricter invariants in CheckBlock helps us guard against potential errors in later sections of the code and opens up the door to new optimizations, parallelizations, or simplifications in the application of transactions in a block. For instance, we could create all new UTXOS in parallel and then spend all inputs in parallel.\r\n2) **Better Performance**  This checker is 6.5x faster on the duplicate inputs benchmark, and 1.1x faster on a more general test.\r\nBefore this PR:\r\n```\r\nDuplicateInputs, 5, 10, 0.334544, 0.00665873, 0.00671868, 0.00669463\r\nDeserializeAndCheckBlockTest, 5, 160, 2.17535, 0.00267973, 0.00273858, 0.00272915\r\n```\r\nAfter this PR:\r\n```\r\nDuplicateInputs, 5, 10, 0.0513754, 0.00100089, 0.00105766, 0.00102823\r\nDeserializeAndCheckBlockTest, 5, 160, 1.97574, 0.00245479, 0.00248704, 0.00246725\r\n```\r\n3) **Better Complexity** The time complexity of the algorithm is E[O(N)], compared to E[O(N log(N)]. It also, in theory uses much less memory in the worst case (constant 300k) compared to O(N) (i.e., 1MB) worst case for the previous algorithm. Furthermore, the number of actual hash comparisons is substantially reduced, which contributes a big constant factor. The analysis is given in more detail in the PR which justifies the constants selected.\r\n\r\n\r\n# Potential Risks & Redresses\r\n\r\nIn this section I'll try to exhaustively go through the various risks of this PR.\r\n\r\n1) **Probabilistic Algorithms are Confusing**. Should the PCG based hashing algorithm (or other probabilistic aspects) be broken in this code, then an attacker could theoretically cause a block to take O(N^2) time to validate. One way to de-risk this issue would be to, upon erroneous collision, fall back to checking against a std::set which would have O(n log n) worst-case behavior (the existing runtime). In general, the theory behind PCGs makes it unlikely that an attacker could predict collisions across the network because each PCG is salted individually (random seed xor'd in) and started with a different increment (the increment includes the output's n, and the seed is the 64 bit hash value -- this prevents adversary from using the output's n to generate collisions). Therefore, a spurious collision on one instance should have an exceedingly small probability of colliding on another. Perhaps there are further ways to harden this hash scheme while maintaining performance. In any case, the block still validates, just more slowly.\r\n2) **Code Complexity**. Should the code be simply incorrect (e.g., not actually checking that duplicate inputs are not present somehow) then unintended inflation could occur. This is always a risk with any change. I believe the stricter invariant checking justifies this change as reducing likelihood of bugs long term, as this protects sensitive code in block application from encountering certain types of invalid blocks based on sequential application of transactions.\r\n3) **Block Size dependency**. Technically this algorithm degrades in expected performance the more transactions are in a block, which may make it more difficult to increase block sizes. Fortunately, should block sizes ever be increased, the hash table size can be increased too (e.g. a 1MB table would support 4MB blocks easily).\r\n4) **Loss of WTXID caching of duplicate input checks**. It has been proposed WTXIDs could cache that they don't have duplicate inputs. I don't see WTXID caching this property as a really useful thing to cache because it needs to be checked at the block level across all transactions anyways. Further, the use of PCG for hashing makes the performance overhead negligible compared to a cache lookup.\r\n5) **Testing Coverage Difficulty** Because the algorithm fails infrequently, it's difficult to write a test that covers the case where the algorithm sees a spurious collision and the continues checking. This could be fixed by templating the Invariant function to allow for a biased PCG implementation which only generates collisions.\r\n6) **Changed failure messages** Because the algorithm checks more invariants at once and detects them in a different order than before, clients relying on an exact reject reason may be confused. Clients should already not rely on exact reject reasons, so I don't believe this has a ramification.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 9,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837/comments",
   "created_at" : "2018-11-29T08:25:40Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837",
   "id" : 385620075,
   "labels" : [
      {
         "color" : "009800",
         "default" : false,
         "id" : 192202000,
         "name" : "Consensus",
         "node_id" : "MDU6TGFiZWwxOTIyMDIwMDA=",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Consensus"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDExOlB1bGxSZXF1ZXN0MjM0NTQ2OTA1",
   "number" : 14837,
   "pull_request" : {
      "diff_url" : "https://github.com/bitcoin/bitcoin/pull/14837.diff",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837",
      "patch_url" : "https://github.com/bitcoin/bitcoin/pull/14837.patch",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
   },
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "Stricter & More Performant Invariant Checking in CheckBlock",
   "updated_at" : "2019-01-10T19:31:21Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
   "user" : {
      "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
      "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
      "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/JeremyRubin",
      "id" : 886523,
      "login" : "JeremyRubin",
      "node_id" : "MDQ6VXNlcjg4NjUyMw==",
      "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
      "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
      "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/JeremyRubin"
   }
}
