[
   {
      "author_association" : "MEMBER",
      "body" : " The argument that the CVE fix was a performance regression is based on a misunderstand of the system's current operation: Block validation is only very rarely on the critical path for block propagation.  This wasn't the case when the duplicate checking skipping was added, but it is the case now. I can't imagine that the PR to skip the \"redundant\" duplicate check would have gone through if it wasn't on the block propagation critical path then, so I can't see a change that is 10x+ more complicated being adopted now that its off the critical path.\r\n\r\nThis adds hundreds of lines of code and a homebrew cryptographic hash that AFAICT isn't particularly cryptographic but if broken turns into a DOS attack (and no, XORing a seed is does not obviously produce pairwise independence, which some approximation of is required to achieve the claimed property that a bad input for one user would be okay for others),  -- and it looks like doesn't actually result in an observable benefit except on microbenchmarks.  \r\n\r\nNAK.",
      "created_at" : "2018-11-29T08:42:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-442751314",
      "id" : 442751314,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mjc1MTMxNA==",
      "updated_at" : "2018-11-29T08:42:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442751314",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "The main benefit I'm emphasizing here is that it checks more strict properties.\r\n\r\nAs noted. the stricter check need not introduce a 'DoS attack' -- it can revert to the existing runtime easily. In any case, our goal isn't really to validate a maliciously created block quickly, it is to validate an honestly created block as quickly as possible and a maliciously created block in tolerable time -- I figured that they O(N / log(N)) speedup to switch back to the set algorithm upon collision wasn't worth the added complexity there, but it can certainly be done.  \r\n\r\nThe PCG I am using is not homebrew (except in implementation). If you prefer, we could add a dependency to the standard PCG library which contains a similar function. Thus the unstudied portion is mostly limited to the inputs to the function. My understanding of PCG is such that the xor'd seed should produce pairwise independence, although I grant you that it may be better to use two different seeds k1_1 and k1_2.  Perhaps there are other efficiently computable prfs which have pairwise independence that would be suited for this purpose -- I previously used SIPHASH for this.",
      "created_at" : "2018-11-29T09:05:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-442757835",
      "id" : 442757835,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mjc1NzgzNQ==",
      "updated_at" : "2018-11-29T09:05:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442757835",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14696](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14696.html) (qa: Add explicit references to related CVE's in p2p_invalid_block test. by lucash-dev)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-11-29T09:31:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-442766164",
      "id" : 442766164,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mjc2NjE2NA==",
      "updated_at" : "2018-11-29T09:31:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442766164",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Stricter Invariants This PR checks stricter properties. Before this PR, a block might pass checkblock with duplicate inputs spent across transactions and invalid longchain order.\r\n\r\n> The main benefit I'm emphasizing here is that it checks more strict properties.\r\n\r\nWhat's the list of properties that this PR checks for? \"Invalid longchain order\" seems to mean that \"outputs being created by this transaction being have not been spent by an earlier transaction.\" Are there other checks, too?\r\n",
      "created_at" : "2018-11-29T15:44:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-442881137",
      "id" : 442881137,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mjg4MTEzNw==",
      "updated_at" : "2018-11-29T15:44:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442881137",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> What's the list of properties that this PR checks for?\r\n\r\nFound the list here:\r\n\r\nhttps://github.com/JeremyRubin/bitcoin/blob/0425c6409000aeb3270ba8f9c30d2746c5c5b784/src/validation.cpp#L3078-L3086\r\n\r\nThe actual implementation of this is change is short, clean and not hard to understand. This change doesn't add \"hundreds of lines of code\", though it does add a lot of comments and analysis.\r\n\r\nIf it's true that \"Block validation is only very rarely on the critical path for block propagation\" then making this change by itself try to help with performance and complexity is probably not worth the risks. But I am curious about:\r\n\r\n> Enforcing stricter invariants in CheckBlock helps us guard against potential errors in later sections of the code and opens up the door to new optimizations, parallelizations, or simplifications in the application of transactions in a block. For instance, we could create all new UTXOS in parallel and then spend all inputs in parallel.\r\n\r\nThis is an interesting idea, even though it seems like it would require a lock-free CCoinsViewCache to improve performance. It does seem conceptually like adding an \"Invalid longchain order\" invariant could make future optimizations possible, so maybe this is worth thinking about more.",
      "created_at" : "2018-11-29T16:27:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-442898663",
      "id" : 442898663,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Mjg5ODY2Mw==",
      "updated_at" : "2018-11-29T16:27:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/442898663",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237787454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237787454"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Precision is lost here. Make that explicit?",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:04:31Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237787454",
      "id" : 237787454,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4NzQ1NA==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 108,
      "path" : "src/validation.cpp",
      "position" : 108,
      "pull_request_review_id" : 180171475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:04:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237787454",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237787620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237787620"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This `.get()` is redundant, right?",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:05:14Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;\n+        uint32_t r = nxt >> 59;\n+        return (x >> r) | (x << (31 & (-r)));\n+\n+    };\n+    const uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k3 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k4 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k5 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k6 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k7 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k8 = GetRand(std::numeric_limits<uint64_t>::max());\n+    struct pos {\n+        uint32_t a : 21;\n+        uint32_t b : 21;\n+        uint32_t c : 21;\n+        bool empty_1 : 1;\n+        uint32_t d : 21;\n+        uint32_t e : 21;\n+        uint32_t f : 21;\n+        bool empty_2 : 1;\n+        uint32_t g : 21;\n+        uint32_t h : 21;\n+        uint32_t unused : 22;\n+    };\n+    auto hasher = [k1, k2, k3, k4, k5, k6, k7, k8, pcg](const COutPoint& out) {\n+        return pos{\n+            pcg(out.hash.GetUint64(0) ^ k1, 1 | ((((uint64_t)out.n) << 1) ^ k1)),\n+            pcg(out.hash.GetUint64(0) ^ k2, 1 | ((((uint64_t)out.n) << 1) ^ k2)),\n+            pcg(out.hash.GetUint64(1) ^ k3, 1 | ((((uint64_t)out.n) << 1) ^ k3)),\n+            false,\n+            pcg(out.hash.GetUint64(1) ^ k4, 1 | ((((uint64_t)out.n) << 1) ^ k4)),\n+            pcg(out.hash.GetUint64(2) ^ k5, 1 | ((((uint64_t)out.n) << 1) ^ k5)),\n+            pcg(out.hash.GetUint64(2) ^ k6, 1 | ((((uint64_t)out.n) << 1) ^ k6)),\n+            false,\n+            pcg(out.hash.GetUint64(3) ^ k7, 1 | ((((uint64_t)out.n) << 1) ^ k7)),\n+            pcg(out.hash.GetUint64(3) ^ k8, 1 | ((((uint64_t)out.n) << 1) ^ k8)),\n+            0,\n+        };\n+    };\n+\n+    std::unique_ptr<std::bitset<1 << 21>> pTable = MakeUnique<std::bitset<1 << 21>>();\n+    auto& table = *pTable.get();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237787620",
      "id" : 237787620,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4NzYyMA==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 151,
      "path" : "src/validation.cpp",
      "position" : 151,
      "pull_request_review_id" : 180171703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:05:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237787620",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237788322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237788322"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make it explicit that the unsigned integer wraparound that will take place here at run-time is intentional? Or alternatively rewrite so that no integer wraparound takes place at run-time? Verify with `-fsanitize=integer`.",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:07:20Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237788322",
      "id" : 237788322,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4ODMyMg==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 107,
      "path" : "src/validation.cpp",
      "position" : 107,
      "pull_request_review_id" : 180172622,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:10:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237788322",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789039"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789039"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make it explicit that the unsigned integer wraparound that will take place here at run-time is intentional? Or alternatively rewrite so that no integer wraparound takes place at run-time? Verify with `-fsanitize=integer`.",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:09:22Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;\n+        uint32_t r = nxt >> 59;\n+        return (x >> r) | (x << (31 & (-r)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789039",
      "id" : 237789039,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4OTAzOQ==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 110,
      "path" : "src/validation.cpp",
      "position" : 110,
      "pull_request_review_id" : 180173483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:10:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789039",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789510"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789510"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Critical :-)",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:10:33Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789510",
      "id" : 237789510,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4OTUxMA==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 4,
      "path" : "src/validation.cpp",
      "position" : 4,
      "pull_request_review_id" : 180174058,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:10:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789510",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789768"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789768"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here. Precision is lost. Make that explicit :-)",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T09:11:16Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;\n+        uint32_t r = nxt >> 59;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237789768",
      "id" : 237789768,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzc4OTc2OA==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 109,
      "path" : "src/validation.cpp",
      "position" : 109,
      "pull_request_review_id" : 180174393,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T09:11:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237789768",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237850750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237850750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`#include <bitset>` to make appveyor happy.",
      "commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "created_at" : "2018-11-30T12:55:11Z",
      "diff_hunk" : "@@ -3075,6 +3075,232 @@ static bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state,\n     return true;\n }\n \n+/* CheckInputInvariants checks for three criticial invariants for the inputs in a block:\n+ * 1) No Duplicate Inputs\n+ * 2) Only one Coinbase (implied by 1)\n+ * 3) No Null Inputs other than coinbase (implied by 1 and 5)\n+ * 4) All long-chains are in order\n+ *\n+ * It does not check\n+ * 5) First txn is coinbase\n+ */\n+static bool CheckInputInvariants(const CBlock& block, CValidationState& state)\n+{\n+    /* This duplication checking algorithm uses a probabilistic filter to check\n+     * for collisions efficiently.  This is faster than the naive construction,\n+     * using a set, which requires more allocation and comparisons of uint256s.\n+     *\n+     * First we create a bitset table with 1<<21 elements. This is around 300\n+     * KB, so we construct it on the heap. We also create 8 pseudo-random\n+     * functions based on PCG. Each PCG function considers looks at 64 bits of\n+     * the prevout's hash, and the increment is xor'd with the index. Although\n+     * each hash is not dependent on the entire hash, a single 64-bit collision\n+     * would be expected with 4-billion UTXOS, and even then that would not\n+     * trigger a collision in this algorithm directly as there are 3 other\n+     * 64-bit hashes to collide.\n+     *\n+     *\n+     * Then, we iterate through the inputs one by one in order, hashing them using\n+     * our PCG hash functions.\n+     *\n+     * We then check if all 8 hashes are set in the table yet. If they are, we\n+     * do a linear scan through the inputs to see if it was a true collision,\n+     * and reject the txn.\n+     *\n+     * Otherwise, we set the 8 bits corresponding to the hashes and continue.\n+     *\n+     * ------------------------------------------------------------------------\n+     * Analysis\n+     * ------------------------------------------------------------------------\n+     * From the perspective of the N+1st prevout, assuming the transaction does\n+     * not double spend:\n+     *\n+     * Up to N*8 hashes have been set in the table already (potentially fewer if\n+     * collisions)\n+     *\n+     * For each of the 8 hashes h_1...h_8, P(bit set in table for h_i) =\n+     * (N*8)/1<<21\n+     *\n+     * Each of these probabilities is independent\n+     *\n+     * Therefore the total probability of a false collision on all bits is:\n+     * ((N*8)/2**21)**8\n+     *\n+     * The cost of a false collision is to do N comparisons.\n+     *\n+     * Therefore, the expression for the expected number of comparisons is:\n+     *\n+     * Sum[i*( i*8 / 2**21)**8, {i, 0, M}]\n+     *\n+     * Based on an input being at least 41 bytes, and a block being 1M bytes\n+     * max, there are a maximum of 24390 inputs, so M = 24390\n+     *\n+     * The total expected number of direct comparisons for M=24930 is therefore\n+     * 0.33 with this algorithm.\n+     *\n+     * The worst case for this algorithm from a denial of service perspective\n+     * with an invalid block would be to do a transaction where the last two\n+     * elements are a collision. In this case, the scan would require to scan all\n+     * N elements to find the conflict.\n+     *\n+     * ------------------------------------------------------------------------\n+     *  Extensions\n+     * ------------------------------------------------------------------------\n+     *\n+     * - Single Coinbase / Null Input Check\n+     *     Note that the first element checked is the coinbase transaction,\n+     *     whose input is null. Therefore, any subsequent null input would be a\n+     *     collision with that null, enabling us to not null check every\n+     *     subsequent entry. This has 0 overhead.\n+     * - Long Chain Check\n+     *     We also scan for the presence of the outputs of a transaction in the\n+     *     table as we go (without insertion), which detects an out-of-order\n+     *     spend in a long-chain within a block.\n+     *\n+     *     The worst case behavior for a block under this additional scan is for\n+     *     all inputs to be spent and then all outputs to be created. Any other\n+     *     pattern of inputs and outputs would be strictly less work. A minimal\n+     *     output is 9 bytes -- there are at most 1e6/9 outputs. Thus, we can\n+     *     model it as:\n+     *\n+     *     Max[((1-x)*1e6/9)(x*1e6/41)*(8*x*(1e6/41) / 2**21)**8 +\n+     *         Sum[ i*( i*8 / 2**21)**8, {i, 0, x*1e6/41}], {x, 0, 1}]\n+     *\n+     *     That is:\n+     *       The most amount of work for a given fraction x of block space devoted to\n+     *       inputs, which is the expected amount of work for checking a table with\n+     *       x*1e6/41 entries (1-x)*1e6/9 additional times plus the expected  work\n+     *       for deduplicating just the inputs.\n+     *\n+     *     This expression is at most ~0.7 expected comparisons worst case, which is\n+     *     still perfectly acceptable.\n+     */\n+\n+\n+    const auto pcg = [](uint64_t start, uint64_t inc) {\n+        uint64_t nxt = (inc | 1) + (start * 6364136223846793005ULL);\n+        uint32_t x = (nxt ^ (nxt >> 18)) >> 27;\n+        uint32_t r = nxt >> 59;\n+        return (x >> r) | (x << (31 & (-r)));\n+\n+    };\n+    const uint64_t k1 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k2 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k3 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k4 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k5 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k6 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k7 = GetRand(std::numeric_limits<uint64_t>::max());\n+    const uint64_t k8 = GetRand(std::numeric_limits<uint64_t>::max());\n+    struct pos {\n+        uint32_t a : 21;\n+        uint32_t b : 21;\n+        uint32_t c : 21;\n+        bool empty_1 : 1;\n+        uint32_t d : 21;\n+        uint32_t e : 21;\n+        uint32_t f : 21;\n+        bool empty_2 : 1;\n+        uint32_t g : 21;\n+        uint32_t h : 21;\n+        uint32_t unused : 22;\n+    };\n+    auto hasher = [k1, k2, k3, k4, k5, k6, k7, k8, pcg](const COutPoint& out) {\n+        return pos{\n+            pcg(out.hash.GetUint64(0) ^ k1, 1 | ((((uint64_t)out.n) << 1) ^ k1)),\n+            pcg(out.hash.GetUint64(0) ^ k2, 1 | ((((uint64_t)out.n) << 1) ^ k2)),\n+            pcg(out.hash.GetUint64(1) ^ k3, 1 | ((((uint64_t)out.n) << 1) ^ k3)),\n+            false,\n+            pcg(out.hash.GetUint64(1) ^ k4, 1 | ((((uint64_t)out.n) << 1) ^ k4)),\n+            pcg(out.hash.GetUint64(2) ^ k5, 1 | ((((uint64_t)out.n) << 1) ^ k5)),\n+            pcg(out.hash.GetUint64(2) ^ k6, 1 | ((((uint64_t)out.n) << 1) ^ k6)),\n+            false,\n+            pcg(out.hash.GetUint64(3) ^ k7, 1 | ((((uint64_t)out.n) << 1) ^ k7)),\n+            pcg(out.hash.GetUint64(3) ^ k8, 1 | ((((uint64_t)out.n) << 1) ^ k8)),\n+            0,\n+        };\n+    };\n+\n+    std::unique_ptr<std::bitset<1 << 21>> pTable = MakeUnique<std::bitset<1 << 21>>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#discussion_r237850750",
      "id" : 237850750,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzNzg1MDc1MA==",
      "original_commit_id" : "0425c6409000aeb3270ba8f9c30d2746c5c5b784",
      "original_position" : 150,
      "path" : "src/validation.cpp",
      "position" : 150,
      "pull_request_review_id" : 180252878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14837",
      "updated_at" : "2018-11-30T12:55:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/237850750",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I agree with @gmaxwell.  Adding complexity to the consensus code (or, as I often argue, changing it at all) should be something we do for only very good reasons, both because of the high review burden consensus code changes incur on the project, and because of the maintenance burden and cognitive load we put on future developers as well. \r\n\r\nI really don't think we should consider making consensus code changes that are designed to have no effect but prep the way for unspecified future code changes (which is why I often chime in with a Concept NACK on consensus refactoring PRs).  These incur all the review and testing costs of a consensus change, but by design have no benefit to the network.  This project is way too busy for this to be a good use of developer effort IMO.\r\n\r\nIn my view, if we're going to make changes to the consensus code for performance reasons, then (a) those performance numbers should be demonstrably and meaningfully better for the network, and (b) we should generally discuss all the designs that might achieve the same performance benefit, and have a very good reason for not choosing the simplest such design.  In the case of this change, the performance benefits could likely be realized by far simpler changes, as has been pointed out in the review comments on other versions of this PR.\r\n\r\nI do think that it would be a useful discussion to figure out exactly what would be the simplest code design for where the duplicate inputs check should live -- I've had some offline conversations and in my view it's not obvious whether it should naturally be considered a context-free check we perform on transactions, or whether the check should reside instead at the utxo database layer.  If we care to improve the underlying issue here, I think we would best served by engaging in that design discussion to come up with the simplest way of reasoning about things in the future.\r\n\r\nFinally -- I think we should remember that we're not just writing code for ourselves, but for hopefully a much larger set of future engineers.  If we are going to burden people with complicated reasoning about a consensus topic, it should be because it's really important.",
      "created_at" : "2018-11-30T15:05:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14837#issuecomment-443231239",
      "id" : 443231239,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14837",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0MzIzMTIzOQ==",
      "updated_at" : "2018-11-30T15:05:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/443231239",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   }
]
