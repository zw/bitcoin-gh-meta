{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "MEMBER",
   "body" : "There is a fair amount of code in `util.cpp` that by its nature has to be done completely differently on Windows and Unix (and sometimes differently on Linux, BSD, etc). There's actually more of this kind of stuff that I want to add e.g. see some of my other outstanding PRs like #12618 and #12696.\r\n\r\nMost of the functions like this are written with a top-level `#ifdef` that dispatches based on Windows or non-Windows:\r\n\r\n```c++\r\nint RaiseFileDescriptorLimit(int nMinFD) {\r\n#if defined(WIN32)\r\n    return 2048;\r\n#else\r\n    struct rlimit limitFD;\r\n    if (getrlimit(RLIMIT_NOFILE, &limitFD) != -1) {\r\n        if (limitFD.rlim_cur < (rlim_t)nMinFD) {\r\n            limitFD.rlim_cur = nMinFD;\r\n            if (limitFD.rlim_cur > limitFD.rlim_max)\r\n                limitFD.rlim_cur = limitFD.rlim_max;\r\n            setrlimit(RLIMIT_NOFILE, &limitFD);\r\n            getrlimit(RLIMIT_NOFILE, &limitFD);\r\n        }\r\n        return limitFD.rlim_cur;\r\n    }\r\n    return nMinFD; // getrlimit failed, assume it's fine\r\n#endif\r\n\r\n```\r\n\r\nIn a few cases this kind of logic will be interspersed in functions that are otherwise fairly platform independent, e.g. `ArgsManager::ParseParameters` has logic to convert Unix-style filenames to Windows style filenames:\r\n\r\n```c++\r\nvoid ArgsManager::ParseParameters(int argc, const char* const argv[])\r\n{\r\n    // ...\r\n#ifdef WIN32\r\n        boost::to_lower(str);\r\n        if (boost::algorithm::starts_with(str, \"/\"))\r\n            str = \"-\" + str.substr(1);\r\n#endif\r\n    // ...\r\n}\r\n```\r\n\r\nThere are also a few where we need to do different things if we're on Linux, macOS, etc.\r\n\r\n## Proposal\r\n\r\nMy proposal is to take all of the functions that are specific to Windows or Unix, and create a common set of methods in a new header file called `util_platform.h`. This would contain prototypes for methods like `RenameOver()`, `FileCommit()`, etc.\r\n\r\nThen we'd have two implementation files, `util_windows.cpp` and `util_posix.cpp` that implement these methods. The building/linking of `util_windows.cpp` or `util_posix.cpp` would be handled using `AM_CONDITIONAL`. My feeling is that the POSIX stuff is similar enough that we can avoid a `util_mac.cpp`, `util_linux.cpp`, etc. for now (and hopefully forever).\r\n\r\nWhen you add a new function prototype to `util_platform.h` you need to write implementations in both `util_windows.cpp` and `util_posix.cpp`. In some cases that will mean there are empty functions defined which is fine.\r\n\r\nI think if we do this correctly there should be ZERO statements that are checking for `#ifdef WIN32` in the rest of the code. As an example, previously I showed some code from ArgsManager that was munging Unix filenames to Windows filenames. I think that should be handled in a function e.g. named `MungeUnixFilename()` and then on Windows it would implemented with the existing lowercase/replace slash logic, and on POSIX systems it would be a function that just returned the original string unchanged.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 1,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12697/comments",
   "created_at" : "2018-03-15T14:51:12Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12697/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/12697",
   "id" : 305585025,
   "labels" : [],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12697/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "number" : 12697,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "Proposal: Refactoring platform-specific code in util.h/util.cpp",
   "updated_at" : "2018-03-15T15:15:11Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12697",
   "user" : {
      "avatar_url" : "https://avatars0.githubusercontent.com/u/2734?v=4",
      "events_url" : "https://api.github.com/users/eklitzke/events{/privacy}",
      "followers_url" : "https://api.github.com/users/eklitzke/followers",
      "following_url" : "https://api.github.com/users/eklitzke/following{/other_user}",
      "gists_url" : "https://api.github.com/users/eklitzke/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/eklitzke",
      "id" : 2734,
      "login" : "eklitzke",
      "organizations_url" : "https://api.github.com/users/eklitzke/orgs",
      "received_events_url" : "https://api.github.com/users/eklitzke/received_events",
      "repos_url" : "https://api.github.com/users/eklitzke/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/eklitzke/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/eklitzke/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/eklitzke"
   }
}
