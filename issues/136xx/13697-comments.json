[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203241841"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203241841"
         }
      },
      "author_association" : "MEMBER",
      "body" : "~Missing copyright block~",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T03:26:51Z",
      "diff_hunk" : "@@ -0,0 +1,615 @@\n+#include <script/descriptor.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203241841",
      "id" : 203241841,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzI0MTg0MQ==",
      "original_commit_id" : "a6eba6912bdfa7e5809223b24817516c1509ce86",
      "original_position" : 1,
      "path" : "src/script/descriptor.cpp",
      "position" : 5,
      "pull_request_review_id" : 138092091,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203241841",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203242258"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203242258"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T03:30:30Z",
      "diff_hunk" : "@@ -0,0 +1,615 @@\n+#include <script/descriptor.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203242258",
      "id" : 203242258,
      "in_reply_to_id" : 203241841,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzI0MjI1OA==",
      "original_commit_id" : "a6eba6912bdfa7e5809223b24817516c1509ce86",
      "original_position" : 1,
      "path" : "src/script/descriptor.cpp",
      "position" : 5,
      "pull_request_review_id" : 138092534,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203242258",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203374074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203374074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, remove empty line.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T13:17:58Z",
      "diff_hunk" : "@@ -28,6 +28,20 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+struct FlatSigningProvider final : public SigningProvider\n+{\n+    std::map<CScriptID, CScript> scripts;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> keys;\n+\n+    bool GetCScript(const CScriptID& scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;\n+    bool GetKey(const CKeyID& keyid, CKey& key) const override;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203374074",
      "id" : 203374074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzM3NDA3NA==",
      "original_commit_id" : "422d08c1f907e92d8c4c216a71b6ca5ffbf05f0d",
      "original_position" : 13,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 138248785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203374074",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203375847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203375847"
         }
      },
      "author_association" : "MEMBER",
      "body" : "At the moment this is only used in tests, move there?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T13:22:42Z",
      "diff_hunk" : "@@ -28,6 +28,20 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+struct FlatSigningProvider final : public SigningProvider\n+{\n+    std::map<CScriptID, CScript> scripts;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> keys;\n+\n+    bool GetCScript(const CScriptID& scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;\n+    bool GetKey(const CKeyID& keyid, CKey& key) const override;\n+\n+};\n+\n+FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvider& b);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203375847",
      "id" : 203375847,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzM3NTg0Nw==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 16,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 138248785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203375847",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203379602"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203379602"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, add `// KEY_ORIGIN_SUPPORT`.\r\n",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T13:33:16Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203379602",
      "id" : 203379602,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzM3OTYwMg==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 82,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138248785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203379602",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203379927"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203379927"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `{` in new line.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T13:34:13Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203379927",
      "id" : 203379927,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzM3OTkyNw==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 29,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138248785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203379927",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203380024"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203380024"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `= default`?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T13:34:31Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203380024",
      "id" : 203380024,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzM4MDAyNA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 30,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138248785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203380024",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203426710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203426710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add\r\n```cpp\r\nif (it == sp.end()) return ret;\r\n```\r\nfor when string is empty.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T15:34:18Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203426710",
      "id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQyNjcxMA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138313440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203426710",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203436690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203436690"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Compiler warning:\r\n```\r\nscript/descriptor.cpp:617:39: warning: moving a local object in a return statement prevents copy elision [-Wpessimizing-move]\r\n    if (sp.size() == 0 && ret) return std::move(ret);\r\n                                      ^\r\nscript/descriptor.cpp:617:39: note: remove std::move call here\r\n    if (sp.size() == 0 && ret) return std::move(ret);\r\n                                      ^~~~~~~~~~  \r\n```",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:01:21Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n+/** Parse a key path, being passed a split list of elements (the first element is ignored). */\n+bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out)\n+{\n+    for (size_t i = 1; i < split.size(); ++i) {\n+        Span<const char> elem = split[i];\n+        bool hardened = false;\n+        if (elem.size() > 0 && elem[elem.size() - 1] == '\\'') {\n+            elem = elem.first(elem.size() - 1);\n+            hardened = true;\n+        }\n+        uint32_t p;\n+        if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p) || p > 0x7FFFFFFFUL) return false;\n+        out.push_back(p | (((uint32_t)hardened) << 31));\n+    }\n+    return true;\n+}\n+\n+/** Parse a public key that excludes origin information. */\n+std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto split = Split(sp, '/');\n+    std::string str(split[0].begin(), split[0].end());\n+    if (split.size() == 1) {\n+        if (IsHex(str)) {\n+            std::vector<unsigned char> data = ParseHex(str);\n+            CPubKey pubkey(data);\n+            if (pubkey.IsFullyValid() && (permit_uncompressed || pubkey.IsCompressed())) return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+        CKey key = DecodeSecret(str);\n+        if (key.IsValid() && (permit_uncompressed || key.IsCompressed())) {\n+            CPubKey pubkey = key.GetPubKey();\n+            out.keys.emplace(pubkey.GetID(), key);\n+            return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+    }\n+    CExtKey extkey = DecodeExtKey(str);\n+    CExtPubKey extpubkey = DecodeExtPubKey(str);\n+    if (!extkey.key.IsValid() && !extpubkey.pubkey.IsValid()) return nullptr;\n+    KeyPath path;\n+    DeriveType type = DeriveType::NO;\n+    if (split.back() == MakeSpan(\"*\").first(1)) {\n+        split.pop_back();\n+        type = DeriveType::UNHARDENED;\n+    } else if (split.back() == MakeSpan(\"*'\").first(2)) {\n+        split.pop_back();\n+        type = DeriveType::HARDENED;\n+    }\n+    if (!ParseKeyPath(split, path)) return nullptr;\n+    if (extkey.key.IsValid()) {\n+        extpubkey = extkey.Neuter();\n+        out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n+    }\n+    return MakeUnique<BIP32PubkeyProvider>(extpubkey, std::move(path), type);\n+}\n+\n+/** Parse a public key including origin information (if enabled). */\n+std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto colon_split = Split(sp, ':');\n+    if (colon_split.size() > 2) return nullptr;\n+    if (colon_split.size() == 1) return ParsePubkeyInner(colon_split[0], permit_uncompressed, out);\n+#ifdef KEY_ORIGIN_SUPPORT\n+    auto slash_split = Split(colon_split[0], '/');\n+    if (slash_split[0].size() != 8) return nullptr;\n+    std::string fpr_hex = std::string(slash_split[0].begin(), slash_split[0].end());\n+    if (!IsHex(fpr_hex)) return nullptr;\n+    auto fpr_bytes = ParseHex(fpr_hex);\n+    uint32_t fpr = ReadBE32(fpr_bytes.data());\n+    KeyPath path;\n+    if (!ParseKeyPath(slash_split, path)) return nullptr;\n+    auto provider = ParsePubkeyInner(colon_split[1], permit_uncompressed, out);\n+    if (!provider) return nullptr;\n+    return MakeUnique<OriginPubkeyProvider>(fpr, std::move(path), std::move(provider));\n+#else\n+    return nullptr;\n+#endif\n+}\n+\n+/** Parse a script in a particular context. */\n+std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+{\n+    auto expr = Expr(sp);\n+    if (Func(\"pk\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+    }\n+    if (Func(\"pkh\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKHGetScript, \"pkh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"old\", expr)) {\n+        auto pubkey = ParsePubkey(expr, true, out);\n+        if (pubkey) return MakeUnique<OldKeyDescriptor>(std::move(pubkey));\n+    }\n+    if (Func(\"multi\", expr)) {\n+        auto threshold = Expr(expr);\n+        uint32_t thres;\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        if (!ParseUInt32(std::string(threshold.begin(), threshold.end()), &thres)) return nullptr;\n+        size_t script_size = 0;\n+        while (expr.size()) {\n+            if (!Const(\",\", expr)) return nullptr;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(arg, ctx != ParseScriptContext::P2WSH, out);\n+            if (!pk) return nullptr;\n+            script_size += pk->GetSize() + 1;\n+            providers.emplace_back(std::move(pk));\n+        }\n+        if (providers.size() < 1 || providers.size() > 16 || thres < 1 || thres > providers.size()) return nullptr;\n+        if (ctx == ParseScriptContext::TOP) {\n+            if (providers.size() > 3) return nullptr; // Not more than 3 pubkeys for raw multisig\n+        }\n+        if (ctx == ParseScriptContext::P2SH) {\n+            if (script_size + 3 > 520) return nullptr; // Enforce P2SH script size limit\n+        }\n+        return MakeUnique<MultisigDescriptor>(thres, std::move(providers));\n+    }\n+    if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n+        auto pubkey = ParsePubkey(expr, false, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2WPKHGetScript, \"wpkh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n+        auto desc = ParseScript(expr, ParseScriptContext::P2SH, out);\n+        if (desc && expr.size() == 0) return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2SH, \"sh\");\n+    }\n+    if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n+        auto desc = ParseScript(expr, ParseScriptContext::P2WSH, out);\n+        if (desc && expr.size() == 0) return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2WSH, \"wsh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n+        CTxDestination dest = DecodeDestination(std::string(expr.begin(), expr.end()));\n+        if (IsValidDestination(dest)) return MakeUnique<AddressDescriptor>(std::move(dest));\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"raw\", expr)) {\n+        std::string str(expr.begin(), expr.end());\n+        if (IsHex(str)) {\n+            auto bytes = ParseHex(str);\n+            return MakeUnique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out)\n+{\n+    Span<const char> sp(descriptor.data(), descriptor.size());\n+    auto ret = ParseScript(sp, ParseScriptContext::TOP, out);\n+    if (sp.size() == 0 && ret) return std::move(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203436690",
      "id" : 203436690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQzNjY5MA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 617,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138325814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203436690",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443145"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443145"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why give both options? `[{ \"desc\": \"...\", ...}, ...]` is enough?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:20:05Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443145",
      "id" : 203443145,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ0MzE0NQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 84,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 86,
      "pull_request_review_id" : 138333458,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443145",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could have a test.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:20:57Z",
      "diff_hunk" : "@@ -2090,79 +2060,35 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n \n         // loop through the scan objects\n         for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n-            if (!scanobject.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n-            }\n-            UniValue address_uni = find_value(scanobject, \"address\");\n-            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n-            UniValue script_uni  = find_value(scanobject, \"script\");\n-\n-            // make sure only one object type is present\n-            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n-            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n-            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n-            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n-            } else if (address_uni.isStr()) {\n-                // type: address\n-                // decode destination and derive the scriptPubKey\n-                // add the script to the scan containers\n-                CTxDestination dest = DecodeDestination(address_uni.get_str());\n-                if (!IsValidDestination(dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-                }\n-                CScript script = GetScriptForDestination(dest);\n-                assert(!script.empty());\n-                needles.insert(script);\n-            } else if (pubkey_uni.isObject()) {\n-                // type: pubkey\n-                // derive script(s) according to the script_type parameter\n-                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n-                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n-\n-                // check the script types and use the default if not provided\n-                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n-                } else if (script_types_uni.isNull()) {\n-                    // use the default script types\n-                    script_types_uni = UniValue(UniValue::VARR);\n-                    for (const char *t : g_default_scantxoutset_script_types) {\n-                        script_types_uni.push_back(t);\n-                    }\n-                }\n-\n-                // check the acctual pubkey\n-                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n-                }\n-                CPubKey pubkey(ParseHexV(pubkeydata_uni, \"pubkey\"));\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+            std::string desc_str;\n+            int range = 1000;\n+            if (scanobject.isStr()) {\n+                desc_str = scanobject.get_str();\n+            } else if (scanobject.isObject()) {\n+                UniValue desc_uni = find_value(scanobject, \"desc\");\n+                if (desc_uni.isNull()) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor needs to be provided in scan object\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443457",
      "id" : 203443457,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ0MzQ1Nw==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 156,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 158,
      "pull_request_review_id" : 138333833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443457",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443476"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443476"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could have a test.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:21:01Z",
      "diff_hunk" : "@@ -2090,79 +2060,35 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n \n         // loop through the scan objects\n         for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n-            if (!scanobject.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n-            }\n-            UniValue address_uni = find_value(scanobject, \"address\");\n-            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n-            UniValue script_uni  = find_value(scanobject, \"script\");\n-\n-            // make sure only one object type is present\n-            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n-            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n-            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n-            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n-            } else if (address_uni.isStr()) {\n-                // type: address\n-                // decode destination and derive the scriptPubKey\n-                // add the script to the scan containers\n-                CTxDestination dest = DecodeDestination(address_uni.get_str());\n-                if (!IsValidDestination(dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-                }\n-                CScript script = GetScriptForDestination(dest);\n-                assert(!script.empty());\n-                needles.insert(script);\n-            } else if (pubkey_uni.isObject()) {\n-                // type: pubkey\n-                // derive script(s) according to the script_type parameter\n-                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n-                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n-\n-                // check the script types and use the default if not provided\n-                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n-                } else if (script_types_uni.isNull()) {\n-                    // use the default script types\n-                    script_types_uni = UniValue(UniValue::VARR);\n-                    for (const char *t : g_default_scantxoutset_script_types) {\n-                        script_types_uni.push_back(t);\n-                    }\n-                }\n-\n-                // check the acctual pubkey\n-                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n-                }\n-                CPubKey pubkey(ParseHexV(pubkeydata_uni, \"pubkey\"));\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+            std::string desc_str;\n+            int range = 1000;\n+            if (scanobject.isStr()) {\n+                desc_str = scanobject.get_str();\n+            } else if (scanobject.isObject()) {\n+                UniValue desc_uni = find_value(scanobject, \"desc\");\n+                if (desc_uni.isNull()) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor needs to be provided in scan object\");\n+                desc_str = desc_uni.get_str();\n+                UniValue range_uni = find_value(scanobject, \"range\");\n+                if (!range_uni.isNull()) {\n+                    range = range_uni.get_int();\n+                    if (range < 1 || range > 1000000) throw JSONRPCError(RPC_INVALID_PARAMETER, \"range out of range\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203443476",
      "id" : 203443476,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ0MzQ3Ng==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 161,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 138333857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203443476",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203446922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203446922"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why not return `nullptr` in these cases?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:31:47Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n+/** Parse a key path, being passed a split list of elements (the first element is ignored). */\n+bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out)\n+{\n+    for (size_t i = 1; i < split.size(); ++i) {\n+        Span<const char> elem = split[i];\n+        bool hardened = false;\n+        if (elem.size() > 0 && elem[elem.size() - 1] == '\\'') {\n+            elem = elem.first(elem.size() - 1);\n+            hardened = true;\n+        }\n+        uint32_t p;\n+        if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p) || p > 0x7FFFFFFFUL) return false;\n+        out.push_back(p | (((uint32_t)hardened) << 31));\n+    }\n+    return true;\n+}\n+\n+/** Parse a public key that excludes origin information. */\n+std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto split = Split(sp, '/');\n+    std::string str(split[0].begin(), split[0].end());\n+    if (split.size() == 1) {\n+        if (IsHex(str)) {\n+            std::vector<unsigned char> data = ParseHex(str);\n+            CPubKey pubkey(data);\n+            if (pubkey.IsFullyValid() && (permit_uncompressed || pubkey.IsCompressed())) return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+        CKey key = DecodeSecret(str);\n+        if (key.IsValid() && (permit_uncompressed || key.IsCompressed())) {\n+            CPubKey pubkey = key.GetPubKey();\n+            out.keys.emplace(pubkey.GetID(), key);\n+            return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+    }\n+    CExtKey extkey = DecodeExtKey(str);\n+    CExtPubKey extpubkey = DecodeExtPubKey(str);\n+    if (!extkey.key.IsValid() && !extpubkey.pubkey.IsValid()) return nullptr;\n+    KeyPath path;\n+    DeriveType type = DeriveType::NO;\n+    if (split.back() == MakeSpan(\"*\").first(1)) {\n+        split.pop_back();\n+        type = DeriveType::UNHARDENED;\n+    } else if (split.back() == MakeSpan(\"*'\").first(2)) {\n+        split.pop_back();\n+        type = DeriveType::HARDENED;\n+    }\n+    if (!ParseKeyPath(split, path)) return nullptr;\n+    if (extkey.key.IsValid()) {\n+        extpubkey = extkey.Neuter();\n+        out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n+    }\n+    return MakeUnique<BIP32PubkeyProvider>(extpubkey, std::move(path), type);\n+}\n+\n+/** Parse a public key including origin information (if enabled). */\n+std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto colon_split = Split(sp, ':');\n+    if (colon_split.size() > 2) return nullptr;\n+    if (colon_split.size() == 1) return ParsePubkeyInner(colon_split[0], permit_uncompressed, out);\n+#ifdef KEY_ORIGIN_SUPPORT\n+    auto slash_split = Split(colon_split[0], '/');\n+    if (slash_split[0].size() != 8) return nullptr;\n+    std::string fpr_hex = std::string(slash_split[0].begin(), slash_split[0].end());\n+    if (!IsHex(fpr_hex)) return nullptr;\n+    auto fpr_bytes = ParseHex(fpr_hex);\n+    uint32_t fpr = ReadBE32(fpr_bytes.data());\n+    KeyPath path;\n+    if (!ParseKeyPath(slash_split, path)) return nullptr;\n+    auto provider = ParsePubkeyInner(colon_split[1], permit_uncompressed, out);\n+    if (!provider) return nullptr;\n+    return MakeUnique<OriginPubkeyProvider>(fpr, std::move(path), std::move(provider));\n+#else\n+    return nullptr;\n+#endif\n+}\n+\n+/** Parse a script in a particular context. */\n+std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+{\n+    auto expr = Expr(sp);\n+    if (Func(\"pk\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203446922",
      "id" : 203446922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ0NjkyMg==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 553,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138337945,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203446922",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203447244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203447244"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n#endif // BITCOIN_SCRIPT_DESCRIPTOR_H\r\n```",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T16:32:36Z",
      "diff_hunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_DESCRIPTOR_H\n+#define BITCOIN_SCRIPT_DESCRIPTOR_H\n+\n+#include <script/script.h>\n+#include <script/sign.h>\n+\n+#include <vector>\n+\n+// Descriptors are strings that describe a set of scriptPubKeys, together with\n+// all information necessary to solve them. By combining all information into\n+// one, they avoid the need to separately import keys and scripts.\n+//\n+// Descriptors may be ranged, which occurs when the public keys inside are\n+// specified in the form of HD chains (xpubs).\n+//\n+// Descriptors always represent public information - public keys and scripts -\n+// but in cases where private keys need to be conveyed along with a descriptor,\n+// they can be included inside by changing public keys to private keys (WIF\n+// format), and changing xpubs by xprvs.\n+//\n+// 1. Examples\n+//\n+// A P2PK descriptor with a fixed public key:\n+// - pk(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)\n+//\n+// A P2SH-P2WSH-P2PKH descriptor with a fixed public key:\n+// - sh(wsh(pkh(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13)))\n+//\n+// A bare 1-of-2 multisig descriptor:\n+// - multi(1,022f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)\n+//\n+// A chain of P2PKH outputs (this needs the corresponding private key to derive):\n+// - pkh(xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw/1'/2/*)\n+//\n+// 2. Grammar description:\n+//\n+// X: xpub or xprv encoded extended key\n+// I: decimal encoded integer\n+// H: Hex encoded byte array\n+// A: Address in P2PKH, P2SH, or Bech32 encoding\n+//\n+// S (Scripts):\n+// * pk(P): Pay-to-pubkey (P2PK) output for public key P.\n+// * pkh(P): Pay-to-pubkey-hash (P2PKH) output for public key P.\n+// * wpkh(P): Pay-to-witness-pubkey-hash (P2WPKH) output for public key P.\n+// * sh(S): Pay-to-script-hash (P2SH) output for script S\n+// * wsh(S): Pay-to-witness-script-hash (P2WSH) output for script S\n+// * old(P): combination of P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH for public key P.\n+// * multi(I,L): k-of-n multisig for given public keys\n+// * addr(A): Output to address\n+// * raw(H): scriptPubKey with raw bytes\n+//\n+// P (Public keys):\n+// * H: fixed public key (or WIF-encoded private key)\n+// * E: extended public key\n+// * E/*: (ranged) all unhardened direct children of an extended public key\n+// * E/*': (ranged) all hardened direct children of an extended public key\n+//\n+// L (Comma-separated lists of public keys):\n+// * P\n+// * L,P\n+//\n+// E (Extended public keys):\n+// * X\n+// * E/I: unhardened child\n+// * E/I': hardened child\n+//\n+// The top level is S.\n+\n+/** Interface for parsed descriptor objects. */\n+struct Descriptor {\n+    virtual ~Descriptor() {}\n+\n+    /** Whether the expansion of this descriptor depends on the position. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Convert the descriptor back to a string, undoing parsing. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Convert the descriptor to a private string. This fails if the provided provider does not have the relevant private keys. */\n+    virtual bool ToPrivateString(const SigningProvider& provider, std::string& out) const = 0;\n+\n+    /** Expand a descriptor at a specified position.\n+     *\n+     * pos: the position at which to expand the descriptor. If IsRange() is false, this is ignored.\n+     * provider: the provider to query for private keys in case of hardened derivation.\n+     * output_script: the expanded scriptPubKeys will be put here.\n+     * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     */\n+    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n+};\n+\n+/** Parse a descriptor string. Included private keys are put in out. Returns nullptr if parsing fails. */\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out);\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203447244",
      "id" : 203447244,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ0NzI0NA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 100,
      "path" : "src/script/descriptor.h",
      "position" : null,
      "pull_request_review_id" : 138338279,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203447244",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203496728"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203496728"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can the path writing be separated out into another function to avoid code duplication and so that we can use it elsewhere?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:11:07Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203496728",
      "id" : 203496728,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzQ5NjcyOA==",
      "original_commit_id" : "1143a75c2f74335365dc62063f2fdc6c74eefcda",
      "original_position" : 189,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138398176,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203496728",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500757"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500757"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:05Z",
      "diff_hunk" : "@@ -28,6 +28,20 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+struct FlatSigningProvider final : public SigningProvider\n+{\n+    std::map<CScriptID, CScript> scripts;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> keys;\n+\n+    bool GetCScript(const CScriptID& scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;\n+    bool GetKey(const CKeyID& keyid, CKey& key) const override;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500757",
      "id" : 203500757,
      "in_reply_to_id" : 203374074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDc1Nw==",
      "original_commit_id" : "422d08c1f907e92d8c4c216a71b6ca5ffbf05f0d",
      "original_position" : 13,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 138403222,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500757",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500825"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd rather not. I think more things will be able to use this.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:21Z",
      "diff_hunk" : "@@ -28,6 +28,20 @@ class SigningProvider\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;\n \n+struct FlatSigningProvider final : public SigningProvider\n+{\n+    std::map<CScriptID, CScript> scripts;\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> keys;\n+\n+    bool GetCScript(const CScriptID& scriptid, CScript& script) const override;\n+    bool GetPubKey(const CKeyID& keyid, CPubKey& pubkey) const override;\n+    bool GetKey(const CKeyID& keyid, CKey& key) const override;\n+\n+};\n+\n+FlatSigningProvider Merge(const FlatSigningProvider& a, const FlatSigningProvider& b);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500825",
      "id" : 203500825,
      "in_reply_to_id" : 203375847,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDgyNQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 16,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 138403311,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500825",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500850"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500850"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:28Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500850",
      "id" : 203500850,
      "in_reply_to_id" : 203379602,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDg1MA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 82,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138403353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500850",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500890"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500890"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500890",
      "id" : 203500890,
      "in_reply_to_id" : 203379927,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDg5MA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 29,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138403404,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500890",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, here and elsewhere.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:47Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500938",
      "id" : 203500938,
      "in_reply_to_id" : 203380024,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDkzOA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 30,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138403484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500938",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500981"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:26:53Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203500981",
      "id" : 203500981,
      "in_reply_to_id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMDk4MQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138403526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203500981",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501008"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:27:01Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n+/** Parse a key path, being passed a split list of elements (the first element is ignored). */\n+bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out)\n+{\n+    for (size_t i = 1; i < split.size(); ++i) {\n+        Span<const char> elem = split[i];\n+        bool hardened = false;\n+        if (elem.size() > 0 && elem[elem.size() - 1] == '\\'') {\n+            elem = elem.first(elem.size() - 1);\n+            hardened = true;\n+        }\n+        uint32_t p;\n+        if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p) || p > 0x7FFFFFFFUL) return false;\n+        out.push_back(p | (((uint32_t)hardened) << 31));\n+    }\n+    return true;\n+}\n+\n+/** Parse a public key that excludes origin information. */\n+std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto split = Split(sp, '/');\n+    std::string str(split[0].begin(), split[0].end());\n+    if (split.size() == 1) {\n+        if (IsHex(str)) {\n+            std::vector<unsigned char> data = ParseHex(str);\n+            CPubKey pubkey(data);\n+            if (pubkey.IsFullyValid() && (permit_uncompressed || pubkey.IsCompressed())) return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+        CKey key = DecodeSecret(str);\n+        if (key.IsValid() && (permit_uncompressed || key.IsCompressed())) {\n+            CPubKey pubkey = key.GetPubKey();\n+            out.keys.emplace(pubkey.GetID(), key);\n+            return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+    }\n+    CExtKey extkey = DecodeExtKey(str);\n+    CExtPubKey extpubkey = DecodeExtPubKey(str);\n+    if (!extkey.key.IsValid() && !extpubkey.pubkey.IsValid()) return nullptr;\n+    KeyPath path;\n+    DeriveType type = DeriveType::NO;\n+    if (split.back() == MakeSpan(\"*\").first(1)) {\n+        split.pop_back();\n+        type = DeriveType::UNHARDENED;\n+    } else if (split.back() == MakeSpan(\"*'\").first(2)) {\n+        split.pop_back();\n+        type = DeriveType::HARDENED;\n+    }\n+    if (!ParseKeyPath(split, path)) return nullptr;\n+    if (extkey.key.IsValid()) {\n+        extpubkey = extkey.Neuter();\n+        out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n+    }\n+    return MakeUnique<BIP32PubkeyProvider>(extpubkey, std::move(path), type);\n+}\n+\n+/** Parse a public key including origin information (if enabled). */\n+std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto colon_split = Split(sp, ':');\n+    if (colon_split.size() > 2) return nullptr;\n+    if (colon_split.size() == 1) return ParsePubkeyInner(colon_split[0], permit_uncompressed, out);\n+#ifdef KEY_ORIGIN_SUPPORT\n+    auto slash_split = Split(colon_split[0], '/');\n+    if (slash_split[0].size() != 8) return nullptr;\n+    std::string fpr_hex = std::string(slash_split[0].begin(), slash_split[0].end());\n+    if (!IsHex(fpr_hex)) return nullptr;\n+    auto fpr_bytes = ParseHex(fpr_hex);\n+    uint32_t fpr = ReadBE32(fpr_bytes.data());\n+    KeyPath path;\n+    if (!ParseKeyPath(slash_split, path)) return nullptr;\n+    auto provider = ParsePubkeyInner(colon_split[1], permit_uncompressed, out);\n+    if (!provider) return nullptr;\n+    return MakeUnique<OriginPubkeyProvider>(fpr, std::move(path), std::move(provider));\n+#else\n+    return nullptr;\n+#endif\n+}\n+\n+/** Parse a script in a particular context. */\n+std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+{\n+    auto expr = Expr(sp);\n+    if (Func(\"pk\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+    }\n+    if (Func(\"pkh\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKHGetScript, \"pkh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"old\", expr)) {\n+        auto pubkey = ParsePubkey(expr, true, out);\n+        if (pubkey) return MakeUnique<OldKeyDescriptor>(std::move(pubkey));\n+    }\n+    if (Func(\"multi\", expr)) {\n+        auto threshold = Expr(expr);\n+        uint32_t thres;\n+        std::vector<std::unique_ptr<PubkeyProvider>> providers;\n+        if (!ParseUInt32(std::string(threshold.begin(), threshold.end()), &thres)) return nullptr;\n+        size_t script_size = 0;\n+        while (expr.size()) {\n+            if (!Const(\",\", expr)) return nullptr;\n+            auto arg = Expr(expr);\n+            auto pk = ParsePubkey(arg, ctx != ParseScriptContext::P2WSH, out);\n+            if (!pk) return nullptr;\n+            script_size += pk->GetSize() + 1;\n+            providers.emplace_back(std::move(pk));\n+        }\n+        if (providers.size() < 1 || providers.size() > 16 || thres < 1 || thres > providers.size()) return nullptr;\n+        if (ctx == ParseScriptContext::TOP) {\n+            if (providers.size() > 3) return nullptr; // Not more than 3 pubkeys for raw multisig\n+        }\n+        if (ctx == ParseScriptContext::P2SH) {\n+            if (script_size + 3 > 520) return nullptr; // Enforce P2SH script size limit\n+        }\n+        return MakeUnique<MultisigDescriptor>(thres, std::move(providers));\n+    }\n+    if (ctx != ParseScriptContext::P2WSH && Func(\"wpkh\", expr)) {\n+        auto pubkey = ParsePubkey(expr, false, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2WPKHGetScript, \"wpkh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"sh\", expr)) {\n+        auto desc = ParseScript(expr, ParseScriptContext::P2SH, out);\n+        if (desc && expr.size() == 0) return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2SH, \"sh\");\n+    }\n+    if (ctx != ParseScriptContext::P2WSH && Func(\"wsh\", expr)) {\n+        auto desc = ParseScript(expr, ParseScriptContext::P2WSH, out);\n+        if (desc && expr.size() == 0) return MakeUnique<ConvertorDescriptor>(std::move(desc), ConvertP2WSH, \"wsh\");\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"addr\", expr)) {\n+        CTxDestination dest = DecodeDestination(std::string(expr.begin(), expr.end()));\n+        if (IsValidDestination(dest)) return MakeUnique<AddressDescriptor>(std::move(dest));\n+    }\n+    if (ctx == ParseScriptContext::TOP && Func(\"raw\", expr)) {\n+        std::string str(expr.begin(), expr.end());\n+        if (IsHex(str)) {\n+            auto bytes = ParseHex(str);\n+            return MakeUnique<RawDescriptor>(CScript(bytes.begin(), bytes.end()));\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+} // namespace\n+\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out)\n+{\n+    Span<const char> sp(descriptor.data(), descriptor.size());\n+    auto ret = ParseScript(sp, ParseScriptContext::TOP, out);\n+    if (sp.size() == 0 && ret) return std::move(ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501008",
      "id" : 203501008,
      "in_reply_to_id" : 203436690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMTAwOA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 617,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138403563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501008",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501110"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501110"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's pretty verbose to use the long form, and probably not all that often needed.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:27:27Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501110",
      "id" : 203501110,
      "in_reply_to_id" : 203443145,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMTExMA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 84,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 86,
      "pull_request_review_id" : 138403712,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501110",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501180"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501180"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, will add when there's sufficient agreement about RPC.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:27:46Z",
      "diff_hunk" : "@@ -2090,79 +2060,35 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n \n         // loop through the scan objects\n         for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n-            if (!scanobject.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n-            }\n-            UniValue address_uni = find_value(scanobject, \"address\");\n-            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n-            UniValue script_uni  = find_value(scanobject, \"script\");\n-\n-            // make sure only one object type is present\n-            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n-            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n-            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n-            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n-            } else if (address_uni.isStr()) {\n-                // type: address\n-                // decode destination and derive the scriptPubKey\n-                // add the script to the scan containers\n-                CTxDestination dest = DecodeDestination(address_uni.get_str());\n-                if (!IsValidDestination(dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-                }\n-                CScript script = GetScriptForDestination(dest);\n-                assert(!script.empty());\n-                needles.insert(script);\n-            } else if (pubkey_uni.isObject()) {\n-                // type: pubkey\n-                // derive script(s) according to the script_type parameter\n-                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n-                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n-\n-                // check the script types and use the default if not provided\n-                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n-                } else if (script_types_uni.isNull()) {\n-                    // use the default script types\n-                    script_types_uni = UniValue(UniValue::VARR);\n-                    for (const char *t : g_default_scantxoutset_script_types) {\n-                        script_types_uni.push_back(t);\n-                    }\n-                }\n-\n-                // check the acctual pubkey\n-                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n-                }\n-                CPubKey pubkey(ParseHexV(pubkeydata_uni, \"pubkey\"));\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+            std::string desc_str;\n+            int range = 1000;\n+            if (scanobject.isStr()) {\n+                desc_str = scanobject.get_str();\n+            } else if (scanobject.isObject()) {\n+                UniValue desc_uni = find_value(scanobject, \"desc\");\n+                if (desc_uni.isNull()) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor needs to be provided in scan object\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501180",
      "id" : 203501180,
      "in_reply_to_id" : 203443457,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMTE4MA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 156,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 158,
      "pull_request_review_id" : 138403805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501180",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501298"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501298"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done,  here and elsewhere.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:28:10Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {\n+        if (*it == sep) {\n+            ret.emplace_back(start, it);\n+            start = it + 1;\n+        }\n+        ++it;\n+    }\n+    ret.emplace_back(start, it);\n+    return ret;\n+}\n+\n+/** Parse a key path, being passed a split list of elements (the first element is ignored). */\n+bool ParseKeyPath(const std::vector<Span<const char>>& split, KeyPath& out)\n+{\n+    for (size_t i = 1; i < split.size(); ++i) {\n+        Span<const char> elem = split[i];\n+        bool hardened = false;\n+        if (elem.size() > 0 && elem[elem.size() - 1] == '\\'') {\n+            elem = elem.first(elem.size() - 1);\n+            hardened = true;\n+        }\n+        uint32_t p;\n+        if (!ParseUInt32(std::string(elem.begin(), elem.end()), &p) || p > 0x7FFFFFFFUL) return false;\n+        out.push_back(p | (((uint32_t)hardened) << 31));\n+    }\n+    return true;\n+}\n+\n+/** Parse a public key that excludes origin information. */\n+std::unique_ptr<PubkeyProvider> ParsePubkeyInner(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto split = Split(sp, '/');\n+    std::string str(split[0].begin(), split[0].end());\n+    if (split.size() == 1) {\n+        if (IsHex(str)) {\n+            std::vector<unsigned char> data = ParseHex(str);\n+            CPubKey pubkey(data);\n+            if (pubkey.IsFullyValid() && (permit_uncompressed || pubkey.IsCompressed())) return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+        CKey key = DecodeSecret(str);\n+        if (key.IsValid() && (permit_uncompressed || key.IsCompressed())) {\n+            CPubKey pubkey = key.GetPubKey();\n+            out.keys.emplace(pubkey.GetID(), key);\n+            return MakeUnique<ConstPubkeyProvider>(pubkey);\n+        }\n+    }\n+    CExtKey extkey = DecodeExtKey(str);\n+    CExtPubKey extpubkey = DecodeExtPubKey(str);\n+    if (!extkey.key.IsValid() && !extpubkey.pubkey.IsValid()) return nullptr;\n+    KeyPath path;\n+    DeriveType type = DeriveType::NO;\n+    if (split.back() == MakeSpan(\"*\").first(1)) {\n+        split.pop_back();\n+        type = DeriveType::UNHARDENED;\n+    } else if (split.back() == MakeSpan(\"*'\").first(2)) {\n+        split.pop_back();\n+        type = DeriveType::HARDENED;\n+    }\n+    if (!ParseKeyPath(split, path)) return nullptr;\n+    if (extkey.key.IsValid()) {\n+        extpubkey = extkey.Neuter();\n+        out.keys.emplace(extpubkey.pubkey.GetID(), extkey.key);\n+    }\n+    return MakeUnique<BIP32PubkeyProvider>(extpubkey, std::move(path), type);\n+}\n+\n+/** Parse a public key including origin information (if enabled). */\n+std::unique_ptr<PubkeyProvider> ParsePubkey(const Span<const char>& sp, bool permit_uncompressed, FlatSigningProvider& out)\n+{\n+    auto colon_split = Split(sp, ':');\n+    if (colon_split.size() > 2) return nullptr;\n+    if (colon_split.size() == 1) return ParsePubkeyInner(colon_split[0], permit_uncompressed, out);\n+#ifdef KEY_ORIGIN_SUPPORT\n+    auto slash_split = Split(colon_split[0], '/');\n+    if (slash_split[0].size() != 8) return nullptr;\n+    std::string fpr_hex = std::string(slash_split[0].begin(), slash_split[0].end());\n+    if (!IsHex(fpr_hex)) return nullptr;\n+    auto fpr_bytes = ParseHex(fpr_hex);\n+    uint32_t fpr = ReadBE32(fpr_bytes.data());\n+    KeyPath path;\n+    if (!ParseKeyPath(slash_split, path)) return nullptr;\n+    auto provider = ParsePubkeyInner(colon_split[1], permit_uncompressed, out);\n+    if (!provider) return nullptr;\n+    return MakeUnique<OriginPubkeyProvider>(fpr, std::move(path), std::move(provider));\n+#else\n+    return nullptr;\n+#endif\n+}\n+\n+/** Parse a script in a particular context. */\n+std::unique_ptr<Descriptor> ParseScript(Span<const char>& sp, ParseScriptContext ctx, FlatSigningProvider& out)\n+{\n+    auto expr = Expr(sp);\n+    if (Func(\"pk\", expr)) {\n+        auto pubkey = ParsePubkey(expr, ctx != ParseScriptContext::P2WSH, out);\n+        if (pubkey) return MakeUnique<SingleKeyDescriptor>(std::move(pubkey), P2PKGetScript, \"pk\");\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501298",
      "id" : 203501298,
      "in_reply_to_id" : 203446922,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMTI5OA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 553,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138403956,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501298",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501337"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501337"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T19:28:18Z",
      "diff_hunk" : "@@ -0,0 +1,100 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_DESCRIPTOR_H\n+#define BITCOIN_SCRIPT_DESCRIPTOR_H\n+\n+#include <script/script.h>\n+#include <script/sign.h>\n+\n+#include <vector>\n+\n+// Descriptors are strings that describe a set of scriptPubKeys, together with\n+// all information necessary to solve them. By combining all information into\n+// one, they avoid the need to separately import keys and scripts.\n+//\n+// Descriptors may be ranged, which occurs when the public keys inside are\n+// specified in the form of HD chains (xpubs).\n+//\n+// Descriptors always represent public information - public keys and scripts -\n+// but in cases where private keys need to be conveyed along with a descriptor,\n+// they can be included inside by changing public keys to private keys (WIF\n+// format), and changing xpubs by xprvs.\n+//\n+// 1. Examples\n+//\n+// A P2PK descriptor with a fixed public key:\n+// - pk(0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798)\n+//\n+// A P2SH-P2WSH-P2PKH descriptor with a fixed public key:\n+// - sh(wsh(pkh(02e493dbf1c10d80f3581e4904930b1404cc6c13900ee0758474fa94abe8c4cd13)))\n+//\n+// A bare 1-of-2 multisig descriptor:\n+// - multi(1,022f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4,025cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc)\n+//\n+// A chain of P2PKH outputs (this needs the corresponding private key to derive):\n+// - pkh(xpub68Gmy5EdvgibQVfPdqkBBCHxA5htiqg55crXYuXoQRKfDBFA1WEjWgP6LHhwBZeNK1VTsfTFUHCdrfp1bgwQ9xv5ski8PX9rL2dZXvgGDnw/1'/2/*)\n+//\n+// 2. Grammar description:\n+//\n+// X: xpub or xprv encoded extended key\n+// I: decimal encoded integer\n+// H: Hex encoded byte array\n+// A: Address in P2PKH, P2SH, or Bech32 encoding\n+//\n+// S (Scripts):\n+// * pk(P): Pay-to-pubkey (P2PK) output for public key P.\n+// * pkh(P): Pay-to-pubkey-hash (P2PKH) output for public key P.\n+// * wpkh(P): Pay-to-witness-pubkey-hash (P2WPKH) output for public key P.\n+// * sh(S): Pay-to-script-hash (P2SH) output for script S\n+// * wsh(S): Pay-to-witness-script-hash (P2WSH) output for script S\n+// * old(P): combination of P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH for public key P.\n+// * multi(I,L): k-of-n multisig for given public keys\n+// * addr(A): Output to address\n+// * raw(H): scriptPubKey with raw bytes\n+//\n+// P (Public keys):\n+// * H: fixed public key (or WIF-encoded private key)\n+// * E: extended public key\n+// * E/*: (ranged) all unhardened direct children of an extended public key\n+// * E/*': (ranged) all hardened direct children of an extended public key\n+//\n+// L (Comma-separated lists of public keys):\n+// * P\n+// * L,P\n+//\n+// E (Extended public keys):\n+// * X\n+// * E/I: unhardened child\n+// * E/I': hardened child\n+//\n+// The top level is S.\n+\n+/** Interface for parsed descriptor objects. */\n+struct Descriptor {\n+    virtual ~Descriptor() {}\n+\n+    /** Whether the expansion of this descriptor depends on the position. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Convert the descriptor back to a string, undoing parsing. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Convert the descriptor to a private string. This fails if the provided provider does not have the relevant private keys. */\n+    virtual bool ToPrivateString(const SigningProvider& provider, std::string& out) const = 0;\n+\n+    /** Expand a descriptor at a specified position.\n+     *\n+     * pos: the position at which to expand the descriptor. If IsRange() is false, this is ignored.\n+     * provider: the provider to query for private keys in case of hardened derivation.\n+     * output_script: the expanded scriptPubKeys will be put here.\n+     * out: scripts and public keys necessary for solving the expanded scriptPubKeys will be put here (may be equal to provider).\n+     */\n+    virtual bool Expand(int pos, const SigningProvider& provider, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const = 0;\n+};\n+\n+/** Parse a descriptor string. Included private keys are put in out. Returns nullptr if parsing fails. */\n+std::unique_ptr<Descriptor> Parse(const std::string& descriptor, FlatSigningProvider& out);\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203501337",
      "id" : 203501337,
      "in_reply_to_id" : 203447244,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUwMTMzNw==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 100,
      "path" : "src/script/descriptor.h",
      "position" : null,
      "pull_request_review_id" : 138404004,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203501337",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, removed future \"key origin\" support (not needed right now, ignore).\r\n\r\nAlso, I'd like people to first review the descriptor language itself (a very short summary is in the RPC help, more of a reference in script/descriptor.h, and a design document in https://gist.github.com/sipa/e3d23d498c430bb601c5bca83523fa82). In particular, I'm not convinced about the \"old\" function (which maps pubkeys to P2PK,P2PKH,P2WPKH, and P2SH-PWPKH) - it's very useful for dealing with existing Core wallets, but \"old\" doesn't really convey the right meaning. However, I don't see what else to use. \"legacy\" is confusing (as it would have a different meaning than legacy in -addresstype). \"default\" sounds like it could change over time (the intention is that it wouldn't). \"sk\" or \"singlekey\" sounds like it's encouraged and/or could change over time, ...",
      "created_at" : "2018-07-18T19:31:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-406047815",
      "id" : 406047815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNjA0NzgxNQ==",
      "updated_at" : "2018-07-18T19:31:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406047815",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203517259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203517259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The statement `ret.emplace_back(start, it);` below should not be executed if `sp` is empty.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T20:25:19Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203517259",
      "id" : 203517259,
      "in_reply_to_id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUxNzI1OQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138423920,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203517259",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203517440"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203517440"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I mean, should `Split(\"\", sep)` equal `[]`?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T20:25:53Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203517440",
      "id" : 203517440,
      "in_reply_to_id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUxNzQ0MA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138424121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203517440",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203518803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203518803"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, it should be `[\"\"]`. Callers can rely on there always being at least one argument in the result.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T20:30:05Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203518803",
      "id" : 203518803,
      "in_reply_to_id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUxODgwMw==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138425789,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203518803",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203520519"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203520519"
         }
      },
      "author_association" : "MEMBER",
      "body" : "In that case  ",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T20:35:48Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {\n+            out += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) out += '\\'';\n+        }\n+        if (IsRange()) {\n+            out += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) out += '\\'';\n+        }\n+        return true;\n+    }\n+};\n+\n+/** A parsed addr(A) descriptor. */\n+class AddressDescriptor final : public Descriptor\n+{\n+    CTxDestination m_destination;\n+\n+public:\n+    AddressDescriptor(CTxDestination destination) : m_destination(std::move(destination)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"addr(\" + EncodeDestination(m_destination) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{GetScriptForDestination(m_destination)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed raw(H) descriptor. */\n+class RawDescriptor final : public Descriptor\n+{\n+    CScript m_script;\n+\n+public:\n+    RawDescriptor(CScript script) : m_script(std::move(script)) {}\n+\n+    bool IsRange() const override { return false; }\n+    std::string ToString() const override { return \"raw(\" + HexStr(m_script.begin(), m_script.end()) + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override { out = ToString(); return true; }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        output_scripts = std::vector<CScript>{m_script};\n+        return true;\n+    }\n+};\n+\n+/** A parsed pk(P), pkh(P), or wpkh(P) descriptor. */\n+class SingleKeyDescriptor final : public Descriptor\n+{\n+    const std::function<CScript(const CPubKey&)> m_script_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    SingleKeyDescriptor(std::unique_ptr<PubkeyProvider> prov, const std::function<CScript(const CPubKey&)>& fn, const std::string& name) : m_script_fn(fn), m_fn_name(name), m_provider(std::move(prov)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        output_scripts = std::vector<CScript>{m_script_fn(key)};\n+        out.pubkeys.emplace(key.GetID(), std::move(key));\n+        return true;\n+    }\n+};\n+\n+CScript P2PKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(pubkey.GetID()); }\n+CScript P2PKGetScript(const CPubKey& pubkey) { return GetScriptForRawPubKey(pubkey); }\n+CScript P2WPKHGetScript(const CPubKey& pubkey) { return GetScriptForDestination(WitnessV0KeyHash(pubkey.GetID())); }\n+\n+/** A parsed multi(...) descriptor. */\n+class MultisigDescriptor : public Descriptor\n+{\n+    int m_threshold;\n+    std::vector<std::unique_ptr<PubkeyProvider>> m_providers;\n+\n+public:\n+    MultisigDescriptor(int threshold, std::vector<std::unique_ptr<PubkeyProvider>> providers) : m_threshold(threshold), m_providers(std::move(providers)) {}\n+\n+    bool IsRange() const override\n+    {\n+        for (const auto& p : m_providers) {\n+            if (p->IsRange()) return true;\n+        }\n+        return false;\n+    }\n+\n+    std::string ToString() const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            ret += \",\" + p->ToString();\n+        }\n+        return std::move(ret) + \")\";\n+    }\n+\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret = strprintf(\"multi(%i\", m_threshold);\n+        for (const auto& p : m_providers) {\n+            std::string sub;\n+            if (!p->ToPrivateString(arg, sub)) return false;\n+            ret += \",\" + std::move(sub);\n+        }\n+        out = std::move(ret) + \")\";\n+        return true;\n+    }\n+\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CPubKey> pubkeys;\n+        pubkeys.reserve(m_providers.size());\n+        for (const auto& p : m_providers) {\n+            CPubKey key;\n+            if (!p->GetPubKey(pos, arg, key)) return false;\n+            pubkeys.push_back(key);\n+        }\n+        for (const CPubKey& key : pubkeys) {\n+            out.pubkeys.emplace(key.GetID(), std::move(key));\n+        }\n+        output_scripts = std::vector<CScript>{GetScriptForMultisig(m_threshold, pubkeys)};\n+        return true;\n+    }\n+};\n+\n+/** A parsed sh(S) or wsh(S) descriptor. */\n+class ConvertorDescriptor : public Descriptor\n+{\n+    const std::function<CScript(const CScript&)> m_convert_fn;\n+    const std::string m_fn_name;\n+    std::unique_ptr<Descriptor> m_descriptor;\n+\n+public:\n+    ConvertorDescriptor(std::unique_ptr<Descriptor> descriptor, const std::function<CScript(const CScript&)>& fn, const std::string& name) : m_convert_fn(fn), m_fn_name(name), m_descriptor(std::move(descriptor)) {}\n+\n+    bool IsRange() const override { return m_descriptor->IsRange(); }\n+    std::string ToString() const override { return m_fn_name + \"(\" + m_descriptor->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_descriptor->ToPrivateString(arg, ret)) return false;\n+        out = m_fn_name + \"(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        std::vector<CScript> sub;\n+        if (!m_descriptor->Expand(pos, arg, sub, out)) return false;\n+        output_scripts.clear();\n+        for (const auto& script : sub) {\n+            CScriptID id(script);\n+            out.scripts.emplace(CScriptID(script), script);\n+            output_scripts.push_back(m_convert_fn(script));\n+        }\n+        return true;\n+    }\n+};\n+\n+CScript ConvertP2SH(const CScript& script) { return GetScriptForDestination(CScriptID(script)); }\n+CScript ConvertP2WSH(const CScript& script) { return GetScriptForDestination(WitnessV0ScriptHash(script)); }\n+\n+/** A parsed old(P) descriptor. */\n+class OldKeyDescriptor final : public Descriptor\n+{\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+public:\n+    OldKeyDescriptor(std::unique_ptr<PubkeyProvider> provider) : m_provider(std::move(provider)) {}\n+\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    std::string ToString() const override { return \"old(\" + m_provider->ToString() + \")\"; }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        std::string ret;\n+        if (!m_provider->ToPrivateString(arg, ret)) return false;\n+        out = \"old(\" + std::move(ret) + \")\";\n+        return true;\n+    }\n+    bool Expand(int pos, const SigningProvider& arg, std::vector<CScript>& output_scripts, FlatSigningProvider& out) const override\n+    {\n+        CPubKey key;\n+        if (!m_provider->GetPubKey(pos, arg, key)) return false;\n+        CKeyID keyid = key.GetID();\n+        {\n+            CScript p2pk = GetScriptForRawPubKey(key);\n+            CScript p2pkh = GetScriptForDestination(keyid);\n+            output_scripts = std::vector<CScript>{std::move(p2pk), std::move(p2pkh)};\n+            out.pubkeys.emplace(keyid, key);\n+        }\n+        if (key.IsCompressed()) {\n+            CScript p2wpkh = GetScriptForDestination(WitnessV0KeyHash(keyid));\n+            CScriptID p2wpkh_id(p2wpkh);\n+            CScript p2sh_p2wpkh = GetScriptForDestination(p2wpkh_id);\n+            out.scripts.emplace(p2wpkh_id, p2wpkh);\n+            output_scripts.push_back(std::move(p2wpkh));\n+            output_scripts.push_back(std::move(p2sh_p2wpkh));\n+        }\n+        return true;\n+    }\n+};\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Parser                                                                 //\n+////////////////////////////////////////////////////////////////////////////\n+\n+enum class ParseScriptContext {\n+    TOP,\n+    P2SH,\n+    P2WSH,\n+};\n+\n+/** Parse a constant. If succesful, sp is updated to skip the constant and return true. */\n+bool Const(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size());\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Parse a function call. If succesful, sp is updated to be the function's argument(s). */\n+bool Func(const std::string& str, Span<const char>& sp)\n+{\n+    if ((size_t)sp.size() >= str.size() + 2 && sp[str.size()] == '(' && sp[sp.size() - 1] == ')' && std::equal(str.begin(), str.end(), sp.begin())) {\n+        sp = sp.subspan(str.size() + 1, sp.size() - str.size() - 2);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+/** Return the expression that sp begins with, and update sp to skip it. */\n+Span<const char> Expr(Span<const char>& sp)\n+{\n+    int level = 0;\n+    auto it = sp.begin();\n+    while (it != sp.end()) {\n+        if (*it == '(') {\n+            ++level;\n+        } else if (level && *it == ')') {\n+            --level;\n+        } else if (level == 0 && (*it == ')' || *it == ',')) {\n+            break;\n+        }\n+        ++it;\n+    }\n+    Span<const char> ret = sp.first(it - sp.begin());\n+    sp = sp.subspan(it - sp.begin());\n+    return ret;\n+}\n+\n+/** Split a string on every instance of sep, returning a vector. */\n+std::vector<Span<const char>> Split(const Span<const char>& sp, char sep)\n+{\n+    std::vector<Span<const char>> ret;\n+    auto it = sp.begin();\n+    auto start = it;\n+    while (it != sp.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203520519",
      "id" : 203520519,
      "in_reply_to_id" : 203426710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUyMDUxOQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 457,
      "path" : "src/script/descriptor.cpp",
      "position" : 422,
      "pull_request_review_id" : 138427853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203520519",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203522024"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203522024"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> It's pretty verbose\r\n\r\nOn the client side I think it doesn't matter (unless it's a human making the call).",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T20:41:04Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203522024",
      "id" : 203522024,
      "in_reply_to_id" : 203443145,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzUyMjAyNA==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 84,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 86,
      "pull_request_review_id" : 138429780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203522024",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Regarding the \"old\" function, I think it could receive the version, for instance `default(args..., version)`  it should validate if args are compatible with the version specified (at the moment args should be only a pubkey).",
      "created_at" : "2018-07-18T20:56:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-406071681",
      "id" : 406071681,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNjA3MTY4MQ==",
      "updated_at" : "2018-07-18T21:02:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406071681",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@promag There is no intention of ever adding another of those \"defaults\". Future versions should work with specific derivations (only P2WSH directly for example, rather than a collection). It's only for compatibility with the backward way we used to derive what scriptPubKeys are ours that such a default is useful.",
      "created_at" : "2018-07-18T21:06:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-406074546",
      "id" : 406074546,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNjA3NDU0Ng==",
      "updated_at" : "2018-07-18T21:08:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406074546",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203551841"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203551841"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, the reason to support the short notation is to simplify things for humans.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T22:33:41Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203551841",
      "id" : 203551841,
      "in_reply_to_id" : 203443145,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzU1MTg0MQ==",
      "original_commit_id" : "1b7c0c7fbd346109721197cefd4d464fc0bcae0b",
      "original_position" : 84,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 86,
      "pull_request_review_id" : 138465633,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203551841",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203553644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203553644"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-18T22:41:00Z",
      "diff_hunk" : "@@ -0,0 +1,619 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/descriptor.h>\n+\n+#include <key_io.h>\n+#include <pubkey.h>\n+#include <script/script.h>\n+#include <script/standard.h>\n+\n+#include <span.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+\n+////////////////////////////////////////////////////////////////////////////\n+// Internal representation                                                //\n+////////////////////////////////////////////////////////////////////////////\n+\n+typedef std::vector<uint32_t> KeyPath;\n+\n+/** Interface for public key objects in descriptors. */\n+struct PubkeyProvider {\n+    virtual ~PubkeyProvider(){};\n+\n+    /** Derive a public key. */\n+    virtual bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const = 0;\n+\n+    /** Whether this represent multiple public keys at different positions. */\n+    virtual bool IsRange() const = 0;\n+\n+    /** Get the size of the generated public key(s) in bytes (33 or 65). */\n+    virtual size_t GetSize() const = 0;\n+\n+    /** Get the descriptor string form. */\n+    virtual std::string ToString() const = 0;\n+\n+    /** Get the descriptor string form including private data (if available in arg). */\n+    virtual bool ToPrivateString(const SigningProvider& arg, std::string& out) const = 0;\n+};\n+\n+#ifdef KEY_ORIGIN_SUPPORT\n+class OriginPubkeyProvider final : public PubkeyProvider\n+{\n+    uint32_t m_fingerprint;\n+    KeyPath m_path;\n+    std::unique_ptr<PubkeyProvider> m_provider;\n+\n+    std::string OriginString() const\n+    {\n+        std::string ret = strprintf(\"%08x\", m_fingerprint);\n+        for (uint32_t x : m_path) {\n+            if (x >> 31) {\n+                ret += strprintf(\"/%i'\", (x << 1) >> 1);\n+            } else {\n+                ret += strprintf(\"/%i\", x);\n+            }\n+        }\n+        return ret;\n+    }\n+\n+public:\n+    OriginPubkeyProvider(uint32_t fingerprint, KeyPath path, std::unique_ptr<PubkeyProvider> provider) : m_fingerprint(fingerprint), m_path(std::move(path)), m_provider(std::move(provider)) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override { return m_provider->GetPubKey(pos, arg, out); }\n+    bool IsRange() const override { return m_provider->IsRange(); }\n+    size_t GetSize() const override { return m_provider->GetSize(); }\n+    std::string ToString() const override { return OriginString() + \":\" + m_provider->ToString(); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        std::string sub;\n+        if (!m_provider->ToPrivateString(arg, sub)) return false;\n+        ret = OriginString() + \":\" + std::move(sub);\n+        return true;\n+    }\n+};\n+#endif\n+\n+/** An object representing a parsed constant public key in a descriptor. */\n+class ConstPubkeyProvider final : public PubkeyProvider\n+{\n+    CPubKey m_pubkey;\n+\n+public:\n+    ConstPubkeyProvider(const CPubKey& pubkey) : m_pubkey(pubkey) {}\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        out = m_pubkey;\n+        return true;\n+    }\n+    bool IsRange() const override { return false; }\n+    size_t GetSize() const override { return m_pubkey.size(); }\n+    std::string ToString() const override { return HexStr(m_pubkey.begin(), m_pubkey.end()); }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& ret) const override\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_pubkey.GetID(), key)) return false;\n+        ret = EncodeSecret(key);\n+        return true;\n+    }\n+};\n+\n+enum class DeriveType {\n+    NO,\n+    UNHARDENED,\n+    HARDENED,\n+};\n+\n+/** An object representing a parsed extended public key in a descriptor. */\n+class BIP32PubkeyProvider final : public PubkeyProvider\n+{\n+    CExtPubKey m_extkey;\n+    KeyPath m_path;\n+    DeriveType m_derive;\n+\n+    bool GetExtKey(const SigningProvider& arg, CExtKey& ret) const\n+    {\n+        CKey key;\n+        if (!arg.GetKey(m_extkey.pubkey.GetID(), key)) return false;\n+        ret.nDepth = m_extkey.nDepth;\n+        std::copy(m_extkey.vchFingerprint, m_extkey.vchFingerprint + 4, ret.vchFingerprint);\n+        ret.nChild = m_extkey.nChild;\n+        ret.chaincode = m_extkey.chaincode;\n+        ret.key = key;\n+        return true;\n+    }\n+\n+    bool IsHardened() const\n+    {\n+        if (m_derive == DeriveType::HARDENED) return true;\n+        for (auto entry : m_path) {\n+            if (entry >> 31) return true;\n+        }\n+        return false;\n+    }\n+\n+public:\n+    BIP32PubkeyProvider(const CExtPubKey& extkey, KeyPath path, DeriveType derive) : m_extkey(extkey), m_path(std::move(path)), m_derive(derive) {}\n+    bool IsRange() const override { return m_derive != DeriveType::NO; }\n+    size_t GetSize() const override { return 33; }\n+    bool GetPubKey(int pos, const SigningProvider& arg, CPubKey& out) const override\n+    {\n+        if (IsHardened()) {\n+            CExtKey key;\n+            if (!GetExtKey(arg, key)) return false;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos | 0x80000000UL);\n+            }\n+            out = key.Neuter().pubkey;\n+        } else {\n+            // TODO: optimize by caching\n+            CExtPubKey key = m_extkey;\n+            for (auto entry : m_path) {\n+                key.Derive(key, entry);\n+            }\n+            if (IsRange()) {\n+                key.Derive(key, pos);\n+            }\n+            out = key.pubkey;\n+        }\n+        return true;\n+    }\n+    std::string ToString() const override\n+    {\n+        std::string ret = EncodeExtPubKey(m_extkey);\n+        for (auto entry : m_path) {\n+            ret += strprintf(\"/%i\", entry & 0x7FFFFFFFUL);\n+            if (entry >> 31) ret += '\\'';\n+        }\n+        if (IsRange()) {\n+            ret += \"/*\";\n+            if (m_derive == DeriveType::HARDENED) ret += '\\'';\n+        }\n+        return ret;\n+    }\n+    bool ToPrivateString(const SigningProvider& arg, std::string& out) const override\n+    {\n+        CExtKey key;\n+        if (!GetExtKey(arg, key)) return false;\n+        out = EncodeExtKey(key);\n+        for (auto entry : m_path) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r203553644",
      "id" : 203553644,
      "in_reply_to_id" : 203496728,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMzU1MzY0NA==",
      "original_commit_id" : "1143a75c2f74335365dc62063f2fdc6c74eefcda",
      "original_position" : 189,
      "path" : "src/script/descriptor.cpp",
      "position" : null,
      "pull_request_review_id" : 138467720,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/203553644",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204217254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204217254"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Don't forget to add a command-line example here, it look me a while to figure out the syntax from reading the above.\r\n\r\nI suggest an example with a typical BIP44 (legacy) xpub + BIP49 xpub:\r\n```\r\n[\"pkh(legacy_xpub/0/*)\", \"pkh(legacy_xpub/1/*)\", \"sh(wpkh(segwit_xpub/0/*)\", \"sh(wpkh(segwit_xpub/1/*)\"]\r\n```\r\n\r\nA second example could show the root master xpriv and then do hardened derivation of xpriv/44'/0'/0'/0/* or xpriv/49'/0'/0'/1/*",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-21T18:01:04Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"\n+            \"        {                         (object, optional) An object with output descriptor and metadata\\n\"\n+            \"          \\\"desc\\\": \\\"descriptor\\\",   (string, required) An output descriptor\\n\"\n+            \"          \\\"range\\\": n,             (numeric, optional) Up to what child index HD chains should be explored (default: 1000)\\n\"\n             \"        },\\n\"\n-            \"      ]\\n\"\n+            \"        ...\\n\"\n+            \"    ]\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204217254",
      "id" : 204217254,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDIxNzI1NA==",
      "original_commit_id" : "79b8939362f8a7ebacf709c3ba3934ec731bc076",
      "original_position" : 91,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 93,
      "pull_request_review_id" : 139264846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204217254",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204217288"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204217288"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`sh(wpkh())` is probably quite common, so maybe add that here?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-21T18:02:28Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204217288",
      "id" : 204217288,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDIxNzI4OA==",
      "original_commit_id" : "79b8939362f8a7ebacf709c3ba3934ec731bc076",
      "original_position" : 62,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 139264846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204217288",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204220348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204220348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-21T20:02:08Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"\n+            \"    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs for the given threshold and pubkeys\\n\"\n+            \"\\nIn the above, <pubkey> either refers to a fixed public key in hexadecimal notation, or to an xpub/xprv optionally followed by one\\n\"\n+            \"or more path elements separated by \\\"/\\\", and optionally ending in \\\"/*\\\" or \\\"/*'\\\" to specify all unhardened or hardened child keys.\\n\"\n+            \"In the latter case, a range needs to be specified by below if different from 1000.\\n\"\n+            \"For more information on output descriptors, see the documentation at TODO\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"action\\\"                       (string, required) The action to execute\\n\"\n             \"                                      \\\"start\\\" for starting a scan\\n\"\n             \"                                      \\\"abort\\\" for aborting the current scan (returns true when abort was successful)\\n\"\n             \"                                      \\\"status\\\" for progress report (in %) of the current scan\\n\"\n-            \"2. \\\"scanobjects\\\"                  (array, optional) Array of scan objects (only one object type per scan object allowed)\\n\"\n-            \"      [\\n\"\n-            \"        { \\\"address\\\" : \\\"<address>\\\" },       (string, optional) Bitcoin address\\n\"\n-            \"        { \\\"script\\\"  : \\\"<scriptPubKey>\\\" },  (string, optional) HEX encoded script (scriptPubKey)\\n\"\n-            \"        { \\\"pubkey\\\"  :                      (object, optional) Public key\\n\"\n-            \"          {\\n\"\n-            \"            \\\"pubkey\\\" : \\\"<pubkey\\\">,         (string, required) HEX encoded public key\\n\"\n-            \"            \\\"script_types\\\" : [ ... ],      (array, optional) Array of script-types to derive from the pubkey (possible values: \\\"P2PK\\\", \\\"P2PKH\\\", \\\"P2SH-P2WPKH\\\", \\\"P2WPKH\\\")\\n\"\n-            \"          }\\n\"\n+            \"2. \\\"scanobjects\\\"                  (array, required) Array of scan objects\\n\"\n+            \"    [                             Every scan object is either a string descriptor or an object:\\n\"\n+            \"        \\\"descriptor\\\",             (string, optional) An output descriptor\\n\"\n+            \"        {                         (object, optional) An object with output descriptor and metadata\\n\"\n+            \"          \\\"desc\\\": \\\"descriptor\\\",   (string, required) An output descriptor\\n\"\n+            \"          \\\"range\\\": n,             (numeric, optional) Up to what child index HD chains should be explored (default: 1000)\\n\"\n             \"        },\\n\"\n-            \"      ]\\n\"\n+            \"        ...\\n\"\n+            \"    ]\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204220348",
      "id" : 204220348,
      "in_reply_to_id" : 204217254,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDIyMDM0OA==",
      "original_commit_id" : "79b8939362f8a7ebacf709c3ba3934ec731bc076",
      "original_position" : 91,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 93,
      "pull_request_review_id" : 139267754,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204220348",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204220350"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204220350"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-21T20:02:15Z",
      "diff_hunk" : "@@ -1984,67 +1985,36 @@ class CoinsViewScanReserver\n     }\n };\n \n-static const char *g_default_scantxoutset_script_types[] = { \"P2PKH\", \"P2SH_P2WPKH\", \"P2WPKH\" };\n-\n-enum class OutputScriptType {\n-    UNKNOWN,\n-    P2PK,\n-    P2PKH,\n-    P2SH_P2WPKH,\n-    P2WPKH\n-};\n-\n-static inline OutputScriptType GetOutputScriptTypeFromString(const std::string& outputtype)\n-{\n-    if (outputtype == \"P2PK\") return OutputScriptType::P2PK;\n-    else if (outputtype == \"P2PKH\") return OutputScriptType::P2PKH;\n-    else if (outputtype == \"P2SH_P2WPKH\") return OutputScriptType::P2SH_P2WPKH;\n-    else if (outputtype == \"P2WPKH\") return OutputScriptType::P2WPKH;\n-    else return OutputScriptType::UNKNOWN;\n-}\n-\n-CTxDestination GetDestinationForKey(const CPubKey& key, OutputScriptType type)\n-{\n-    switch (type) {\n-    case OutputScriptType::P2PKH: return key.GetID();\n-    case OutputScriptType::P2SH_P2WPKH:\n-    case OutputScriptType::P2WPKH: {\n-        if (!key.IsCompressed()) return key.GetID();\n-        CTxDestination witdest = WitnessV0KeyHash(key.GetID());\n-        if (type == OutputScriptType::P2SH_P2WPKH) {\n-            CScript witprog = GetScriptForDestination(witdest);\n-            return CScriptID(witprog);\n-        } else {\n-            return witdest;\n-        }\n-    }\n-    default: assert(false);\n-    }\n-}\n-\n UniValue scantxoutset(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n             \"scantxoutset <action> ( <scanobjects> )\\n\"\n-            \"\\nScans the unspent transaction output set for possible entries that matches common scripts of given public keys.\\n\"\n-            \"Using addresses as scanobjects will _not_ detect unspent P2PK txouts\\n\"\n+            \"\\nScans the unspent transaction output set for entries that match certain output descriptors.\\n\"\n+            \"Examples of output descriptors are:\\n\"\n+            \"    addr(<address>)                      Outputs whose scriptPubKey corresponds to the specified address (does not include P2PK)\\n\"\n+            \"    raw(<hex script>)                    Outputs whose scriptPubKey equals the specified hex scripts\\n\"\n+            \"    old(<pubkey>)                        P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH outputs for the given pubkey\\n\"\n+            \"    pkh(<pubkey>)                        P2PKH outputs for the given pubkey\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r204220350",
      "id" : 204220350,
      "in_reply_to_id" : 204217288,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNDIyMDM1MA==",
      "original_commit_id" : "79b8939362f8a7ebacf709c3ba3934ec731bc076",
      "original_position" : 62,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 139267758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/204220350",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->No more conflicts as of last run.",
      "created_at" : "2018-07-22T13:27:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-406866602",
      "id" : 406866602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNjg2NjYwMg==",
      "updated_at" : "2018-07-30T15:10:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/406866602",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sipa since you write that `old` is a \"combination of P2PK, P2PKH, P2WPKH, and P2SH-P2WPKH for public key P.\", you could call it `combo` instead. Or `ck` if you want it to look more like the other things that use `P`. And potentially prepend `bc` to indicate it's for backwards compatibility (but in that case someone should check urban dictionary to make sure `bcck` isn't some newfangled swear word :-))",
      "created_at" : "2018-07-25T13:30:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-407754444",
      "id" : 407754444,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwNzc1NDQ0NA==",
      "updated_at" : "2018-07-25T13:30:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/407754444",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/425166?v=4",
         "events_url" : "https://api.github.com/users/flack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/flack/followers",
         "following_url" : "https://api.github.com/users/flack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/flack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/flack",
         "id" : 425166,
         "login" : "flack",
         "node_id" : "MDQ6VXNlcjQyNTE2Ng==",
         "organizations_url" : "https://api.github.com/users/flack/orgs",
         "received_events_url" : "https://api.github.com/users/flack/received_events",
         "repos_url" : "https://api.github.com/users/flack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/flack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/flack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/flack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@flack Oh, I like that. Changed to \"combo\".",
      "created_at" : "2018-07-26T19:11:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408204024",
      "id" : 408204024,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODIwNDAyNA==",
      "updated_at" : "2018-07-26T19:11:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408204024",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Travis failure:\r\n\r\n```\r\ntest_framework.authproxy.JSONRPCException: Invalid descriptor 'old(03abcaca414970a8d36624011628045855cb01cded780445a33688a0b905a47224)' (-5)",
      "created_at" : "2018-07-26T20:08:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408219631",
      "id" : 408219631,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODIxOTYzMQ==",
      "updated_at" : "2018-07-26T20:08:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408219631",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "First two findings:\r\n\r\n* I think supporting `h` as equivalent to `'` in extended key derivation range would be great (JSON / shell / GUI). I suggest pulling in https://github.com/bitcoin/bitcoin/commit/203b4c94ce83981b0d76dd2adb778719ba868db1.\r\n\r\n* I think the `IsHardened()` function is not correct. Using `0'/0'/*` will derive all hardened keys at the * level (same as `0'/0'/*'`). Seems to be currently impossible to derive unhardened key with the asterisk.",
      "created_at" : "2018-07-27T08:47:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408354687",
      "id" : 408354687,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODM1NDY4Nw==",
      "updated_at" : "2018-07-27T08:47:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408354687",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r205713656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/205713656"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Seems like that results in an off-by-one issue (misses last key):\r\nSuggest pulling fix: https://github.com/bitcoin/bitcoin/commit/875431149745cc517350c0620baa887c748d0b35",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-27T09:13:18Z",
      "diff_hunk" : "@@ -2090,79 +2060,35 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n \n         // loop through the scan objects\n         for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n-            if (!scanobject.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n-            }\n-            UniValue address_uni = find_value(scanobject, \"address\");\n-            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n-            UniValue script_uni  = find_value(scanobject, \"script\");\n-\n-            // make sure only one object type is present\n-            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n-            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n-            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n-            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n-            } else if (address_uni.isStr()) {\n-                // type: address\n-                // decode destination and derive the scriptPubKey\n-                // add the script to the scan containers\n-                CTxDestination dest = DecodeDestination(address_uni.get_str());\n-                if (!IsValidDestination(dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-                }\n-                CScript script = GetScriptForDestination(dest);\n-                assert(!script.empty());\n-                needles.insert(script);\n-            } else if (pubkey_uni.isObject()) {\n-                // type: pubkey\n-                // derive script(s) according to the script_type parameter\n-                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n-                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n-\n-                // check the script types and use the default if not provided\n-                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n-                } else if (script_types_uni.isNull()) {\n-                    // use the default script types\n-                    script_types_uni = UniValue(UniValue::VARR);\n-                    for (const char *t : g_default_scantxoutset_script_types) {\n-                        script_types_uni.push_back(t);\n-                    }\n-                }\n-\n-                // check the acctual pubkey\n-                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n-                }\n-                CPubKey pubkey(ParseHexV(pubkeydata_uni, \"pubkey\"));\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+            std::string desc_str;\n+            int range = 1000;\n+            if (scanobject.isStr()) {\n+                desc_str = scanobject.get_str();\n+            } else if (scanobject.isObject()) {\n+                UniValue desc_uni = find_value(scanobject, \"desc\");\n+                if (desc_uni.isNull()) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor needs to be provided in scan object\");\n+                desc_str = desc_uni.get_str();\n+                UniValue range_uni = find_value(scanobject, \"range\");\n+                if (!range_uni.isNull()) {\n+                    range = range_uni.get_int();\n+                    if (range < 1 || range > 1000000) throw JSONRPCError(RPC_INVALID_PARAMETER, \"range out of range\");\n                 }\n+            } else {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan object needs to be either a string or an object\");\n+            }\n \n-                // loop through the script types and derive the script\n-                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n-                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n-                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n-                    CScript script;\n-                    if (script_type == OutputScriptType::P2PK) {\n-                        // support legacy P2PK scripts\n-                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n-                    } else {\n-                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n-                    }\n-                    assert(!script.empty());\n-                    needles.insert(script);\n+            FlatSigningProvider provider;\n+            auto desc = Parse(desc_str, provider);\n+            if (!desc) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid descriptor '%s'\", desc_str));\n+            }\n+            if (!desc->IsRange()) range = 1;\n+            for (int i = 0; i < range; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r205713656",
      "id" : 205713656,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTcxMzY1Ng==",
      "original_commit_id" : "852cf1f0785cf2ef6de34f0a9c426eacf39f11e8",
      "original_position" : 186,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 141038847,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/205713656",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Additional xpub range tests can be pulled from here: https://github.com/bitcoin/bitcoin/commit/cc1ffb324b53855f7eae81a6b0df10bd677ca1a5",
      "created_at" : "2018-07-27T09:14:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408361519",
      "id" : 408361519,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODM2MTUxOQ==",
      "updated_at" : "2018-07-27T09:14:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408361519",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "+1 on `h` alias\r\n\r\nI only tested unhardened derivation (`xpub/0/*`) because most wallets only export account level xpubs. @jonasschnelli maybe add a test for the `'/*)` pattern to cc1ffb3? It currently only checks `'/*')`",
      "created_at" : "2018-07-27T09:24:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408364209",
      "id" : 408364209,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODM2NDIwOQ==",
      "updated_at" : "2018-07-27T09:24:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408364209",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors: A test for `'/*` would currently fail,... but it's simple to add (keys are already prepared in \r\nhttps://github.com/bitcoin/bitcoin/commit/cc1ffb324b53855f7eae81a6b0df10bd677ca1a5), just waiting for a fix for the hardened/non-hardened mix.",
      "created_at" : "2018-07-27T09:54:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408371614",
      "id" : 408371614,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODM3MTYxNA==",
      "updated_at" : "2018-07-27T09:54:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408371614",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Suggest pulling in the experimental warning for scantxoutset here: https://github.com/bitcoin/bitcoin/commit/3ec0958ea746d0db5edefff9f423cd2caab32857",
      "created_at" : "2018-07-27T09:58:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408372532",
      "id" : 408372532,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODM3MjUzMg==",
      "updated_at" : "2018-07-27T09:58:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408372532",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r205854812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/205854812"
         }
      },
      "author_association" : "MEMBER",
      "body" : "BIP32 indexes are 0-based, so I think the current code is correct. If you expand 1000 keys, those will be indices 0 through 999.",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-07-27T18:02:39Z",
      "diff_hunk" : "@@ -2090,79 +2060,35 @@ UniValue scantxoutset(const JSONRPCRequest& request)\n \n         // loop through the scan objects\n         for (const UniValue& scanobject : request.params[1].get_array().getValues()) {\n-            if (!scanobject.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scan object\");\n-            }\n-            UniValue address_uni = find_value(scanobject, \"address\");\n-            UniValue pubkey_uni  = find_value(scanobject, \"pubkey\");\n-            UniValue script_uni  = find_value(scanobject, \"script\");\n-\n-            // make sure only one object type is present\n-            if (1 != !address_uni.isNull() + !pubkey_uni.isNull() + !script_uni.isNull()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Only one object type is allowed per scan object\");\n-            } else if (!address_uni.isNull() && !address_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"address\\\" must contain a single string as value\");\n-            } else if (!pubkey_uni.isNull() && !pubkey_uni.isObject()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"pubkey\\\" must contain an object as value\");\n-            } else if (!script_uni.isNull() && !script_uni.isStr()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scanobject \\\"script\\\" must contain a single string as value\");\n-            } else if (address_uni.isStr()) {\n-                // type: address\n-                // decode destination and derive the scriptPubKey\n-                // add the script to the scan containers\n-                CTxDestination dest = DecodeDestination(address_uni.get_str());\n-                if (!IsValidDestination(dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-                }\n-                CScript script = GetScriptForDestination(dest);\n-                assert(!script.empty());\n-                needles.insert(script);\n-            } else if (pubkey_uni.isObject()) {\n-                // type: pubkey\n-                // derive script(s) according to the script_type parameter\n-                UniValue script_types_uni = find_value(pubkey_uni, \"script_types\");\n-                UniValue pubkeydata_uni = find_value(pubkey_uni, \"pubkey\");\n-\n-                // check the script types and use the default if not provided\n-                if (!script_types_uni.isNull() && !script_types_uni.isArray()) {\n-                    throw JSONRPCError(RPC_INVALID_PARAMETER, \"script_types must be an array\");\n-                } else if (script_types_uni.isNull()) {\n-                    // use the default script types\n-                    script_types_uni = UniValue(UniValue::VARR);\n-                    for (const char *t : g_default_scantxoutset_script_types) {\n-                        script_types_uni.push_back(t);\n-                    }\n-                }\n-\n-                // check the acctual pubkey\n-                if (!pubkeydata_uni.isStr() || !IsHex(pubkeydata_uni.get_str())) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Public key must be hex encoded\");\n-                }\n-                CPubKey pubkey(ParseHexV(pubkeydata_uni, \"pubkey\"));\n-                if (!pubkey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid public key\");\n+            std::string desc_str;\n+            int range = 1000;\n+            if (scanobject.isStr()) {\n+                desc_str = scanobject.get_str();\n+            } else if (scanobject.isObject()) {\n+                UniValue desc_uni = find_value(scanobject, \"desc\");\n+                if (desc_uni.isNull()) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor needs to be provided in scan object\");\n+                desc_str = desc_uni.get_str();\n+                UniValue range_uni = find_value(scanobject, \"range\");\n+                if (!range_uni.isNull()) {\n+                    range = range_uni.get_int();\n+                    if (range < 1 || range > 1000000) throw JSONRPCError(RPC_INVALID_PARAMETER, \"range out of range\");\n                 }\n+            } else {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Scan object needs to be either a string or an object\");\n+            }\n \n-                // loop through the script types and derive the script\n-                for (const UniValue& script_type_uni : script_types_uni.get_array().getValues()) {\n-                    OutputScriptType script_type = GetOutputScriptTypeFromString(script_type_uni.get_str());\n-                    if (script_type == OutputScriptType::UNKNOWN) throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid script type\");\n-                    CScript script;\n-                    if (script_type == OutputScriptType::P2PK) {\n-                        // support legacy P2PK scripts\n-                        script << ToByteVector(pubkey) << OP_CHECKSIG;\n-                    } else {\n-                        script = GetScriptForDestination(GetDestinationForKey(pubkey, script_type));\n-                    }\n-                    assert(!script.empty());\n-                    needles.insert(script);\n+            FlatSigningProvider provider;\n+            auto desc = Parse(desc_str, provider);\n+            if (!desc) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, strprintf(\"Invalid descriptor '%s'\", desc_str));\n+            }\n+            if (!desc->IsRange()) range = 1;\n+            for (int i = 0; i < range; ++i) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r205854812",
      "id" : 205854812,
      "in_reply_to_id" : 205713656,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNTg1NDgxMg==",
      "original_commit_id" : "852cf1f0785cf2ef6de34f0a9c426eacf39f11e8",
      "original_position" : 186,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 141213208,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-07-27T19:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/205854812",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli Good catch; the derivation for \"/*\" with a parent hardened step is incorrect. Fixing.",
      "created_at" : "2018-07-27T18:09:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408497118",
      "id" : 408497118,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODQ5NzExOA==",
      "updated_at" : "2018-07-27T18:09:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408497118",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli Ok, fixed the derivation, changed the range to be max index rather than count, included your tests and experimental warning, and added a number of tests myself (generated with an independent BIP32 implementation).",
      "created_at" : "2018-07-27T18:53:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408508731",
      "id" : 408508731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODUwODczMQ==",
      "updated_at" : "2018-07-27T18:53:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408508731",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli Added support for h instead of ' in hardened descriptor paths as well (plus some tests for it). Serializing a descriptor will always use '.",
      "created_at" : "2018-07-27T19:23:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-408515755",
      "id" : 408515755,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODUxNTc1NQ==",
      "updated_at" : "2018-07-27T19:23:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408515755",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK f6b7fc3",
      "created_at" : "2018-08-01T15:52:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-409622920",
      "id" : 409622920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwOTYyMjkyMA==",
      "updated_at" : "2018-08-01T15:52:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/409622920",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "utACK f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-08-01T16:51:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#issuecomment-409643713",
      "id" : 409643713,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13697",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwOTY0MzcxMw==",
      "updated_at" : "2018-08-01T16:51:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/409643713",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r207197458"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/207197458"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe use `range: 1` and `range: 2` everywhere to speed up these tests?",
      "commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "created_at" : "2018-08-02T11:52:11Z",
      "diff_hunk" : "@@ -36,13 +52,39 @@ def run_test(self):\n \n         self.restart_node(0, ['-nowallet'])\n         self.log.info(\"Test if we have found the non HD unspent outputs.\")\n-        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"pubkey\": {\"pubkey\": pubk1}}, {\"pubkey\": {\"pubkey\": pubk2}}, {\"pubkey\": {\"pubkey\": pubk3}}])['total_amount'], 6)\n-        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"address\": addr_BECH32}])['total_amount'], 6)\n-        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"address\": addr_P2SH_SEGWIT}, {\"address\": addr_LEGACY}, {\"pubkey\": {\"pubkey\": pubk3}} ])['total_amount'], 6)\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"pkh(\" + pubk1 + \")\", \"pkh(\" + pubk2 + \")\", \"pkh(\" + pubk3 + \")\"])['total_amount'], Decimal(\"0.002\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"wpkh(\" + pubk1 + \")\", \"wpkh(\" + pubk2 + \")\", \"wpkh(\" + pubk3 + \")\"])['total_amount'], Decimal(\"0.004\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"sh(wpkh(\" + pubk1 + \"))\", \"sh(wpkh(\" + pubk2 + \"))\", \"sh(wpkh(\" + pubk3 + \"))\"])['total_amount'], Decimal(\"0.001\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(\" + pubk1 + \")\", \"combo(\" + pubk2 + \")\", \"combo(\" + pubk3 + \")\"])['total_amount'], Decimal(\"0.007\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"addr(\" + addr_P2SH_SEGWIT + \")\", \"addr(\" + addr_LEGACY + \")\", \"addr(\" + addr_BECH32 + \")\"])['total_amount'], Decimal(\"0.007\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"addr(\" + addr_P2SH_SEGWIT + \")\", \"addr(\" + addr_LEGACY + \")\", \"combo(\" + pubk3 + \")\"])['total_amount'], Decimal(\"0.007\"))\n \n-        self.log.info(\"Test invalid parameters.\")\n-        assert_raises_rpc_error(-8, 'Scanobject \"pubkey\" must contain an object as value', self.nodes[0].scantxoutset, \"start\", [ {\"pubkey\": pubk1}]) #missing pubkey object\n-        assert_raises_rpc_error(-8, 'Scanobject \"address\" must contain a single string as value', self.nodes[0].scantxoutset, \"start\", [ {\"address\": {\"address\": addr_P2SH_SEGWIT}}]) #invalid object for address object\n+        self.log.info(\"Test extended key derivation.\")\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0h/0h)\"])['total_amount'], Decimal(\"0.008\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0'/1h)\"])['total_amount'], Decimal(\"0.016\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/1500')\"])['total_amount'], Decimal(\"0.032\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0h/0)\"])['total_amount'], Decimal(\"0.064\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0h/1)\"])['total_amount'], Decimal(\"0.128\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/1500)\"])['total_amount'], Decimal(\"0.256\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0h/*h)\", \"range\": 1499}])['total_amount'], Decimal(\"0.024\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0'/*h)\", \"range\": 1500}])['total_amount'], Decimal(\"0.056\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0h/0'/*)\", \"range\": 1499}])['total_amount'], Decimal(\"0.192\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/0'/0h/*)\", \"range\": 1500}])['total_amount'], Decimal(\"0.448\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0')\"])['total_amount'], Decimal(\"0.512\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/1')\"])['total_amount'], Decimal(\"1.024\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/1500h)\"])['total_amount'], Decimal(\"2.048\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/0)\"])['total_amount'], Decimal(\"4.096\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/1)\"])['total_amount'], Decimal(\"8.192\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/1500)\"])['total_amount'], Decimal(\"16.384\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/0)\"])['total_amount'], Decimal(\"4.096\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/1)\"])['total_amount'], Decimal(\"8.192\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ \"combo(tpubD6NzVbkrYhZ4WaWSyoBvQwbpLkojyoTZPRsgXELWz3Popb3qkjcJyJUGLnL4qHHoQvao8ESaAstxYSnhyswJ76uZPStJRJCTKvosUCJZL5B/1/1/1500)\"])['total_amount'], Decimal(\"16.384\"))\n+        assert_equal(self.nodes[0].scantxoutset(\"start\", [ {\"desc\": \"combo(tprv8ZgxMBicQKsPd7Uf69XL1XwhmjHopUGep8GuEiJDZmbQz6o58LninorQAfcKZWARbtRtfnLcJ5MQ2AtHcQJCCRUcMRvmDUjyEmNUWwx8UbK/1/1/*')\", \"range\": 1499}])['total_amount'], Decimal(\"1.536\"))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13697#discussion_r207197458",
      "id" : 207197458,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwNzE5NzQ1OA==",
      "original_commit_id" : "f6b7fc349ccf9cfbeb7e91e19c20e2a2fcc9026f",
      "original_position" : 66,
      "path" : "test/functional/rpc_scantxoutset.py",
      "position" : 66,
      "pull_request_review_id" : 142757687,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13697",
      "updated_at" : "2018-08-02T11:52:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/207197458",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
