[
   {
      "body" : "This has been tested by setting up a node and then connected to it from the same source ip in a loop.\r\n\r\nAdditional testing is needed around multiple source ips.",
      "created_at" : "2015-07-05T07:46:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-118594113",
      "id" : 118594113,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-05T07:46:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/118594113",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "Concept ACK\r\n\r\nThis does need extensive testing in various scenarios - e.g. what happens with Tor hidden service connections, which all appear to come from one IP (localhost) address.",
      "created_at" : "2015-07-05T07:55:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-118594345",
      "id" : 118594345,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-05T09:14:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/118594345",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Tested with multiple inbound connections from 128+ source ips.\r\n\r\nLong lived connections were stable and the newer connections dropped.",
      "created_at" : "2015-07-05T08:47:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-118596476",
      "id" : 118596476,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-05T08:47:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/118596476",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "@pstratem How did you actually test that?\r\n\r\nWe could make good use of automated scripts to make such testing relocatable.",
      "created_at" : "2015-07-06T22:39:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-119017939",
      "id" : 119017939,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-06T22:39:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/119017939",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "@petertodd python script that connects to the node in a loop running on top of torify and me sitting there hitting \"new identity\" in vidalia a bunch until i had unique ips connecting...\r\n\r\nnot exactly an automated process",
      "created_at" : "2015-07-06T23:28:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-119026601",
      "id" : 119026601,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-06T23:28:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/119026601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "@laanwj Missed the second part of your comment.\r\n\r\nThis wont ever evict localhost connections, so inbound connections to a hidden service wont ever be disconnected by this.\r\n\r\nThat's actually not optimal, but unfortunately getting info on inbound hidden service connections requires interfacing with tors control port.\r\n\r\nThat's definitely out of scope for this patch set.",
      "created_at" : "2015-07-12T21:55:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-120766274",
      "id" : 120766274,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-12T21:55:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/120766274",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "@pstratem Absolutely - I wasn't implying that you'd have to interact with Tor's control port in this pull, just that it's a requirement that it didn't make the current situation worse.\r\n\r\nNeeds a trivial rebase in net.cpp due to #5288.\r\n",
      "created_at" : "2015-07-28T09:16:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-125515815",
      "id" : 125515815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-07-28T09:16:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125515815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36103572"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36103572"
         }
      },
      "body" : "Deleting CNodes happens in the \"Delete disconnected nodes\" loop, which first makes sure that no one is using the node anymore. Adding a `delete pnode` here seems like a danger for race conditions?\r\n",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-03T16:36:31Z",
      "diff_hunk" : "@@ -943,35 +981,95 @@ void ThreadSocketHandler()\n                             nInbound++;\n                 }\n \n+                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+                pnode->AddRef();\n+                pnode->fWhitelisted = whitelisted;\n+\n                 if (hSocket == INVALID_SOCKET)\n                 {\n                     int nErr = WSAGetLastError();\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n                 }\n-                else if (nInbound >= nMaxInbound)\n+                else if (CNode::IsBanned(addr) && !whitelisted)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (full)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+                    pnode->fDisconnect = true;\n                 }\n-                else if (!whitelisted && (nInbound >= (nMaxInbound - nWhiteConnections)))\n+                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (non-whitelisted)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrint(\"net\", \"over connection limit\\n\");\n+                    static std::vector<unsigned char> vSecretKey;\n+\n+                    if (vSecretKey.empty()) {\n+                        vSecretKey.resize(32, 0);\n+                        GetRandBytes(vSecretKey.data(), vSecretKey.size());\n+                    }\n+\n+                    {\n+                        LOCK(cs_vNodes);\n+                        std::vector<CNode*> vEvictionCandidates;\n+\n+                        BOOST_FOREACH(CNode *node, vNodes) {\n+                            if (node->fWhitelisted)\n+                                continue;\n+                            if (!node->fInbound)\n+                                continue;\n+                            if (node->fDisconnect)\n+                                continue;\n+                            if (node->addr.IsLocal())\n+                                continue;\n+                            vEvictionCandidates.push_back(node);\n+                        }\n+\n+                        // Protect connections with certain characteristics\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        CompareNetGroupKeyed comparerNetGroupKeyed(vSecretKey);\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        if (!vEvictionCandidates.empty()) {\n+                            // Identify CNetAddr with the most connections\n+                            CNetAddr naMostConnections;\n+                            unsigned int nMostConnections = 0;\n+                            std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+                            BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+                                mapAddrCounts[node->addr].push_back(node);\n+\n+                                if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+                                    nMostConnections = mapAddrCounts[node->addr].size();\n+                                    naMostConnections = node->addr;\n+                                }\n+                            }\n+\n+                            vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+                            // Disconnect the most recent connection from the CNetAddr with the most connections\n+                            std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                            vEvictionCandidates[0]->fDisconnect = true;\n+\n+                            nInbound--;\n+                        }\n+                    }\n+\n+                    if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS) {\n+                        LogPrint(\"net\", \"no peers to evict, disconnecting new client\\n\");\n+                        pnode->fDisconnect = true;\n+                    }\n                 }\n-                else if (CNode::IsBanned(addr) && !whitelisted)\n-                {\n-                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+\n+                if (pnode->fDisconnect) {\n                     CloseSocket(hSocket);\n+                    delete pnode;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36103572",
      "id" : 36103572,
      "original_commit_id" : "5f33e1ec5d735eac9fb881cb02b7833cbd3b9f12",
      "original_position" : 143,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T00:34:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36103572",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36136096"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36136096"
         }
      },
      "body" : "This is deleting the CNode which was created at 984 and which was not added to vNodes.\r\n\r\nNot deleting it here would be a memory leak.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-03T21:52:16Z",
      "diff_hunk" : "@@ -943,35 +981,95 @@ void ThreadSocketHandler()\n                             nInbound++;\n                 }\n \n+                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+                pnode->AddRef();\n+                pnode->fWhitelisted = whitelisted;\n+\n                 if (hSocket == INVALID_SOCKET)\n                 {\n                     int nErr = WSAGetLastError();\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n                 }\n-                else if (nInbound >= nMaxInbound)\n+                else if (CNode::IsBanned(addr) && !whitelisted)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (full)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+                    pnode->fDisconnect = true;\n                 }\n-                else if (!whitelisted && (nInbound >= (nMaxInbound - nWhiteConnections)))\n+                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (non-whitelisted)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrint(\"net\", \"over connection limit\\n\");\n+                    static std::vector<unsigned char> vSecretKey;\n+\n+                    if (vSecretKey.empty()) {\n+                        vSecretKey.resize(32, 0);\n+                        GetRandBytes(vSecretKey.data(), vSecretKey.size());\n+                    }\n+\n+                    {\n+                        LOCK(cs_vNodes);\n+                        std::vector<CNode*> vEvictionCandidates;\n+\n+                        BOOST_FOREACH(CNode *node, vNodes) {\n+                            if (node->fWhitelisted)\n+                                continue;\n+                            if (!node->fInbound)\n+                                continue;\n+                            if (node->fDisconnect)\n+                                continue;\n+                            if (node->addr.IsLocal())\n+                                continue;\n+                            vEvictionCandidates.push_back(node);\n+                        }\n+\n+                        // Protect connections with certain characteristics\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        CompareNetGroupKeyed comparerNetGroupKeyed(vSecretKey);\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        if (!vEvictionCandidates.empty()) {\n+                            // Identify CNetAddr with the most connections\n+                            CNetAddr naMostConnections;\n+                            unsigned int nMostConnections = 0;\n+                            std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+                            BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+                                mapAddrCounts[node->addr].push_back(node);\n+\n+                                if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+                                    nMostConnections = mapAddrCounts[node->addr].size();\n+                                    naMostConnections = node->addr;\n+                                }\n+                            }\n+\n+                            vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+                            // Disconnect the most recent connection from the CNetAddr with the most connections\n+                            std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                            vEvictionCandidates[0]->fDisconnect = true;\n+\n+                            nInbound--;\n+                        }\n+                    }\n+\n+                    if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS) {\n+                        LogPrint(\"net\", \"no peers to evict, disconnecting new client\\n\");\n+                        pnode->fDisconnect = true;\n+                    }\n                 }\n-                else if (CNode::IsBanned(addr) && !whitelisted)\n-                {\n-                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+\n+                if (pnode->fDisconnect) {\n                     CloseSocket(hSocket);\n+                    delete pnode;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36136096",
      "id" : 36136096,
      "original_commit_id" : "5f33e1ec5d735eac9fb881cb02b7833cbd3b9f12",
      "original_position" : 143,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T00:34:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36136096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36495467"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36495467"
         }
      },
      "body" : "Bah.\r\nI wonder if we could use e.g. boost::scoped_ptr or auto_ptr to avoid this. It's too easy to get memory leaks with manual deallocation along a subset of code paths, especially when factoring in exceptions.\r\n",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-07T07:09:16Z",
      "diff_hunk" : "@@ -943,35 +981,95 @@ void ThreadSocketHandler()\n                             nInbound++;\n                 }\n \n+                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+                pnode->AddRef();\n+                pnode->fWhitelisted = whitelisted;\n+\n                 if (hSocket == INVALID_SOCKET)\n                 {\n                     int nErr = WSAGetLastError();\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n                 }\n-                else if (nInbound >= nMaxInbound)\n+                else if (CNode::IsBanned(addr) && !whitelisted)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (full)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+                    pnode->fDisconnect = true;\n                 }\n-                else if (!whitelisted && (nInbound >= (nMaxInbound - nWhiteConnections)))\n+                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (non-whitelisted)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrint(\"net\", \"over connection limit\\n\");\n+                    static std::vector<unsigned char> vSecretKey;\n+\n+                    if (vSecretKey.empty()) {\n+                        vSecretKey.resize(32, 0);\n+                        GetRandBytes(vSecretKey.data(), vSecretKey.size());\n+                    }\n+\n+                    {\n+                        LOCK(cs_vNodes);\n+                        std::vector<CNode*> vEvictionCandidates;\n+\n+                        BOOST_FOREACH(CNode *node, vNodes) {\n+                            if (node->fWhitelisted)\n+                                continue;\n+                            if (!node->fInbound)\n+                                continue;\n+                            if (node->fDisconnect)\n+                                continue;\n+                            if (node->addr.IsLocal())\n+                                continue;\n+                            vEvictionCandidates.push_back(node);\n+                        }\n+\n+                        // Protect connections with certain characteristics\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        CompareNetGroupKeyed comparerNetGroupKeyed(vSecretKey);\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        if (!vEvictionCandidates.empty()) {\n+                            // Identify CNetAddr with the most connections\n+                            CNetAddr naMostConnections;\n+                            unsigned int nMostConnections = 0;\n+                            std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+                            BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+                                mapAddrCounts[node->addr].push_back(node);\n+\n+                                if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+                                    nMostConnections = mapAddrCounts[node->addr].size();\n+                                    naMostConnections = node->addr;\n+                                }\n+                            }\n+\n+                            vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+                            // Disconnect the most recent connection from the CNetAddr with the most connections\n+                            std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                            vEvictionCandidates[0]->fDisconnect = true;\n+\n+                            nInbound--;\n+                        }\n+                    }\n+\n+                    if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS) {\n+                        LogPrint(\"net\", \"no peers to evict, disconnecting new client\\n\");\n+                        pnode->fDisconnect = true;\n+                    }\n                 }\n-                else if (CNode::IsBanned(addr) && !whitelisted)\n-                {\n-                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+\n+                if (pnode->fDisconnect) {\n                     CloseSocket(hSocket);\n+                    delete pnode;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36495467",
      "id" : 36495467,
      "original_commit_id" : "5f33e1ec5d735eac9fb881cb02b7833cbd3b9f12",
      "original_position" : 143,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T00:34:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36495467",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36563756"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36563756"
         }
      },
      "body" : "Alternatively I could just add it to vNodes and rely on the normal cleanup logic.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-07T21:39:26Z",
      "diff_hunk" : "@@ -943,35 +981,95 @@ void ThreadSocketHandler()\n                             nInbound++;\n                 }\n \n+                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+                pnode->AddRef();\n+                pnode->fWhitelisted = whitelisted;\n+\n                 if (hSocket == INVALID_SOCKET)\n                 {\n                     int nErr = WSAGetLastError();\n                     if (nErr != WSAEWOULDBLOCK)\n                         LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n                 }\n-                else if (nInbound >= nMaxInbound)\n+                else if (CNode::IsBanned(addr) && !whitelisted)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (full)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+                    pnode->fDisconnect = true;\n                 }\n-                else if (!whitelisted && (nInbound >= (nMaxInbound - nWhiteConnections)))\n+                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n                 {\n-                    LogPrint(\"net\", \"connection from %s dropped (non-whitelisted)\\n\", addr.ToString());\n-                    CloseSocket(hSocket);\n+                    LogPrint(\"net\", \"over connection limit\\n\");\n+                    static std::vector<unsigned char> vSecretKey;\n+\n+                    if (vSecretKey.empty()) {\n+                        vSecretKey.resize(32, 0);\n+                        GetRandBytes(vSecretKey.data(), vSecretKey.size());\n+                    }\n+\n+                    {\n+                        LOCK(cs_vNodes);\n+                        std::vector<CNode*> vEvictionCandidates;\n+\n+                        BOOST_FOREACH(CNode *node, vNodes) {\n+                            if (node->fWhitelisted)\n+                                continue;\n+                            if (!node->fInbound)\n+                                continue;\n+                            if (node->fDisconnect)\n+                                continue;\n+                            if (node->addr.IsLocal())\n+                                continue;\n+                            vEvictionCandidates.push_back(node);\n+                        }\n+\n+                        // Protect connections with certain characteristics\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        CompareNetGroupKeyed comparerNetGroupKeyed(vSecretKey);\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+                        vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+                        if (!vEvictionCandidates.empty()) {\n+                            // Identify CNetAddr with the most connections\n+                            CNetAddr naMostConnections;\n+                            unsigned int nMostConnections = 0;\n+                            std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+                            BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+                                mapAddrCounts[node->addr].push_back(node);\n+\n+                                if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+                                    nMostConnections = mapAddrCounts[node->addr].size();\n+                                    naMostConnections = node->addr;\n+                                }\n+                            }\n+\n+                            vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+                            // Disconnect the most recent connection from the CNetAddr with the most connections\n+                            std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+                            vEvictionCandidates[0]->fDisconnect = true;\n+\n+                            nInbound--;\n+                        }\n+                    }\n+\n+                    if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS) {\n+                        LogPrint(\"net\", \"no peers to evict, disconnecting new client\\n\");\n+                        pnode->fDisconnect = true;\n+                    }\n                 }\n-                else if (CNode::IsBanned(addr) && !whitelisted)\n-                {\n-                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+\n+                if (pnode->fDisconnect) {\n                     CloseSocket(hSocket);\n+                    delete pnode;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r36563756",
      "id" : 36563756,
      "original_commit_id" : "5f33e1ec5d735eac9fb881cb02b7833cbd3b9f12",
      "original_position" : 143,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T00:34:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/36563756",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "Spoke with @pstratem about this for a bit and we agreed this should be refactored so that the connection acceptance stuff is in a separate function. Also after this change the nWhiteConnections variable is set in init but goes unused.",
      "created_at" : "2015-08-13T11:08:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-130619710",
      "id" : 130619710,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-08-13T11:08:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/130619710",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "@TheBlueMatt I've simply removed the whiteconnections option in favor of protecting any inbound whitelisted connection.  This is safe as outbound connections are never disconnected.",
      "created_at" : "2015-08-14T00:35:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-130902260",
      "id" : 130902260,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-08-14T00:35:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/130902260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051343"
         }
      },
      "body" : "size_t to unsigned int is safe? You could use size_t for nMostConnections also.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T05:53:42Z",
      "diff_hunk" : "@@ -776,6 +775,173 @@ void SocketSendData(CNode *pnode)\n \n static list<CNode*> vNodesDisconnected;\n \n+static bool ReverseCompareNodeMinPingTime(CNode *a, CNode *b)\n+{\n+    return a->nMinPingUsecTime > b->nMinPingUsecTime;\n+}\n+\n+static bool ReverseCompareNodeTimeConnected(CNode *a, CNode *b)\n+{\n+    return a->nTimeConnected > b->nTimeConnected;\n+}\n+\n+class CompareNetGroupKeyed\n+{\n+    std::vector<unsigned char> vchSecretKey;\n+public:\n+    CompareNetGroupKeyed()\n+    {\n+        vchSecretKey.resize(32, 0);\n+        GetRandBytes(vchSecretKey.data(), vchSecretKey.size());\n+    }\n+\n+    bool operator()(CNode *a, CNode *b)\n+    {\n+        std::vector<unsigned char> vchGroupA, vchGroupB;\n+        CSHA256 hashA, hashB;\n+        std::vector<unsigned char> vchA(32), vchB(32);\n+\n+        vchGroupA = a->addr.GetGroup();\n+        vchGroupB = b->addr.GetGroup();\n+\n+        hashA.Write(begin_ptr(vchGroupA), vchGroupA.size());\n+        hashB.Write(begin_ptr(vchGroupB), vchGroupB.size());\n+\n+        hashA.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+        hashB.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+\n+        hashA.Finalize(begin_ptr(vchA));\n+        hashB.Finalize(begin_ptr(vchB));\n+\n+        return vchA < vchB;\n+    }\n+};\n+\n+static bool AttemptToEvictConnection(bool fPreferNewConnection) {\n+    std::vector<CNode*> vEvictionCandidates;\n+    {\n+        LOCK(cs_vNodes);\n+\n+        BOOST_FOREACH(CNode *node, vNodes) {\n+            if (node->fWhitelisted)\n+                continue;\n+            if (!node->fInbound)\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            if (node->addr.IsLocal())\n+                continue;\n+            vEvictionCandidates.push_back(node);\n+        }\n+    }\n+\n+    // Protect connections with certain characteristics\n+    static CompareNetGroupKeyed comparerNetGroupKeyed;\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    if (vEvictionCandidates.empty())\n+        return false;\n+\n+    // Identify CNetAddr with the most connections\n+    CNetAddr naMostConnections;\n+    unsigned int nMostConnections = 0;\n+    std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+    BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+        mapAddrCounts[node->addr].push_back(node);\n+\n+        if (mapAddrCounts[node->addr].size() > nMostConnections) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051343",
      "id" : 37051343,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 93,
      "path" : "src/net.cpp",
      "position" : 93,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T05:53:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1419649?v=3",
         "events_url" : "https://api.github.com/users/Diapolo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Diapolo/followers",
         "following_url" : "https://api.github.com/users/Diapolo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Diapolo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Diapolo",
         "id" : 1419649,
         "login" : "Diapolo",
         "organizations_url" : "https://api.github.com/users/Diapolo/orgs",
         "received_events_url" : "https://api.github.com/users/Diapolo/received_events",
         "repos_url" : "https://api.github.com/users/Diapolo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Diapolo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Diapolo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Diapolo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051366"
         }
      },
      "body" : "This should be a more detailed comment IMHO.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T05:54:41Z",
      "diff_hunk" : "@@ -776,6 +775,173 @@ void SocketSendData(CNode *pnode)\n \n static list<CNode*> vNodesDisconnected;\n \n+static bool ReverseCompareNodeMinPingTime(CNode *a, CNode *b)\n+{\n+    return a->nMinPingUsecTime > b->nMinPingUsecTime;\n+}\n+\n+static bool ReverseCompareNodeTimeConnected(CNode *a, CNode *b)\n+{\n+    return a->nTimeConnected > b->nTimeConnected;\n+}\n+\n+class CompareNetGroupKeyed\n+{\n+    std::vector<unsigned char> vchSecretKey;\n+public:\n+    CompareNetGroupKeyed()\n+    {\n+        vchSecretKey.resize(32, 0);\n+        GetRandBytes(vchSecretKey.data(), vchSecretKey.size());\n+    }\n+\n+    bool operator()(CNode *a, CNode *b)\n+    {\n+        std::vector<unsigned char> vchGroupA, vchGroupB;\n+        CSHA256 hashA, hashB;\n+        std::vector<unsigned char> vchA(32), vchB(32);\n+\n+        vchGroupA = a->addr.GetGroup();\n+        vchGroupB = b->addr.GetGroup();\n+\n+        hashA.Write(begin_ptr(vchGroupA), vchGroupA.size());\n+        hashB.Write(begin_ptr(vchGroupB), vchGroupB.size());\n+\n+        hashA.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+        hashB.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+\n+        hashA.Finalize(begin_ptr(vchA));\n+        hashB.Finalize(begin_ptr(vchB));\n+\n+        return vchA < vchB;\n+    }\n+};\n+\n+static bool AttemptToEvictConnection(bool fPreferNewConnection) {\n+    std::vector<CNode*> vEvictionCandidates;\n+    {\n+        LOCK(cs_vNodes);\n+\n+        BOOST_FOREACH(CNode *node, vNodes) {\n+            if (node->fWhitelisted)\n+                continue;\n+            if (!node->fInbound)\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            if (node->addr.IsLocal())\n+                continue;\n+            vEvictionCandidates.push_back(node);\n+        }\n+    }\n+\n+    // Protect connections with certain characteristics",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051366",
      "id" : 37051366,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 72,
      "path" : "src/net.cpp",
      "position" : 72,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T05:54:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1419649?v=3",
         "events_url" : "https://api.github.com/users/Diapolo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Diapolo/followers",
         "following_url" : "https://api.github.com/users/Diapolo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Diapolo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Diapolo",
         "id" : 1419649,
         "login" : "Diapolo",
         "organizations_url" : "https://api.github.com/users/Diapolo/orgs",
         "received_events_url" : "https://api.github.com/users/Diapolo/received_events",
         "repos_url" : "https://api.github.com/users/Diapolo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Diapolo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Diapolo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Diapolo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051432"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051432"
         }
      },
      "body" : "You seem to use this bool first at line 916, why not move the check there? At first look I had the impression it belongs to the LOCK block.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T05:56:58Z",
      "diff_hunk" : "@@ -776,6 +775,173 @@ void SocketSendData(CNode *pnode)\n \n static list<CNode*> vNodesDisconnected;\n \n+static bool ReverseCompareNodeMinPingTime(CNode *a, CNode *b)\n+{\n+    return a->nMinPingUsecTime > b->nMinPingUsecTime;\n+}\n+\n+static bool ReverseCompareNodeTimeConnected(CNode *a, CNode *b)\n+{\n+    return a->nTimeConnected > b->nTimeConnected;\n+}\n+\n+class CompareNetGroupKeyed\n+{\n+    std::vector<unsigned char> vchSecretKey;\n+public:\n+    CompareNetGroupKeyed()\n+    {\n+        vchSecretKey.resize(32, 0);\n+        GetRandBytes(vchSecretKey.data(), vchSecretKey.size());\n+    }\n+\n+    bool operator()(CNode *a, CNode *b)\n+    {\n+        std::vector<unsigned char> vchGroupA, vchGroupB;\n+        CSHA256 hashA, hashB;\n+        std::vector<unsigned char> vchA(32), vchB(32);\n+\n+        vchGroupA = a->addr.GetGroup();\n+        vchGroupB = b->addr.GetGroup();\n+\n+        hashA.Write(begin_ptr(vchGroupA), vchGroupA.size());\n+        hashB.Write(begin_ptr(vchGroupB), vchGroupB.size());\n+\n+        hashA.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+        hashB.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+\n+        hashA.Finalize(begin_ptr(vchA));\n+        hashB.Finalize(begin_ptr(vchB));\n+\n+        return vchA < vchB;\n+    }\n+};\n+\n+static bool AttemptToEvictConnection(bool fPreferNewConnection) {\n+    std::vector<CNode*> vEvictionCandidates;\n+    {\n+        LOCK(cs_vNodes);\n+\n+        BOOST_FOREACH(CNode *node, vNodes) {\n+            if (node->fWhitelisted)\n+                continue;\n+            if (!node->fInbound)\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            if (node->addr.IsLocal())\n+                continue;\n+            vEvictionCandidates.push_back(node);\n+        }\n+    }\n+\n+    // Protect connections with certain characteristics\n+    static CompareNetGroupKeyed comparerNetGroupKeyed;\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    if (vEvictionCandidates.empty())\n+        return false;\n+\n+    // Identify CNetAddr with the most connections\n+    CNetAddr naMostConnections;\n+    unsigned int nMostConnections = 0;\n+    std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+    BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+        mapAddrCounts[node->addr].push_back(node);\n+\n+        if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+            nMostConnections = mapAddrCounts[node->addr].size();\n+            naMostConnections = node->addr;\n+        }\n+    }\n+\n+    // Reduce to the CNetAddr with the most connections\n+    vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+    // Do not disconnect peers who have only 1 evictable connection\n+    if (vEvictionCandidates.size() <= 1)\n+        // unless we prefer the new connection (for whitelisted peers)\n+        if (!fPreferNewConnection)\n+            return false;\n+\n+    // Disconnect the most recent connection from the CNetAddr with the most connections\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates[0]->fDisconnect = true;\n+\n+    return true;\n+}\n+\n+static void AcceptConnection(const ListenSocket& hListenSocket) {\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    CAddress addr;\n+    int nInbound = 0;\n+    int nMaxInbound = nMaxConnections - MAX_OUTBOUND_CONNECTIONS;\n+\n+    if (hSocket != INVALID_SOCKET)\n+        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+            LogPrintf(\"Warning: Unknown socket family\\n\");\n+\n+    bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051432",
      "id" : 37051432,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 127,
      "path" : "src/net.cpp",
      "position" : 127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T05:56:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051432",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1419649?v=3",
         "events_url" : "https://api.github.com/users/Diapolo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Diapolo/followers",
         "following_url" : "https://api.github.com/users/Diapolo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Diapolo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Diapolo",
         "id" : 1419649,
         "login" : "Diapolo",
         "organizations_url" : "https://api.github.com/users/Diapolo/orgs",
         "received_events_url" : "https://api.github.com/users/Diapolo/received_events",
         "repos_url" : "https://api.github.com/users/Diapolo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Diapolo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Diapolo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Diapolo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051503"
         }
      },
      "body" : "Is this the check for the accept call? Would be cleaner if it was below the call. You also wouldn't need the ``hSocket != INVALID_SOCKET`` check at the top.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T05:58:08Z",
      "diff_hunk" : "@@ -776,6 +775,173 @@ void SocketSendData(CNode *pnode)\n \n static list<CNode*> vNodesDisconnected;\n \n+static bool ReverseCompareNodeMinPingTime(CNode *a, CNode *b)\n+{\n+    return a->nMinPingUsecTime > b->nMinPingUsecTime;\n+}\n+\n+static bool ReverseCompareNodeTimeConnected(CNode *a, CNode *b)\n+{\n+    return a->nTimeConnected > b->nTimeConnected;\n+}\n+\n+class CompareNetGroupKeyed\n+{\n+    std::vector<unsigned char> vchSecretKey;\n+public:\n+    CompareNetGroupKeyed()\n+    {\n+        vchSecretKey.resize(32, 0);\n+        GetRandBytes(vchSecretKey.data(), vchSecretKey.size());\n+    }\n+\n+    bool operator()(CNode *a, CNode *b)\n+    {\n+        std::vector<unsigned char> vchGroupA, vchGroupB;\n+        CSHA256 hashA, hashB;\n+        std::vector<unsigned char> vchA(32), vchB(32);\n+\n+        vchGroupA = a->addr.GetGroup();\n+        vchGroupB = b->addr.GetGroup();\n+\n+        hashA.Write(begin_ptr(vchGroupA), vchGroupA.size());\n+        hashB.Write(begin_ptr(vchGroupB), vchGroupB.size());\n+\n+        hashA.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+        hashB.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+\n+        hashA.Finalize(begin_ptr(vchA));\n+        hashB.Finalize(begin_ptr(vchB));\n+\n+        return vchA < vchB;\n+    }\n+};\n+\n+static bool AttemptToEvictConnection(bool fPreferNewConnection) {\n+    std::vector<CNode*> vEvictionCandidates;\n+    {\n+        LOCK(cs_vNodes);\n+\n+        BOOST_FOREACH(CNode *node, vNodes) {\n+            if (node->fWhitelisted)\n+                continue;\n+            if (!node->fInbound)\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            if (node->addr.IsLocal())\n+                continue;\n+            vEvictionCandidates.push_back(node);\n+        }\n+    }\n+\n+    // Protect connections with certain characteristics\n+    static CompareNetGroupKeyed comparerNetGroupKeyed;\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    if (vEvictionCandidates.empty())\n+        return false;\n+\n+    // Identify CNetAddr with the most connections\n+    CNetAddr naMostConnections;\n+    unsigned int nMostConnections = 0;\n+    std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+    BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+        mapAddrCounts[node->addr].push_back(node);\n+\n+        if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+            nMostConnections = mapAddrCounts[node->addr].size();\n+            naMostConnections = node->addr;\n+        }\n+    }\n+\n+    // Reduce to the CNetAddr with the most connections\n+    vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+    // Do not disconnect peers who have only 1 evictable connection\n+    if (vEvictionCandidates.size() <= 1)\n+        // unless we prefer the new connection (for whitelisted peers)\n+        if (!fPreferNewConnection)\n+            return false;\n+\n+    // Disconnect the most recent connection from the CNetAddr with the most connections\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates[0]->fDisconnect = true;\n+\n+    return true;\n+}\n+\n+static void AcceptConnection(const ListenSocket& hListenSocket) {\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    CAddress addr;\n+    int nInbound = 0;\n+    int nMaxInbound = nMaxConnections - MAX_OUTBOUND_CONNECTIONS;\n+\n+    if (hSocket != INVALID_SOCKET)\n+        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+            LogPrintf(\"Warning: Unknown socket family\\n\");\n+\n+    bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);\n+    {\n+        LOCK(cs_vNodes);\n+        BOOST_FOREACH(CNode* pnode, vNodes)\n+            if (pnode->fInbound)\n+                nInbound++;\n+    }\n+\n+    if (hSocket == INVALID_SOCKET)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051503",
      "id" : 37051503,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 135,
      "path" : "src/net.cpp",
      "position" : 135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T05:58:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1419649?v=3",
         "events_url" : "https://api.github.com/users/Diapolo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Diapolo/followers",
         "following_url" : "https://api.github.com/users/Diapolo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Diapolo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Diapolo",
         "id" : 1419649,
         "login" : "Diapolo",
         "organizations_url" : "https://api.github.com/users/Diapolo/orgs",
         "received_events_url" : "https://api.github.com/users/Diapolo/received_events",
         "repos_url" : "https://api.github.com/users/Diapolo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Diapolo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Diapolo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Diapolo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051576"
         }
      },
      "body" : "Is this interresting for ``getpeerinfo``?",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T06:00:43Z",
      "diff_hunk" : "@@ -4522,6 +4522,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     if (pingUsecTime > 0) {\n                         // Successful ping time measurement, replace previous\n                         pfrom->nPingUsecTime = pingUsecTime;\n+                        pfrom->nMinPingUsecTime = std::min(pfrom->nMinPingUsecTime, pingUsecTime);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37051576",
      "id" : 37051576,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 4,
      "path" : "src/main.cpp",
      "position" : 4,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T06:00:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37051576",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1419649?v=3",
         "events_url" : "https://api.github.com/users/Diapolo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Diapolo/followers",
         "following_url" : "https://api.github.com/users/Diapolo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Diapolo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Diapolo",
         "id" : 1419649,
         "login" : "Diapolo",
         "organizations_url" : "https://api.github.com/users/Diapolo/orgs",
         "received_events_url" : "https://api.github.com/users/Diapolo/received_events",
         "repos_url" : "https://api.github.com/users/Diapolo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Diapolo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Diapolo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Diapolo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37060766"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37060766"
         }
      },
      "body" : "I also had this impression,  though that is a common theme with several of the variables (`nInbound`, `nMaxInbound`).  It'd be nice to see them declared where they are used, rather than C99 style at the top of the function.\r\n\r\n**edit**: Though to be fair, this code is simply copied, so this is not @pstratem's fault.",
      "commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "created_at" : "2015-08-14T09:13:27Z",
      "diff_hunk" : "@@ -776,6 +775,173 @@ void SocketSendData(CNode *pnode)\n \n static list<CNode*> vNodesDisconnected;\n \n+static bool ReverseCompareNodeMinPingTime(CNode *a, CNode *b)\n+{\n+    return a->nMinPingUsecTime > b->nMinPingUsecTime;\n+}\n+\n+static bool ReverseCompareNodeTimeConnected(CNode *a, CNode *b)\n+{\n+    return a->nTimeConnected > b->nTimeConnected;\n+}\n+\n+class CompareNetGroupKeyed\n+{\n+    std::vector<unsigned char> vchSecretKey;\n+public:\n+    CompareNetGroupKeyed()\n+    {\n+        vchSecretKey.resize(32, 0);\n+        GetRandBytes(vchSecretKey.data(), vchSecretKey.size());\n+    }\n+\n+    bool operator()(CNode *a, CNode *b)\n+    {\n+        std::vector<unsigned char> vchGroupA, vchGroupB;\n+        CSHA256 hashA, hashB;\n+        std::vector<unsigned char> vchA(32), vchB(32);\n+\n+        vchGroupA = a->addr.GetGroup();\n+        vchGroupB = b->addr.GetGroup();\n+\n+        hashA.Write(begin_ptr(vchGroupA), vchGroupA.size());\n+        hashB.Write(begin_ptr(vchGroupB), vchGroupB.size());\n+\n+        hashA.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+        hashB.Write(begin_ptr(vchSecretKey), vchSecretKey.size());\n+\n+        hashA.Finalize(begin_ptr(vchA));\n+        hashB.Finalize(begin_ptr(vchB));\n+\n+        return vchA < vchB;\n+    }\n+};\n+\n+static bool AttemptToEvictConnection(bool fPreferNewConnection) {\n+    std::vector<CNode*> vEvictionCandidates;\n+    {\n+        LOCK(cs_vNodes);\n+\n+        BOOST_FOREACH(CNode *node, vNodes) {\n+            if (node->fWhitelisted)\n+                continue;\n+            if (!node->fInbound)\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            if (node->addr.IsLocal())\n+                continue;\n+            vEvictionCandidates.push_back(node);\n+        }\n+    }\n+\n+    // Protect connections with certain characteristics\n+    static CompareNetGroupKeyed comparerNetGroupKeyed;\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), comparerNetGroupKeyed);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(4, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeMinPingTime);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(8, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates.erase(vEvictionCandidates.end() - std::min(64, static_cast<int>(vEvictionCandidates.size())), vEvictionCandidates.end());\n+\n+    if (vEvictionCandidates.empty())\n+        return false;\n+\n+    // Identify CNetAddr with the most connections\n+    CNetAddr naMostConnections;\n+    unsigned int nMostConnections = 0;\n+    std::map<CNetAddr, std::vector<CNode*> > mapAddrCounts;\n+    BOOST_FOREACH(CNode *node, vEvictionCandidates) {\n+        mapAddrCounts[node->addr].push_back(node);\n+\n+        if (mapAddrCounts[node->addr].size() > nMostConnections) {\n+            nMostConnections = mapAddrCounts[node->addr].size();\n+            naMostConnections = node->addr;\n+        }\n+    }\n+\n+    // Reduce to the CNetAddr with the most connections\n+    vEvictionCandidates = mapAddrCounts[naMostConnections];\n+\n+    // Do not disconnect peers who have only 1 evictable connection\n+    if (vEvictionCandidates.size() <= 1)\n+        // unless we prefer the new connection (for whitelisted peers)\n+        if (!fPreferNewConnection)\n+            return false;\n+\n+    // Disconnect the most recent connection from the CNetAddr with the most connections\n+    std::sort(vEvictionCandidates.begin(), vEvictionCandidates.end(), ReverseCompareNodeTimeConnected);\n+    vEvictionCandidates[0]->fDisconnect = true;\n+\n+    return true;\n+}\n+\n+static void AcceptConnection(const ListenSocket& hListenSocket) {\n+    struct sockaddr_storage sockaddr;\n+    socklen_t len = sizeof(sockaddr);\n+    SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+    CAddress addr;\n+    int nInbound = 0;\n+    int nMaxInbound = nMaxConnections - MAX_OUTBOUND_CONNECTIONS;\n+\n+    if (hSocket != INVALID_SOCKET)\n+        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+            LogPrintf(\"Warning: Unknown socket family\\n\");\n+\n+    bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#discussion_r37060766",
      "id" : 37060766,
      "original_commit_id" : "1f1c87438db3e707b2bfc0e35b12e054df5c0661",
      "original_position" : 127,
      "path" : "src/net.cpp",
      "position" : 127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6374",
      "updated_at" : "2015-08-14T09:15:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/37060766",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "Concept ACK",
      "created_at" : "2015-08-14T09:15:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6374#issuecomment-131036709",
      "id" : 131036709,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6374",
      "updated_at" : "2015-08-14T09:15:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/131036709",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   }
]
