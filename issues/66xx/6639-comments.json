[
   {
      "body" : "I like the feature - concept ACK\r\n\r\nTrying to think through whether there are edge cases that persuade us to default this 'off'  Leaning towards default-on as presented.",
      "created_at" : "2015-09-15T23:27:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-140579848",
      "id" : 140579848,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-09-15T23:27:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/140579848",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/494411?v=3",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2015-09-16T07:09:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-140650996",
      "id" : 140650996,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-09-16T07:09:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/140650996",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2015-09-23T19:55:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-142710743",
      "id" : 142710743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-09-23T19:55:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/142710743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "body" : "2015-09-26 00:03:11 [tor] Using COOKIE authentication, reading cookie authentication from /var/run/tor/control.authcookie\r\n2015-09-26 00:03:11 [tor] Authentication cookie not found, is inaccessible, or is not exactly 64 bytes\r\n\r\nI have ControlPort 9051 and CookieAuthentication in torrc.",
      "created_at" : "2015-09-26T00:07:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-143380439",
      "id" : 143380439,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-09-26T00:07:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/143380439",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Check the permissions\nOn Sep 25, 2015 5:07 PM, \"Pieter Wuille\" <notifications@github.com> wrote:\n\n> 2015-09-26 00:03:11 [tor] Using COOKIE authentication, reading cookie\n> authentication from /var/run/tor/control.authcookie\n> 2015-09-26 00:03:11 [tor] Authentication cookie not found, is\n> inaccessible, or is not exactly 64 bytes\n>\n> I have ControlPort 9051 and CookieAuthentication in torrc.\n>\n> Ã¢ÂÂ\n> Reply to this email directly or view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-143380439>.\n>\n",
      "created_at" : "2015-09-26T00:23:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-143382128",
      "id" : 143382128,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-09-26T00:23:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/143382128",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/620611?v=3",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "body" : "@sipa the check was broken, the cookie is 32 bytes not 64. That said, we should have a more specific error message.",
      "created_at" : "2015-10-02T12:25:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145002257",
      "id" : 145002257,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-02T12:25:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145002257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41033302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41033302"
         }
      },
      "body" : "false case needs fclose too",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T15:24:04Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+    b_conn = 0;\n+    return true;\n+}\n+\n+bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB& reply_handler)\n+{\n+    if (!b_conn)\n+        return false;\n+    struct evbuffer *buf = bufferevent_get_output(b_conn);\n+    if (!buf)\n+        return false;\n+    evbuffer_add(buf, cmd.data(), cmd.size());\n+    evbuffer_add(buf, \"\\r\\n\", 2);\n+    reply_handlers.push_back(reply_handler);\n+    return true;\n+}\n+\n+/****** General parsing utilities ********/\n+\n+/* Split reply line in the form 'AUTH METHODS=...' into a type\n+ * 'AUTH' and arguments 'METHODS=...'.\n+ */\n+static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+{\n+    size_t ptr=0;\n+    std::string type;\n+    while (ptr < s.size() && s[ptr] != ' ') {\n+        type.push_back(s[ptr]);\n+        ++ptr;\n+    }\n+    if (ptr < s.size())\n+        ++ptr; // skip ' '\n+    return make_pair(type, s.substr(ptr));\n+}\n+\n+/** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ */\n+static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+{\n+    std::map<std::string,std::string> mapping;\n+    size_t ptr=0;\n+    while (ptr < s.size()) {\n+        std::string key, value;\n+        while (ptr < s.size() && s[ptr] != '=') {\n+            key.push_back(s[ptr]);\n+            ++ptr;\n+        }\n+        if (ptr == s.size()) // unexpected end of line\n+            return std::map<std::string,std::string>();\n+        ++ptr; // skip '='\n+        if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n+            ++ptr; // skip '='\n+            bool escape_next = false;\n+            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n+                escape_next = (s[ptr] == '\\\\');\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+            if (ptr == s.size()) // unexpected end of line\n+                return std::map<std::string,std::string>();\n+            ++ptr; // skip closing '\"'\n+            /* TODO: unescape value - according to the spec this depends on the\n+             * context, some strings use C-LogPrintf style escape codes, some\n+             * don't. So may be better handled at the call site.\n+             */\n+        } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n+            while (ptr < s.size() && s[ptr] != ' ') {\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+        }\n+        if (ptr < s.size() && s[ptr] == ' ')\n+            ++ptr; // skip ' ' after key=value\n+        mapping[key] = value;\n+    }\n+    return mapping;\n+}\n+\n+/** Read full contents of a file and return them in a std::string. */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fopen(filename.c_str(), \"rb\");\n+    if (f == NULL)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    size_t n;\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        retval.append(buffer, buffer+n);\n+        if (retval.size() > maxsize) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+    }\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+/** Write contents of std::string to a file.\n+ * @return true on success.\n+ */\n+static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+{\n+    FILE *f = fopen(filename.c_str(), \"wb\");\n+    if (f == NULL)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size())\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41033302",
      "id" : 41033302,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 306,
      "path" : "src/torcontrol.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41033302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Can the shutdown detection be changed to work like the httpserver? ie Init calls InterruptTorControl() which starts the immediate shutdown process?",
      "created_at" : "2015-10-02T15:54:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145069722",
      "id" : 145069722,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-02T15:54:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145069722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41039837"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41039837"
         }
      },
      "body" : "Need to undo the AddLocal here?",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T16:26:06Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41039837",
      "id" : 41039837,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 197,
      "path" : "src/torcontrol.cpp",
      "position" : 224,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41039837",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41040909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41040909"
         }
      },
      "body" : "Don't we want logic to retry this every n seconds if it fails? If I launch Bitcoin and Tor a minute later, I would expect that it would be detected and used after a few minutes.",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T16:37:59Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41040909",
      "id" : 41040909,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 188,
      "path" : "src/torcontrol.cpp",
      "position" : 215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41040909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "(Not for this PR) Looks like it'd be pretty simple to add support for connecting via Unix socket (/var/run/tor/control) as well.",
      "created_at" : "2015-10-02T16:43:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145082851",
      "id" : 145082851,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-02T16:43:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145082851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Concept ACK. This looks like a great feature.",
      "created_at" : "2015-10-02T16:45:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145083330",
      "id" : 145083330,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-02T16:45:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145083330",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41041888"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41041888"
         }
      },
      "body" : "That's what `RECONNECT_TIMEOUT_START` / `RECONNECT_TIMEOUT_EXP` is supposed to do. When I last checked, it was working.",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T16:48:14Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41041888",
      "id" : 41041888,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 188,
      "path" : "src/torcontrol.cpp",
      "position" : 215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41041888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41042111"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41042111"
         }
      },
      "body" : "oops good catch",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T16:50:45Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+    b_conn = 0;\n+    return true;\n+}\n+\n+bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB& reply_handler)\n+{\n+    if (!b_conn)\n+        return false;\n+    struct evbuffer *buf = bufferevent_get_output(b_conn);\n+    if (!buf)\n+        return false;\n+    evbuffer_add(buf, cmd.data(), cmd.size());\n+    evbuffer_add(buf, \"\\r\\n\", 2);\n+    reply_handlers.push_back(reply_handler);\n+    return true;\n+}\n+\n+/****** General parsing utilities ********/\n+\n+/* Split reply line in the form 'AUTH METHODS=...' into a type\n+ * 'AUTH' and arguments 'METHODS=...'.\n+ */\n+static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+{\n+    size_t ptr=0;\n+    std::string type;\n+    while (ptr < s.size() && s[ptr] != ' ') {\n+        type.push_back(s[ptr]);\n+        ++ptr;\n+    }\n+    if (ptr < s.size())\n+        ++ptr; // skip ' '\n+    return make_pair(type, s.substr(ptr));\n+}\n+\n+/** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ */\n+static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+{\n+    std::map<std::string,std::string> mapping;\n+    size_t ptr=0;\n+    while (ptr < s.size()) {\n+        std::string key, value;\n+        while (ptr < s.size() && s[ptr] != '=') {\n+            key.push_back(s[ptr]);\n+            ++ptr;\n+        }\n+        if (ptr == s.size()) // unexpected end of line\n+            return std::map<std::string,std::string>();\n+        ++ptr; // skip '='\n+        if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n+            ++ptr; // skip '='\n+            bool escape_next = false;\n+            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n+                escape_next = (s[ptr] == '\\\\');\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+            if (ptr == s.size()) // unexpected end of line\n+                return std::map<std::string,std::string>();\n+            ++ptr; // skip closing '\"'\n+            /* TODO: unescape value - according to the spec this depends on the\n+             * context, some strings use C-LogPrintf style escape codes, some\n+             * don't. So may be better handled at the call site.\n+             */\n+        } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n+            while (ptr < s.size() && s[ptr] != ' ') {\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+        }\n+        if (ptr < s.size() && s[ptr] == ' ')\n+            ++ptr; // skip ' ' after key=value\n+        mapping[key] = value;\n+    }\n+    return mapping;\n+}\n+\n+/** Read full contents of a file and return them in a std::string. */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fopen(filename.c_str(), \"rb\");\n+    if (f == NULL)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    size_t n;\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        retval.append(buffer, buffer+n);\n+        if (retval.size() > maxsize) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+    }\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+/** Write contents of std::string to a file.\n+ * @return true on success.\n+ */\n+static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+{\n+    FILE *f = fopen(filename.c_str(), \"wb\");\n+    if (f == NULL)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size())\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41042111",
      "id" : 41042111,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 306,
      "path" : "src/torcontrol.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41042111",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41043270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41043270"
         }
      },
      "body" : "It looks like that only works on disconnection, though. If the first attempt fails on socket connection and the callbacks never start, I don't see how the reconnect logic kicks in. Am I misreading?",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T17:04:21Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41043270",
      "id" : 41043270,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 188,
      "path" : "src/torcontrol.cpp",
      "position" : 215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41043270",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41045722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41045722"
         }
      },
      "body" : "Nevermind, I misremembered this function's return meaning. I thought it was possible to get an immediate failure in some cases, but a quick test shows that's not the case.",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-10-02T17:28:29Z",
      "diff_hunk" : "@@ -0,0 +1,580 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"init.h\" // Just for ShutdownRequested\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r41045722",
      "id" : 41045722,
      "original_commit_id" : "4ed85cff18ef419830b41b8cee2778d763c338e4",
      "original_position" : 188,
      "path" : "src/torcontrol.cpp",
      "position" : 215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T14:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/41045722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "@cfields \r\n\r\n> Can the shutdown detection be changed to work like the httpserver? ie Init calls InterruptTorControl() which starts the immediate shutdown process?\r\n\r\nYes, that sounds better. I have not done this before because it means making the libevent instance thread-safe - `Interrupt` happens from a different thread. But as we need multi-threaded libevent anyway from the http server that's a bad reason.\r\n\r\n> (Not for this PR) Looks like it'd be pretty simple to add support for connecting via Unix socket (/var/run/tor/control) as well.\r\n\r\nGood idea.\r\n",
      "created_at" : "2015-10-03T09:57:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145233066",
      "id" : 145233066,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-03T09:57:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145233066",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Ok: addressed all of @theuni's comments (apart from the UNIX socket, which we can add later).\r\nStill have SAFECOOKIE auth support on my TODO list above, it is superior to COOKIE (no potential exposure of data), and COOKIE will eventually be deprecated.\r\nThis does require use of HMAC-SHA256. Luckily we have an implementation of that for BIP32, so I think it's doable.\r\n\r\nEdit: done",
      "created_at" : "2015-10-03T15:26:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-145256375",
      "id" : 145256375,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-10-03T16:51:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/145256375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Also mentioned in release notes now.\r\n",
      "created_at" : "2015-11-10T17:07:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155489121",
      "id" : 155489121,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-10T17:07:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155489121",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "ACK\r\n\r\nTests done:\r\n\r\n- [x] Restart reuses cached onion private key\r\n- [X] SAFECOOKIE auth\r\n- [X] HASHEDPASSWORD auth\r\n- [X] Onion advertisement stops with tor disconnects\r\n- [X] Onion advertisement starts when tor restarted\r\n",
      "created_at" : "2015-11-10T20:30:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155556503",
      "id" : 155556503,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T10:41:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155556503",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "No code review, did a weak test (it correctly reports my Tor version is too old).",
      "created_at" : "2015-11-11T07:53:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155696989",
      "id" : 155696989,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T07:53:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155696989",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "That's great! I will try to look into this soon.\r\n",
      "created_at" : "2015-11-11T12:50:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155769558",
      "id" : 155769558,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T12:50:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155769558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "utACK squashme commits",
      "created_at" : "2015-11-11T18:06:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155863540",
      "id" : 155863540,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T18:06:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155863540",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r44597922"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44597922"
         }
      },
      "body" : "~~Nit: \"Wrote service key...\"?~~",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-11-11T22:41:44Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"crypto/hmac_sha256.h\"\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+#include <event2/thread.h>\n+\n+/** Default control port */\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+/** Tor cookie size (from control-spec.txt) */\n+static const int TOR_COOKIE_SIZE = 32;\n+/** Size of client/server nonce for SAFECOOKIE */\n+static const int TOR_NONCE_SIZE = 32;\n+/** For computing serverHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_SERVERKEY = \"Tor safe cookie authentication server-to-controller hash\";\n+/** For computing clientHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_CLIENTKEY = \"Tor safe cookie authentication controller-to-server hash\";\n+/** Exponential backoff configuration - initial timeout in seconds */\n+static const float RECONNECT_TIMEOUT_START = 1.0;\n+/** Exponential backoff configuration - growth factor */\n+static const float RECONNECT_TIMEOUT_EXP = 1.5;\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+    b_conn = 0;\n+    return true;\n+}\n+\n+bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB& reply_handler)\n+{\n+    if (!b_conn)\n+        return false;\n+    struct evbuffer *buf = bufferevent_get_output(b_conn);\n+    if (!buf)\n+        return false;\n+    evbuffer_add(buf, cmd.data(), cmd.size());\n+    evbuffer_add(buf, \"\\r\\n\", 2);\n+    reply_handlers.push_back(reply_handler);\n+    return true;\n+}\n+\n+/****** General parsing utilities ********/\n+\n+/* Split reply line in the form 'AUTH METHODS=...' into a type\n+ * 'AUTH' and arguments 'METHODS=...'.\n+ */\n+static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+{\n+    size_t ptr=0;\n+    std::string type;\n+    while (ptr < s.size() && s[ptr] != ' ') {\n+        type.push_back(s[ptr]);\n+        ++ptr;\n+    }\n+    if (ptr < s.size())\n+        ++ptr; // skip ' '\n+    return make_pair(type, s.substr(ptr));\n+}\n+\n+/** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ */\n+static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+{\n+    std::map<std::string,std::string> mapping;\n+    size_t ptr=0;\n+    while (ptr < s.size()) {\n+        std::string key, value;\n+        while (ptr < s.size() && s[ptr] != '=') {\n+            key.push_back(s[ptr]);\n+            ++ptr;\n+        }\n+        if (ptr == s.size()) // unexpected end of line\n+            return std::map<std::string,std::string>();\n+        ++ptr; // skip '='\n+        if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n+            ++ptr; // skip '='\n+            bool escape_next = false;\n+            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n+                escape_next = (s[ptr] == '\\\\');\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+            if (ptr == s.size()) // unexpected end of line\n+                return std::map<std::string,std::string>();\n+            ++ptr; // skip closing '\"'\n+            /* TODO: unescape value - according to the spec this depends on the\n+             * context, some strings use C-LogPrintf style escape codes, some\n+             * don't. So may be better handled at the call site.\n+             */\n+        } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n+            while (ptr < s.size() && s[ptr] != ' ') {\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+        }\n+        if (ptr < s.size() && s[ptr] == ' ')\n+            ++ptr; // skip ' ' after key=value\n+        mapping[key] = value;\n+    }\n+    return mapping;\n+}\n+\n+/** Read full contents of a file and return them in a std::string.\n+ * Returns a pair <status, string>.\n+ * If an error occured, status will be false, otherwise status will be true and the data will be returned in string.\n+ *\n+ * @param maxsize Puts a maximum size limit on the file that is read. If the file is larger than this, truncated data\n+ *         (with len > maxsize) will be returned.\n+ */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fopen(filename.c_str(), \"rb\");\n+    if (f == NULL)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    size_t n;\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        retval.append(buffer, buffer+n);\n+        if (retval.size() > maxsize)\n+            break;\n+    }\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+/** Write contents of std::string to a file.\n+ * @return true on success.\n+ */\n+static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+{\n+    FILE *f = fopen(filename.c_str(), \"wb\");\n+    if (f == NULL)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    fclose(f);\n+    return true;\n+}\n+\n+/****** Bitcoin specific TorController implementation ********/\n+\n+/** Controller that connects to Tor control socket, authenticate, then create\n+ * and maintain a ephemeral hidden service.\n+ */\n+class TorController\n+{\n+public:\n+    TorController(struct event_base* base, const std::string& target);\n+    ~TorController();\n+\n+    /** Get name fo file to store private key in */\n+    std::string GetPrivateKeyFile();\n+\n+    /** Reconnect, after getting disconnected */\n+    void Reconnect();\n+private:\n+    struct event_base* base;\n+    std::string target;\n+    TorControlConnection conn;\n+    std::string private_key;\n+    std::string service_id;\n+    bool reconnect;\n+    struct event *reconnect_ev;\n+    float reconnect_timeout;\n+    CService service;\n+    /** Cooie for SAFECOOKIE auth */\n+    std::vector<uint8_t> cookie;\n+    /** ClientNonce for SAFECOOKIE auth */\n+    std::vector<uint8_t> clientNonce;\n+\n+    /** Callback for ADD_ONION result */\n+    void add_onion_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHENTICATE result */\n+    void auth_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHCHALLENGE result */\n+    void authchallenge_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for PROTOCOLINFO result */\n+    void protocolinfo_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback after succesful connection */\n+    void connected_cb(TorControlConnection& conn);\n+    /** Callback after connection lost or failed connection attempt */\n+    void disconnected_cb(TorControlConnection& conn);\n+\n+    /** Callback for reconnect timer */\n+    static void reconnect_cb(evutil_socket_t fd, short what, void *arg);\n+};\n+\n+TorController::TorController(struct event_base* base, const std::string& target):\n+    base(base),\n+    target(target), conn(base), reconnect(true), reconnect_ev(0),\n+    reconnect_timeout(RECONNECT_TIMEOUT_START)\n+{\n+    // Start connection attempts immediately\n+    if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n+         boost::bind(&TorController::disconnected_cb, this, _1) )) {\n+        LogPrintf(\"tor: Initiating connection to Tor control port %s failed\\n\", target);\n+    }\n+    // Read service private key if cached\n+    std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n+    if (pkf.first) {\n+        LogPrint(\"tor\", \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        private_key = pkf.second;\n+    }\n+}\n+\n+TorController::~TorController()\n+{\n+    if (reconnect_ev)\n+        event_del(reconnect_ev);\n+    if (service.IsValid()) {\n+        RemoveLocal(service);\n+    }\n+}\n+\n+void TorController::add_onion_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        LogPrint(\"tor\", \"tor: ADD_ONION succesful\\n\");\n+        BOOST_FOREACH(const std::string &s, reply.lines) {\n+            std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n+            std::map<std::string,std::string>::iterator i;\n+            if ((i = m.find(\"ServiceID\")) != m.end())\n+                service_id = i->second;\n+            if ((i = m.find(\"PrivateKey\")) != m.end())\n+                private_key = i->second;\n+        }\n+\n+        service = CService(service_id+\".onion\", GetListenPort(), false);\n+        LogPrintf(\"tor: Got service ID %s, advertizing service %s\\n\", service_id, service.ToString());\n+        if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n+            LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r44597922",
      "id" : 44597922,
      "original_commit_id" : "1bcc6beff668ff6b42a086bce3e35a6ffa454cbb",
      "original_position" : 423,
      "path" : "src/torcontrol.cpp",
      "position" : 435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T23:07:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44597922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r44599329"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44599329"
         }
      },
      "body" : "Also, mind to pass this file through\r\n\r\n`contrib/devtools/clang-format.py clang-format src/torcontrol.cpp `?",
      "commit_id" : "f1d548d2c4d5c97527d5397b8fd8d92e59eefc55",
      "created_at" : "2015-11-11T22:54:29Z",
      "diff_hunk" : "@@ -0,0 +1,673 @@\n+#include \"torcontrol.h\"\n+#include \"utilstrencodings.h\"\n+#include \"net.h\"\n+#include \"util.h\"\n+#include \"crypto/hmac_sha256.h\"\n+\n+#include <vector>\n+#include <deque>\n+#include <set>\n+#include <stdlib.h>\n+\n+#include <boost/function.hpp>\n+#include <boost/bind.hpp>\n+#include <boost/signals2/signal.hpp>\n+#include <boost/foreach.hpp>\n+#include <boost/algorithm/string/predicate.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/replace.hpp>\n+\n+#include <event2/bufferevent.h>\n+#include <event2/buffer.h>\n+#include <event2/util.h>\n+#include <event2/event.h>\n+#include <event2/thread.h>\n+\n+/** Default control port */\n+const std::string DEFAULT_TOR_CONTROL = \"127.0.0.1:9051\";\n+/** Tor cookie size (from control-spec.txt) */\n+static const int TOR_COOKIE_SIZE = 32;\n+/** Size of client/server nonce for SAFECOOKIE */\n+static const int TOR_NONCE_SIZE = 32;\n+/** For computing serverHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_SERVERKEY = \"Tor safe cookie authentication server-to-controller hash\";\n+/** For computing clientHash in SAFECOOKIE */\n+static const std::string TOR_SAFE_CLIENTKEY = \"Tor safe cookie authentication controller-to-server hash\";\n+/** Exponential backoff configuration - initial timeout in seconds */\n+static const float RECONNECT_TIMEOUT_START = 1.0;\n+/** Exponential backoff configuration - growth factor */\n+static const float RECONNECT_TIMEOUT_EXP = 1.5;\n+\n+/****** Low-level TorControlConnection ********/\n+\n+/** Reply from Tor, can be single or multi-line */\n+class TorControlReply\n+{\n+public:\n+    TorControlReply() { Clear(); }\n+\n+    int code;\n+    std::vector<std::string> lines;\n+\n+    void Clear()\n+    {\n+        code = 0;\n+        lines.clear();\n+    }\n+};\n+\n+/** Low-level handling for Tor control connection.\n+ * Speaks the SMTP-like protocol as defined in torspec/control-spec.txt\n+ */\n+class TorControlConnection\n+{\n+public:\n+    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+\n+    /** Create a new TorControlConnection.\n+     */\n+    TorControlConnection(struct event_base *base);\n+    ~TorControlConnection();\n+\n+    /**\n+     * Connect to a Tor control port.\n+     * target is address of the form host:port.\n+     * connected is the handler that is called when connection is succesfully established.\n+     * disconnected is a handler that is called when the connection is broken.\n+     * Return true on success.\n+     */\n+    bool Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected);\n+\n+    /**\n+     * Disconnect from Tor control port.\n+     */\n+    bool Disconnect();\n+\n+    /** Send a command, register a handler for the reply.\n+     * A trailing CRLF is automatically added.\n+     * Return true on success.\n+     */\n+    bool Command(const std::string &cmd, const ReplyHandlerCB& reply_handler);\n+\n+    /** Response handlers for async replies */\n+    boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n+private:\n+    /** Callback when ready for use */\n+    boost::function<void(TorControlConnection&)> connected;\n+    /** Callback when connection lost */\n+    boost::function<void(TorControlConnection&)> disconnected;\n+    /** Libevent event base */\n+    struct event_base *base;\n+    /** Connection to control socket */\n+    struct bufferevent *b_conn;\n+    /** Message being received */\n+    TorControlReply message;\n+    /** Response handlers */\n+    std::deque<ReplyHandlerCB> reply_handlers;\n+\n+    /** Libevent handlers: internal */\n+    static void readcb(struct bufferevent *bev, void *ctx);\n+    static void eventcb(struct bufferevent *bev, short what, void *ctx);\n+};\n+\n+TorControlConnection::TorControlConnection(struct event_base *base):\n+    base(base), b_conn(0)\n+{\n+}\n+\n+TorControlConnection::~TorControlConnection()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+}\n+\n+void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    struct evbuffer *input = bufferevent_get_input(bev);\n+    size_t n_read_out = 0;\n+    char *line;\n+    assert(input);\n+    //  If there is not a whole line to read, evbuffer_readln returns NULL\n+    while((line = evbuffer_readln(input, &n_read_out, EVBUFFER_EOL_CRLF)) != NULL)\n+    {\n+        std::string s(line, n_read_out);\n+        free(line);\n+        if (s.size() < 4) // Short line\n+            continue;\n+        // <status>(-|+| )<data><CRLF>\n+        self->message.code = atoi(s.substr(0,3).c_str());\n+        self->message.lines.push_back(s.substr(4));\n+        char ch = s[3]; // '-','+' or ' '\n+        if (ch == ' ') {\n+            // Final line, dispatch reply and clean up\n+            if (self->message.code >= 600) {\n+                // Dispatch async notifications to async handler\n+                // Synchronous and asynchronous messages are never interleaved\n+                self->async_handler(*self, self->message);\n+            } else {\n+                if (!self->reply_handlers.empty()) {\n+                    // Invoke reply handler with message\n+                    self->reply_handlers.front()(*self, self->message);\n+                    self->reply_handlers.pop_front();\n+                } else {\n+                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                }\n+            }\n+            self->message.Clear();\n+        }\n+    }\n+}\n+\n+void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ctx)\n+{\n+    TorControlConnection *self = (TorControlConnection*)ctx;\n+    if (what & BEV_EVENT_CONNECTED) {\n+        LogPrint(\"tor\", \"tor: Succesfully connected!\\n\");\n+        self->connected(*self);\n+    } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n+        if (what & BEV_EVENT_ERROR)\n+            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n+        else\n+            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        self->Disconnect();\n+        self->disconnected(*self);\n+    }\n+}\n+\n+bool TorControlConnection::Connect(const std::string &target, const ConnectionCB& connected, const ConnectionCB& disconnected)\n+{\n+    if (b_conn)\n+        Disconnect();\n+    // Parse target address:port\n+    struct sockaddr_storage connect_to_addr;\n+    int connect_to_addrlen = sizeof(connect_to_addr);\n+    if (evutil_parse_sockaddr_port(target.c_str(),\n+        (struct sockaddr*)&connect_to_addr, &connect_to_addrlen)<0) {\n+        LogPrintf(\"tor: Error parsing socket address %s\\n\", target);\n+        return false;\n+    }\n+\n+    // Create a new socket, set up callbacks and enable notification bits\n+    b_conn = bufferevent_socket_new(base, -1, BEV_OPT_CLOSE_ON_FREE);\n+    if (!b_conn)\n+        return false;\n+    bufferevent_setcb(b_conn, TorControlConnection::readcb, NULL, TorControlConnection::eventcb, this);\n+    bufferevent_enable(b_conn, EV_READ|EV_WRITE);\n+    this->connected = connected;\n+    this->disconnected = disconnected;\n+\n+    // Finally, connect to target\n+    if (bufferevent_socket_connect(b_conn, (struct sockaddr*)&connect_to_addr, connect_to_addrlen) < 0) {\n+        LogPrintf(\"tor: Error connecting to address %s\\n\", target);\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool TorControlConnection::Disconnect()\n+{\n+    if (b_conn)\n+        bufferevent_free(b_conn);\n+    b_conn = 0;\n+    return true;\n+}\n+\n+bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB& reply_handler)\n+{\n+    if (!b_conn)\n+        return false;\n+    struct evbuffer *buf = bufferevent_get_output(b_conn);\n+    if (!buf)\n+        return false;\n+    evbuffer_add(buf, cmd.data(), cmd.size());\n+    evbuffer_add(buf, \"\\r\\n\", 2);\n+    reply_handlers.push_back(reply_handler);\n+    return true;\n+}\n+\n+/****** General parsing utilities ********/\n+\n+/* Split reply line in the form 'AUTH METHODS=...' into a type\n+ * 'AUTH' and arguments 'METHODS=...'.\n+ */\n+static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n+{\n+    size_t ptr=0;\n+    std::string type;\n+    while (ptr < s.size() && s[ptr] != ' ') {\n+        type.push_back(s[ptr]);\n+        ++ptr;\n+    }\n+    if (ptr < s.size())\n+        ++ptr; // skip ' '\n+    return make_pair(type, s.substr(ptr));\n+}\n+\n+/** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ */\n+static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n+{\n+    std::map<std::string,std::string> mapping;\n+    size_t ptr=0;\n+    while (ptr < s.size()) {\n+        std::string key, value;\n+        while (ptr < s.size() && s[ptr] != '=') {\n+            key.push_back(s[ptr]);\n+            ++ptr;\n+        }\n+        if (ptr == s.size()) // unexpected end of line\n+            return std::map<std::string,std::string>();\n+        ++ptr; // skip '='\n+        if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n+            ++ptr; // skip '='\n+            bool escape_next = false;\n+            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n+                escape_next = (s[ptr] == '\\\\');\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+            if (ptr == s.size()) // unexpected end of line\n+                return std::map<std::string,std::string>();\n+            ++ptr; // skip closing '\"'\n+            /* TODO: unescape value - according to the spec this depends on the\n+             * context, some strings use C-LogPrintf style escape codes, some\n+             * don't. So may be better handled at the call site.\n+             */\n+        } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n+            while (ptr < s.size() && s[ptr] != ' ') {\n+                value.push_back(s[ptr]);\n+                ++ptr;\n+            }\n+        }\n+        if (ptr < s.size() && s[ptr] == ' ')\n+            ++ptr; // skip ' ' after key=value\n+        mapping[key] = value;\n+    }\n+    return mapping;\n+}\n+\n+/** Read full contents of a file and return them in a std::string.\n+ * Returns a pair <status, string>.\n+ * If an error occured, status will be false, otherwise status will be true and the data will be returned in string.\n+ *\n+ * @param maxsize Puts a maximum size limit on the file that is read. If the file is larger than this, truncated data\n+ *         (with len > maxsize) will be returned.\n+ */\n+static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fopen(filename.c_str(), \"rb\");\n+    if (f == NULL)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    size_t n;\n+    while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        retval.append(buffer, buffer+n);\n+        if (retval.size() > maxsize)\n+            break;\n+    }\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+/** Write contents of std::string to a file.\n+ * @return true on success.\n+ */\n+static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+{\n+    FILE *f = fopen(filename.c_str(), \"wb\");\n+    if (f == NULL)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    fclose(f);\n+    return true;\n+}\n+\n+/****** Bitcoin specific TorController implementation ********/\n+\n+/** Controller that connects to Tor control socket, authenticate, then create\n+ * and maintain a ephemeral hidden service.\n+ */\n+class TorController\n+{\n+public:\n+    TorController(struct event_base* base, const std::string& target);\n+    ~TorController();\n+\n+    /** Get name fo file to store private key in */\n+    std::string GetPrivateKeyFile();\n+\n+    /** Reconnect, after getting disconnected */\n+    void Reconnect();\n+private:\n+    struct event_base* base;\n+    std::string target;\n+    TorControlConnection conn;\n+    std::string private_key;\n+    std::string service_id;\n+    bool reconnect;\n+    struct event *reconnect_ev;\n+    float reconnect_timeout;\n+    CService service;\n+    /** Cooie for SAFECOOKIE auth */\n+    std::vector<uint8_t> cookie;\n+    /** ClientNonce for SAFECOOKIE auth */\n+    std::vector<uint8_t> clientNonce;\n+\n+    /** Callback for ADD_ONION result */\n+    void add_onion_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHENTICATE result */\n+    void auth_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for AUTHCHALLENGE result */\n+    void authchallenge_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback for PROTOCOLINFO result */\n+    void protocolinfo_cb(TorControlConnection& conn, const TorControlReply& reply);\n+    /** Callback after succesful connection */\n+    void connected_cb(TorControlConnection& conn);\n+    /** Callback after connection lost or failed connection attempt */\n+    void disconnected_cb(TorControlConnection& conn);\n+\n+    /** Callback for reconnect timer */\n+    static void reconnect_cb(evutil_socket_t fd, short what, void *arg);\n+};\n+\n+TorController::TorController(struct event_base* base, const std::string& target):\n+    base(base),\n+    target(target), conn(base), reconnect(true), reconnect_ev(0),\n+    reconnect_timeout(RECONNECT_TIMEOUT_START)\n+{\n+    // Start connection attempts immediately\n+    if (!conn.Connect(target, boost::bind(&TorController::connected_cb, this, _1),\n+         boost::bind(&TorController::disconnected_cb, this, _1) )) {\n+        LogPrintf(\"tor: Initiating connection to Tor control port %s failed\\n\", target);\n+    }\n+    // Read service private key if cached\n+    std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n+    if (pkf.first) {\n+        LogPrint(\"tor\", \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        private_key = pkf.second;\n+    }\n+}\n+\n+TorController::~TorController()\n+{\n+    if (reconnect_ev)\n+        event_del(reconnect_ev);\n+    if (service.IsValid()) {\n+        RemoveLocal(service);\n+    }\n+}\n+\n+void TorController::add_onion_cb(TorControlConnection& conn, const TorControlReply& reply)\n+{\n+    if (reply.code == 250) {\n+        LogPrint(\"tor\", \"tor: ADD_ONION succesful\\n\");\n+        BOOST_FOREACH(const std::string &s, reply.lines) {\n+            std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n+            std::map<std::string,std::string>::iterator i;\n+            if ((i = m.find(\"ServiceID\")) != m.end())\n+                service_id = i->second;\n+            if ((i = m.find(\"PrivateKey\")) != m.end())\n+                private_key = i->second;\n+        }\n+\n+        service = CService(service_id+\".onion\", GetListenPort(), false);\n+        LogPrintf(\"tor: Got service ID %s, advertizing service %s\\n\", service_id, service.ToString());\n+        if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n+            LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#discussion_r44599329",
      "id" : 44599329,
      "original_commit_id" : "1bcc6beff668ff6b42a086bce3e35a6ffa454cbb",
      "original_position" : 423,
      "path" : "src/torcontrol.cpp",
      "position" : 435,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6639",
      "updated_at" : "2015-11-11T22:54:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/44599329",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "Somehow I can set up a `-onlynet=onion` node and connect to it (sometimes) but it never established outgoing connections:\r\n\r\n```\r\n2015-11-11 22:05:45 tor: ADD_ONION succesful\r\n2015-11-11 22:05:45 tor: Got service ID moheur3skn7jbca4, advertizing service moheur3skn7jbca4.onion:18333\r\n2015-11-11 22:05:45 tor: Cached service private key to /home/test/.bitcoin/testnet3/onion_private_key\r\n2015-11-11 22:05:45 AddLocal(moheur3skn7jbca4.onion:18333,4)\r\n2015-11-11 22:05:46 Cannot connect to t6xj6wilh4ytvcs7.onion:18333: unsupported network\r\n2015-11-11 22:05:46 Cannot connect to 4azvkpo55qaskhjl.onion:18333: unsupported network\r\n2015-11-11 22:05:47 Cannot connect to nkf5e6b7pl4jfd4a.onion:18333: unsupported network\r\n2015-11-11 22:05:48 Cannot connect to 4zhkir2ofl7orfom.onion:18333: unsupported network\r\n```",
      "created_at" : "2015-11-11T22:57:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155936122",
      "id" : 155936122,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T22:57:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155936122",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "body" : "you are mistaking. it's -onlynet=tor . you confuse onion with -onion=127.0.0.1:9050 where you instruct bitcoin to use that socks5 proxy to connect to onion peers (from tor network). While -onlynet=tor will make sure you connect only to onion (Tor) peers, -onion=xxx will only provide a gateway for these peers but connect to other kind of peers also.",
      "created_at" : "2015-11-11T23:56:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6639#issuecomment-155948382",
      "id" : 155948382,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6639",
      "updated_at" : "2015-11-11T23:56:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/155948382",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6549887?v=3",
         "events_url" : "https://api.github.com/users/gits7r/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gits7r/followers",
         "following_url" : "https://api.github.com/users/gits7r/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gits7r/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gits7r",
         "id" : 6549887,
         "login" : "gits7r",
         "organizations_url" : "https://api.github.com/users/gits7r/orgs",
         "received_events_url" : "https://api.github.com/users/gits7r/received_events",
         "repos_url" : "https://api.github.com/users/gits7r/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gits7r/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gits7r/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gits7r"
      }
   }
]
