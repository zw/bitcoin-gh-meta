[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16653](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16653.html) (script: add simple signature support (checker/creator) by kallewoof)\n* [#16439](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16439.html) (RPC: support \"@height\" in place of blockhash for getblock etc by ajtowns)\n* [#16365](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16365.html) (Log RPC parameters (arguments) if -debug=rpcparams by LarryRuane)\n* [#16341](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16341.html) (Introduce ScriptPubKeyMan interface and use it for key and script management (aka wallet boxes) by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-07-23T06:38:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-514074976",
      "id" : 514074976,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDA3NDk3Ng==",
      "updated_at" : "2019-09-02T20:34:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514074976",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2019-07-23T13:32:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-514211484",
      "id" : 514211484,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDIxMTQ4NA==",
      "updated_at" : "2019-07-23T13:32:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514211484",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308020901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308020901"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think \"the derived BECH32 address\" will become ambiguous if subsequent versions of segwit are adopted.  E.g. if taproot is adopted, there would be two possible bech32 addresses for the same public key.  Perhaps this should say, \"the derived P2WPKH bech32 address\".\r\n\r\nNit: BECH is not an acronym AFAIK and so should not be all caps.  A quick git grep shows that the convention in the repository is to treat it as a common noun, so all lowercase unless at the start of a sentence.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-28T22:18:06Z",
      "diff_hunk" : "@@ -272,48 +277,44 @@ static UniValue verifymessage(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid address\");\n     }\n \n-    const PKHash *pkhash = boost::get<PKHash>(&destination);\n-    if (!pkhash) {\n-        throw JSONRPCError(RPC_TYPE_ERROR, \"Address does not refer to key\");\n-    }\n+    proof::SignMessageWorkspace p;\n+\n+    p.AppendDestinationChallenge(destination);\n \n     bool fInvalid = false;\n     std::vector<unsigned char> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);\n \n-    if (fInvalid)\n+    if (fInvalid) {\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Malformed base64 encoding\");\n+    }\n \n-    CHashWriter ss(SER_GETHASH, 0);\n-    ss << strMessageMagic;\n-    ss << strMessage;\n+    CDataStream stream(vchSig, SER_DISK, PROTOCOL_VERSION);\n \n-    CPubKey pubkey;\n-    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig))\n-        return false;\n+    stream >> p.m_proof;\n \n-    return (pubkey.GetID() == *pkhash);\n+    return proof::ResultString(p.Verify(strMessage));\n }\n \n static UniValue signmessagewithprivkey(const JSONRPCRequest& request)\n {\n-            RPCHelpMan{\"signmessagewithprivkey\",\n-                \"\\nSign a message with the private key of an address\\n\",\n-                {\n-                    {\"privkey\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The private key to sign the message with.\"},\n-                    {\"message\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The message to create a signature of.\"},\n-                },\n-                RPCResult{\n-            \"\\\"signature\\\"          (string) The signature of the message encoded in base 64\\n\"\n-                },\n-                RPCExamples{\n+    RPCHelpMan{\"signmessagewithprivkey\",\n+        \"\\nSign a message with the private key of an address\\n\",\n+        {\n+            {\"privkey\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The private key to sign the message with.\"},\n+            {\"message\", RPCArg::Type::STR, RPCArg::Optional::NO, \"The message to create a signature of.\"},\n+        },\n+        RPCResult{\n+            \"\\\"signature\\\"          (string) The signature of the message encoded in base 64 (note: the address for the private key is the derived BECH32 address; any other type will fail validation)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308020901",
      "id" : 308020901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODAyMDkwMQ==",
      "original_commit_id" : "ef8fa5ceae9fbc8499b2529bd53e7699e2a0f8a7",
      "original_position" : 109,
      "path" : "src/rpc/misc.cpp",
      "position" : null,
      "pull_request_review_id" : 267525062,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308020901",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@harding \r\n\r\n> I really like the idea of BIP322, but I don't like that this changes existing RPCs in way that's not backwards compatible (e.g. a signmessage created and verified on 0.18 produces a \"CDataStream::read(): end of data: iostream error\" here). Similarly, a P2PKH signmessage created on this branch results in false when checked with 0.18. Either P2PKH signing/verifying should be special cased to use the legacy signmessage format, or BIP322 message signing should use different RPCs (or at least a special RPC parameter or configuration option to indicate the user wants to use BIP322).\r\n\r\nI don't really agree. Proving that you own an address is something that you do \"now\", not something you do and keep the proof around indefinitely. Losing an old proof should be perfectly fine, as the point is lost if you can't reproduce it.\r\n\r\nOf course, down the road Craig could claim that his broken proof actually worked, \"but that core changed the mechanism so it can't be verified anymore\" but I don't know if anybody cares about him enough to warrant keeping both kinds of verifiers (we probably do not want to keep the signmessage part).\r\n\r\n> Just on this branch, I also created a 2-of-3 P2WSH address using addmultisigaddress and then attempted to signmessage with it. I received the error, ScriptPubKey does not refer to a key. Unless I'm misunderstanding BIP322, this should be possible and it would be cool if the wallet knew how to do it (however, even if the wallet doesn't know how to do it, as long as it's possible by BIP322, the error message should be changed). I didn't test any more advanced scripts, although I think that would be worthwhile to test later---in theory, the wallet should be able to signmessage for any script where its solver could sign for a spend. I think importing some advanced scripts using descriptors and then signmessage'ing for them might make a good addition to the integration tests in this PR.\r\n\r\nYes, BIP322 literally just says \"the sighash (normally based on the transaction) is X; now sign/verify with this address\" and uses exactly the same code that is used by the wallet to sign transactions, so anything goes. I'm actually confused why your example doesn't work out of the box. I'll look into that.\r\n\r\n> Another concern is that I don't believe the discussion over how BIP322 should handle timelocking opcodes (CLTV and CSV) was ever resolved. I think that's probably important before this could be released.\r\n\r\nActually, those should just be removed; they were meant for the proof of funds, which I am removing from BIP322. Thanks for the nudge.\r\n\r\n> Finally, I skimmed the code and left one documentation-related note. Thanks for working on this!\r\n\r\nGreat! Thanks, will address.",
      "created_at" : "2019-07-29T03:30:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515831681",
      "id" : 515831681,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTgzMTY4MQ==",
      "updated_at" : "2019-07-29T03:30:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515831681",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@kallewoof \r\n\r\n> >  I don't like that this changes existing RPCs in way that's not backwards compatible [...]\r\n\r\n> I don't really agree. Proving that you own an address is something that you do \"now\", not something you do and keep the proof around indefinitely. [...]\r\n\r\nI think there are several points here:\r\n\r\n1. This change breaks backwards compatibility between different versions of Bitcoin Core.  I think it's unfortunate if someone running version x can't create or verify proofs when talking to someone running version y.  Sure, it'd be nice if everyone upgraded to the latest version, but that takes time (sometimes years in the case of cold wallets).\r\n\r\n2. This change breaks compatibility with almost every other wallet that has implemented signmessage support.  Again, it'd be great if they all have BIP322 support ready at the same time this code gets into a Bitcoin Core release, but that seems extremely unlikely to me---I expect it to take years to get widespread BIP322 support.  Then each of those wallets has their own user upgrade cycle which may take years, so we're talking years + years until everyone is using BIP322 (if it is generally adopted at all).  Until near-universal adoption happens, it'd be nice if Bitcion Core is compatible with other wallets.\r\n\r\n3. As you mention, this breaks old signmessages.  While I don't feel strongly about that and I'm at least somewhat sympathetic with your arguments about people just generating new proofs, I think unnecessary breakage is something we should try to avoid.\r\n\r\nI think the appropriate solution to all three issues is that these existing RPCs should continue to generate and verify legacy P2PKH signmessages when called with P2PKH addresses.  They could automatically switch between legacy support and BIP322 support depending on address type or BIP322 could get new RPCs.  (Something to consider would be amending BIP322 so that P2PKH addresses in BIP322 are special cased to use the old signmessage format; that way this PR can be made fully BIP322 compliant and yet backward compatible.)",
      "created_at" : "2019-07-29T04:12:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515837523",
      "id" : 515837523,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTgzNzUyMw==",
      "updated_at" : "2019-07-29T04:12:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515837523",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I see what you're saying.\r\n\r\nI think adding an optional 'format' which defaults to 'bip322' but can be set to 'legacy' for 'sign', and autodetection in 'verify' should be sufficient. What do you think?",
      "created_at" : "2019-07-29T04:55:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515844196",
      "id" : 515844196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg0NDE5Ng==",
      "updated_at" : "2019-07-29T04:55:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515844196",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@kallewoof \r\n\r\n> I think adding an optional 'format' which defaults to 'bip322' but can be set to 'legacy' for 'sign', and autodetection in 'verify' should be sufficient. What do you think?\r\n\r\nSounds reasonable to me.  I'd slightly prefer the default be legacy if the user provides a P2PKH address---but not enough to argue about it.  Thanks! ",
      "created_at" : "2019-07-29T05:40:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515851920",
      "id" : 515851920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg1MTkyMA==",
      "updated_at" : "2019-07-29T05:40:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515851920",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for picking this up again.\n\nI don't think we should gratuitously break compatibility with the existing signature scheme; that's generally not the approach we take with RPCs, and given that the scheme is implemented in other software too probably even more disruptive.\n\nI wouldn't be opposed to adding an exception in BIP322 that for P2PKH address the existing key recovery based scheme is used; in general I like avoiding ambiguity in these things. However I also see this may add additional complication to the spec, and perhaps not be very clear cut either (why just the P2PKH ones, and not the extensions to other single-key address types people have proposed and adopted in other software, for example?).",
      "created_at" : "2019-07-29T05:44:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515852677",
      "id" : 515852677,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg1MjY3Nw==",
      "updated_at" : "2019-07-29T05:44:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515852677",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@harding @sipa Defaulting to legacy for P2PKH means we can basically never get rid of the legacy code. That's okay, but unfortunate, IMO.",
      "created_at" : "2019-07-29T05:54:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515854860",
      "id" : 515854860,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg1NDg2MA==",
      "updated_at" : "2019-07-29T05:54:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515854860",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I didn't expect we'd ever be able to get rid of the old format, even if the default would be a new format now. That'd indeed unfortunate, but that's life when you want compatibility. I don't think it's a big problem; it's not that much code.",
      "created_at" : "2019-07-29T06:07:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515857539",
      "id" : 515857539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg1NzUzOQ==",
      "updated_at" : "2019-07-29T06:09:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515857539",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@harding @sipa I have updated the specification to include the special case, and I also added a description of the legacy format: https://github.com/bitcoin/bips/blob/e24e86b482e394e18803f14c7e2338aab9b7e1e2/bip-0322.mediawiki (from https://github.com/bitcoin/bips/pull/808)\r\n\r\nLet me know if I got something wrong there. I wrote the legacy format spec based on the code.",
      "created_at" : "2019-07-29T06:29:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515862737",
      "id" : 515862737,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTg2MjczNw==",
      "updated_at" : "2019-07-29T11:45:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515862737",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I updated the code in this PR to do what was suggested (use legacy if p2pkh, otherwise use bip322), and I also updated bip322 to require this.",
      "created_at" : "2019-07-29T08:51:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-515905247",
      "id" : 515905247,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNTkwNTI0Nw==",
      "updated_at" : "2019-07-29T08:51:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/515905247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Tested `signmessage` and `verifymessage` both ways between 0.18 and this branch, looks good, thanks!  You may want to consider making `signmessagewithprivkey` default to using P2PKH for backwards compatibility and add a third argument to that RPC that allows selecting P2WPKH (I'd suggest the argument select between P2PKH and P2WPKH (rather than legacy vs bip322) so that it can be extended to take a P2TR argument or other address format argument in the future).\r\n\r\nI skimmed [this commit](https://github.com/bitcoin/bips/commit/cfcd4e1a37545a8c86ab22e1cda540e876f11836) with the proposed changes to BIP322 and left a couple nits.  As a specification, I think it could also use a description of `CKey::SignCompact()` and `CKey::RecoverCompact()` such as how they serialize which derived pubkey to use and whether or not it's compressed or uncompressed.  An alternative to putting this information in BIP322 would be to create a separate BIP for the established legacy signmessage format (which was created before we had BIPs) and then simply have BIP322 reference that BIP.  I can help with documentation if you'd like.",
      "created_at" : "2019-07-29T14:40:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516020208",
      "id" : 516020208,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjAyMDIwOA==",
      "updated_at" : "2019-07-29T14:40:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516020208",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@harding\r\n\r\nFYI the bitcoin/bips PR was merged as you were reviewing it; I opened a fix-up here: https://github.com/bitcoin/bips/pull/814\r\n\r\nThanks for testing!\r\n\r\n> You may want to consider making `signmessagewithprivkey` default to using P2PKH for backwards compatibility and add a third argument to that RPC that allows selecting P2WPKH (I'd suggest the argument select between P2PKH and P2WPKH (rather than legacy vs bip322) so that it can be extended to take a P2TR argument or other address format argument in the future).\r\n\r\nSure, since we are not getting rid of the legacy format, we might as well use it where it is usable. \r\n\r\nEdit: This has been updated. It uses the output type parsing from other places to allow legacy, p2sh-segwit, or bech32. I assume once taproot and such appear, they will be added to this and this should \"just work [tm]\".",
      "created_at" : "2019-07-29T15:00:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516028954",
      "id" : 516028954,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjAyODk1NA==",
      "updated_at" : "2019-07-29T15:17:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516028954",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308332901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308332901"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You may want to check with @achow101 that this doesn't conflict with the descriptor wallet changes.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-29T16:53:47Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308332901",
      "id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODMzMjkwMQ==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 267910356,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308332901",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK based on light testing.  The API changes default to backwards compatibility with legacy signmessage and BIP322 is an excellent extension of the signmessage mechanism.\r\n\r\nNeeds fix and testing for this case:\r\n\r\n```text\r\n$ _gna() { src/bitcoin-cli getnewaddress '' bech32 ; } ; export -f _gna\r\n$ bitcoin-cli addmultisigaddress 2 '[\"'$(_gna)'\", \"'$(_gna)'\", \"'$(_gna)'\"]' '' bech32\r\n{\r\n  \"address\": \"bc1qxg4wrq0yc2vngavudljkjdvwcah6j06pc2pyygy3kevdqqlf707se96d7s\",\r\n  \"redeemScript\": \"522103da30e969126296db3db0b95030b8813557f031b3ce8aaa43215f77d62f6f506721021d856b20af7e5fc6f0f0e873e6bdbc1030a3ca63a19e8e71b2ed806ca5ec4ef521032f278e5fc10fa304151b6939dc545189905e492dbe8cb393fb8f2e976fb5440e53ae\"\r\n}\r\n$ bitcoin-cli signmessage bc1qxg4wrq0yc2vngavudljkjdvwcah6j06pc2pyygy3kevdqqlf707se96d7s Test\r\nerror code: -1\r\nerror message:\r\nScriptPubKey does not refer to a key\r\n```\r\n\r\n(Same error message also returned for legacy and p2sh-segwit.)",
      "created_at" : "2019-07-29T17:11:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516079185",
      "id" : 516079185,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjA3OTE4NQ==",
      "updated_at" : "2019-07-29T17:11:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516079185",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308521465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308521465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This doesn't interfere with the descriptor wallet changes since a `SigningProvider` was never actually needed in the GUI.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-30T03:40:31Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308521465",
      "id" : 308521465,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODUyMTQ2NQ==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268142363,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308521465",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308522630"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308522630"
         }
      },
      "author_association" : "MEMBER",
      "body" : "But there won't be a singular signing provider for the whole wallet anymore, right?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-30T03:48:18Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308522630",
      "id" : 308522630,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODUyMjYzMA==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268143674,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308522630",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@harding I looked closer and it looks like a bunch of juggling is required to do multisig proving. I could sort of make an attempt to make it prove for the case where you have all the keys, but that doesn't seem overly interesting. For now, I have updated the error message to note that multisig is not yet supported, though this is not a limitation in the BIP322 spec, only in the code.",
      "created_at" : "2019-07-30T05:39:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516270489",
      "id" : 516270489,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjI3MDQ4OQ==",
      "updated_at" : "2019-07-30T05:40:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516270489",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "For generic multisig signing you basically want something like PSBT, but then for messages instead of transactions... certainly not for inclusion in the first PR though.",
      "created_at" : "2019-07-30T05:53:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516273707",
      "id" : 516273707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjI3MzcwNw==",
      "updated_at" : "2019-07-30T05:53:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516273707",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa That is the conclusion I made as well (PSBT).",
      "created_at" : "2019-07-30T06:00:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516275197",
      "id" : 516275197,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjI3NTE5Nw==",
      "updated_at" : "2019-07-30T06:00:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516275197",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK now that we are backwards compatible by defaulting to legacy for P2PKH\r\n\r\n",
      "created_at" : "2019-07-30T09:21:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516339126",
      "id" : 516339126,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjMzOTEyNg==",
      "updated_at" : "2019-07-30T09:21:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516339126",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308805714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308805714"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "FWIW, I think it would be better to add an `interfaces::Wallet::signMessage()` method instead of adding an `interfaces::Wallet::getSigningProvider()` method. Few reasons:\r\n\r\n1) It would allow deduplicating more code for signing messages instead of having it written twice in qt and rpcwallet.\r\n\r\n2) It would create a little less work for me with #10102, so I don't have to an add IPC wrapper around `SigningProvider`, or serialize `SigningProvider` with private key information and send it from the wallet process to the qt process.\r\n\r\n3) Just in general I think `rpcwallet.cpp` is too monolothic and has too much important code mixed with UniValue boilerplate. So I'd love to see something like `src/wallet/sign.h` / `src/wallet/sign.cpp` files with a `bool SignMessage(CWallet& wallet, message, options...)` function and start organizing things better.\r\n\r\nAnyway, I'm fine with this approach, but wanted to suggest an alternative.\r\n\r\nEDIT: Changed `Wallet&` to `CWallet&` above (sorry for the confusing typo) ",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-30T15:56:31Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308805714",
      "id" : 308805714,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODgwNTcxNA==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268497999,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308805714",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308998638"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308998638"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ryanofsky That sounds good to me! I am not sure how to access the `interfaces::Wallet` instance from `rpcwallet.cpp` though. It seems like it only has access to `CWallet` (while the QT side only has access to `interfaces::Wallet`).\r\n\r\nIs the idea to add two signmessage functions, where the interface one simply calls down into `m_wallet->SignMessage(..)`?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-31T00:37:09Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308998638",
      "id" : 308998638,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODk5ODYzOA==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268735402,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308998638",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309005098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309005098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> @ryanofsky That sounds good to me! I am not sure how to access the `interfaces::Wallet` instance from `rpcwallet.cpp` though. It seems like it only has access to `CWallet` (while the QT side only has access to `interfaces::Wallet`).\r\n\r\nrpcwallet.cpp shouldn't need to access `interfaces::Wallet` here (and in general) because `interfaces::Wallet` doesn't contain any real functionality, it's just a high level wrapper around selected wallet functions that GUI code uses to indirectly control wallets.\r\n\r\nSo the idea is just to implement a standalone function in wallet code:\r\n\r\n```c++\r\nbool SignMessage(CWallet& wallet, message, options...)\r\n```\r\n\r\nand to call this function both from `wallet/rpcwallet.cpp` and `interfaces/wallet.cpp` (just adding a one-line `WalletImpl::signMessage()` wrapper method in the interface code).\r\n\r\n> Is the idea to add two signmessage functions, where the interface one simply calls down into `m_wallet->SignMessage(..)`?\r\n\r\nSorry! Just realized I had a typo in https://github.com/bitcoin/bitcoin/pull/16440#discussion_r308805714, which is fixed now but was probably pretty confusing. I was trying to suggest not having a `CWallet::SignMesage(...)` method, but instead defining a standalone `SignMessage(CWallet&, ...)` function. Really either a method or a standalone function would be fine, but the function seemed better because we're gradually breaking CWallet up and pulling functionality out of it, so adding new functionality there without a reason seemed to be moving in wrong direction.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-31T01:16:48Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309005098",
      "id" : 309005098,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTAwNTA5OA==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268743044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309005098",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309021522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309021522"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ryanofsky I ended up adding a couple of helper functions to `proof.h` and adding a `proof.cpp` file. The P2PKH-vs-others logic is now all contained inside the proof code, and is called from `rpcwallet`/`misc`/`interfaces/wallet`:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/6e9947e2ee6a9f9cef173a47ff56e11fc4d32efd/src/script/proof.h#L237-L250\r\n\r\nThe interface side ends up like\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/6e9947e2ee6a9f9cef173a47ff56e11fc4d32efd/src/interfaces/wallet.cpp#L460-L463",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-31T02:58:45Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309021522",
      "id" : 309021522,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTAyMTUyMg==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268763269,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309021522",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309024560"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309024560"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As a side result of this, `strMessageMagic` was moved out of validation.h/cpp into proof.cpp, and is no longer public, which is nice.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-31T03:19:22Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309024560",
      "id" : 309024560,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTAyNDU2MA==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 268767051,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309024560",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\nWill try to implement it in NBitcoin.",
      "created_at" : "2019-07-31T07:37:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516734883",
      "id" : 516734883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjczNDg4Mw==",
      "updated_at" : "2019-07-31T07:37:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516734883",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/3020646?v=4",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "node_id" : "MDQ6VXNlcjMwMjA2NDY=",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@fanquake I think the \"Needs Conceptual Review\" flag can be removed. Got Conceptual ACKs from @laanwj, @harding, @practicalswift, and @NicolasDorier (and no Concept NACKs from anyone).",
      "created_at" : "2019-07-31T08:09:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-516744856",
      "id" : 516744856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjc0NDg1Ng==",
      "updated_at" : "2019-07-31T08:09:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516744856",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309320697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309320697"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks good. The new SignMessageWithSigningProvider makes for fewer wallet changes than what I suggested, which is great!",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-07-31T16:38:14Z",
      "diff_hunk" : "@@ -255,6 +256,9 @@ class Wallet\n     // Remove wallet.\n     virtual void remove() = 0;\n \n+    // Get a signing provider for the wallet.\n+    virtual SigningProvider& getSigningProvider() = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r309320697",
      "id" : 309320697,
      "in_reply_to_id" : 308332901,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTMyMDY5Nw==",
      "original_commit_id" : "053afb22228ad62a7bd1bdf2aa2987c1d088e5fe",
      "original_position" : 13,
      "path" : "src/interfaces/wallet.h",
      "position" : null,
      "pull_request_review_id" : 269140504,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-28T05:02:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309320697",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "FTR, I updated the BIP to fix verification which was a bit broken. I have also updated the code here. New BIP can be seen here: https://github.com/bitcoin/bips/blob/499a2eaf8943c1fbfef2dd9a0ef2201d70352fbb/bip-0322.mediawiki",
      "created_at" : "2019-08-01T07:22:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-517155975",
      "id" : 517155975,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNzE1NTk3NQ==",
      "updated_at" : "2019-08-01T07:22:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/517155975",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Abstract, tentative concept NACK:\r\n\r\nI'm not convinced BIP322 is itself a good idea as-is. Its multiple-proofs concept seems ripe to encourage misuse of signatures as a false \"proof\" of spend-ability rather than simply proving a receiver (as current signatures do).\r\n\r\nIf BIP322 is intended for proving spend-ability, then it confuses the matter of addresses (which don't spend), and also conflicts with the historical use case of `signmessage` and `verifymessage` which is never for spend-ability purposes.",
      "created_at" : "2019-08-20T00:36:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-522805617",
      "id" : 522805617,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMjgwNTYxNw==",
      "updated_at" : "2019-08-20T00:36:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/522805617",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr\r\n\r\n> I'm not convinced BIP322 is itself a good idea as-is. Its multiple-proofs concept seems ripe to encourage misuse of signatures as a false \"proof\" of spend-ability rather than simply proving a receiver (as current signatures do).\r\n\r\nThe argument for multiple proofs is that it's not trivial to verify that many independent proofs are not overlapping. This becomes more serious if/when a \"proof of funds\" purpose is added, where I may convince you that I have more money than I actually do. Even now, though, I can make you think I have the private keys to more pubkeys than I do (and whatever locked funds associated with those).\r\n\r\nThe BIP explicitly describes how multiple proofs should be handled (e.g. immediately abort if the same proof appears twice), but if there are attack vectors I didn't think of, I'd of course like to address them.\r\n\r\n> If BIP322 is intended for proving spend-ability, then it confuses the matter of addresses (which don't spend), and also conflicts with the historical use case of signmessage and verifymessage which is never for spend-ability purposes.\r\n\r\nBIP322 is intended to be a general purpose \"prove/verify\" system for script-style \"stuff\" in Bitcoin. \r\n\r\n* The signmessage purpose is used to prove that you are able to create a valid scriptSig for a given scriptPubKey. \r\n* A theoretical proof of funds purpose would be used to prove that you can spend a given set of transaction outputs, but this is beyond the scope of both BIP322 and this PR.\r\n\r\nIf there is a way to clarify the above, I'm all ears.",
      "created_at" : "2019-08-20T06:20:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-522871224",
      "id" : 522871224,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMjg3MTIyNA==",
      "updated_at" : "2019-08-20T06:20:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/522871224",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@kallewoof Existing signatures do not prove you have access to any private keys nor funds, only that you are the recipient to future transactions paying an address (and therefore the right person to be signing contractual terms for such payments). Because it proves nothing about existing funds or keys, there is no such thing as \"overlapping\" proofs to worry about.\r\n\r\nIf you intend to cover more proof cases than that, you probably need a new RPC so it can't be confused with the purpose of the existing ones.",
      "created_at" : "2019-08-20T12:43:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-522996437",
      "id" : 522996437,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMjk5NjQzNw==",
      "updated_at" : "2019-08-20T12:43:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/522996437",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr Yes I agree that prove funds may need a separate RPC. I chose to exclude that from the BIP because there are things that should be resolved before including it, but it should be easy to add as an extension to BIP-322. This is why it inherently supports multiple proofs, even if as you mention this is not an issue with address proving.",
      "created_at" : "2019-08-21T02:38:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-523270985",
      "id" : 523270985,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyMzI3MDk4NQ==",
      "updated_at" : "2019-08-21T02:38:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/523270985",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I know I'm late to the party but I would like to give some conceptual feedback.  But I have some more serious issues understanding the BIP.\r\n\r\nOn a high level, it seems to me that the purpose of the BIP is not entirely clear. At the moment, it is only for signing messages but includes the entire scripting system. As I understand it, the reason is future extensions to proving ownership of funds. If this is right, I'm not convinced by this approach: If we want a BIP for signing and verifying messages, this can much simpler (if restricted to addresses). If we want a BIP for proving ownership of funds, we should actually write one. My concerns are: \r\n * These two purposes of signing messages and proving ownership are very different, and maybe they deserve different approaches/BIPs/RPC.\r\n * The current BIP seems to be in the middle and it could very well happen that some of decisions taken now turn out to be not great when there is an actual extension to proving ownership.\r\n\r\n(edit:) Maybe it helps to think about actual applications: When do we need a signed message? I think this is related to @luke-jr's comments.  \r\n\r\nOn a more technical level and related to the previous point: Does the BIP implicitly assume that a scriptPubKey contains exactly one pubkey? I'm not sure after reading it. Signing seems to fail if I can't derive a private key from a scriptPubKey (but this could happen because there is not a single pubkey in the scriptPubKey OR because we don't have the private key). Verification always uses some sighash, but what if there is no pubkey (or more than one pubkey)? This illustrates what I meant when I said the purposes are different: If you want to verify a signed message, you need a pubkey (and better exactly one). If you want to prove ownership, we shouldn't give the user a `verifymessage` function that in fact won't verify a signature in some cases.\r\n\r\nI guess I have some more comments but it's probably better to clarify this first. I'm happy to move this discussion to the mailing list if this is more appropriate for these conceptual issues.",
      "created_at" : "2019-08-28T10:20:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-525680906",
      "id" : 525680906,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNTY4MDkwNg==",
      "updated_at" : "2019-08-28T10:22:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/525680906",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> On a high level, it seems to me that the purpose of the BIP is not entirely clear. At the moment, it is only for signing messages but includes the entire scripting system. As I understand it, the reason is future extensions to proving ownership of funds. If this is right, I'm not convinced by this approach: If we want a BIP for signing and verifying messages, this can much simpler (if restricted to addresses). If we want a BIP for proving ownership of funds, we should actually write one. My concerns are:\r\n\r\nNo, this is not the reason. The reason why the script system is used is unrelated to a potential future funds proving tool, and is purely done this way to make future upgrades (e.g. taproot, schnorr, ...) seamless. New address formats and such will work out of the box assuming the underlying node(s) actually understand them.\r\n\r\n> * These two purposes of signing messages and proving ownership are very different, and maybe they deserve different approaches/BIPs/RPC.\r\n\r\nYes, I specifically removed any proof-of-funds related stuff from the BIP for this reason. It should be considered a separate thing, albeit with some shared functionality.\r\n\r\n> * The current BIP seems to be in the middle and it could very well happen that some of decisions taken now turn out to be not great when there is an actual extension to proving ownership.\r\n\r\nAside from the fact it is extensible to add another purpose (for the reason stated above), I'm not sure it's overly middle-groundy as it stands. What could be trimmed out to make it less so without burning too many bridges in a potential future expansion to add a POF purpose?\r\n\r\n> On a more technical level and related to the previous point: Does the BIP implicitly assume that a scriptPubKey contains exactly one pubkey?\r\n\r\nThe BIP accepts any kind of script. In practice, if you feed it the appropriate scriptSig to fulfill the scriptPubKey associated with the address in question, it should be able to work with any scriptPubKeys.\r\n\r\n>  I'm not sure after reading it. Signing seems to fail if I can't derive a private key from a scriptPubKey (but this could happen because there is not a single pubkey in the scriptPubKey OR because we don't have the private key).\r\n\r\nRight now, it will attempt to derive a P2PKH key. If it succeeds, it uses the legacy system, otherwise it tries to produce a signature given that scriptPubKey as the input (just like it does when signing transactions). There is some practical bits missing to do e.g. multisig right now; the conclusion was basically that PSBT should be used, and was out of scope of this PR.\r\n",
      "created_at" : "2019-08-29T06:32:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-526045151",
      "id" : 526045151,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjA0NTE1MQ==",
      "updated_at" : "2019-08-29T06:32:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526045151",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318941957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318941957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Won't this make signatures trivially malleable? Also, maybe SIGHASH_ALL is somewhat abused here. Do we need a flag at all?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-08-29T08:20:46Z",
      "diff_hunk" : "@@ -1416,6 +1416,20 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n+bool SimpleSignatureChecker::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    CPubKey pubkey(vchPubKey);\n+    if (!pubkey.IsValid()) return false;\n+\n+    // Hash type is one byte tacked on to the end of the signature\n+    std::vector<unsigned char> vchSig(vchSigIn);\n+    if (vchSig.empty()) return false;\n+    // int nHashType = vchSig.back();\n+    vchSig.pop_back();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318941957",
      "id" : 318941957,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxODk0MTk1Nw==",
      "original_commit_id" : "5e6affa7fef44a812b571fc605af99b037b42d41",
      "original_position" : 13,
      "path" : "src/script/interpreter.cpp",
      "position" : 13,
      "pull_request_review_id" : 281291336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-29T08:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318941957",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318945748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318945748"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this intended to limit the string? I think it won't.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-08-29T08:29:29Z",
      "diff_hunk" : "@@ -0,0 +1,98 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/proof.h>\n+\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+\n+namespace proof\n+{\n+\n+Result SignMessage::Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const {\n+    Result rv = Purpose::Prepare(m_scriptpubkey, inputs_out);\n+    if (rv != RESULT_VALID) return rv;\n+    CHashWriter hw(SER_DISK, 0);\n+    std::string s = strMessageMagic + message;\n+    hw << m_scriptpubkey << LimitedString<65536>(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318945748",
      "id" : 318945748,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxODk0NTc0OA==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 17,
      "path" : "src/script/proof.cpp",
      "position" : 17,
      "pull_request_review_id" : 281291336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-29T08:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318945748",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318954925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318954925"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think if the (attacker-provided) input is indeed invalid, this should `INVALID` instead of `ERROR`. I think it's cleaner to use `ERROR` only for real processing errors when we can't reach a result, e.g., out-of-memory (okay, maybe a bad example here). Here, we have a result: The proof is invalid because a legacy proof for P2PKH is not allowed.\r\n\r\nThe background is that crypto APIs typically work like this and are easier to get wrong for the user. If someone gives me a 3 byte string and claims it's an ECDSA signature for some message and some key, then it's an invalid signature. That's all I care about if I call a RPC, I don't care (or shouldn't care) why it's invalid and I don't need to handle different errors differently.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-08-29T08:48:35Z",
      "diff_hunk" : "@@ -11,32 +11,73 @@ class SignMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        self.extra_args = [[\"-addresstype=legacy\"]]\n+        self.extra_args = [[\"-addresstype=bech32\"]]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n         message = 'This is just a test message'\n \n-        self.log.info('test signing with priv_key')\n+        self.log.info('test signing with priv_key with bech32')\n+        priv_key = 'cVbpmtsSXkBJhSZakwBSUY7jxhUgXZeT4hCAGyKixccRZwMG4jrf'\n+        address = 'bcrt1qf2yvxk355rc6pqgprrn7q4d3lctr22ta3ne08w'\n+        signature = self.nodes[0].signmessagewithprivkey(priv_key, message, 'bech32')\n+        assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n+\n+        self.log.info('test legacy key signing')\n         priv_key = 'cUeKHd5orzT3mz8P9pxyREHfsWtVfgsfDjiZZBcjUBAaGk1BTj7N'\n         address = 'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB'\n         expected_signature = 'INbVnW4e6PeRmsv2Qgu8NuopvrVjkcxob+sX8OcZG0SALhWybUjzMLPdAsXI46YZGb0KQTRii+wWIQzRpG/U+S0='\n         signature = self.nodes[0].signmessagewithprivkey(priv_key, message)\n         assert_equal(expected_signature, signature)\n         assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n \n         self.log.info('test signing with an address with wallet')\n         address = self.nodes[0].getnewaddress()\n         signature = self.nodes[0].signmessage(address, message)\n         assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n \n         self.log.info('test verifying with another address should not work')\n         other_address = self.nodes[0].getnewaddress()\n+        legacy_address = self.nodes[0].getnewaddress(address_type='legacy')\n+        other_signature = self.nodes[0].signmessage(other_address, message)\n+        legacy_signature = self.nodes[0].signmessage(legacy_address, message)\n+        assert not self.nodes[0].verifymessage(other_address, signature, message)\n+        assert not self.nodes[0].verifymessage(address, other_signature, message)\n+        assert not self.nodes[0].verifymessage(legacy_address, signature, message)\n+        assert not self.nodes[0].verifymessage(address, legacy_signature, message)\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(other_address, signature, message, 1))\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(address, other_signature, message, 1))\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(legacy_address, signature, message, 1))\n+        # We get an error here, because the verifier believes the proof should be a BIP-322 proof, due to\n+        # the address not being P2PKH, but the proof is a legacy proof\n+        assert_equal(\"ERROR\", self.nodes[0].verifymessage(address, legacy_signature, message, 1))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r318954925",
      "id" : 318954925,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxODk1NDkyNQ==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 50,
      "path" : "test/functional/rpc_signmessage.py",
      "position" : 50,
      "pull_request_review_id" : 281291336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-08-29T08:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/318954925",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> No, this is not the reason. The reason why the script system is used is unrelated to a potential future funds proving tool, and is purely done this way to make future upgrades (e.g. taproot, schnorr, ...) seamless. New address formats and such will work out of the box assuming the underlying node(s) actually understand them.\r\n\r\nOkay, I see. This was not clear at all the me from reading the BIP because the BIP talks about verifying messages based on the \"Bitcoin Script Format\". (Yes, it's kind of clear if you look at the RPC...) But the purpose of the BIP is rather signing and verifying messages with respect to address (and the script format is only a technical tool.) I think this can be made clearer in the BIP.\r\n\r\n> Aside from the fact it is extensible to add another purpose (for the reason stated above), I'm not sure it's overly middle-groundy as it stands. What could be trimmed out to make it less so without burning too many bridges in a potential future expansion to add a POF purpose?\r\n\r\nHm yeah, good question. I think @luke-jr is right and we don't need multiple proofs for simple signatures of messages. And we should think about disallowing proofs that don't require any signatures.\r\n\r\nAlso the terminology is somehow unclear, both in the BIP and in the code. What I mean is that don't understand the difference between a \"proof\" and a \"signature\" (or maybe call it \"message signature\" or \"signed message\" to make clear it's not a signature of a transaction)?\r\n\r\nIf I read the code correctly, the basic idea is \r\n * checking that a provided script matches the address and\r\n * verifying the script but replacing every signature verification operation by a signature verification operation on the provided message instead of the transaction.\r\n\r\nTo be honest, this was only clear to me after reading the code and not at all from the BIP.\r\n\r\nAnother concern that I have is that there are a lot of verification result codes (related to what I said above for ERROR/INVALID). I guess we INCOMPLETE for PSBT? But this should concern signers only. Wouldn't INVALID be enough for a verifier?\r\n\r\nAlso, I see the point of INCONCLUSIVE but this reminds me a lot of certificate warnings, which are a UX mess. What should I as a user when I get an inconclusive signature? (I'm not saying that I have a better idea to implement this.)",
      "created_at" : "2019-08-29T09:05:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-526096522",
      "id" : 526096522,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjA5NjUyMg==",
      "updated_at" : "2019-08-29T09:05:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526096522",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806069"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think it's a problem to have malleable signature in this case, but perhaps this should be bolted down to always say `SIGHASH_ALL`.\r\n\r\nWe do not need the flag, in all honesty, but removing it means special-casing stuff in various places, so it felt simpler to just keep it in there.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-02T04:53:39Z",
      "diff_hunk" : "@@ -1416,6 +1416,20 @@ bool GenericTransactionSignatureChecker<T>::CheckSequence(const CScriptNum& nSeq\n template class GenericTransactionSignatureChecker<CTransaction>;\n template class GenericTransactionSignatureChecker<CMutableTransaction>;\n \n+bool SimpleSignatureChecker::CheckSig(const std::vector<unsigned char>& vchSigIn, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    CPubKey pubkey(vchPubKey);\n+    if (!pubkey.IsValid()) return false;\n+\n+    // Hash type is one byte tacked on to the end of the signature\n+    std::vector<unsigned char> vchSig(vchSigIn);\n+    if (vchSig.empty()) return false;\n+    // int nHashType = vchSig.back();\n+    vchSig.pop_back();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806069",
      "id" : 319806069,
      "in_reply_to_id" : 318941957,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTgwNjA2OQ==",
      "original_commit_id" : "5e6affa7fef44a812b571fc605af99b037b42d41",
      "original_position" : 13,
      "path" : "src/script/interpreter.cpp",
      "position" : 13,
      "pull_request_review_id" : 282400917,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-02T04:53:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806069",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806242"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Limiting was not the intention, really, and I'm not sure there is an attack vector for very large messages since these are passed between users outside of the proofs.",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-02T04:55:11Z",
      "diff_hunk" : "@@ -0,0 +1,98 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/proof.h>\n+\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+\n+namespace proof\n+{\n+\n+Result SignMessage::Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const {\n+    Result rv = Purpose::Prepare(m_scriptpubkey, inputs_out);\n+    if (rv != RESULT_VALID) return rv;\n+    CHashWriter hw(SER_DISK, 0);\n+    std::string s = strMessageMagic + message;\n+    hw << m_scriptpubkey << LimitedString<65536>(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806242",
      "id" : 319806242,
      "in_reply_to_id" : 318945748,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTgwNjI0Mg==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 17,
      "path" : "src/script/proof.cpp",
      "position" : 17,
      "pull_request_review_id" : 282401101,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-02T04:55:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806242",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806528"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it's useful to distinguish between what is considered a proper but invalid BIP-322 proof vs something that is not a proper BIP-322 proof. An error in this case means the proof could not be deserialized. Saying it's invalid means the user will not even know that the proof wasn't checked at all, which would be useful for debugging the reason. (For example, if someone provides a proof from Electrum (IIRC) which uses the legacy mode for new address types, it should error, not say invalid, because those proofs are not properly formatted according to BIP-322.)",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-02T04:57:58Z",
      "diff_hunk" : "@@ -11,32 +11,73 @@ class SignMessagesTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.setup_clean_chain = True\n         self.num_nodes = 1\n-        self.extra_args = [[\"-addresstype=legacy\"]]\n+        self.extra_args = [[\"-addresstype=bech32\"]]\n \n     def skip_test_if_missing_module(self):\n         self.skip_if_no_wallet()\n \n     def run_test(self):\n         message = 'This is just a test message'\n \n-        self.log.info('test signing with priv_key')\n+        self.log.info('test signing with priv_key with bech32')\n+        priv_key = 'cVbpmtsSXkBJhSZakwBSUY7jxhUgXZeT4hCAGyKixccRZwMG4jrf'\n+        address = 'bcrt1qf2yvxk355rc6pqgprrn7q4d3lctr22ta3ne08w'\n+        signature = self.nodes[0].signmessagewithprivkey(priv_key, message, 'bech32')\n+        assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n+\n+        self.log.info('test legacy key signing')\n         priv_key = 'cUeKHd5orzT3mz8P9pxyREHfsWtVfgsfDjiZZBcjUBAaGk1BTj7N'\n         address = 'mpLQjfK79b7CCV4VMJWEWAj5Mpx8Up5zxB'\n         expected_signature = 'INbVnW4e6PeRmsv2Qgu8NuopvrVjkcxob+sX8OcZG0SALhWybUjzMLPdAsXI46YZGb0KQTRii+wWIQzRpG/U+S0='\n         signature = self.nodes[0].signmessagewithprivkey(priv_key, message)\n         assert_equal(expected_signature, signature)\n         assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n \n         self.log.info('test signing with an address with wallet')\n         address = self.nodes[0].getnewaddress()\n         signature = self.nodes[0].signmessage(address, message)\n         assert self.nodes[0].verifymessage(address, signature, message)\n+        assert_equal(\"VALID\", self.nodes[0].verifymessage(address, signature, message, 1))\n \n         self.log.info('test verifying with another address should not work')\n         other_address = self.nodes[0].getnewaddress()\n+        legacy_address = self.nodes[0].getnewaddress(address_type='legacy')\n+        other_signature = self.nodes[0].signmessage(other_address, message)\n+        legacy_signature = self.nodes[0].signmessage(legacy_address, message)\n+        assert not self.nodes[0].verifymessage(other_address, signature, message)\n+        assert not self.nodes[0].verifymessage(address, other_signature, message)\n+        assert not self.nodes[0].verifymessage(legacy_address, signature, message)\n+        assert not self.nodes[0].verifymessage(address, legacy_signature, message)\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(other_address, signature, message, 1))\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(address, other_signature, message, 1))\n+        assert_equal(\"INVALID\", self.nodes[0].verifymessage(legacy_address, signature, message, 1))\n+        # We get an error here, because the verifier believes the proof should be a BIP-322 proof, due to\n+        # the address not being P2PKH, but the proof is a legacy proof\n+        assert_equal(\"ERROR\", self.nodes[0].verifymessage(address, legacy_signature, message, 1))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r319806528",
      "id" : 319806528,
      "in_reply_to_id" : 318954925,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTgwNjUyOA==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 50,
      "path" : "test/functional/rpc_signmessage.py",
      "position" : 50,
      "pull_request_review_id" : 282401484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-02T04:57:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319806528",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@real-or-random Thanks a lot for all your feedback. Sorry it took some days to get back to you.\r\n\r\nWould you mind opening a PR to https://github.com/bitcoin/bips to make the BIP clearer?\r\n\r\nEdit: to answer your question, if you get an inconclusive proof from someone, it means your node is probably old. If it isn't old, the prover is probably using broken software to generate said proof. This feature is here to deal with the case where new consensus rules were activated (e.g. Segwit Script Version 1). Old nodes would accept those in blocks (not INVALID) but would not be able to check them beyond that (thus INCONCLUSIVE).",
      "created_at" : "2019-09-02T04:59:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-527001787",
      "id" : 527001787,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzAwMTc4Nw==",
      "updated_at" : "2019-09-02T07:13:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527001787",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "node_id" : "MDQ6VXNlcjI1MDIyNA==",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "A good idea someone had: refuse to validate a signed message if the key backing it has any outstanding UTXOs. This does need some care to ensure people can validate old signed messages, but hopefully that's not a fatal issue.",
      "created_at" : "2019-09-04T03:11:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#issuecomment-527720750",
      "id" : 527720750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16440",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzcyMDc1MA==",
      "updated_at" : "2019-09-04T03:11:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527720750",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321962813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321962813"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Could use `enum class`?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T09:36:54Z",
      "diff_hunk" : "@@ -0,0 +1,266 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_PROOF_H\n+#define BITCOIN_SCRIPT_PROOF_H\n+\n+#include <script/bitcoinconsensus.h> // Block script flags\n+#include <script/interpreter.h>      // SimpleSignatureChecker\n+#include <script/standard.h>         // CTxDestination\n+#include <script/sign.h>             // ProduceSignature, SimpleSignatureCreator\n+#include <serialize.h>\n+#include <outputtype.h>              // GetDestinationForKey\n+#include <policy/policy.h>           // for STANDARD_SCRIPT_VERIFY_FLAGS\n+#include <hash.h>                    // CHashWriter\n+\n+namespace proof {\n+\n+class dest_unavailable_error : public std::runtime_error { public: explicit dest_unavailable_error(const std::string& str = \"Destination is not available\") : std::runtime_error(str) {} };\n+class privkey_unavailable_error : public std::runtime_error { public: explicit privkey_unavailable_error(const std::string& str = \"Private key is not available\") : std::runtime_error(str) {} };\n+class signing_error : public std::runtime_error { public: explicit signing_error(const std::string& str = \"Sign failed\") : std::runtime_error(str) {} };\n+class serialization_error : public std::runtime_error { public: explicit serialization_error(const std::string& str = \"Serialization error\") : std::runtime_error(str) {} };\n+\n+/**\n+ * Result codes ordered numerically by severity, so that A is reported, if A <= B and A and B are\n+ * two results for a verification attempt.\n+ */\n+enum Result {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321962813",
      "id" : 321962813,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MjgxMw==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 28,
      "path" : "src/script/proof.h",
      "position" : 28,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321962813",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963433"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963433"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: `r < -4 || r > 0` is known to be `false` at compile-time and the `\"???\"` path is thus unreachable. Perhaps use `switch` instead?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T09:59:58Z",
      "diff_hunk" : "@@ -0,0 +1,266 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_PROOF_H\n+#define BITCOIN_SCRIPT_PROOF_H\n+\n+#include <script/bitcoinconsensus.h> // Block script flags\n+#include <script/interpreter.h>      // SimpleSignatureChecker\n+#include <script/standard.h>         // CTxDestination\n+#include <script/sign.h>             // ProduceSignature, SimpleSignatureCreator\n+#include <serialize.h>\n+#include <outputtype.h>              // GetDestinationForKey\n+#include <policy/policy.h>           // for STANDARD_SCRIPT_VERIFY_FLAGS\n+#include <hash.h>                    // CHashWriter\n+\n+namespace proof {\n+\n+class dest_unavailable_error : public std::runtime_error { public: explicit dest_unavailable_error(const std::string& str = \"Destination is not available\") : std::runtime_error(str) {} };\n+class privkey_unavailable_error : public std::runtime_error { public: explicit privkey_unavailable_error(const std::string& str = \"Private key is not available\") : std::runtime_error(str) {} };\n+class signing_error : public std::runtime_error { public: explicit signing_error(const std::string& str = \"Sign failed\") : std::runtime_error(str) {} };\n+class serialization_error : public std::runtime_error { public: explicit serialization_error(const std::string& str = \"Serialization error\") : std::runtime_error(str) {} };\n+\n+/**\n+ * Result codes ordered numerically by severity, so that A is reported, if A <= B and A and B are\n+ * two results for a verification attempt.\n+ */\n+enum Result {\n+    RESULT_VALID = 0,           //!< All proofs were deemed valid.\n+    RESULT_INCONCLUSIVE = -1,   //!< One or several of the given proofs used unknown opcodes or the scriptPubKey had an unknown witness version, perhaps due to the verifying node being outdated.\n+    RESULT_INCOMPLETE = -2,     //!< One or several of the given challenges had an empty proof. The prover may need some other entity to complete the proof.\n+    RESULT_INVALID = -3,        //!< One or more of the given proofs were invalid\n+    RESULT_ERROR = -4,          //!< An error was encountered\n+};\n+\n+inline std::string ResultString(const Result r) {\n+    static const char *strings[] = {\"ERROR\", \"INVALID\", \"INCOMPLETE\", \"INCONCLUSIVE\", \"VALID\"};\n+    return r < -4 || r > 0 ? \"???\" : strings[r + 4];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963433",
      "id" : 321963433,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzQzMw==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 38,
      "path" : "src/script/proof.h",
      "position" : 38,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963433",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963486"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`challenge` and `message` not used?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T10:01:50Z",
      "diff_hunk" : "@@ -0,0 +1,266 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_PROOF_H\n+#define BITCOIN_SCRIPT_PROOF_H\n+\n+#include <script/bitcoinconsensus.h> // Block script flags\n+#include <script/interpreter.h>      // SimpleSignatureChecker\n+#include <script/standard.h>         // CTxDestination\n+#include <script/sign.h>             // ProduceSignature, SimpleSignatureCreator\n+#include <serialize.h>\n+#include <outputtype.h>              // GetDestinationForKey\n+#include <policy/policy.h>           // for STANDARD_SCRIPT_VERIFY_FLAGS\n+#include <hash.h>                    // CHashWriter\n+\n+namespace proof {\n+\n+class dest_unavailable_error : public std::runtime_error { public: explicit dest_unavailable_error(const std::string& str = \"Destination is not available\") : std::runtime_error(str) {} };\n+class privkey_unavailable_error : public std::runtime_error { public: explicit privkey_unavailable_error(const std::string& str = \"Private key is not available\") : std::runtime_error(str) {} };\n+class signing_error : public std::runtime_error { public: explicit signing_error(const std::string& str = \"Sign failed\") : std::runtime_error(str) {} };\n+class serialization_error : public std::runtime_error { public: explicit serialization_error(const std::string& str = \"Serialization error\") : std::runtime_error(str) {} };\n+\n+/**\n+ * Result codes ordered numerically by severity, so that A is reported, if A <= B and A and B are\n+ * two results for a verification attempt.\n+ */\n+enum Result {\n+    RESULT_VALID = 0,           //!< All proofs were deemed valid.\n+    RESULT_INCONCLUSIVE = -1,   //!< One or several of the given proofs used unknown opcodes or the scriptPubKey had an unknown witness version, perhaps due to the verifying node being outdated.\n+    RESULT_INCOMPLETE = -2,     //!< One or several of the given challenges had an empty proof. The prover may need some other entity to complete the proof.\n+    RESULT_INVALID = -3,        //!< One or more of the given proofs were invalid\n+    RESULT_ERROR = -4,          //!< An error was encountered\n+};\n+\n+inline std::string ResultString(const Result r) {\n+    static const char *strings[] = {\"ERROR\", \"INVALID\", \"INCOMPLETE\", \"INCONCLUSIVE\", \"VALID\"};\n+    return r < -4 || r > 0 ? \"???\" : strings[r + 4];\n+}\n+\n+inline Result ResultFromBool(bool success) {\n+    return success ? RESULT_VALID : RESULT_INVALID;\n+}\n+\n+static constexpr uint32_t BIP322_FORMAT_VERSION = 1;\n+\n+struct Header {\n+    uint32_t m_version;     //!< Format version\n+    uint8_t m_entries;      //!< Number of proof entries\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        m_version = BIP322_FORMAT_VERSION;\n+        READWRITE(m_version);\n+        if (m_version > BIP322_FORMAT_VERSION) throw serialization_error(\"Unknown BIP322 proof format; you may need to update your node\");\n+        if (m_version < BIP322_FORMAT_VERSION) throw serialization_error(\"Outdated BIP322 proof format; ask prover to re-sign using newer software\");\n+        READWRITE(m_entries);\n+    }\n+};\n+\n+struct SignatureProof {\n+    CScript m_scriptsig; //!< ScriptSig data\n+    CScriptWitness m_witness;   //!< Witness\n+\n+    explicit SignatureProof(const SignatureData& sigdata = SignatureData()) {\n+        m_scriptsig = sigdata.scriptSig;\n+        m_witness = sigdata.scriptWitness;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptsig);\n+        READWRITE(m_witness.stack);\n+    }\n+};\n+\n+struct Purpose {\n+    template<typename T>\n+    Result Prepare(const T& input, std::set<T>& inputs_out) const {\n+        if (inputs_out.count(input)) return RESULT_ERROR;\n+        inputs_out.insert(input);\n+        return RESULT_VALID;\n+    }\n+};\n+\n+/**\n+ * Purpose: SignMessage\n+ *\n+ * Generate a sighash based on a scriptPubKey and a message. Emits VALID on success.\n+ */\n+struct SignMessage: Purpose {\n+    CScript m_scriptpubkey;\n+\n+    explicit SignMessage(const CScript& scriptpubkey = CScript()) : m_scriptpubkey(scriptpubkey) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptpubkey);\n+    }\n+\n+    Result Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const;\n+\n+    inline std::set<CScript> InputsSet() { return std::set<CScript>(); }\n+};\n+\n+struct Proof: public Header {\n+    std::vector<SignatureProof> m_items;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        Header::SerializationOp(s, ser_action);\n+        m_items.resize(m_entries);\n+        for (auto& e : m_items) {\n+            READWRITE(e);\n+        }\n+    }\n+};\n+\n+template<typename T>\n+struct BaseWorkSpace {\n+    std::map<CTxDestination, CKey> privkeys;\n+    std::vector<T> m_challenge;\n+    Proof m_proof;\n+\n+    virtual void GenerateSingleProof(const T& challenge, SigningProvider* sp, const uint256& sighash, const CScript& scriptPubKey, const std::string& message) = 0;\n+    virtual Result VerifySingleProof(unsigned int flags, const T& challenge, const SignatureProof& proof, const std::string& message, const uint256& sighash, const CScript& scriptPubKey) = 0;\n+\n+    void Prove(const std::string& message, SigningProvider* signingProvider = nullptr) {\n+        m_proof.m_items.clear();\n+        m_proof.m_version = BIP322_FORMAT_VERSION;\n+        m_proof.m_entries = m_challenge.size();\n+        if (m_challenge.size() == 0) return;\n+        auto inputs = m_challenge.back().InputsSet();\n+        uint256 sighash;\n+        CScript scriptPubKey;\n+        for (auto& c : m_challenge) {\n+            auto r = c.Prepare(m_challenge, message, inputs, sighash, scriptPubKey);\n+            if (r != RESULT_VALID) {\n+                throw std::runtime_error(\"Prepare call failed (error code \" + std::to_string(r) + \")\");\n+            }\n+            CTxDestination destination;\n+            if (!ExtractDestination(scriptPubKey, destination)) {\n+                throw dest_unavailable_error();\n+            }\n+            CKey secret;\n+            if (privkeys.count(destination)) {\n+                secret = privkeys.at(destination);\n+            } else if (signingProvider) {\n+                auto keyid = GetKeyForDestination(*signingProvider, destination);\n+                if (keyid.IsNull()) {\n+                    throw privkey_unavailable_error(\"ScriptPubKey does not refer to a key (note: multisig is not yet supported)\");\n+                }\n+                if (!signingProvider->GetKey(keyid, secret)) {\n+                    throw privkey_unavailable_error(\"Private key for scriptPubKey is not known\");\n+                }\n+            } else {\n+                throw privkey_unavailable_error(\"Failed to obtain private key for destination\");\n+            }\n+            FillableSigningProvider sp;\n+            sp.AddKey(secret);\n+            GenerateSingleProof(c, &sp, sighash, scriptPubKey, message);\n+        }\n+    }\n+\n+    Result Verify(const std::string& message) {\n+        size_t proofs = m_proof.m_items.size();\n+        size_t challenges = m_challenge.size();\n+        if (challenges == 0) {\n+            throw std::runtime_error(\"Nothing to verify\");\n+        }\n+        if (proofs != challenges) {\n+            // TODO: fill out vector with empty proofs if too few and get incomplete result? What to do about too many?\n+            throw std::runtime_error(proofs < challenges ? \"Proofs missing\" : \"Too many proofs\");\n+        }\n+\n+        auto inputs = m_challenge.back().InputsSet();\n+        Result aggres = RESULT_VALID;\n+        for (size_t i = 0; i < proofs; ++i) {\n+            auto& proof = m_proof.m_items.at(i);\n+            if (proof.m_scriptsig.size() == 0 && proof.m_witness.stack.size() == 0) {\n+                if (aggres == RESULT_VALID) aggres = RESULT_INCOMPLETE;\n+                continue;\n+            }\n+            auto& challenge = m_challenge.at(i);\n+            uint256 sighash;\n+            CScript scriptPubKey;\n+            Result res = challenge.Prepare(m_challenge, message, inputs, sighash, scriptPubKey);\n+            if (res != RESULT_VALID) return res;\n+            // verify using consensus rules first\n+            res = VerifySingleProof(bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL, challenge, proof, message, sighash, scriptPubKey);\n+            if (res == RESULT_ERROR || res == RESULT_INVALID) return res;\n+            if (res == RESULT_VALID) {\n+                res = VerifySingleProof(STANDARD_SCRIPT_VERIFY_FLAGS, challenge, proof, message, sighash, scriptPubKey);\n+                if (res == RESULT_INVALID) res = RESULT_INCONCLUSIVE;\n+            }\n+            if (res < aggres) {\n+                aggres = res;\n+            }\n+        }\n+        return aggres;\n+    }\n+};\n+\n+template<typename T> struct Workspace: public BaseWorkSpace<T> {};\n+\n+template<>\n+struct Workspace<SignMessage>: public BaseWorkSpace<SignMessage> {\n+    void AppendDestinationChallenge(const CTxDestination& destination) {\n+        auto a = GetScriptForDestination(destination);\n+        m_challenge.emplace_back(a);\n+    }\n+    void AppendPrivKeyChallenge(const CKey& key, OutputType address_type = OutputType::BECH32) {\n+        auto d = GetDestinationForKey(key.GetPubKey(), address_type);\n+        auto a = GetScriptForDestination(d);\n+        privkeys[d] = key;\n+        m_challenge.emplace_back(a);\n+    }\n+    void GenerateSingleProof(const SignMessage& challenge, SigningProvider* sp, const uint256& sighash, const CScript& scriptPubKey, const std::string& message) override {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963486",
      "id" : 321963486,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzQ4Ng==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 226,
      "path" : "src/script/proof.h",
      "position" : 226,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963486",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`challenge` and `message` not used?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T10:02:09Z",
      "diff_hunk" : "@@ -0,0 +1,266 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_PROOF_H\n+#define BITCOIN_SCRIPT_PROOF_H\n+\n+#include <script/bitcoinconsensus.h> // Block script flags\n+#include <script/interpreter.h>      // SimpleSignatureChecker\n+#include <script/standard.h>         // CTxDestination\n+#include <script/sign.h>             // ProduceSignature, SimpleSignatureCreator\n+#include <serialize.h>\n+#include <outputtype.h>              // GetDestinationForKey\n+#include <policy/policy.h>           // for STANDARD_SCRIPT_VERIFY_FLAGS\n+#include <hash.h>                    // CHashWriter\n+\n+namespace proof {\n+\n+class dest_unavailable_error : public std::runtime_error { public: explicit dest_unavailable_error(const std::string& str = \"Destination is not available\") : std::runtime_error(str) {} };\n+class privkey_unavailable_error : public std::runtime_error { public: explicit privkey_unavailable_error(const std::string& str = \"Private key is not available\") : std::runtime_error(str) {} };\n+class signing_error : public std::runtime_error { public: explicit signing_error(const std::string& str = \"Sign failed\") : std::runtime_error(str) {} };\n+class serialization_error : public std::runtime_error { public: explicit serialization_error(const std::string& str = \"Serialization error\") : std::runtime_error(str) {} };\n+\n+/**\n+ * Result codes ordered numerically by severity, so that A is reported, if A <= B and A and B are\n+ * two results for a verification attempt.\n+ */\n+enum Result {\n+    RESULT_VALID = 0,           //!< All proofs were deemed valid.\n+    RESULT_INCONCLUSIVE = -1,   //!< One or several of the given proofs used unknown opcodes or the scriptPubKey had an unknown witness version, perhaps due to the verifying node being outdated.\n+    RESULT_INCOMPLETE = -2,     //!< One or several of the given challenges had an empty proof. The prover may need some other entity to complete the proof.\n+    RESULT_INVALID = -3,        //!< One or more of the given proofs were invalid\n+    RESULT_ERROR = -4,          //!< An error was encountered\n+};\n+\n+inline std::string ResultString(const Result r) {\n+    static const char *strings[] = {\"ERROR\", \"INVALID\", \"INCOMPLETE\", \"INCONCLUSIVE\", \"VALID\"};\n+    return r < -4 || r > 0 ? \"???\" : strings[r + 4];\n+}\n+\n+inline Result ResultFromBool(bool success) {\n+    return success ? RESULT_VALID : RESULT_INVALID;\n+}\n+\n+static constexpr uint32_t BIP322_FORMAT_VERSION = 1;\n+\n+struct Header {\n+    uint32_t m_version;     //!< Format version\n+    uint8_t m_entries;      //!< Number of proof entries\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        m_version = BIP322_FORMAT_VERSION;\n+        READWRITE(m_version);\n+        if (m_version > BIP322_FORMAT_VERSION) throw serialization_error(\"Unknown BIP322 proof format; you may need to update your node\");\n+        if (m_version < BIP322_FORMAT_VERSION) throw serialization_error(\"Outdated BIP322 proof format; ask prover to re-sign using newer software\");\n+        READWRITE(m_entries);\n+    }\n+};\n+\n+struct SignatureProof {\n+    CScript m_scriptsig; //!< ScriptSig data\n+    CScriptWitness m_witness;   //!< Witness\n+\n+    explicit SignatureProof(const SignatureData& sigdata = SignatureData()) {\n+        m_scriptsig = sigdata.scriptSig;\n+        m_witness = sigdata.scriptWitness;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptsig);\n+        READWRITE(m_witness.stack);\n+    }\n+};\n+\n+struct Purpose {\n+    template<typename T>\n+    Result Prepare(const T& input, std::set<T>& inputs_out) const {\n+        if (inputs_out.count(input)) return RESULT_ERROR;\n+        inputs_out.insert(input);\n+        return RESULT_VALID;\n+    }\n+};\n+\n+/**\n+ * Purpose: SignMessage\n+ *\n+ * Generate a sighash based on a scriptPubKey and a message. Emits VALID on success.\n+ */\n+struct SignMessage: Purpose {\n+    CScript m_scriptpubkey;\n+\n+    explicit SignMessage(const CScript& scriptpubkey = CScript()) : m_scriptpubkey(scriptpubkey) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptpubkey);\n+    }\n+\n+    Result Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const;\n+\n+    inline std::set<CScript> InputsSet() { return std::set<CScript>(); }\n+};\n+\n+struct Proof: public Header {\n+    std::vector<SignatureProof> m_items;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        Header::SerializationOp(s, ser_action);\n+        m_items.resize(m_entries);\n+        for (auto& e : m_items) {\n+            READWRITE(e);\n+        }\n+    }\n+};\n+\n+template<typename T>\n+struct BaseWorkSpace {\n+    std::map<CTxDestination, CKey> privkeys;\n+    std::vector<T> m_challenge;\n+    Proof m_proof;\n+\n+    virtual void GenerateSingleProof(const T& challenge, SigningProvider* sp, const uint256& sighash, const CScript& scriptPubKey, const std::string& message) = 0;\n+    virtual Result VerifySingleProof(unsigned int flags, const T& challenge, const SignatureProof& proof, const std::string& message, const uint256& sighash, const CScript& scriptPubKey) = 0;\n+\n+    void Prove(const std::string& message, SigningProvider* signingProvider = nullptr) {\n+        m_proof.m_items.clear();\n+        m_proof.m_version = BIP322_FORMAT_VERSION;\n+        m_proof.m_entries = m_challenge.size();\n+        if (m_challenge.size() == 0) return;\n+        auto inputs = m_challenge.back().InputsSet();\n+        uint256 sighash;\n+        CScript scriptPubKey;\n+        for (auto& c : m_challenge) {\n+            auto r = c.Prepare(m_challenge, message, inputs, sighash, scriptPubKey);\n+            if (r != RESULT_VALID) {\n+                throw std::runtime_error(\"Prepare call failed (error code \" + std::to_string(r) + \")\");\n+            }\n+            CTxDestination destination;\n+            if (!ExtractDestination(scriptPubKey, destination)) {\n+                throw dest_unavailable_error();\n+            }\n+            CKey secret;\n+            if (privkeys.count(destination)) {\n+                secret = privkeys.at(destination);\n+            } else if (signingProvider) {\n+                auto keyid = GetKeyForDestination(*signingProvider, destination);\n+                if (keyid.IsNull()) {\n+                    throw privkey_unavailable_error(\"ScriptPubKey does not refer to a key (note: multisig is not yet supported)\");\n+                }\n+                if (!signingProvider->GetKey(keyid, secret)) {\n+                    throw privkey_unavailable_error(\"Private key for scriptPubKey is not known\");\n+                }\n+            } else {\n+                throw privkey_unavailable_error(\"Failed to obtain private key for destination\");\n+            }\n+            FillableSigningProvider sp;\n+            sp.AddKey(secret);\n+            GenerateSingleProof(c, &sp, sighash, scriptPubKey, message);\n+        }\n+    }\n+\n+    Result Verify(const std::string& message) {\n+        size_t proofs = m_proof.m_items.size();\n+        size_t challenges = m_challenge.size();\n+        if (challenges == 0) {\n+            throw std::runtime_error(\"Nothing to verify\");\n+        }\n+        if (proofs != challenges) {\n+            // TODO: fill out vector with empty proofs if too few and get incomplete result? What to do about too many?\n+            throw std::runtime_error(proofs < challenges ? \"Proofs missing\" : \"Too many proofs\");\n+        }\n+\n+        auto inputs = m_challenge.back().InputsSet();\n+        Result aggres = RESULT_VALID;\n+        for (size_t i = 0; i < proofs; ++i) {\n+            auto& proof = m_proof.m_items.at(i);\n+            if (proof.m_scriptsig.size() == 0 && proof.m_witness.stack.size() == 0) {\n+                if (aggres == RESULT_VALID) aggres = RESULT_INCOMPLETE;\n+                continue;\n+            }\n+            auto& challenge = m_challenge.at(i);\n+            uint256 sighash;\n+            CScript scriptPubKey;\n+            Result res = challenge.Prepare(m_challenge, message, inputs, sighash, scriptPubKey);\n+            if (res != RESULT_VALID) return res;\n+            // verify using consensus rules first\n+            res = VerifySingleProof(bitcoinconsensus_SCRIPT_FLAGS_VERIFY_ALL, challenge, proof, message, sighash, scriptPubKey);\n+            if (res == RESULT_ERROR || res == RESULT_INVALID) return res;\n+            if (res == RESULT_VALID) {\n+                res = VerifySingleProof(STANDARD_SCRIPT_VERIFY_FLAGS, challenge, proof, message, sighash, scriptPubKey);\n+                if (res == RESULT_INVALID) res = RESULT_INCONCLUSIVE;\n+            }\n+            if (res < aggres) {\n+                aggres = res;\n+            }\n+        }\n+        return aggres;\n+    }\n+};\n+\n+template<typename T> struct Workspace: public BaseWorkSpace<T> {};\n+\n+template<>\n+struct Workspace<SignMessage>: public BaseWorkSpace<SignMessage> {\n+    void AppendDestinationChallenge(const CTxDestination& destination) {\n+        auto a = GetScriptForDestination(destination);\n+        m_challenge.emplace_back(a);\n+    }\n+    void AppendPrivKeyChallenge(const CKey& key, OutputType address_type = OutputType::BECH32) {\n+        auto d = GetDestinationForKey(key.GetPubKey(), address_type);\n+        auto a = GetScriptForDestination(d);\n+        privkeys[d] = key;\n+        m_challenge.emplace_back(a);\n+    }\n+    void GenerateSingleProof(const SignMessage& challenge, SigningProvider* sp, const uint256& sighash, const CScript& scriptPubKey, const std::string& message) override {\n+        SimpleSignatureCreator sc(sighash);\n+        SignatureData sigdata;\n+        if (!ProduceSignature(*sp, sc, scriptPubKey, sigdata)) {\n+            throw signing_error(\"Failed to produce a signature\");\n+        }\n+        m_proof.m_items.emplace_back(sigdata);\n+    }\n+    Result VerifySingleProof(unsigned int flags, const SignMessage& challenge, const SignatureProof& proof, const std::string& message, const uint256& sighash, const CScript& scriptPubKey) override {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963492",
      "id" : 321963492,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzQ5Mg==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 234,
      "path" : "src/script/proof.h",
      "position" : 234,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963492",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`entries` not used?",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T10:03:18Z",
      "diff_hunk" : "@@ -0,0 +1,98 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/proof.h>\n+\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+\n+namespace proof\n+{\n+\n+Result SignMessage::Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963518",
      "id" : 321963518,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzUxOA==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 12,
      "path" : "src/script/proof.cpp",
      "position" : 12,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963518",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963578"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963578"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is `m_challenge.size() <= 255` guaranteed here (`m_entries` is `uint8_t`)? If so, perhaps `assert(...)` that to make the tacit assumption explicit? :-)",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T10:06:08Z",
      "diff_hunk" : "@@ -0,0 +1,266 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_PROOF_H\n+#define BITCOIN_SCRIPT_PROOF_H\n+\n+#include <script/bitcoinconsensus.h> // Block script flags\n+#include <script/interpreter.h>      // SimpleSignatureChecker\n+#include <script/standard.h>         // CTxDestination\n+#include <script/sign.h>             // ProduceSignature, SimpleSignatureCreator\n+#include <serialize.h>\n+#include <outputtype.h>              // GetDestinationForKey\n+#include <policy/policy.h>           // for STANDARD_SCRIPT_VERIFY_FLAGS\n+#include <hash.h>                    // CHashWriter\n+\n+namespace proof {\n+\n+class dest_unavailable_error : public std::runtime_error { public: explicit dest_unavailable_error(const std::string& str = \"Destination is not available\") : std::runtime_error(str) {} };\n+class privkey_unavailable_error : public std::runtime_error { public: explicit privkey_unavailable_error(const std::string& str = \"Private key is not available\") : std::runtime_error(str) {} };\n+class signing_error : public std::runtime_error { public: explicit signing_error(const std::string& str = \"Sign failed\") : std::runtime_error(str) {} };\n+class serialization_error : public std::runtime_error { public: explicit serialization_error(const std::string& str = \"Serialization error\") : std::runtime_error(str) {} };\n+\n+/**\n+ * Result codes ordered numerically by severity, so that A is reported, if A <= B and A and B are\n+ * two results for a verification attempt.\n+ */\n+enum Result {\n+    RESULT_VALID = 0,           //!< All proofs were deemed valid.\n+    RESULT_INCONCLUSIVE = -1,   //!< One or several of the given proofs used unknown opcodes or the scriptPubKey had an unknown witness version, perhaps due to the verifying node being outdated.\n+    RESULT_INCOMPLETE = -2,     //!< One or several of the given challenges had an empty proof. The prover may need some other entity to complete the proof.\n+    RESULT_INVALID = -3,        //!< One or more of the given proofs were invalid\n+    RESULT_ERROR = -4,          //!< An error was encountered\n+};\n+\n+inline std::string ResultString(const Result r) {\n+    static const char *strings[] = {\"ERROR\", \"INVALID\", \"INCOMPLETE\", \"INCONCLUSIVE\", \"VALID\"};\n+    return r < -4 || r > 0 ? \"???\" : strings[r + 4];\n+}\n+\n+inline Result ResultFromBool(bool success) {\n+    return success ? RESULT_VALID : RESULT_INVALID;\n+}\n+\n+static constexpr uint32_t BIP322_FORMAT_VERSION = 1;\n+\n+struct Header {\n+    uint32_t m_version;     //!< Format version\n+    uint8_t m_entries;      //!< Number of proof entries\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        m_version = BIP322_FORMAT_VERSION;\n+        READWRITE(m_version);\n+        if (m_version > BIP322_FORMAT_VERSION) throw serialization_error(\"Unknown BIP322 proof format; you may need to update your node\");\n+        if (m_version < BIP322_FORMAT_VERSION) throw serialization_error(\"Outdated BIP322 proof format; ask prover to re-sign using newer software\");\n+        READWRITE(m_entries);\n+    }\n+};\n+\n+struct SignatureProof {\n+    CScript m_scriptsig; //!< ScriptSig data\n+    CScriptWitness m_witness;   //!< Witness\n+\n+    explicit SignatureProof(const SignatureData& sigdata = SignatureData()) {\n+        m_scriptsig = sigdata.scriptSig;\n+        m_witness = sigdata.scriptWitness;\n+    }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptsig);\n+        READWRITE(m_witness.stack);\n+    }\n+};\n+\n+struct Purpose {\n+    template<typename T>\n+    Result Prepare(const T& input, std::set<T>& inputs_out) const {\n+        if (inputs_out.count(input)) return RESULT_ERROR;\n+        inputs_out.insert(input);\n+        return RESULT_VALID;\n+    }\n+};\n+\n+/**\n+ * Purpose: SignMessage\n+ *\n+ * Generate a sighash based on a scriptPubKey and a message. Emits VALID on success.\n+ */\n+struct SignMessage: Purpose {\n+    CScript m_scriptpubkey;\n+\n+    explicit SignMessage(const CScript& scriptpubkey = CScript()) : m_scriptpubkey(scriptpubkey) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(m_scriptpubkey);\n+    }\n+\n+    Result Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const;\n+\n+    inline std::set<CScript> InputsSet() { return std::set<CScript>(); }\n+};\n+\n+struct Proof: public Header {\n+    std::vector<SignatureProof> m_items;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        Header::SerializationOp(s, ser_action);\n+        m_items.resize(m_entries);\n+        for (auto& e : m_items) {\n+            READWRITE(e);\n+        }\n+    }\n+};\n+\n+template<typename T>\n+struct BaseWorkSpace {\n+    std::map<CTxDestination, CKey> privkeys;\n+    std::vector<T> m_challenge;\n+    Proof m_proof;\n+\n+    virtual void GenerateSingleProof(const T& challenge, SigningProvider* sp, const uint256& sighash, const CScript& scriptPubKey, const std::string& message) = 0;\n+    virtual Result VerifySingleProof(unsigned int flags, const T& challenge, const SignatureProof& proof, const std::string& message, const uint256& sighash, const CScript& scriptPubKey) = 0;\n+\n+    void Prove(const std::string& message, SigningProvider* signingProvider = nullptr) {\n+        m_proof.m_items.clear();\n+        m_proof.m_version = BIP322_FORMAT_VERSION;\n+        m_proof.m_entries = m_challenge.size();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963578",
      "id" : 321963578,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzU3OA==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 139,
      "path" : "src/script/proof.h",
      "position" : 139,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963578",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963617"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Don't forget to terminate namespace using `// namespace proof` :-)",
      "commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "created_at" : "2019-09-07T10:07:58Z",
      "diff_hunk" : "@@ -0,0 +1,98 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <script/proof.h>\n+\n+const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+\n+namespace proof\n+{\n+\n+Result SignMessage::Prepare(const std::vector<SignMessage>& entries, const std::string& message, std::set<CScript>& inputs_out, uint256& sighash_out, CScript& spk_out) const {\n+    Result rv = Purpose::Prepare(m_scriptpubkey, inputs_out);\n+    if (rv != RESULT_VALID) return rv;\n+    CHashWriter hw(SER_DISK, 0);\n+    std::string s = strMessageMagic + message;\n+    hw << m_scriptpubkey << LimitedString<65536>(s);\n+    sighash_out = hw.GetHash();\n+    spk_out = m_scriptpubkey;\n+    return RESULT_VALID;\n+}\n+\n+void SignMessageWithSigningProvider(SigningProvider* sp, const std::string& message, const CTxDestination& destination, std::vector<uint8_t>& signature_out)\n+{\n+    signature_out.clear();\n+\n+    // if this is a P2PKH, use the legacy approach\n+    const PKHash *pkhash = boost::get<PKHash>(&destination);\n+    if (pkhash) {\n+        CKey key;\n+        if (!sp->GetKey(CKeyID(*pkhash), key)) {\n+            throw privkey_unavailable_error();\n+        }\n+\n+        CHashWriter ss(SER_GETHASH, 0);\n+        ss << strMessageMagic << message;\n+\n+        if (!key.SignCompact(ss.GetHash(), signature_out)) {\n+            throw signing_error();\n+        }\n+    } else {\n+        SignMessageWorkspace p;\n+\n+        p.AppendDestinationChallenge(destination);\n+\n+        p.Prove(message, sp);\n+\n+        CVectorWriter w(SER_DISK, PROTOCOL_VERSION, signature_out, 0);\n+        w << p.m_proof;\n+    }\n+}\n+\n+void SignMessageWithPrivateKey(CKey& key, OutputType address_type, const std::string& message, std::vector<uint8_t>& signature_out)\n+{\n+    if (address_type == OutputType::LEGACY) {\n+        CHashWriter ss(SER_GETHASH, 0);\n+        ss << strMessageMagic << message;\n+\n+        if (!key.SignCompact(ss.GetHash(), signature_out)) {\n+            throw signing_error();\n+        }\n+    } else {\n+        SignMessageWorkspace p;\n+\n+        p.AppendPrivKeyChallenge(key, address_type);\n+\n+        p.Prove(message);\n+\n+        CVectorWriter w(SER_DISK, PROTOCOL_VERSION, signature_out, 0);\n+        w << p.m_proof;\n+    }\n+}\n+\n+Result VerifySignature(const std::string& message, const CTxDestination& destination, const std::vector<uint8_t>& signature)\n+{\n+    // if this is a P2PKH, use the legacy approach\n+    const PKHash* pkhash = boost::get<PKHash>(&destination);\n+    if (pkhash) {\n+        CHashWriter ss(SER_GETHASH, 0);\n+        ss << strMessageMagic << message;\n+        CPubKey pubkey;\n+        return ResultFromBool(pubkey.RecoverCompact(ss.GetHash(), signature) && pubkey.GetID() == *pkhash);\n+    }\n+\n+    SignMessageWorkspace p;\n+\n+    p.AppendDestinationChallenge(destination);\n+\n+    CDataStream stream(signature, SER_DISK, PROTOCOL_VERSION);\n+    try {\n+        stream >> p.m_proof;\n+        return p.Verify(message);\n+    } catch (const std::runtime_error&) {\n+        return Result::RESULT_ERROR;\n+    }\n+}\n+\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16440#discussion_r321963617",
      "id" : 321963617,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2MzYxNw==",
      "original_commit_id" : "942cbd5d830c8f6d2390ea297ff6834a885d21e4",
      "original_position" : 98,
      "path" : "src/script/proof.cpp",
      "position" : 98,
      "pull_request_review_id" : 285164963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16440",
      "updated_at" : "2019-09-07T10:10:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963617",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
