[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16400](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16400.html) ([refactor] Rewrite AcceptToMemoryPoolWorker() using smaller parts by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-07-18T23:28:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-513031077",
      "id" : 513031077,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMzAzMTA3Nw==",
      "updated_at" : "2019-07-31T17:53:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/513031077",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Please rebase so this only contains the single commit for this PR.",
      "created_at" : "2019-07-22T21:34:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-513963835",
      "id" : 513963835,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMzk2MzgzNQ==",
      "updated_at" : "2019-07-22T21:34:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/513963835",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased. Now just one commit + master.",
      "created_at" : "2019-07-23T20:08:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-514364535",
      "id" : 514364535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNDM2NDUzNQ==",
      "updated_at" : "2019-07-23T20:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/514364535",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased after #16471. Also, @sdaftuar noted that I (a) misunderstood the meaning of setConflicts so the description in the comment was wrong in a few ways, and also we were allowing an RBF transaction to get in via the carve-out even when it shouldn't be allowed to (ie when it has more than one mempool ancestor). Sadly, after talking through it it doesn't seem like we'll be able to get away with no extra calls to CalculateMemPoolAncestors, but at least its a bit easier to reason about now (IMO).",
      "created_at" : "2019-07-29T18:36:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516111698",
      "id" : 516111698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjExMTY5OA==",
      "updated_at" : "2019-07-29T18:36:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516111698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308384647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308384647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can we just use `GetMemPoolParents(conflict)` and grab the hashes from there, instead of iterating all the inputs?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T18:53:41Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308384647",
      "id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NDY0Nw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308384647",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308385882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308385882"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Similarly, if you hadn't cleared out setAncestors() a few lines up, I think you could skip having to walk all the inputs again here.  Perhaps save that and then compare setAncestors to the mempool parents of conflictTx?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T18:56:11Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308385882",
      "id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NTg4Mg==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308385882",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308387438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308387438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think a comment would be helpful here to explain exactly what we're doing:\r\n * No need to bump ancestor sizes/limits (since those are only tested on the transaction itself and are unaffected by the presence of conflicting transactions)\r\n * Descendant size / count are bumped by conflict tx size and 1, to account for the removal of that transaction from all the ancestors of the new transaction. Since we require that the new transaction not introduce any new mempool-ancestors (compared with the conflict tx), this is sufficient to enforce our existing package limits.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T18:59:40Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308387438",
      "id" : 308387438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4NzQzOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 54,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308387438",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Another comment would be helpful here, to explain that if we failed to RBF due to the package limit, we'll give it one more try using the carve-out rules.  So we use the same ancestor limits that the carve-out provision requires, but bump the descendant limits to account for the to-be-removed transaction.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T19:01:39Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,\n+                        nLimitDescendantSize + conflict->GetTxSize(), dummy_err_string)) {\n+                    if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388243",
      "id" : 308388243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODI0Mw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 56,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388243",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It looks like you're not clearing setAncestors before this call.  I think that's actually fine, but maybe better practice to clear it out to avoid confusion?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T19:02:07Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }\n+                if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants + 1,\n+                        nLimitDescendantSize + conflict->GetTxSize(), dummy_err_string)) {\n+                    if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n+                            !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 2,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388398",
      "id" : 308388398,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODM5OA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 57,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388398",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This whole section could probably use a clearer comment that lays out the problem we have with evaluating package limits in the presence of RBF transactions, to help future readers of this code.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-29T19:03:30Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308388970",
      "id" : 308388970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODM4ODk3MA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 25,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 267974544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308388970",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308860203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308860203"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, GetMemPoolParents just returns the parents set, which isn't actually filled until the very last step in addUnchecked.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-30T17:57:57Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308860203",
      "id" : 308860203,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2MDIwMw==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268566504,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308860203",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308861464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308861464"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, but doesn't CalculateMemPoolAncestors return early if we hit a limit? I didn't want to start introducing some \"if we return early, X is initialized, but Y is not\" kind of invariants in CalculateMemPoolAncestors. If you think its worth it, though...",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-30T18:00:39Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308861464",
      "id" : 308861464,
      "in_reply_to_id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2MTQ2NA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268568786,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308861464",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308864741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308864741"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh right, never mind.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-30T18:06:18Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (mempool.exists(new_input.prevout.hash)) {\n+                        if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);\n+                        }\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308864741",
      "id" : 308864741,
      "in_reply_to_id" : 308385882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2NDc0MQ==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 53,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268571888,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308864741",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308866818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308866818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The conflict tx is already in the mempool, so shouldnt that work fine?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-30T18:11:02Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r308866818",
      "id" : 308866818,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwODg2NjgxOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 268574451,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/308866818",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rewrote the comment at the top of the new block to now be a Mega Comment (tm). Hopefully its sufficient, though I can break it up and move it to corresponding code if you really want @sdaftuar, I just didn't bother cause its easy to rewrite without.",
      "created_at" : "2019-07-30T18:46:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516545624",
      "id" : 516545624,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjU0NTYyNA==",
      "updated_at" : "2019-07-30T18:46:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516545624",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, though I'd prefer if this was solved for all mempool txs and not only for a special case of lightning txs.",
      "created_at" : "2019-07-30T21:06:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-516595758",
      "id" : 516595758,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNjU5NTc1OA==",
      "updated_at" : "2019-07-30T21:06:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/516595758",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r309431618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309431618"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Oh right, was looking at the wrong line and thought you meant the new entry. Will fix.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-07-31T21:05:25Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // If we are an RBF transaction which conflicts directly with exactly one other transaction (but may\n+                // evict children of said transaction), conservatively accept transactions which are not adding any\n+                // new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case, with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction.\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxIn& input : conflict->GetTx().vin) {\n+                    if (mempool.exists(input.prevout.hash)) {\n+                        conflict_existing_mempool_inputs.insert(input.prevout.hash);\n+                    }\n+                }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r309431618",
      "id" : 309431618,
      "in_reply_to_id" : 308384647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMwOTQzMTYxOA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 45,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 269282594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/309431618",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@MarcoFalke This isn't *completely* targeted only at lightning/carve-out/contract applications, though it obviously ensures that carve-out transactions are a supported use-case. Mostly trying to implement this in the general case is Hard (tm), but this does work for any only-directly-conflicts-with-1-transaction tx.",
      "created_at" : "2019-07-31T21:07:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#issuecomment-517021531",
      "id" : 517021531,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16421",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxNzAyMTUzMQ==",
      "updated_at" : "2019-07-31T21:07:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/517021531",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166682"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166682"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Rather than doing this test after the initial CalculateMemPoolAncestors(), would it make sense to work out if the limits can be relaxed first, and then start calling CalculateMemPoolAncestors? ie\r\n\r\n```c++\r\nint bump_desc = 0;\r\nint bump_desc_size = 0;\r\nif (setConflicts.size() == 1) {\r\n auto conflict = *setIterConflicting.begin();\r\n if (tx_only_uses_unconfirmed_inputs_from_conflicting_tx) {\r\n  bump_desc = 1;\r\n  bump_desc_size = conflict->GetTxSize();\r\n }\r\n}\r\nif (!CalculateMemPoolAncestors(..,nLimitDescendents+bump_desc, nLimitDescendantSize+bump_desc_size,..) {\r\n std::string dummy_err;\r\n if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT || !CalculateMemPoolAncestors(..+bump_desc,..+bump_desc_size)) {\r\n  Invalid();\r\n }\r\n}\r\n```\r\n",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-15T03:53:03Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166682",
      "id" : 314166682,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDE2NjY4Mg==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 9,
      "path" : "src/validation.cpp",
      "position" : 47,
      "pull_request_review_id" : 275251295,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166682",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166985"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I wonder if extensive comments like this wouldn't be better as an informative BIP? Also it's probably a lost cause, but wrapping the comments at 80 columns or less rather than ~120 would be nice :)",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-15T03:55:28Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r314166985",
      "id" : 314166985,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNDE2Njk4NQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 26,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 275251686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/314166985",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315229807"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315229807"
         }
      },
      "author_association" : "MEMBER",
      "body" : "too many commas :) `s/very realistic, either/very realistic either/`",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:07:52Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315229807",
      "id" : 315229807,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIyOTgwNw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 30,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315229807",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315235160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315235160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "for readers of the comments, this has (attempted) to be addressed",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:18:12Z",
      "diff_hunk" : "@@ -620,19 +621,58 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315235160",
      "id" : 315235160,
      "in_reply_to_id" : 308388970,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIzNTE2MA==",
      "original_commit_id" : "e8bd0c5ee183977a2e1910e9591ba48124f9582a",
      "original_position" : 25,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315235160",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315237028"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315237028"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> the subset of RBF transactions which we allow despite conflicts\r\n\r\nAren't RBF transactions conflicting by definition?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:21:40Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315237028",
      "id" : 315237028,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTIzNzAyOA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 35,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315237028",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315240852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315240852"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This check appears to be identical to https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L733\r\n\r\nwhich would at least be good to point out, or how it's different, if it's not the same. I could see the other check being relaxed in the future but this kept in place.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:28:58Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case (as the ancestor limits should be the same for both our new\n+                // transaction and any conflicts, though you shouldn't be able to violate these given the\n+                // no-new-unconfirmed-inputs check), with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction (as these are recalculated by assuming the new\n+                // transaction being added is a new dependant, with no removals, of each parents' existing\n+                // dependant set).\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                    conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                        if (pool.exists(new_input.prevout.hash)) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315240852",
      "id" : 315240852,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MDg1Mg==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 61,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315240852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315241877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315241877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "you should probably label the thing you're calling `carve-out` for those not reading git history.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:30:46Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315241877",
      "id" : 315241877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MTg3Nw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 32,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315241877",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315243438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315243438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Having real trouble parsing this last paragraph.\r\n\r\nLots of different things being referenced, \"above\", \"below\", \"corresponding\", unsure exactly what it's referring to.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T14:33:36Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315243438",
      "id" : 315243438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTI0MzQzOA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276583486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315243438",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428075"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, indeed, nice call, done.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T21:52:11Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428075",
      "id" : 315428075,
      "in_reply_to_id" : 314166682,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQyODA3NQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 9,
      "path" : "src/validation.cpp",
      "position" : 47,
      "pull_request_review_id" : 276835021,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428075",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428337"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428337"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "80 chars is....very antiquated. I dunno anyone who is left coding on a 80x60 terminal :p.\r\n\r\nStill, I don't think this deserves a BIP if only cause we hopefully can extend it further in the future.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T21:53:01Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315428337",
      "id" : 315428337,
      "in_reply_to_id" : 314166985,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQyODMzNw==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 26,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276835333,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315428337",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315437310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315437310"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this a bit more readable given the changes made for https://github.com/bitcoin/bitcoin/pull/16421#pullrequestreview-275251295 ?",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-19T22:23:30Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315437310",
      "id" : 315437310,
      "in_reply_to_id" : 315243438,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQzNzMxMA==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 42,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276846287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315437310",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472937"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`setIterConflicting.size()` could theoretically be zero if the conflicting hash from `setConflicts` isn't in the mempool somehow. That shouldn't be possible because we've held a lock on `cs_main` and `pool.cs` since we populated `setConflicts`, so this assertion should be correct.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-20T01:19:31Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472937",
      "id" : 315472937,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ3MjkzNw==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 35,
      "path" : "src/validation.cpp",
      "position" : 38,
      "pull_request_review_id" : 276888919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472937",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472953"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"Contracting\" with a t? :)\r\n",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-20T01:19:37Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            std::set<uint256> conflict_existing_mempool_inputs;\n+            for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+            }\n+\n+            bool meets_rbf_conflict_limit = true;\n+            for (const CTxIn& new_input: tx.vin) {\n+                if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                    if (pool.exists(new_input.prevout.hash)) {\n+                        meets_rbf_conflict_limit = false;\n+                    }\n+                }\n+            }\n+\n+            if (meets_rbf_conflict_limit) {\n+                nLimitDescendants += 1;\n+                nLimitDescendantSize += conflict->GetTxSize();\n+            }\n+        }\n+\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n+            // Contracing/payment channels CPFP carve-out:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315472953",
      "id" : 315472953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ3Mjk1Mw==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 63,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276888919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315472953",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315497691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315497691"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No one ever warned me I'd need to know how to spell to write code :(",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-20T03:57:20Z",
      "diff_hunk" : "@@ -609,17 +609,66 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 REJECT_HIGHFEE, \"absurdly-high-fee\",\n                 strprintf(\"%d > %d\", nFees, nAbsurdFee));\n \n+        const CTxMemPool::setEntries setIterConflicting = pool.GetIterSet(setConflicts);\n         // Calculate in-mempool ancestors, up to a limit.\n         CTxMemPool::setEntries setAncestors;\n         size_t nLimitAncestors = gArgs.GetArg(\"-limitancestorcount\", DEFAULT_ANCESTOR_LIMIT);\n         size_t nLimitAncestorSize = gArgs.GetArg(\"-limitancestorsize\", DEFAULT_ANCESTOR_SIZE_LIMIT)*1000;\n         size_t nLimitDescendants = gArgs.GetArg(\"-limitdescendantcount\", DEFAULT_DESCENDANT_LIMIT);\n         size_t nLimitDescendantSize = gArgs.GetArg(\"-limitdescendantsize\", DEFAULT_DESCENDANT_SIZE_LIMIT)*1000;\n+\n+        if (setConflicts.size() == 1) {\n+            // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+            // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+            // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+            // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+            // very realistic either, thus we we try to ensure a limited set of transactions are RBF'able despite\n+            // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+            // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+            // for off-chain contract systems (see link in the comment below).\n+            //\n+            // Specifically, the subset of RBF transactions which we allow despite chain limits are those which\n+            // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+            // and which are not adding any new mempool dependencies (checked first).\n+            // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+            // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+            // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+            // to.\n+            //\n+            // To check these we first check if we meet the RBF criteria, above, and increment the descendant\n+            // limits by the single direct conflict (as these are recalculated by assuming the new transaction\n+            // being added is a new dependant, with no removals, of each parents' existing dependant set).\n+            // The ancestor count limits are unmodified (as the ancestor limits should be the same for both our\n+            // new transaction and any conflicts).\n+            assert(setIterConflicting.size() == 1);\n+            CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+            std::set<uint256> conflict_existing_mempool_inputs;\n+            for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+            }\n+\n+            bool meets_rbf_conflict_limit = true;\n+            for (const CTxIn& new_input: tx.vin) {\n+                if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                    if (pool.exists(new_input.prevout.hash)) {\n+                        meets_rbf_conflict_limit = false;\n+                    }\n+                }\n+            }\n+\n+            if (meets_rbf_conflict_limit) {\n+                nLimitDescendants += 1;\n+                nLimitDescendantSize += conflict->GetTxSize();\n+            }\n+        }\n+\n         std::string errString;\n         if (!pool.CalculateMemPoolAncestors(entry, setAncestors, nLimitAncestors, nLimitAncestorSize, nLimitDescendants, nLimitDescendantSize, errString)) {\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n+            // Contracing/payment channels CPFP carve-out:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315497691",
      "id" : 315497691,
      "in_reply_to_id" : 315472953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTQ5NzY5MQ==",
      "original_commit_id" : "8b1884f38bb7b4cd893ff13a2a86c1e975966711",
      "original_position" : 63,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 276920137,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315497691",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315847891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315847891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Indeed! Good call. I removes the entire block of code wholesale, but added extra comments to ensure if the BIP 125 rules are relaxed we know to re-add the checks here.",
      "commit_id" : "b9dc087c99d327aaa194de31282fedde864b7740",
      "created_at" : "2019-08-20T18:47:24Z",
      "diff_hunk" : "@@ -620,19 +621,70 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             setAncestors.clear();\n             // If CalculateMemPoolAncestors fails second time, we want the original error string.\n             std::string dummy_err_string;\n-            // If the new transaction is relatively small (up to 40k weight)\n-            // and has at most one ancestor (ie ancestor limit of 2, including\n-            // the new transaction), allow it if its parent has exactly the\n-            // descendant limit descendants.\n-            //\n-            // This allows protocols which rely on distrusting counterparties\n-            // being able to broadcast descendants of an unconfirmed transaction\n-            // to be secure by simply only having two immediately-spendable\n-            // outputs - one for each counterparty. For more info on the uses for\n-            // this, see https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-November/016518.html\n-            if (nSize >  EXTRA_DESCENDANT_TX_SIZE_LIMIT ||\n-                    !pool.CalculateMemPoolAncestors(entry, setAncestors, 2, nLimitAncestorSize, nLimitDescendants + 1, nLimitDescendantSize + EXTRA_DESCENDANT_TX_SIZE_LIMIT, dummy_err_string)) {\n-                return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", errString);\n+            if (setConflicts.size() == 1) {\n+                // In general, when we receive an RBF transaction with mempool conflicts, we want to know whether we\n+                // would meet the chain limits after the conflicts have been removed. However, there isn't a practical\n+                // way to do this short of calculating the ancestor and descendant sets with an overlay cache of\n+                // changed mempool entries. Due to both implementation and runtime complexity concerns, this isn't\n+                // very realistic, either, thus we we try to ensure a limited set of transaction is RBF'able despite\n+                // mempool conflicts here. Importantly, we want to ensure that transactions which were accepted using\n+                // the below carve-out are able to be RBF'ed, without impacting the security the carve-out provides\n+                // for off-chain contract systems (see link in the comment below).\n+                //\n+                // Specifically, the subset of RBF transactions which we allow despite conflicts are those which\n+                // conflict directly with exactly one other transaction (but may evict children of said transaction),\n+                // and which are not adding any new mempool dependencies (checked first).\n+                // Such transactions are clearly not merging any existing packages, so we are only concerned with\n+                // ensuring that (a) no package is growing past the package size (not count) limits and (b) we are\n+                // not allowing something to effectively use the (below) carve-out spot when it shouldn't be allowed\n+                // to.\n+                // To check these we re-run CalculateMemPoolAncestors up to twice, once corresponding to the above,\n+                // regular, case, and one corresponding to the below, carve-out, case. Each has the same ancestor\n+                // count limits as the corresponding case (as the ancestor limits should be the same for both our new\n+                // transaction and any conflicts, though you shouldn't be able to violate these given the\n+                // no-new-unconfirmed-inputs check), with the descendant limits increased by the size (and one\n+                // count) of the directly-conflicting transaction (as these are recalculated by assuming the new\n+                // transaction being added is a new dependant, with no removals, of each parents' existing\n+                // dependant set).\n+                assert(setIterConflicting.size() == 1);\n+                CTxMemPool::txiter conflict = *setIterConflicting.begin();\n+\n+                std::set<uint256> conflict_existing_mempool_inputs;\n+                for (const CTxMemPool::txiter& txit : pool.GetMemPoolParents(conflict)) {\n+                    conflict_existing_mempool_inputs.insert(txit->GetTx().GetHash());\n+                }\n+\n+                for (const CTxIn& new_input: tx.vin) {\n+                    if (conflict_existing_mempool_inputs.count(new_input.prevout.hash) == 0) {\n+                        if (pool.exists(new_input.prevout.hash)) {\n+                            return state.Invalid(ValidationInvalidReason::TX_MEMPOOL_POLICY, false, REJECT_NONSTANDARD, \"too-long-mempool-chain\", dummy_err_string);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16421#discussion_r315847891",
      "id" : 315847891,
      "in_reply_to_id" : 315240852,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxNTg0Nzg5MQ==",
      "original_commit_id" : "ab603961f13f09ff18877e732ed87705ed23db52",
      "original_position" : 61,
      "path" : "src/validation.cpp",
      "position" : null,
      "pull_request_review_id" : 277368804,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16421",
      "updated_at" : "2019-08-20T18:47:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/315847891",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   }
]
