[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For the same reason as pointed out in the other PR, you can't do this; you're going to mark payments to individual multisig pubkeys as incoming payments.\r\n\r\nYou'll need a way to restrict this to P2PK, P2WPKH, and P2SH/P2WSH wrapped versions of those.\r\n\r\nEDIT: I realize that when it's about private keys, the same effect applies too, and there it can't be avoided. Perhaps this stuff is just to scary, and we should wait until there's a way to actually specify what to treat as ours explicitly...",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T06:11:05Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327",
      "id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQwODMyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 164997487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (data.exists(\"scriptPubKey\") && data.exists(\"descriptor\")) {\r\n    // throw error because these should be exclusive?\r\n}\r\n```\r\nand add test.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:32:07Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727",
      "id" : 225484727,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NDcyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 536,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:41:39Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379",
      "id" : 225487379,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzM3OQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 444,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 406,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:41:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418",
      "id" : 225487418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzQxOA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 446,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 408,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:42:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555",
      "id" : 225487555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzU1NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 450,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`;",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:42:48Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698",
      "id" : 225487698,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzY5OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 491,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:43:16Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854",
      "id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzg1NA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 473,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `ProcessImportDescriptor`.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T10:43:40Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947",
      "id" : 225487947,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzk0Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 539,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, extra `-` :sweat_smile:",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T11:10:21Z",
      "diff_hunk" : "@@ -0,0 +1,6 @@\n+Low-level RPC changes\n+----------------------",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251",
      "id" : 225495251,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ5NTI1MQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 2,
      "path" : "doc/release-notes-14454.md",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit space after `if`.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T11:51:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588",
      "id" : 225505588,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUwNTU4OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 431,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Restricting it from multisig(to avoid being tricked as you mention) would make this even more confusing to a user. \r\n\r\nUnfortunate. ",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T13:10:52Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603",
      "id" : 225531603,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUzMTYwMw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165149268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mentioned on IRC, but what if we just never import public keys at all, and only either A) add the scriptPubKey as watch only or B) import the private key. If we have the private key then IMO it's less scary, because it's still \"ours\" and we can access the funds",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T18:21:27Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495",
      "id" : 225654495,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY1NDQ5NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165301641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right; the same concern doesn't exist for private keys as you're obviously able to spend those coins anyway.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T18:40:24Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278",
      "id" : 225662278,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2MjI3OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165309946,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would not importing the pubkeys affect the wallet's ability to construct PSBT inputs?",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T18:50:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843",
      "id" : 225665843,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2NTg0Mw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165314304,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Only for things that have PKH/WPKH construction in them (GetPubKey is needed for those, which finds a pubkey based on pubkeyhash).\r\n\r\n@MeshCollider To be clear, we do have to import the pubkey for those; otherwise the result is not solvable.",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T18:54:12Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972",
      "id" : 225666972,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2Njk3Mg==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165315744,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I said more tests were coming ",
      "commit_id" : "6894bf55d5728410011e32730f8e3d64ac8b82d1",
      "created_at" : "2018-10-16T23:08:21Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677",
      "id" : 225736677,
      "in_reply_to_id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTczNjY3Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 473,
      "pull_request_review_id" : 165403464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-03T01:45:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After discussion with sipa, closing for now, will come back to this after #14454 is merged",
      "created_at" : "2018-10-16T23:48:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-430440099",
      "id" : 430440099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzMDQ0MDA5OQ==",
      "updated_at" : "2018-10-16T23:48:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/430440099",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Since #14454 has been merged, this can be reopened?",
      "created_at" : "2018-11-01T19:13:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435153258",
      "id" : 435153258,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1MzI1OA==",
      "updated_at" : "2018-11-01T19:13:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435153258",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I believe a simpler approach is possible on top of #14565.",
      "created_at" : "2018-11-01T19:20:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435155301",
      "id" : 435155301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NTMwMQ==",
      "updated_at" : "2018-11-01T19:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435155301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yep I'll reopen this when rebased on 14565",
      "created_at" : "2018-11-01T19:24:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435156556",
      "id" : 435156556,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NjU1Ng==",
      "updated_at" : "2018-11-01T19:24:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435156556",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on https://github.com/bitcoin/bitcoin/pull/14565\r\n\r\nStill planning on adding more tests + release notes, please don't nitpick the lack of tests yet",
      "created_at" : "2018-11-03T00:23:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435544886",
      "id" : 435544886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU0NDg4Ng==",
      "updated_at" : "2018-11-03T02:02:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435544886",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors thanks for the feedback :) \r\n\r\n> If I use watchonly: true, then getaddressinfo doesn't show a descriptor and it says solvable: false, which seems wrong (the latter also happens without cherry-pick).\r\n\r\nIt should only watch for the scriptPubKey and import no other information, watch-only is a different requirement than being solvable without private keys.\r\n\r\n>  the origin info in the descriptor seems both wrong and incomplete: \"desc\": \"wpkh([224885f8]026...)\", where 224885f8 is not the master fingerprint I used, and derivation info is missing. \r\n\r\nYou're right, good point. I'll take a look at andrews PR\r\n\r\n> I didn't use the watchonly while importing a descriptor with an xpub, should that be allowed? Or should watchonly argument not be allowed when using a descriptor?\r\n\r\nI think it should be allowed, because of the above reason. Using an xpub without watch only allows it to be solvable without being spendable",
      "created_at" : "2018-11-05T23:33:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436075791",
      "id" : 436075791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NTc5MQ==",
      "updated_at" : "2018-11-05T23:33:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436075791",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MeshCollider @Sjors I was imagining that \"watchonly\" would be implicit when using descriptors (`addr()` and `raw()` would be watchonly; anything else would result in a solvable result).\r\n\r\nThe reason for \"watchonly\" is so that users need to be explicit about the fact they _don't_ want solvability (generally, you should always want solvability, but if you can't, you can tell importmulti that it's fine without).",
      "created_at" : "2018-11-05T23:39:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436077191",
      "id" : 436077191,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NzE5MQ==",
      "updated_at" : "2018-11-05T23:39:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436077191",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa I like your suggestion. In that case we should disallow usage of the `watchonly` param when combined with a descriptor.\r\n\r\nRegarding getting origin information from the descriptors, @achow101  just rebased #14021 on top of this PR. It's a non trivial change. Perhaps for this PR it's best to not store origin information. Just make sure that if you do `walletcreatefundedpsbt` with bip32 flag set to true, then the result doesn't crash `decodepsbt`.",
      "created_at" : "2018-11-06T08:56:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436177401",
      "id" : 436177401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE3NzQwMQ==",
      "updated_at" : "2018-11-06T08:56:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436177401",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I don't see the problem if you want to add a ranged descriptor as watch only to import all the scriptPubKeys but not retain any more info than that?",
      "created_at" : "2018-11-06T10:02:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436197110",
      "id" : 436197110,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE5NzExMA==",
      "updated_at" : "2018-11-06T10:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436197110",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "IIUC you would indicate that in the descriptor by wrapping the result in `addr(...)`. Mandating that removes ambiguity from how a descriptor ends up in a wallet.",
      "created_at" : "2018-11-06T10:15:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436201303",
      "id" : 436201303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIwMTMwMw==",
      "updated_at" : "2018-11-06T10:15:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436201303",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors It was my understanding that `addr(...)` cannot contain another type of descriptor or key (e.g. a ranged BIP32 key), only the base58/bech32 encoded address formats. If I'm wrong then I'm happy to change this PR, @sipa could weigh in here",
      "created_at" : "2018-11-06T11:19:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436218992",
      "id" : 436218992,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIxODk5Mg==",
      "updated_at" : "2018-11-06T11:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436218992",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "xpub byte prefix mismatch results in very generic error; would be nice to give something more meaningful ",
      "created_at" : "2018-11-07T18:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436723660",
      "id" : 436723660,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjcyMzY2MA==",
      "updated_at" : "2018-11-07T18:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436723660",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14679](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14679.html) (importmulti: Don't add internal addresses to address book by instagibbs)\n* [#14565](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14565.html) (Overhaul importmulti logic by sipa)\n* [#14530](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14530.html) (Use RPCHelpMan to generate RPC doc strings by MarcoFalke)\n* [#14459](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14459.html) (More RPC help description fixes by ch4ot1c)\n* [#14411](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14411.html) ([wallet] Restore ability to list incoming transactions by label by ryanofsky)\n* [#14021](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14021.html) (Import key origin data through descriptors in importmulti by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-11-08T21:28:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-437162334",
      "id" : 437162334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNzE2MjMzNA==",
      "updated_at" : "2018-11-08T21:28:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437162334",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
