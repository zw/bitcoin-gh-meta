[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17493](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17493.html) (util: Forbid ambiguous repeated assignments in config file by ryanofsky)\n* [#17452](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17452.html) (lib: update fuzz directory in .gitignore by jonatack)\n* [#17398](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17398.html) (build: Update leveldb to 1.22+ by laanwj)\n* [#17383](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17383.html) (Refactor: Move consts to their correct translation units by jnewbery)\n* [#17227](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17227.html) (Qt: Add Android packaging support by icota)\n* [#16722](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16722.html) (build: Disable warnings for leveldb subtree by default by hebasto)\n* [#16161](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16161.html) (util: Fix compilation errors in support/lockedpool.cpp by jkczyz)\n* [#15606](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15606.html) ([experimental] UTXO snapshots by jamesob)\n* [#15367](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15367.html) (feature: Added ability for users to add a startup command by benthecarman)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-08-29T23:53:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526402501",
      "id" : 526402501,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjQwMjUwMQ==",
      "updated_at" : "2019-11-20T04:36:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526402501",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319390967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "AFAICS `--start-group` is not supported in clang (https://bitcoinbuilds.org/index.php?ansilog=6ccfb93d-3437-41c0-99d4-3b6653264739.log#l1705)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-08-30T07:38:07Z",
      "diff_hunk" : "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319390967",
      "id" : 319390967,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MDk2Nw==",
      "original_commit_id" : "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "original_position" : 38,
      "path" : "src/Makefile.am",
      "position" : null,
      "pull_request_review_id" : 281872721,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319390967",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319393006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jonasschnelli Yes `ld` on macOS doesn't support `--start-group` or `--end-group`. This was a bit of a hack to fix a circular dependency issue Matt was seeing on his Debian machine. If you want to compile on macOS you should just be able to drop the `-Wl,--start-group` additions, as that has been working for me. We'll need to fix this **properly** soon.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-08-30T07:44:25Z",
      "diff_hunk" : "@@ -529,7 +537,7 @@ nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n bitcoind_SOURCES = bitcoind.cpp\n bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bitcoind_LDFLAGS = -Wl,--start-group $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r319393006",
      "id" : 319393006,
      "in_reply_to_id" : 319390967,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMxOTM5MzAwNg==",
      "original_commit_id" : "cf221a2410a066fa95f526be343b8fa4c63d5184",
      "original_position" : 38,
      "path" : "src/Makefile.am",
      "position" : null,
      "pull_request_review_id" : 281875349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/319393006",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Interesting idea: cautious concept ACK -- more redundancy is good and it is hard to see how this would make us worse off in any way as long as the existing P2P logic is kept unchanged. (Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK.)\r\n\r\nCensorship scenarios worth thinking about:\r\n\r\nEven if we do the over-REST block downloads over HTTPS it should be noted that the TLS handshake leaks the hostname of the connected to service to passive eavesdroppers. (Unless TLS 1.3 + Encrypted SNI is used: super rare in practice though.)\r\n\r\nThe hostname is obviously also leaked when doing the DNS lookup. (Unless DoH (DNS over HTTPS) or DoT (DNS over TLS) is used: quite rare in practice.)\r\n\r\nThis allows for active censorship attacks if the hostnames used are **only**  used for Bitcoin purposes (such as in the `cloudflare.deanonymizingseed.com` example â I understand it is just used here as an example).\r\n\r\n(The same obviously goes for the IP-address used: if the IP-address connected to is only used for Bitcoin purposes then access to that IP-address could trivially be null routed without any non-Bitcoin users noticing.)\r\n\r\nI guess one way to achieve (partial) censorship resistance is to download over HTTPS URLs where the hostnames used are mostly used for non-Bitcoin purposes (such as `github.com` â just used here as an example: I'm sure we can come up with other examples). That would leak the hostname but since the hostname and the IP address is used for other purposes it would still be hard for an attacker to block it without having non-Bitcoin users complain.\r\n\r\nAnother route would be to use TLS 1.3 + Encrypted SNI + DoH/DoT to connect to a service whose IP-address(es) are used mostly for non-Bitcoin purposes (such as CloudFlare which luckily supports both TLS 1.3 and Encrypted SNI). That wouldn't leak the hostname and the IP-address would be hard to null route for an attacker without having non-Bitcoin users complain.",
      "created_at" : "2019-08-30T12:46:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526588120",
      "id" : 526588120,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjU4ODEyMA==",
      "updated_at" : "2019-08-30T13:13:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526588120",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Intentionally not commenting on the implementation and more specifically the pros and cons of pulling in Rust code: that is an implementation detail that I'm sure will be discussed separately post concept ACK/NACK\r\n\r\nRight, there's a few things that would need to happen to get this in mergeable state (notably buildsystem things), so no need for that just yet.\r\n\r\n> Censorship scenarios worth thinking about:\r\n\r\nRight, two things I'd like to support in the blocks-over-REST module: domain fronting avoids most of the gnarly issues with SNI/DNS lookups breaking your privacy, though sadly many providers don't like it anymore, and Tor support, possibly even with some default onion service recommended as a backup cause privacy is less of a concern there.\r\n\r\nI'd also like to build a whole second P2P implementation (though with an explicit goal of being inefficient and simple, with the same trick as here where you wait 30 seconds before deciding to download anything to avoid wasting bandwidth), but first need to land some bit of rust downloading, and this seemed like an easier target.",
      "created_at" : "2019-08-30T18:33:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526704470",
      "id" : 526704470,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjcwNDQ3MA==",
      "updated_at" : "2019-08-30T18:33:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526704470",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "But why Rust not C++?",
      "created_at" : "2019-08-30T19:46:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526725811",
      "id" : 526725811,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjcyNTgxMQ==",
      "updated_at" : "2019-08-30T19:46:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526725811",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/4500994?v=4",
         "events_url" : "https://api.github.com/users/kristapsk/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kristapsk/followers",
         "following_url" : "https://api.github.com/users/kristapsk/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kristapsk/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kristapsk",
         "id" : 4500994,
         "login" : "kristapsk",
         "node_id" : "MDQ6VXNlcjQ1MDA5OTQ=",
         "organizations_url" : "https://api.github.com/users/kristapsk/orgs",
         "received_events_url" : "https://api.github.com/users/kristapsk/received_events",
         "repos_url" : "https://api.github.com/users/kristapsk/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kristapsk/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kristapsk/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kristapsk"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> But why Rust not C++?\r\n\r\nBecause we can trivially turn on compile-time checking preventing a ton of classes of vulnerabilities (especially for network-facing code), and runtime checking for many other classes (like buffer overflows, at least those the compiler can't prove aren't possible).",
      "created_at" : "2019-08-31T05:59:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803517",
      "id" : 526803517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjgwMzUxNw==",
      "updated_at" : "2019-08-31T05:59:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803517",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm fairly Concept ACK on this. It's been in discussion for a little while, and I'm pretty sure it came up at the last Core dev meetup as well?\r\n\r\n> But why Rust not C++?\r\n\r\n@kristapsk This PR isn't really the place to have that discussion and is only going to distract from what's actually trying to be achieved. Although Matt points out one big advantage:\r\n\r\n> plus we can use compile-time checks to catch any overflows and memory corruption bugs to reduce review burden.\r\n\r\n\r\nIf you'd like to discuss Rust inside Bitcoin Core further, I'd suggest taking a look at #15798. Here are Cory's thoughts on Rust from that thread:\r\n\r\n> Why rust? I don't know. Maybe not. But I think it's a fair assumption to say that Rust code will eventually end up in Bitcoin Core as the result of adding a new dependency. Adoption is happing quickly. So, I think it prudent to look ahead and not only be prepared, but actively help usher it in. Already I have a few things that I would like to work on and upstream to rust-lang to make our integration nicer, and I assume that more will be uncovered as it actually gets used.\r\n\r\nI built and tested that this functions using the instructions above. The backup downloader kicked off after a 10 minute wait\r\n```bash\r\nsrc/bitcoind -blockfetchrest=http://cloudflare.deanonymizingseed.com/rest/ -connect=0\r\n\r\n2019-08-31T05:37:06Z nBestHeight = 311015\r\n2019-08-31T05:37:06Z init message: Loading P2P addresses...\r\n2019-08-31T05:37:06Z Imported mempool transactions from disk: 0 succeeded, 0 failed, 0 expired, 0 already there\r\n2019-08-31T05:37:06Z Loaded 63409 addresses from peers.dat  159ms\r\n2019-08-31T05:37:06Z init message: Starting network threads...\r\n2019-08-31T05:37:06Z DNS seeding disabled\r\n2019-08-31T05:37:06Z net thread start\r\n2019-08-31T05:37:06Z msghand thread start\r\n2019-08-31T05:37:06Z addcon thread start\r\n2019-08-31T05:37:06Z init message: Done loading\r\n2019-08-31T05:47:10Z Synchronizing blockheaders, height: 313014 (~53.91%)\r\n2019-08-31T05:47:13Z Synchronizing blockheaders, height: 315013 (~54.23%)\r\n2019-08-31T05:47:15Z Synchronizing blockheaders, height: 317012 (~54.55%)\r\n2019-08-31T05:47:17Z Synchronizing blockheaders, height: 319011 (~54.87%)\r\n< snip >\r\n2019-08-31T05:52:27Z Synchronizing blockheaders, height: 574883 (~97.17%)\r\n2019-08-31T05:52:34Z Synchronizing blockheaders, height: 576882 (~97.49%)\r\n2019-08-31T05:52:36Z Synchronizing blockheaders, height: 578881 (~97.81%)\r\n2019-08-31T05:52:39Z Synchronizing blockheaders, height: 580880 (~98.14%)\r\n2019-08-31T05:52:41Z Synchronizing blockheaders, height: 582879 (~98.46%)\r\n2019-08-31T05:52:44Z Synchronizing blockheaders, height: 584878 (~98.76%)\r\n2019-08-31T05:52:47Z Synchronizing blockheaders, height: 586877 (~99.09%)\r\n2019-08-31T05:52:49Z Synchronizing blockheaders, height: 588876 (~99.40%)\r\n2019-08-31T05:52:56Z Synchronizing blockheaders, height: 590875 (~99.73%)\r\n2019-08-31T05:52:59Z Synchronizing blockheaders, height: 592551 (~100.00%)\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x3000000 in blk00158.dat\r\n2019-08-31T05:53:35Z Pre-allocating up to position 0x100000 in rev00158.dat\r\n2019-08-31T05:53:35Z UpdateTip: new best=0000000000000000246039d52e90fb6b7cd442dda19861fb948c28e3a44f7a4e height=311016 version=0x00000002 log2_work=79.744641 tx=42644694 date='2014-07-16T13:51:22Z' progress=0.095646 cache=0.5MiB(3475txo)\r\n2019-08-31T05:53:38Z UpdateTip: new best=000000000000000014c552ced25645452a0b8632753e9288e2decedd273c5828 height=311017 version=0x00000002 log2_work=79.744747 tx=42645541 date='2014-07-16T14:10:17Z' progress=0.095648 cache=1.0MiB(7067txo)\r\n2019-08-31T05:53:40Z UpdateTip: new best=0000000000000000260ef522f4875fb0d5207e4e3ac97ce373a47209bcee52b6 height=311018 version=0x00000002 log2_work=79.744853 tx=42645990 date='2014-07-16T14:18:18Z' progress=0.095649 cache=1.2MiB(8621txo)\r\n2019-08-31T05:53:42Z UpdateTip: new best=0000000000000000007dabdebadfde7beaef31d13133600d0d88695146e2fac6 height=311019 version=0x00000002 log2_work=79.744959 tx=42646068 date='2014-07-16T14:19:50Z' progress=0.095649 cache=1.2MiB(8821txo)\r\n2019-08-31T05:53:45Z UpdateTip: new best=00000000000000001fc78d459e2480177ceea92d53f75cdbd856501b60cbdc3a height=311020 version=0x00000002 log2_work=79.745065 tx=42646933 date='2014-07-16T14:34:32Z' progress=0.095651 cache=1.6MiB(11938txo)\r\n< snip >\r\n2019-08-31T06:00:41Z UpdateTip: new best=000000000000000017de2992c0de3e98d711253582fa7ee626645e395e4fd0e5 height=311697 version=0x00000002 log2_work=79.815121 tx=42899222 date='2014-07-20T16:20:21Z' progress=0.096217 cache=67.4MiB(497634txo)\r\n2019-08-31T06:00:44Z UpdateTip: new best=000000000000000022aeedbb76913a3666d997897c23efc8e92fe38ec79728a7 height=311698 version=0x00000002 log2_work=79.815222 tx=42899470 date='2014-07-20T16:25:14Z' progress=0.096217 cache=68.0MiB(502949txo)\r\n2019-08-31T06:00:47Z UpdateTip: new best=000000000000000027a68e70c9c02985173c56e8c8ce210c02eb975530d77f0d height=311699 version=0x00000002 log2_work=79.815323 tx=42899561 date='2014-07-20T16:27:06Z' progress=0.096218 cache=68.3MiB(505709txo)\r\n2019-08-31T06:00:51Z UpdateTip: new best=000000000000000038730cd937f594452e96b97a496afc03a84fc90a18119113 height=311700 version=0x00000002 log2_work=79.815424 tx=42900165 date='2014-07-20T16:40:48Z' progress=0.096219 cache=68.8MiB(509386txo)\r\n```\r\n\r\nFWIW I've also rebased and added another commit for a more recent Rust onto https://github.com/fanquake/bitcoin/tree/theuni-with-rust-example-working-rebased. Will add another commit on top for the `--start-group` workaround. Given that you've dropped `cbindgen` here, I can also maintain a branch with that dropped.",
      "created_at" : "2019-08-31T06:01:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-526803615",
      "id" : 526803615,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNjgwMzYxNQ==",
      "updated_at" : "2019-08-31T06:01:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/526803615",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK on adding more redundancy.\r\nAgree that Tor support is desirable, and also measures suggested by @practicalswift are important, but this feature even before those measures is already a big improvement (without trading any privacy comparing to the current threat model with unencrypted p2p I believe).",
      "created_at" : "2019-09-03T17:04:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527549359",
      "id" : 527549359,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzU0OTM1OQ==",
      "updated_at" : "2019-09-03T21:34:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527549359",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK!",
      "created_at" : "2019-09-04T09:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-527816563",
      "id" : 527816563,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzgxNjU2Mw==",
      "updated_at" : "2019-09-04T09:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527816563",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Could we try and use something like https://github.com/dtolnay/no-panic on parts of the code? (if we can, this will give us compile time guarantees of no panics)\r\n\r\nAnother Idea, checking nullness at the boundaries and then use https://doc.rust-lang.org/std/ptr/struct.NonNull.html (can even use `NonNull::new()` to check for nullness)\r\n\r\nOther than that I like this and would love to review it when it's reviewable :)",
      "created_at" : "2019-09-05T06:47:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528223954",
      "id" : 528223954,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODIyMzk1NA==",
      "updated_at" : "2019-09-05T06:56:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528223954",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd rather deliberately use panics so that we can enable overflow checking and catch the panics to kill the Rust thread(s) but leave the rest of Core running. Good call on NonNull, will update to use that!",
      "created_at" : "2019-09-05T16:53:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528459579",
      "id" : 528459579,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODQ1OTU3OQ==",
      "updated_at" : "2019-09-05T16:53:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528459579",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Aside from the final commit working around one last build issue, I believe this is ready for review. Doesn't make sense to land for 19, but would be nice to land early in the cycle for 20.",
      "created_at" : "2019-09-06T19:19:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-528981929",
      "id" : 528981929,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODk4MTkyOQ==",
      "updated_at" : "2019-09-06T19:19:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528981929",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I'm taking a look at a proper fix for the circular dependency.",
      "created_at" : "2019-09-06T20:53:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529010545",
      "id" : 529010545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTAxMDU0NQ==",
      "updated_at" : "2019-09-06T20:53:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529010545",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L254-L262\r\n\r\nIs there any particular reason that the Rust code is using a hand-rolled HTTP client implementation?\r\n\r\n> https://github.com/bitcoin/bitcoin/blob/3f1ceb95edeb9f58b0a702520a2c452012c63974/src/rusty/src/rest_downloader.rs#L246-L248\r\n\r\nTLS support would be more or less free if we didn't roll our own implementation? :-)\r\n\r\nTLS would be really nice to have since our goal with this PR is to increase censorship resistance.",
      "created_at" : "2019-09-07T05:13:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529074057",
      "id" : 529074057,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTA3NDA1Nw==",
      "updated_at" : "2019-09-07T05:13:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529074057",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-09-07T11:32:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529099951",
      "id" : 529099951,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTA5OTk1MQ==",
      "updated_at" : "2019-09-07T11:32:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529099951",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased.\r\n\r\nYea, probably makes sense to switch to a non-handrolled-HTTP-parser eventually, but:\r\na) I haven't yet had the time to look into existing rust ones to see if I can find anything suitable (ie doesn't pull in a million dependencies, implying its probably not async/tokio based, and easy to review), which in my previous experience implies this may be hard,\r\nb) if we add any dependencies we have to have a process for vendoring the entire recursive dependency tree, which is gonna be its own hurdle, so I figured leave that for a follow-up PR.",
      "created_at" : "2019-09-07T17:33:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-529128639",
      "id" : 529128639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyOTEyODYzOQ==",
      "updated_at" : "2019-09-07T17:33:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/529128639",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983533"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think tracking changes to Cargo.lock might be a good thing. (especially if we will have some dependencies in the future)\r\n\r\n(I know it's against the official recommendation)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:10:57Z",
      "diff_hunk" : "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983533",
      "id" : 321983533,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4MzUzMw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 6,
      "path" : ".gitignore",
      "position" : 6,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983533",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983747"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "why not use the regular `const char*`? why cast it into an unsigned char pointer?\r\nYou could then use rust's `CStr` instead of manually looping and offsetting the pointer:\r\nhttps://doc.rust-lang.org/std/ffi/struct.CStr.html#method.from_ptr",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:20:17Z",
      "diff_hunk" : "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983747",
      "id" : 321983747,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzc0Nw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 29,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983747",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983940"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "A. I'm not sure dereferencing a char* casted to *const u8, is safe.\r\nB. if you pass this as `*const c_char` and then use rust's `CStr` (as I wrote above) you can replace these ~10 lines with:\r\n```\r\nlet uri_str = match CStr::from_ptr(uri).to_str() {\r\n    Ok(r) => r,\r\n    Err(_) => return false,\r\n};\r\n```",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:28:29Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983940",
      "id" : 321983940,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk0MA==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 212,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983940",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "currently the test is pretty small, but maybe still feature gate it with `#[cfg(test)]` so that it won't be compiled normally?",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:30:28Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321983986",
      "id" : 321983986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4Mzk4Ng==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 56,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 61,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321983986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could you add a doc explaining what the function is doing?",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:31:50Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984009",
      "id" : 321984009,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDAwOQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 10,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 14,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984009",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe replace with `host_path.starts_with(\"/\")`? (which also solves possible utf-8 problems)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:39:18Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984146",
      "id" : 321984146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE0Ng==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 21,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984146",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Then you can replace this with `host_path = host_path.trim_start_matches(\"/\");`",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:41:36Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984187",
      "id" : 321984187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDE4Nw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 22,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 26,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984187",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Same, unless we have something that `if !uri.is_ascii() return None;` at the start of the function we should really try and not index into strings",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:52:33Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984418",
      "id" : 321984418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQxOA==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 27,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984418",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "and btw you can do `b'['` instead of `'[' as u8` :)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T21:54:19Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984465",
      "id" : 321984465,
      "in_reply_to_id" : 321984418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDQ2NQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 27,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984465",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984701"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could we easily log a panic easily somehow? (although this introduces a lot of complications to pass the `datadir` location somehow, could we maybe use some tmp location just as a jump start?)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:03:14Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984701",
      "id" : 321984701,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDcwMQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 225,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 224,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984701",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984797"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this should be reversed to check if SSL is true.\r\nBecause if this returns None we might as well also return false and finish this early, because we unwrap this few lines after \r\n\r\nBetter yet, run it once and check for `if ssl {return False;}` so that we won't need to run this twice(not that it really matters that much...)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:06:33Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321984797",
      "id" : 321984797,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NDc5Nw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 221,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 220,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321984797",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "maybe add an example of how the uri should be formatted? (especially because currently there's no feedback from `split_uri`)",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:18:22Z",
      "diff_hunk" : "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985047",
      "id" : 321985047,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTA0Nw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 16,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985047",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985329"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ideally we would match against the exact error match so that if it returns something like `InvalidData` then there's no need to keep the loop running. (so stop unless it's a timeout, broken pipe, would block etc.)  ",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:31:49Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985329",
      "id" : 321985329,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTMyOQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 237,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 236,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985329",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985493"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Add a comment that this should only ever trip on the *second* connection?",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:40:51Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985493",
      "id" : 321985493,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTQ5Mw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 268,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 267,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985493",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985515"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If we're on completely separate chains why reconnect?",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:41:39Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985515",
      "id" : 321985515,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTUxNQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 269,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 268,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985515",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`res.as_mut_ptr()` should also work",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-07T22:51:47Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+use std::ffi::c_void;\n+extern \"C\" {\n+    pub fn rusty_IsInitialBlockDownload() -> bool;\n+    pub fn rusty_ShutdownRequested() -> bool;\n+\n+    fn rusty_ProcessNewBlock(blockdata: *const u8, blockdatalen: usize, blockindex_requested: *const c_void);\n+\n+    /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n+    /// Returns the last header which was connected, if any (or NULL).\n+    fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n+\n+    // Utilities to work with CBlockIndex pointers. Wrapped in a safe wrapper below.\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current tip.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetChainTip() -> *const c_void;\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n+    /// Guaranteed to never be NULL\n+    fn rusty_GetGenesisIndex() -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Finds a CBlockIndex* for a given block hash, or NULL if none is found\n+    fn rusty_HashToIndex(hash: *const u8) -> *const c_void;\n+\n+    #[allow(dead_code)]\n+    /// Gets the height of a given CBlockIndex* pointer\n+    fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+\n+    /// Gets the hash of a given CBlockIndex* pointer\n+    fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n+}\n+\n+#[allow(dead_code)]\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers(headers: &[[u8; 80]]) -> Option<BlockIndex> {\n+    if headers.is_empty() { return None; }\n+    let first_header = headers[0].as_ptr();\n+    let index = if headers.len() == 1 {\n+        unsafe { rusty_ConnectHeaders(first_header, 80, 1) }\n+    } else {\n+        let second_header = headers[1].as_ptr();\n+        let stride = second_header as usize - first_header as usize;\n+        unsafe { rusty_ConnectHeaders(first_header, stride, headers.len()) }\n+    };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n+    if headers.len() % 80 != 0 { return None; }\n+    if headers.is_empty() { return None; }\n+    let index = unsafe { rusty_ConnectHeaders(headers.as_ptr(), 80, headers.len() / 80) };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+/// Processes a new block, in serialized form.\n+/// blockindex_requested_by_state shouild be set *only* if the given BlockIndex was provided by\n+/// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n+pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<BlockIndex>) {\n+    let blockindex = match blockindex_requested_by_state { Some(index) => index.index, None => std::ptr::null(), };\n+    unsafe {\n+        rusty_ProcessNewBlock(blockdata.as_ptr(), blockdata.len(), blockindex);\n+    }\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    index: *const c_void,\n+}\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetChainTip() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn get_from_hash(hash: &[u8; 32]) -> Option<Self> {\n+        let index = unsafe { rusty_HashToIndex(hash.as_ptr()) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            Some(Self { index })\n+        }\n+    }\n+\n+    pub fn genesis() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetGenesisIndex() },\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn height(&self) -> i32 {\n+        unsafe { rusty_IndexToHeight(self.index) }\n+    }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        let hashptr = unsafe { rusty_IndexToHash(self.index) };\n+        let mut res = [0u8; 32];\n+        unsafe { std::ptr::copy(hashptr, (&mut res).as_mut_ptr(), 32) };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r321985689",
      "id" : 321985689,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk4NTY4OQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 105,
      "path" : "src/rusty/src/bridge.rs",
      "position" : null,
      "pull_request_review_id" : 285188001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321985689",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think we'll vendor all our dependencies, so hopefully no need, but we can look into it more once we have a dependency.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-08T20:37:05Z",
      "diff_hunk" : "@@ -137,3 +137,7 @@ db4/\n osx_volname\n dist/\n *.background.tiff\n+\n+# Rust\n+src/rusty/Cargo.lock",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028115",
      "id" : 322028115,
      "in_reply_to_id" : 321983533,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODExNQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 6,
      "path" : ".gitignore",
      "position" : 6,
      "pull_request_review_id" : 285234118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028115",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Cause I didn't know CStr existed :p",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-08T20:43:48Z",
      "diff_hunk" : "@@ -1824,5 +1831,13 @@ bool AppInitMain(InitInterfaces& interfaces)\n         g_banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks((const unsigned char*)uri.c_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322028393",
      "id" : 322028393,
      "in_reply_to_id" : 321983747,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjAyODM5Mw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 29,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 285234379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322028393",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The server may also be broken and be returning empty responses, so best to keep trying.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T02:58:45Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050160",
      "id" : 322050160,
      "in_reply_to_id" : 321985515,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDE2MA==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 269,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 268,
      "pull_request_review_id" : 285261436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050160",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050241"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I mean that seems pretty obvious given the code?",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T02:59:39Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050241",
      "id" : 322050241,
      "in_reply_to_id" : 321985493,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDI0MQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 268,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 267,
      "pull_request_review_id" : 285261556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050241",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050361"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ehh, I'd rather keep polling. Better to keep polling so that when the rest endpoint fixes their misconfiguration (eg its returning a 500 or 404 or whatever) the downloader picks back up.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T03:00:42Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050361",
      "id" : 322050361,
      "in_reply_to_id" : 321985329,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDM2MQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 237,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 236,
      "pull_request_review_id" : 285261700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050361",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I went ahead and added the deanonymizingseed.com one, if folks complain I can use example.com.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T03:02:14Z",
      "diff_hunk" : "@@ -367,6 +371,9 @@ void SetupServerArgs()\n #endif\n     gArgs.AddArg(\"-blockreconstructionextratxn=<n>\", strprintf(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\", DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n     gArgs.AddArg(\"-blocksonly\", strprintf(\"Whether to reject transactions from network peers. Transactions from the wallet, RPC and relay whitelisted inbound peers are not affected. (default: %u)\", DEFAULT_BLOCKSONLY), ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity\", ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050537",
      "id" : 322050537,
      "in_reply_to_id" : 321985047,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDUzNw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 16,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 285261919,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050537",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm? The pattern hers is if let Some() {} else { return; }. It reads a bit weird but its the easiest way to write it out.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T03:03:34Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050675",
      "id" : 322050675,
      "in_reply_to_id" : 321984797,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDY3NQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 221,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 220,
      "pull_request_review_id" : 285262098,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050675",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, it would be really nice to be able to call LogPrintf from rust code, but I'd prefer to leave that to a future PR.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T03:04:15Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = !r.is_empty() && r.as_bytes()[0] == '[' as u8;\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const u8) -> bool {\n+    let mut uri_vec = Vec::with_capacity(50);\n+    for i in 0..10000 {\n+        let c = unsafe { *uri.offset(i) };\n+        if c == 0 { break; }\n+        uri_vec.push(c);\n+    }\n+    let uri_str = match String::from_utf8(uri_vec) {\n+        Ok(r) => r,\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        let _ = catch_unwind(move || {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050763",
      "id" : 322050763,
      "in_reply_to_id" : 321984701,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDc2Mw==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 225,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 224,
      "pull_request_review_id" : 285262204,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050763",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, thats only available in 1.30. For now lets avoid it until we have a clear min version.",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T03:06:12Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322050941",
      "id" : 322050941,
      "in_reply_to_id" : 321984187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjA1MDk0MQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 22,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 26,
      "pull_request_review_id" : 285262464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T03:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322050941",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322292885"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "So you have `trim_left_matches()` which predates it (is in rust since 1.0)\r\nhttps://doc.rust-lang.org/std/primitive.str.html#method.trim_left_matches",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T15:01:43Z",
      "diff_hunk" : "@@ -0,0 +1,325 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while !host_path.is_empty() && host_path.as_bytes()[0] == '/' as u8 {\n+        host_path = &host_path[1..];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322292885",
      "id" : 322292885,
      "in_reply_to_id" : 321984187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5Mjg4NQ==",
      "original_commit_id" : "14bc05537fb2522aad61f119a71949723baaa9b8",
      "original_position" : 22,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 26,
      "pull_request_review_id" : 285573787,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T15:01:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322292885",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322294202"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Great catch :)\r\nthat way we won't have a dangling pointer at some point",
      "commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "created_at" : "2019-09-09T15:04:02Z",
      "diff_hunk" : "@@ -0,0 +1,324 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+/// Splits an HTTP URI into its component part - (is_ssl, hostname, port number, and HTTP path)\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    while host_path.starts_with(\"/\") {\n+        host_path = &host_path[1..];\n+    }\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = r.starts_with(\"[\");\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                resp = resp.split_off(idx + 2);\n+                resp.resize(bytes_read - idx - 2, 0);\n+                break 'read_headers;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                resp = resp.split_off(idx + 4);\n+                resp.resize(bytes_read - idx - 4, 0);\n+                break 'read_headers;\n+            }\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                loop {\n+                    let line = match lineiter.next() { Some(line) => line, None => break };\n+                    if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                        if line.len() > 8 {\n+                            // No reason to ever have a chunk length line longer than 4 chars\n+                            return None;\n+                        }\n+                        break;\n+                    }\n+                    bytes_skipped += line.len() + 1;\n+                    if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                    match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                        Ok(s) => s, Err(_) => return None,\n+                    }, 16) {\n+                        Ok(chunklen) => {\n+                            if chunklen == 0 { finished_read = true; }\n+                            chunk_remaining = chunklen;\n+                            match lineiter.next() {\n+                                Some(l) if l.is_empty() => {\n+                                    // Drop \\r after \\n\n+                                    bytes_skipped += 1;\n+                                    if actual_len + bytes_skipped > bytes_read {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    }\n+                                },\n+                                Some(_) => {},\n+                                None => {\n+                                    // Go back and get more bytes so we can skip trailing \\n\n+                                    chunk_remaining = 0;\n+                                },\n+                            }\n+                            break;\n+                        },\n+                        Err(_) => return None,\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const c_char) -> bool {\n+    let uri_str: String = match unsafe { CStr::from_ptr(uri) }.to_str() {\n+        Ok(r) => r.to_string(),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#discussion_r322294202",
      "id" : 322294202,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMjI5NDIwMg==",
      "original_commit_id" : "2cc8b15de5c075bcfb149ddd9326724e7790fd32",
      "original_position" : 216,
      "path" : "src/rusty/src/rest_downloader.rs",
      "position" : 216,
      "pull_request_review_id" : 285575526,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16762",
      "updated_at" : "2019-09-09T15:04:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/322294202",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Now based on #16834 instead of the other way around, but otherwise this should be mostly good to go!",
      "created_at" : "2019-09-30T23:57:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-536799717",
      "id" : 536799717,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzNjc5OTcxNw==",
      "updated_at" : "2019-09-30T23:57:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/536799717",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "node_id" : "MDQ6VXNlcjY0OTI0Ng==",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-10-09T15:41:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-540059747",
      "id" : 540059747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0MDA1OTc0Nw==",
      "updated_at" : "2019-10-09T15:41:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/540059747",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-10-26T11:13:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-546593385",
      "id" : 546593385,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0NjU5MzM4NQ==",
      "updated_at" : "2019-10-26T11:13:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/546593385",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-11-08T21:25:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-551995383",
      "id" : 551995383,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MTk5NTM4Mw==",
      "updated_at" : "2019-11-08T21:25:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/551995383",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-11-19T09:03:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-555403242",
      "id" : 555403242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1NTQwMzI0Mg==",
      "updated_at" : "2019-11-19T09:03:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/555403242",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-11-20T16:12:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16762#issuecomment-556077966",
      "id" : 556077966,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16762",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1NjA3Nzk2Ng==",
      "updated_at" : "2019-11-20T16:12:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/556077966",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
