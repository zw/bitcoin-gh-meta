[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2019-04-16T07:35:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483546373",
      "id" : 483546373,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzU0NjM3Mw==",
      "updated_at" : "2019-04-16T07:35:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483546373",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nExcellent work! Thanks for doing this!",
      "created_at" : "2019-04-16T08:53:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483571886",
      "id" : 483571886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzU3MTg4Ng==",
      "updated_at" : "2019-04-16T08:53:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483571886",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ":heart: Makes it easier to run the tests on native windows, where I couldn't figure out how to install that library. Will give it a try...",
      "created_at" : "2019-04-16T11:44:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483625450",
      "id" : 483625450,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzYyNTQ1MA==",
      "updated_at" : "2019-04-16T11:44:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483625450",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275756645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275756645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like this is never called. Could either:\r\n* Remove it\r\n* Update the python linter\r\n* Call it in a smoke test",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-16T11:47:56Z",
      "diff_hunk" : "@@ -1,226 +1,338 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, does not properly protect keys, and is\n+trivially vulnerable to side channel attacks. Do not use for anything\n+but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n import hashlib\n+import secrets\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def egcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = egcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = egcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def legendre_symbol(a, p):\n+    \"\"\"Compute the Legendre symbol of a modulo p\n \n+    See http://en.wikipedia.org/wiki/Legendre_symbol\n+    \"\"\"\n+    ls = pow(a, (p - 1)//2, p)\n+    if ls == p - 1:\n+        return -1\n+    return ls\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    return pow(a, (p + 1)//4, p)\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return legendre_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def add(self, p1, p2):\n+        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        if z1 == 0:\n+            return p2\n+        if z2 == 0:\n+            return p1\n+        if z1 == 1:\n+            return self.add_mixed(p2, p1)\n+        if z2 == 1:\n+            return self.add_mixed(p1, p2)\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        z2_2 = (z2**2) % self.p\n+        z2_3 = (z2_2 * z2) % self.p\n+        u1 = (x1 * z2_2) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s1 = (y1 * z2_3) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if u1 == u2:\n+            if (s1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - u1\n+        r = s2 - s1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (u1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def mul(self, ps):\n+        \"\"\"Compute a (multi) point multiplication\n+\n+        ps is a list of (Jacobian tuple, scalar) pairs.\n+        \"\"\"\n+        r = (0, 1, 0)\n+        for i in range(255, -1, -1):\n+            r = self.double(r)\n+            for (p, n) in ps:\n+                if ((n >> i) & 1):\n+                    r = self.add(r, p)\n+        return r\n+\n+SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n-# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n-def _check_result(val, func, args):\n-    if val == 0:\n-        raise ValueError\n-    else:\n-        return ctypes.c_void_p (val)\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n-\n-class CECKey():\n-    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n-\n-    POINT_CONVERSION_COMPRESSED = 2\n-    POINT_CONVERSION_UNCOMPRESSED = 4\n+class ECPubKey():\n+    \"\"\"A secp256k1 public key\"\"\"\n \n     def __init__(self):\n-        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n-\n-    def __del__(self):\n-        if ssl:\n-            ssl.EC_KEY_free(self.k)\n-        self.k = None\n-\n-    def set_secretbytes(self, secret):\n-        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n-        group = ssl.EC_KEY_get0_group(self.k)\n-        pub_key = ssl.EC_POINT_new(group)\n-        ctx = ssl.BN_CTX_new()\n-        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n-            raise ValueError(\"Could not derive public key from the supplied secret.\")\n-        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n-        ssl.EC_KEY_set_private_key(self.k, priv_key)\n-        ssl.EC_KEY_set_public_key(self.k, pub_key)\n-        ssl.EC_POINT_free(pub_key)\n-        ssl.BN_CTX_free(ctx)\n-        return self.k\n-\n-    def set_privkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def set_pubkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def get_privkey(self):\n-        size = ssl.i2d_ECPrivateKey(self.k, 0)\n-        mb_pri = ctypes.create_string_buffer(size)\n-        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n-        return mb_pri.raw\n-\n-    def get_pubkey(self):\n-        size = ssl.i2o_ECPublicKey(self.k, 0)\n-        mb = ctypes.create_string_buffer(size)\n-        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n-        return mb.raw\n-\n-    def get_raw_ecdh_key(self, other_pubkey):\n-        ecdh_keybuffer = ctypes.create_string_buffer(32)\n-        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n-                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n-                                 self.k, 0)\n-        if r != 32:\n-            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n-        return ecdh_keybuffer.raw\n-\n-    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n-        # FIXME: be warned it's not clear what the kdf should be as a default\n-        r = self.get_raw_ecdh_key(other_pubkey)\n-        return kdf(r)\n-\n-    def sign(self, hash, low_s = True):\n-        # FIXME: need unit tests for below cases\n-        if not isinstance(hash, bytes):\n-            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n-        if len(hash) != 32:\n-            raise ValueError('Hash must be exactly 32 bytes long')\n-\n-        sig_size0 = ctypes.c_uint32()\n-        sig_size0.value = ssl.ECDSA_size(self.k)\n-        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n-        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n-        assert 1 == result\n-        assert mb_sig.raw[0] == 0x30\n-        assert mb_sig.raw[1] == sig_size0.value - 2\n-        total_size = mb_sig.raw[1]\n-        assert mb_sig.raw[2] == 2\n-        r_size = mb_sig.raw[3]\n-        assert mb_sig.raw[4 + r_size] == 2\n-        s_size = mb_sig.raw[5 + r_size]\n-        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n-        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n-            return mb_sig.raw[:sig_size0.value]\n-        else:\n-            low_s_value = SECP256K1_ORDER - s_value\n-            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n-            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n-                low_s_bytes = low_s_bytes[1:]\n-            new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n-            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n-\n-    def verify(self, hash, sig):\n-        \"\"\"Verify a DER signature\"\"\"\n-        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n-\n-    def set_compressed(self, compressed):\n-        if compressed:\n-            form = self.POINT_CONVERSION_COMPRESSED\n+        \"\"\"Construct an uninitialized public key\"\"\"\n+        self.valid = False\n+\n+    def set(self, data):\n+        \"\"\"Construct a public key from a serialization in compressed or uncompressed format\"\"\"\n+        if (len(data) == 65 and data[0] == 0x04):\n+            p = (int.from_bytes(data[1:33], 'big'), int.from_bytes(data[33:65], 'big'), 1)\n+            self.valid = SECP256K1.on_curve(p)\n+            if self.valid:\n+                self.p = p\n+                self.compressed = False\n+        elif (len(data) == 33 and (data[0] == 0x02 or data[0] == 0x03)):\n+            x = int.from_bytes(data[1:33], 'big')\n+            if SECP256K1.is_x_coord(x):\n+                p = SECP256K1.lift_x(x)\n+                if (p[1] & 1) != (data[0] & 1):\n+                    p = SECP256K1.negate(p)\n+                self.p = p\n+                self.valid = True\n+                self.compressed = True\n+            else:\n+                self.valid = False\n         else:\n-            form = self.POINT_CONVERSION_UNCOMPRESSED\n-        ssl.EC_KEY_set_conv_form(self.k, form)\n-\n+            self.valid = False\n \n-class CPubKey(bytes):\n-    \"\"\"An encapsulated public key\n-\n-    Attributes:\n+    @property\n+    def is_compressed(self):\n+        return self.compressed\n \n-    is_valid      - Corresponds to CPubKey.IsValid()\n-    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n-    is_compressed - Corresponds to CPubKey.IsCompressed()\n-    \"\"\"\n+    @property\n+    def is_valid(self):\n+        return self.valid\n+\n+    def get_bytes(self):\n+        assert(self.valid)\n+        p = SECP256K1.affine(self.p)\n+        if p is None:\n+            return None\n+        if self.compressed:\n+            return bytes([0x02 + (p[1] & 1)]) + p[0].to_bytes(32, 'big')\n+        else:\n+            return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n+\n+    def verify_ecdsa(self, sig, msg, low_s=True):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275756645",
      "id" : 275756645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NTc1NjY0NQ==",
      "original_commit_id" : "b567f723b9a1bd888a7880781cb9982514425380",
      "original_position" : 414,
      "path" : "test/functional/test_framework/key.py",
      "position" : 431,
      "pull_request_review_id" : 227142044,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275756645",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Makes it easier to run the tests on native windows, where I couldn't figure out how to install that library\r\n\r\nThat seems like a good motivation for making a change like this, but I'm curious if there are other reasons as well?",
      "created_at" : "2019-04-16T11:56:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483628933",
      "id" : 483628933,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzYyODkzMw==",
      "updated_at" : "2019-04-16T11:56:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483628933",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sdaftuar The original motivation was that for testing a Schnorr signature implementation we'll want a Python version to test against, which needs much of this logic anyway, and it felt silly to maintain two independent versions just for testing (especially as one relies on OpenSSL we're trying to get rid of as a dependency).\n\n@MarcoFalke I added the verify_ecdsa function to test the sign_ecdsa code while writing it, but expect it may be useful to test against the Bitcoin Core signing code. I can either make the linter ignore it, or at a simple test that invokes it. Up to you.",
      "created_at" : "2019-04-16T17:07:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483761823",
      "id" : 483761823,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4Mzc2MTgyMw==",
      "updated_at" : "2019-04-16T17:07:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483761823",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yeah, having a test that `verify_ecdsa`s a Bitcoin Core generated signature would be nice",
      "created_at" : "2019-04-16T19:26:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483810752",
      "id" : 483810752,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzgxMDc1Mg==",
      "updated_at" : "2019-04-16T19:26:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483810752",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275963052"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275963052"
         }
      },
      "author_association" : "MEMBER",
      "body" : "unused import `ECPubKey`",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-16T19:46:55Z",
      "diff_hunk" : "@@ -9,7 +9,7 @@\n import time\n \n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n-from test_framework.key import CECKey, CPubKey\n+from test_framework.key import ECKey, ECPubKey",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275963052",
      "id" : 275963052,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NTk2MzA1Mg==",
      "original_commit_id" : "b567f723b9a1bd888a7880781cb9982514425380",
      "original_position" : 5,
      "path" : "test/functional/p2p_segwit.py",
      "position" : null,
      "pull_request_review_id" : 227407184,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275963052",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275968215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275968215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Gone.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-16T20:00:51Z",
      "diff_hunk" : "@@ -9,7 +9,7 @@\n import time\n \n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment, get_witness_script, WITNESS_COMMITMENT_HEADER\n-from test_framework.key import CECKey, CPubKey\n+from test_framework.key import ECKey, ECPubKey",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r275968215",
      "id" : 275968215,
      "in_reply_to_id" : 275963052,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NTk2ODIxNQ==",
      "original_commit_id" : "b567f723b9a1bd888a7880781cb9982514425380",
      "original_position" : 5,
      "path" : "test/functional/p2p_segwit.py",
      "position" : null,
      "pull_request_review_id" : 227413798,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/275968215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've added ecdsa_verify to the ignore list. I'll try to write a test that actually uses it, but it's not that trivial either.",
      "created_at" : "2019-04-16T20:02:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483822298",
      "id" : 483822298,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzgyMjI5OA==",
      "updated_at" : "2019-04-16T20:02:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483822298",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "At a glance this looks fine, I was going to urge you to put a really strong warning on it, but the warning looks adequate.  I'm not going to give this any cryptographic review because I don't think it needs/deserves any.",
      "created_at" : "2019-04-17T01:15:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-483900004",
      "id" : 483900004,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4MzkwMDAwNA==",
      "updated_at" : "2019-04-17T01:15:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/483900004",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276261481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276261481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not that it matters for this application since you only call this with +ve n, but I believe this should be:\r\n\r\n```python\r\nt = 1 if n > 0 else -1\r\n```",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T14:11:55Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    if n == 0:\n+        return 0\n+    t = 1 if n > 0 else 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276261481",
      "id" : 276261481,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjI2MTQ4MQ==",
      "original_commit_id" : "048cbc48684d88af739d778707766ed08b0d5040",
      "original_position" : 100,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 227779474,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276261481",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276289233"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276289233"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That would not be correct (I represent the \"t\" variable from the Wikipedia article as 0/1 rather than 1/-1, so that I can use xor operations to flip it).",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T15:04:24Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    if n == 0:\n+        return 0\n+    t = 1 if n > 0 else 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276289233",
      "id" : 276289233,
      "in_reply_to_id" : 276261481,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjI4OTIzMw==",
      "original_commit_id" : "048cbc48684d88af739d778707766ed08b0d5040",
      "original_position" : 100,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 227814759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276289233",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276340483"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276340483"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As discussed on IRC, I believe this (and the wikipedia Lua code that it's based on) is incorrect when passed -ve a (I believe the bug probably stems from the misunderstanding that % in python and lua represents the remainder, not the modulus, so a % n is negative when n is negative).\r\n\r\nSimplest fix is:\r\n\r\n```python\r\n    assert k > 0 and k % 2\r\n    n = n % k\r\n    t = 1\r\n```",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T16:57:29Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    if n == 0:\n+        return 0\n+    t = 1 if n > 0 else 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276340483",
      "id" : 276340483,
      "in_reply_to_id" : 276261481,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjM0MDQ4Mw==",
      "original_commit_id" : "048cbc48684d88af739d778707766ed08b0d5040",
      "original_position" : 100,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 227879441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276340483",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276351776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276351776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jnewbery Nice catch, fixed. You've inadvertently fixed another bug, I suspect, namely that `jacobi_symbol(0,1)` is supposed to be 1, not 0.\r\n\r\nNote to reviewers: this bug doesn't affect our use, as we never invoke with n<0 or k=1.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T17:26:55Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    if n == 0:\n+        return 0\n+    t = 1 if n > 0 else 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276351776",
      "id" : 276351776,
      "in_reply_to_id" : 276261481,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjM1MTc3Ng==",
      "original_commit_id" : "048cbc48684d88af739d778707766ed08b0d5040",
      "original_position" : 100,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 227893614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276351776",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This will be merged next Monday unless there are objections",
      "created_at" : "2019-04-17T18:29:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-484208598",
      "id" : 484208598,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4NDIwODU5OA==",
      "updated_at" : "2019-04-17T18:29:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/484208598",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276409021"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276409021"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Again, not a problem for this application since a=0 in secp256k1, but I think this should be:\r\n\r\n```python\r\nreturn z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\r\n```\r\n\r\n(ie the self.a term should be multiplied by `z4` so that all terms in the eliptic curve equation have a common z^6 factor that can be cancelled)",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T19:57:31Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276409021",
      "id" : 276409021,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQwOTAyMQ==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 149,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 227966533,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276409021",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276434022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276434022"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note that you can also do ceiling division with `-(-r.bit_length() // 8)`. I'm not sure if that's any more readable though.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T21:06:53Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def add(self, p1, p2):\n+        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        if z1 == 0:\n+            return p2\n+        if z2 == 0:\n+            return p1\n+        if z1 == 1:\n+            return self.add_mixed(p2, p1)\n+        if z2 == 1:\n+            return self.add_mixed(p1, p2)\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        z2_2 = (z2**2) % self.p\n+        z2_3 = (z2_2 * z2) % self.p\n+        u1 = (x1 * z2_2) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s1 = (y1 * z2_3) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if u1 == u2:\n+            if (s1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - u1\n+        r = s2 - s1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (u1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def mul(self, ps):\n+        \"\"\"Compute a (multi) point multiplication\n+\n+        ps is a list of (Jacobian tuple, scalar) pairs.\n+        \"\"\"\n+        r = (0, 1, 0)\n+        for i in range(255, -1, -1):\n+            r = self.double(r)\n+            for (p, n) in ps:\n+                if ((n >> i) & 1):\n+                    r = self.add(r, p)\n+        return r\n+\n+SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n-# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n-def _check_result(val, func, args):\n-    if val == 0:\n-        raise ValueError\n-    else:\n-        return ctypes.c_void_p (val)\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n-\n-class CECKey():\n-    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n-\n-    POINT_CONVERSION_COMPRESSED = 2\n-    POINT_CONVERSION_UNCOMPRESSED = 4\n+class ECPubKey():\n+    \"\"\"A secp256k1 public key\"\"\"\n \n     def __init__(self):\n-        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n-\n-    def __del__(self):\n-        if ssl:\n-            ssl.EC_KEY_free(self.k)\n-        self.k = None\n-\n-    def set_secretbytes(self, secret):\n-        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n-        group = ssl.EC_KEY_get0_group(self.k)\n-        pub_key = ssl.EC_POINT_new(group)\n-        ctx = ssl.BN_CTX_new()\n-        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n-            raise ValueError(\"Could not derive public key from the supplied secret.\")\n-        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n-        ssl.EC_KEY_set_private_key(self.k, priv_key)\n-        ssl.EC_KEY_set_public_key(self.k, pub_key)\n-        ssl.EC_POINT_free(pub_key)\n-        ssl.BN_CTX_free(ctx)\n-        return self.k\n-\n-    def set_privkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def set_pubkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def get_privkey(self):\n-        size = ssl.i2d_ECPrivateKey(self.k, 0)\n-        mb_pri = ctypes.create_string_buffer(size)\n-        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n-        return mb_pri.raw\n-\n-    def get_pubkey(self):\n-        size = ssl.i2o_ECPublicKey(self.k, 0)\n-        mb = ctypes.create_string_buffer(size)\n-        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n-        return mb.raw\n-\n-    def get_raw_ecdh_key(self, other_pubkey):\n-        ecdh_keybuffer = ctypes.create_string_buffer(32)\n-        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n-                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n-                                 self.k, 0)\n-        if r != 32:\n-            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n-        return ecdh_keybuffer.raw\n-\n-    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n-        # FIXME: be warned it's not clear what the kdf should be as a default\n-        r = self.get_raw_ecdh_key(other_pubkey)\n-        return kdf(r)\n-\n-    def sign(self, hash, low_s = True):\n-        # FIXME: need unit tests for below cases\n-        if not isinstance(hash, bytes):\n-            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n-        if len(hash) != 32:\n-            raise ValueError('Hash must be exactly 32 bytes long')\n-\n-        sig_size0 = ctypes.c_uint32()\n-        sig_size0.value = ssl.ECDSA_size(self.k)\n-        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n-        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n-        assert 1 == result\n-        assert mb_sig.raw[0] == 0x30\n-        assert mb_sig.raw[1] == sig_size0.value - 2\n-        total_size = mb_sig.raw[1]\n-        assert mb_sig.raw[2] == 2\n-        r_size = mb_sig.raw[3]\n-        assert mb_sig.raw[4 + r_size] == 2\n-        s_size = mb_sig.raw[5 + r_size]\n-        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n-        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n-            return mb_sig.raw[:sig_size0.value]\n-        else:\n-            low_s_value = SECP256K1_ORDER - s_value\n-            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n-            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n-                low_s_bytes = low_s_bytes[1:]\n-            new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n-            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n-\n-    def verify(self, hash, sig):\n-        \"\"\"Verify a DER signature\"\"\"\n-        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n-\n-    def set_compressed(self, compressed):\n-        if compressed:\n-            form = self.POINT_CONVERSION_COMPRESSED\n+        \"\"\"Construct an uninitialized public key\"\"\"\n+        self.valid = False\n+\n+    def set(self, data):\n+        \"\"\"Construct a public key from a serialization in compressed or uncompressed format\"\"\"\n+        if (len(data) == 65 and data[0] == 0x04):\n+            p = (int.from_bytes(data[1:33], 'big'), int.from_bytes(data[33:65], 'big'), 1)\n+            self.valid = SECP256K1.on_curve(p)\n+            if self.valid:\n+                self.p = p\n+                self.compressed = False\n+        elif (len(data) == 33 and (data[0] == 0x02 or data[0] == 0x03)):\n+            x = int.from_bytes(data[1:33], 'big')\n+            if SECP256K1.is_x_coord(x):\n+                p = SECP256K1.lift_x(x)\n+                if (p[1] & 1) != (data[0] & 1):\n+                    p = SECP256K1.negate(p)\n+                self.p = p\n+                self.valid = True\n+                self.compressed = True\n+            else:\n+                self.valid = False\n         else:\n-            form = self.POINT_CONVERSION_UNCOMPRESSED\n-        ssl.EC_KEY_set_conv_form(self.k, form)\n-\n+            self.valid = False\n \n-class CPubKey(bytes):\n-    \"\"\"An encapsulated public key\n-\n-    Attributes:\n+    @property\n+    def is_compressed(self):\n+        return self.compressed\n \n-    is_valid      - Corresponds to CPubKey.IsValid()\n-    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n-    is_compressed - Corresponds to CPubKey.IsCompressed()\n-    \"\"\"\n+    @property\n+    def is_valid(self):\n+        return self.valid\n+\n+    def get_bytes(self):\n+        assert(self.valid)\n+        p = SECP256K1.affine(self.p)\n+        if p is None:\n+            return None\n+        if self.compressed:\n+            return bytes([0x02 + (p[1] & 1)]) + p[0].to_bytes(32, 'big')\n+        else:\n+            return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n+\n+    def verify_ecdsa(self, sig, msg, low_s=True):\n+        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\"\"\"\n+        assert(self.valid)\n+        if (sig[1] + 2 != len(sig)):\n+            return False\n+        if (len(sig) < 4):\n+            return False\n+        if (sig[0] != 0x30):\n+            return False\n+        if (sig[2] != 0x02):\n+            return False\n+        rlen = sig[3]\n+        if (len(sig) < 6 + rlen):\n+            return False\n+        if rlen < 1 or rlen > 33:\n+            return False\n+        if sig[4] >= 0x80:\n+            return False\n+        if (rlen > 1 and (sig[4] == 0) and not (sig[5] & 0x80)):\n+            return False\n+        r = int.from_bytes(sig[4:4+rlen], 'big')\n+        if (sig[4+rlen] != 0x02):\n+            return False\n+        slen = sig[5+rlen]\n+        if slen < 1 or slen > 33:\n+            return False\n+        if (len(sig) != 6 + rlen + slen):\n+            return False\n+        if sig[6+rlen] >= 0x80:\n+            return False\n+        if (slen > 1 and (sig[6+rlen] == 0) and not (sig[7+rlen] & 0x80)):\n+            return False\n+        s = int.from_bytes(sig[6+rlen:6+rlen+slen], 'big')\n+        if r < 1 or s < 1 or r >= SECP256K1_ORDER or s >= SECP256K1_ORDER:\n+            return False\n+        if low_s and s >= SECP256K1_ORDER_HALF:\n+            return False\n+        z = int.from_bytes(msg, 'big')\n+        w = modinv(s, SECP256K1_ORDER)\n+        u1 = z*w % SECP256K1_ORDER\n+        u2 = r*w % SECP256K1_ORDER\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, u1), (self.p, u2)]))\n+        if R is None or R[0] != r:\n+            return False\n+        return True\n+\n+class ECKey():\n+    \"\"\"A secp256k1 private key\"\"\"\n \n-    def __new__(cls, buf, _cec_key=None):\n-        self = super(CPubKey, cls).__new__(cls, buf)\n-        if _cec_key is None:\n-            _cec_key = CECKey()\n-        self._cec_key = _cec_key\n-        self.is_fullyvalid = _cec_key.set_pubkey(self) != 0\n-        return self\n+    def __init__(self):\n+        self.valid = False\n+\n+    def set(self, secret, compressed):\n+        \"\"\"Construct a private key object with given 32-byte secret and compressed flag.\"\"\"\n+        assert(len(secret) == 32)\n+        secret = int.from_bytes(secret, 'big')\n+        self.valid = (secret > 0 and secret < SECP256K1_ORDER)\n+        if self.valid:\n+            self.secret = secret\n+            self.compressed = compressed\n+\n+    def generate(self, compressed=True):\n+        \"\"\"Generate a random private key (compressed or uncompressed).\"\"\"\n+        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)\n+\n+    def get_bytes(self):\n+        \"\"\"Retrieve the 32-byte representation of this key.\"\"\"\n+        assert(self.valid)\n+        return self.secret.to_bytes(32, 'big')\n \n     @property\n     def is_valid(self):\n-        return len(self) > 0\n+        return self.valid\n \n     @property\n     def is_compressed(self):\n-        return len(self) == 33\n-\n-    def verify(self, hash, sig):\n-        return self._cec_key.verify(hash, sig)\n-\n-    def __str__(self):\n-        return repr(self)\n-\n-    def __repr__(self):\n-        return '%s(%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+        return self.compressed\n \n+    def get_pubkey(self):\n+        \"\"\"Compute an ECPubKey object for this secret key.\"\"\"\n+        assert(self.valid)\n+        ret = ECPubKey()\n+        p = SECP256K1.mul([(SECP256K1_G, self.secret)])\n+        ret.p = p\n+        ret.valid = True\n+        ret.compressed = self.compressed\n+        return ret\n+\n+    def sign_ecdsa(self, msg, low_s=True):\n+        \"\"\"Construct a DER-encoded ECDSA signature with this key.\"\"\"\n+        assert(self.valid)\n+        z = int.from_bytes(msg, 'big')\n+        # Note: no RFC6979, but a simple random nonce (some tests rely on distinct transactions for the same operation)\n+        k = random.randrange(1, SECP256K1_ORDER)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, k)]))\n+        r = R[0] % SECP256K1_ORDER\n+        s = (modinv(k, SECP256K1_ORDER) * (z + self.secret * r)) % SECP256K1_ORDER\n+        if low_s and s > SECP256K1_ORDER_HALF:\n+            s = SECP256K1_ORDER - s\n+        rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276434022",
      "id" : 276434022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQzNDAyMg==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 544,
      "path" : "test/functional/test_framework/key.py",
      "position" : 548,
      "pull_request_review_id" : 227998868,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276434022",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276434289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276434289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Does the project have a policy on individual contributors' copyright notices in source files? Do you also want to include the MIT license boilerplate here too?",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T21:07:40Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276434289",
      "id" : 276434289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQzNDI4OQ==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 3,
      "path" : "test/functional/test_framework/key.py",
      "position" : 3,
      "pull_request_review_id" : 227999237,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276434289",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276436540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276436540"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't want a ceiling division; i want a flooring one plus 1 (255 should become 32, but 256 should become 33).",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T21:13:59Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def add(self, p1, p2):\n+        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        if z1 == 0:\n+            return p2\n+        if z2 == 0:\n+            return p1\n+        if z1 == 1:\n+            return self.add_mixed(p2, p1)\n+        if z2 == 1:\n+            return self.add_mixed(p1, p2)\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        z2_2 = (z2**2) % self.p\n+        z2_3 = (z2_2 * z2) % self.p\n+        u1 = (x1 * z2_2) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s1 = (y1 * z2_3) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if u1 == u2:\n+            if (s1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - u1\n+        r = s2 - s1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (u1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def mul(self, ps):\n+        \"\"\"Compute a (multi) point multiplication\n+\n+        ps is a list of (Jacobian tuple, scalar) pairs.\n+        \"\"\"\n+        r = (0, 1, 0)\n+        for i in range(255, -1, -1):\n+            r = self.double(r)\n+            for (p, n) in ps:\n+                if ((n >> i) & 1):\n+                    r = self.add(r, p)\n+        return r\n+\n+SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n-# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n-def _check_result(val, func, args):\n-    if val == 0:\n-        raise ValueError\n-    else:\n-        return ctypes.c_void_p (val)\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n-\n-class CECKey():\n-    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n-\n-    POINT_CONVERSION_COMPRESSED = 2\n-    POINT_CONVERSION_UNCOMPRESSED = 4\n+class ECPubKey():\n+    \"\"\"A secp256k1 public key\"\"\"\n \n     def __init__(self):\n-        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n-\n-    def __del__(self):\n-        if ssl:\n-            ssl.EC_KEY_free(self.k)\n-        self.k = None\n-\n-    def set_secretbytes(self, secret):\n-        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n-        group = ssl.EC_KEY_get0_group(self.k)\n-        pub_key = ssl.EC_POINT_new(group)\n-        ctx = ssl.BN_CTX_new()\n-        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n-            raise ValueError(\"Could not derive public key from the supplied secret.\")\n-        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n-        ssl.EC_KEY_set_private_key(self.k, priv_key)\n-        ssl.EC_KEY_set_public_key(self.k, pub_key)\n-        ssl.EC_POINT_free(pub_key)\n-        ssl.BN_CTX_free(ctx)\n-        return self.k\n-\n-    def set_privkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def set_pubkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def get_privkey(self):\n-        size = ssl.i2d_ECPrivateKey(self.k, 0)\n-        mb_pri = ctypes.create_string_buffer(size)\n-        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n-        return mb_pri.raw\n-\n-    def get_pubkey(self):\n-        size = ssl.i2o_ECPublicKey(self.k, 0)\n-        mb = ctypes.create_string_buffer(size)\n-        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n-        return mb.raw\n-\n-    def get_raw_ecdh_key(self, other_pubkey):\n-        ecdh_keybuffer = ctypes.create_string_buffer(32)\n-        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n-                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n-                                 self.k, 0)\n-        if r != 32:\n-            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n-        return ecdh_keybuffer.raw\n-\n-    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n-        # FIXME: be warned it's not clear what the kdf should be as a default\n-        r = self.get_raw_ecdh_key(other_pubkey)\n-        return kdf(r)\n-\n-    def sign(self, hash, low_s = True):\n-        # FIXME: need unit tests for below cases\n-        if not isinstance(hash, bytes):\n-            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n-        if len(hash) != 32:\n-            raise ValueError('Hash must be exactly 32 bytes long')\n-\n-        sig_size0 = ctypes.c_uint32()\n-        sig_size0.value = ssl.ECDSA_size(self.k)\n-        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n-        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n-        assert 1 == result\n-        assert mb_sig.raw[0] == 0x30\n-        assert mb_sig.raw[1] == sig_size0.value - 2\n-        total_size = mb_sig.raw[1]\n-        assert mb_sig.raw[2] == 2\n-        r_size = mb_sig.raw[3]\n-        assert mb_sig.raw[4 + r_size] == 2\n-        s_size = mb_sig.raw[5 + r_size]\n-        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n-        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n-            return mb_sig.raw[:sig_size0.value]\n-        else:\n-            low_s_value = SECP256K1_ORDER - s_value\n-            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n-            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n-                low_s_bytes = low_s_bytes[1:]\n-            new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n-            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n-\n-    def verify(self, hash, sig):\n-        \"\"\"Verify a DER signature\"\"\"\n-        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n-\n-    def set_compressed(self, compressed):\n-        if compressed:\n-            form = self.POINT_CONVERSION_COMPRESSED\n+        \"\"\"Construct an uninitialized public key\"\"\"\n+        self.valid = False\n+\n+    def set(self, data):\n+        \"\"\"Construct a public key from a serialization in compressed or uncompressed format\"\"\"\n+        if (len(data) == 65 and data[0] == 0x04):\n+            p = (int.from_bytes(data[1:33], 'big'), int.from_bytes(data[33:65], 'big'), 1)\n+            self.valid = SECP256K1.on_curve(p)\n+            if self.valid:\n+                self.p = p\n+                self.compressed = False\n+        elif (len(data) == 33 and (data[0] == 0x02 or data[0] == 0x03)):\n+            x = int.from_bytes(data[1:33], 'big')\n+            if SECP256K1.is_x_coord(x):\n+                p = SECP256K1.lift_x(x)\n+                if (p[1] & 1) != (data[0] & 1):\n+                    p = SECP256K1.negate(p)\n+                self.p = p\n+                self.valid = True\n+                self.compressed = True\n+            else:\n+                self.valid = False\n         else:\n-            form = self.POINT_CONVERSION_UNCOMPRESSED\n-        ssl.EC_KEY_set_conv_form(self.k, form)\n-\n+            self.valid = False\n \n-class CPubKey(bytes):\n-    \"\"\"An encapsulated public key\n-\n-    Attributes:\n+    @property\n+    def is_compressed(self):\n+        return self.compressed\n \n-    is_valid      - Corresponds to CPubKey.IsValid()\n-    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n-    is_compressed - Corresponds to CPubKey.IsCompressed()\n-    \"\"\"\n+    @property\n+    def is_valid(self):\n+        return self.valid\n+\n+    def get_bytes(self):\n+        assert(self.valid)\n+        p = SECP256K1.affine(self.p)\n+        if p is None:\n+            return None\n+        if self.compressed:\n+            return bytes([0x02 + (p[1] & 1)]) + p[0].to_bytes(32, 'big')\n+        else:\n+            return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n+\n+    def verify_ecdsa(self, sig, msg, low_s=True):\n+        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\"\"\"\n+        assert(self.valid)\n+        if (sig[1] + 2 != len(sig)):\n+            return False\n+        if (len(sig) < 4):\n+            return False\n+        if (sig[0] != 0x30):\n+            return False\n+        if (sig[2] != 0x02):\n+            return False\n+        rlen = sig[3]\n+        if (len(sig) < 6 + rlen):\n+            return False\n+        if rlen < 1 or rlen > 33:\n+            return False\n+        if sig[4] >= 0x80:\n+            return False\n+        if (rlen > 1 and (sig[4] == 0) and not (sig[5] & 0x80)):\n+            return False\n+        r = int.from_bytes(sig[4:4+rlen], 'big')\n+        if (sig[4+rlen] != 0x02):\n+            return False\n+        slen = sig[5+rlen]\n+        if slen < 1 or slen > 33:\n+            return False\n+        if (len(sig) != 6 + rlen + slen):\n+            return False\n+        if sig[6+rlen] >= 0x80:\n+            return False\n+        if (slen > 1 and (sig[6+rlen] == 0) and not (sig[7+rlen] & 0x80)):\n+            return False\n+        s = int.from_bytes(sig[6+rlen:6+rlen+slen], 'big')\n+        if r < 1 or s < 1 or r >= SECP256K1_ORDER or s >= SECP256K1_ORDER:\n+            return False\n+        if low_s and s >= SECP256K1_ORDER_HALF:\n+            return False\n+        z = int.from_bytes(msg, 'big')\n+        w = modinv(s, SECP256K1_ORDER)\n+        u1 = z*w % SECP256K1_ORDER\n+        u2 = r*w % SECP256K1_ORDER\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, u1), (self.p, u2)]))\n+        if R is None or R[0] != r:\n+            return False\n+        return True\n+\n+class ECKey():\n+    \"\"\"A secp256k1 private key\"\"\"\n \n-    def __new__(cls, buf, _cec_key=None):\n-        self = super(CPubKey, cls).__new__(cls, buf)\n-        if _cec_key is None:\n-            _cec_key = CECKey()\n-        self._cec_key = _cec_key\n-        self.is_fullyvalid = _cec_key.set_pubkey(self) != 0\n-        return self\n+    def __init__(self):\n+        self.valid = False\n+\n+    def set(self, secret, compressed):\n+        \"\"\"Construct a private key object with given 32-byte secret and compressed flag.\"\"\"\n+        assert(len(secret) == 32)\n+        secret = int.from_bytes(secret, 'big')\n+        self.valid = (secret > 0 and secret < SECP256K1_ORDER)\n+        if self.valid:\n+            self.secret = secret\n+            self.compressed = compressed\n+\n+    def generate(self, compressed=True):\n+        \"\"\"Generate a random private key (compressed or uncompressed).\"\"\"\n+        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)\n+\n+    def get_bytes(self):\n+        \"\"\"Retrieve the 32-byte representation of this key.\"\"\"\n+        assert(self.valid)\n+        return self.secret.to_bytes(32, 'big')\n \n     @property\n     def is_valid(self):\n-        return len(self) > 0\n+        return self.valid\n \n     @property\n     def is_compressed(self):\n-        return len(self) == 33\n-\n-    def verify(self, hash, sig):\n-        return self._cec_key.verify(hash, sig)\n-\n-    def __str__(self):\n-        return repr(self)\n-\n-    def __repr__(self):\n-        return '%s(%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+        return self.compressed\n \n+    def get_pubkey(self):\n+        \"\"\"Compute an ECPubKey object for this secret key.\"\"\"\n+        assert(self.valid)\n+        ret = ECPubKey()\n+        p = SECP256K1.mul([(SECP256K1_G, self.secret)])\n+        ret.p = p\n+        ret.valid = True\n+        ret.compressed = self.compressed\n+        return ret\n+\n+    def sign_ecdsa(self, msg, low_s=True):\n+        \"\"\"Construct a DER-encoded ECDSA signature with this key.\"\"\"\n+        assert(self.valid)\n+        z = int.from_bytes(msg, 'big')\n+        # Note: no RFC6979, but a simple random nonce (some tests rely on distinct transactions for the same operation)\n+        k = random.randrange(1, SECP256K1_ORDER)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, k)]))\n+        r = R[0] % SECP256K1_ORDER\n+        s = (modinv(k, SECP256K1_ORDER) * (z + self.secret * r)) % SECP256K1_ORDER\n+        if low_s and s > SECP256K1_ORDER_HALF:\n+            s = SECP256K1_ORDER - s\n+        rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276436540",
      "id" : 276436540,
      "in_reply_to_id" : 276434022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQzNjU0MA==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 544,
      "path" : "test/functional/test_framework/key.py",
      "position" : 548,
      "pull_request_review_id" : 228002081,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276436540",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276447177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276447177"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There are a few files with individual author's names. As the \"Copyright The Bitcoin Core contributors\" is likely meaningless I think listing actual authors is preferable when it's a well-defined set of people, but I don't feel strongly.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T21:47:29Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276447177",
      "id" : 276447177,
      "in_reply_to_id" : 276434289,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQ0NzE3Nw==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 3,
      "path" : "test/functional/test_framework/key.py",
      "position" : 3,
      "pull_request_review_id" : 228015423,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276447177",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276451984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276451984"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-17T22:03:55Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276451984",
      "id" : 276451984,
      "in_reply_to_id" : 276409021,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3NjQ1MTk4NA==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 149,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 228021369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276451984",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276754939"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276754939"
         }
      },
      "author_association" : "MEMBER",
      "body" : "oops. Thanks!",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-18T17:13:54Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z2 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def add(self, p1, p2):\n+        \"\"\"Add two Jacobian tuples p1 and p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        if z1 == 0:\n+            return p2\n+        if z2 == 0:\n+            return p1\n+        if z1 == 1:\n+            return self.add_mixed(p2, p1)\n+        if z2 == 1:\n+            return self.add_mixed(p1, p2)\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        z2_2 = (z2**2) % self.p\n+        z2_3 = (z2_2 * z2) % self.p\n+        u1 = (x1 * z2_2) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s1 = (y1 * z2_3) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if u1 == u2:\n+            if (s1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - u1\n+        r = s2 - s1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (u1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p\n+        return (x3, y3, z3)\n+\n+    def mul(self, ps):\n+        \"\"\"Compute a (multi) point multiplication\n+\n+        ps is a list of (Jacobian tuple, scalar) pairs.\n+        \"\"\"\n+        r = (0, 1, 0)\n+        for i in range(255, -1, -1):\n+            r = self.double(r)\n+            for (p, n) in ps:\n+                if ((n >> i) & 1):\n+                    r = self.add(r, p)\n+        return r\n+\n+SECP256K1 = EllipticCurve(2**256 - 2**32 - 977, 0, 7)\n+SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n-# Thx to Sam Devlin for the ctypes magic 64-bit fix.\n-def _check_result(val, func, args):\n-    if val == 0:\n-        raise ValueError\n-    else:\n-        return ctypes.c_void_p (val)\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.errcheck = _check_result\n-\n-class CECKey():\n-    \"\"\"Wrapper around OpenSSL's EC_KEY\"\"\"\n-\n-    POINT_CONVERSION_COMPRESSED = 2\n-    POINT_CONVERSION_UNCOMPRESSED = 4\n+class ECPubKey():\n+    \"\"\"A secp256k1 public key\"\"\"\n \n     def __init__(self):\n-        self.k = ssl.EC_KEY_new_by_curve_name(NID_secp256k1)\n-\n-    def __del__(self):\n-        if ssl:\n-            ssl.EC_KEY_free(self.k)\n-        self.k = None\n-\n-    def set_secretbytes(self, secret):\n-        priv_key = ssl.BN_bin2bn(secret, 32, ssl.BN_new())\n-        group = ssl.EC_KEY_get0_group(self.k)\n-        pub_key = ssl.EC_POINT_new(group)\n-        ctx = ssl.BN_CTX_new()\n-        if not ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx):\n-            raise ValueError(\"Could not derive public key from the supplied secret.\")\n-        ssl.EC_POINT_mul(group, pub_key, priv_key, None, None, ctx)\n-        ssl.EC_KEY_set_private_key(self.k, priv_key)\n-        ssl.EC_KEY_set_public_key(self.k, pub_key)\n-        ssl.EC_POINT_free(pub_key)\n-        ssl.BN_CTX_free(ctx)\n-        return self.k\n-\n-    def set_privkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.d2i_ECPrivateKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def set_pubkey(self, key):\n-        self.mb = ctypes.create_string_buffer(key)\n-        return ssl.o2i_ECPublicKey(ctypes.byref(self.k), ctypes.byref(ctypes.pointer(self.mb)), len(key))\n-\n-    def get_privkey(self):\n-        size = ssl.i2d_ECPrivateKey(self.k, 0)\n-        mb_pri = ctypes.create_string_buffer(size)\n-        ssl.i2d_ECPrivateKey(self.k, ctypes.byref(ctypes.pointer(mb_pri)))\n-        return mb_pri.raw\n-\n-    def get_pubkey(self):\n-        size = ssl.i2o_ECPublicKey(self.k, 0)\n-        mb = ctypes.create_string_buffer(size)\n-        ssl.i2o_ECPublicKey(self.k, ctypes.byref(ctypes.pointer(mb)))\n-        return mb.raw\n-\n-    def get_raw_ecdh_key(self, other_pubkey):\n-        ecdh_keybuffer = ctypes.create_string_buffer(32)\n-        r = ssl.ECDH_compute_key(ctypes.pointer(ecdh_keybuffer), 32,\n-                                 ssl.EC_KEY_get0_public_key(other_pubkey.k),\n-                                 self.k, 0)\n-        if r != 32:\n-            raise Exception('CKey.get_ecdh_key(): ECDH_compute_key() failed')\n-        return ecdh_keybuffer.raw\n-\n-    def get_ecdh_key(self, other_pubkey, kdf=lambda k: hashlib.sha256(k).digest()):\n-        # FIXME: be warned it's not clear what the kdf should be as a default\n-        r = self.get_raw_ecdh_key(other_pubkey)\n-        return kdf(r)\n-\n-    def sign(self, hash, low_s = True):\n-        # FIXME: need unit tests for below cases\n-        if not isinstance(hash, bytes):\n-            raise TypeError('Hash must be bytes instance; got %r' % hash.__class__)\n-        if len(hash) != 32:\n-            raise ValueError('Hash must be exactly 32 bytes long')\n-\n-        sig_size0 = ctypes.c_uint32()\n-        sig_size0.value = ssl.ECDSA_size(self.k)\n-        mb_sig = ctypes.create_string_buffer(sig_size0.value)\n-        result = ssl.ECDSA_sign(0, hash, len(hash), mb_sig, ctypes.byref(sig_size0), self.k)\n-        assert 1 == result\n-        assert mb_sig.raw[0] == 0x30\n-        assert mb_sig.raw[1] == sig_size0.value - 2\n-        total_size = mb_sig.raw[1]\n-        assert mb_sig.raw[2] == 2\n-        r_size = mb_sig.raw[3]\n-        assert mb_sig.raw[4 + r_size] == 2\n-        s_size = mb_sig.raw[5 + r_size]\n-        s_value = int.from_bytes(mb_sig.raw[6+r_size:6+r_size+s_size], byteorder='big')\n-        if (not low_s) or s_value <= SECP256K1_ORDER_HALF:\n-            return mb_sig.raw[:sig_size0.value]\n-        else:\n-            low_s_value = SECP256K1_ORDER - s_value\n-            low_s_bytes = (low_s_value).to_bytes(33, byteorder='big')\n-            while len(low_s_bytes) > 1 and low_s_bytes[0] == 0 and low_s_bytes[1] < 0x80:\n-                low_s_bytes = low_s_bytes[1:]\n-            new_s_size = len(low_s_bytes)\n-            new_total_size_byte = (total_size + new_s_size - s_size).to_bytes(1,byteorder='big')\n-            new_s_size_byte = (new_s_size).to_bytes(1,byteorder='big')\n-            return b'\\x30' + new_total_size_byte + mb_sig.raw[2:5+r_size] + new_s_size_byte + low_s_bytes\n-\n-    def verify(self, hash, sig):\n-        \"\"\"Verify a DER signature\"\"\"\n-        return ssl.ECDSA_verify(0, hash, len(hash), sig, len(sig), self.k) == 1\n-\n-    def set_compressed(self, compressed):\n-        if compressed:\n-            form = self.POINT_CONVERSION_COMPRESSED\n+        \"\"\"Construct an uninitialized public key\"\"\"\n+        self.valid = False\n+\n+    def set(self, data):\n+        \"\"\"Construct a public key from a serialization in compressed or uncompressed format\"\"\"\n+        if (len(data) == 65 and data[0] == 0x04):\n+            p = (int.from_bytes(data[1:33], 'big'), int.from_bytes(data[33:65], 'big'), 1)\n+            self.valid = SECP256K1.on_curve(p)\n+            if self.valid:\n+                self.p = p\n+                self.compressed = False\n+        elif (len(data) == 33 and (data[0] == 0x02 or data[0] == 0x03)):\n+            x = int.from_bytes(data[1:33], 'big')\n+            if SECP256K1.is_x_coord(x):\n+                p = SECP256K1.lift_x(x)\n+                if (p[1] & 1) != (data[0] & 1):\n+                    p = SECP256K1.negate(p)\n+                self.p = p\n+                self.valid = True\n+                self.compressed = True\n+            else:\n+                self.valid = False\n         else:\n-            form = self.POINT_CONVERSION_UNCOMPRESSED\n-        ssl.EC_KEY_set_conv_form(self.k, form)\n-\n+            self.valid = False\n \n-class CPubKey(bytes):\n-    \"\"\"An encapsulated public key\n-\n-    Attributes:\n+    @property\n+    def is_compressed(self):\n+        return self.compressed\n \n-    is_valid      - Corresponds to CPubKey.IsValid()\n-    is_fullyvalid - Corresponds to CPubKey.IsFullyValid()\n-    is_compressed - Corresponds to CPubKey.IsCompressed()\n-    \"\"\"\n+    @property\n+    def is_valid(self):\n+        return self.valid\n+\n+    def get_bytes(self):\n+        assert(self.valid)\n+        p = SECP256K1.affine(self.p)\n+        if p is None:\n+            return None\n+        if self.compressed:\n+            return bytes([0x02 + (p[1] & 1)]) + p[0].to_bytes(32, 'big')\n+        else:\n+            return bytes([0x04]) + p[0].to_bytes(32, 'big') + p[1].to_bytes(32, 'big')\n+\n+    def verify_ecdsa(self, sig, msg, low_s=True):\n+        \"\"\"Verify a strictly DER-encoded ECDSA signature against this pubkey.\"\"\"\n+        assert(self.valid)\n+        if (sig[1] + 2 != len(sig)):\n+            return False\n+        if (len(sig) < 4):\n+            return False\n+        if (sig[0] != 0x30):\n+            return False\n+        if (sig[2] != 0x02):\n+            return False\n+        rlen = sig[3]\n+        if (len(sig) < 6 + rlen):\n+            return False\n+        if rlen < 1 or rlen > 33:\n+            return False\n+        if sig[4] >= 0x80:\n+            return False\n+        if (rlen > 1 and (sig[4] == 0) and not (sig[5] & 0x80)):\n+            return False\n+        r = int.from_bytes(sig[4:4+rlen], 'big')\n+        if (sig[4+rlen] != 0x02):\n+            return False\n+        slen = sig[5+rlen]\n+        if slen < 1 or slen > 33:\n+            return False\n+        if (len(sig) != 6 + rlen + slen):\n+            return False\n+        if sig[6+rlen] >= 0x80:\n+            return False\n+        if (slen > 1 and (sig[6+rlen] == 0) and not (sig[7+rlen] & 0x80)):\n+            return False\n+        s = int.from_bytes(sig[6+rlen:6+rlen+slen], 'big')\n+        if r < 1 or s < 1 or r >= SECP256K1_ORDER or s >= SECP256K1_ORDER:\n+            return False\n+        if low_s and s >= SECP256K1_ORDER_HALF:\n+            return False\n+        z = int.from_bytes(msg, 'big')\n+        w = modinv(s, SECP256K1_ORDER)\n+        u1 = z*w % SECP256K1_ORDER\n+        u2 = r*w % SECP256K1_ORDER\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, u1), (self.p, u2)]))\n+        if R is None or R[0] != r:\n+            return False\n+        return True\n+\n+class ECKey():\n+    \"\"\"A secp256k1 private key\"\"\"\n \n-    def __new__(cls, buf, _cec_key=None):\n-        self = super(CPubKey, cls).__new__(cls, buf)\n-        if _cec_key is None:\n-            _cec_key = CECKey()\n-        self._cec_key = _cec_key\n-        self.is_fullyvalid = _cec_key.set_pubkey(self) != 0\n-        return self\n+    def __init__(self):\n+        self.valid = False\n+\n+    def set(self, secret, compressed):\n+        \"\"\"Construct a private key object with given 32-byte secret and compressed flag.\"\"\"\n+        assert(len(secret) == 32)\n+        secret = int.from_bytes(secret, 'big')\n+        self.valid = (secret > 0 and secret < SECP256K1_ORDER)\n+        if self.valid:\n+            self.secret = secret\n+            self.compressed = compressed\n+\n+    def generate(self, compressed=True):\n+        \"\"\"Generate a random private key (compressed or uncompressed).\"\"\"\n+        self.set(random.randrange(1, SECP256K1_ORDER).to_bytes(32, 'big'), compressed)\n+\n+    def get_bytes(self):\n+        \"\"\"Retrieve the 32-byte representation of this key.\"\"\"\n+        assert(self.valid)\n+        return self.secret.to_bytes(32, 'big')\n \n     @property\n     def is_valid(self):\n-        return len(self) > 0\n+        return self.valid\n \n     @property\n     def is_compressed(self):\n-        return len(self) == 33\n-\n-    def verify(self, hash, sig):\n-        return self._cec_key.verify(hash, sig)\n-\n-    def __str__(self):\n-        return repr(self)\n-\n-    def __repr__(self):\n-        return '%s(%s)' % (self.__class__.__name__, super(CPubKey, self).__repr__())\n+        return self.compressed\n \n+    def get_pubkey(self):\n+        \"\"\"Compute an ECPubKey object for this secret key.\"\"\"\n+        assert(self.valid)\n+        ret = ECPubKey()\n+        p = SECP256K1.mul([(SECP256K1_G, self.secret)])\n+        ret.p = p\n+        ret.valid = True\n+        ret.compressed = self.compressed\n+        return ret\n+\n+    def sign_ecdsa(self, msg, low_s=True):\n+        \"\"\"Construct a DER-encoded ECDSA signature with this key.\"\"\"\n+        assert(self.valid)\n+        z = int.from_bytes(msg, 'big')\n+        # Note: no RFC6979, but a simple random nonce (some tests rely on distinct transactions for the same operation)\n+        k = random.randrange(1, SECP256K1_ORDER)\n+        R = SECP256K1.affine(SECP256K1.mul([(SECP256K1_G, k)]))\n+        r = R[0] % SECP256K1_ORDER\n+        s = (modinv(k, SECP256K1_ORDER) * (z + self.secret * r)) % SECP256K1_ORDER\n+        if low_s and s > SECP256K1_ORDER_HALF:\n+            s = SECP256K1_ORDER - s\n+        rb = r.to_bytes((r.bit_length() + 8) // 8, 'big')",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276754939",
      "id" : 276754939,
      "in_reply_to_id" : 276434022,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3Njc1NDkzOQ==",
      "original_commit_id" : "c01a1b9e1e676107aaebf176baeb305738b7064b",
      "original_position" : 544,
      "path" : "test/functional/test_framework/key.py",
      "position" : 548,
      "pull_request_review_id" : 228405264,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276754939",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276763690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276763690"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd have a slight preference for these to be named `x2`, `y2`, `z2`",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-18T17:38:32Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276763690",
      "id" : 276763690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3Njc2MzY5MA==",
      "original_commit_id" : "8cc786094fb55907a25a4b46caa7f1f8fb512363",
      "original_position" : 178,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 228411337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276763690",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276763899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276763899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: You could remove `z2` here (since it's 1 for an affine point)",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-18T17:39:05Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276763899",
      "id" : 276763899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3Njc2Mzg5OQ==",
      "original_commit_id" : "8cc786094fb55907a25a4b46caa7f1f8fb512363",
      "original_position" : 205,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 228411337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276763899",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "good to lose this dependency on an external library w/ ctypes, this makes porting the tests easier\r\n\r\nACK 8cc786094fb55907a25a4b46caa7f1f8fb512363 (though would be good to integrate @jnewbery's comments)",
      "created_at" : "2019-04-18T18:34:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#issuecomment-484631489",
      "id" : 484631489,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/15826",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ4NDYzMTQ4OQ==",
      "updated_at" : "2019-04-18T18:35:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/484631489",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276793201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276793201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-18T18:58:52Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276793201",
      "id" : 276793201,
      "in_reply_to_id" : 276763690,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3Njc5MzIwMQ==",
      "original_commit_id" : "8cc786094fb55907a25a4b46caa7f1f8fb512363",
      "original_position" : 178,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 228454066,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:58:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276793201",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276793247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276793247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "8c7b9324ca3f3ffb178bea56a96ea23f7e0383cb",
      "created_at" : "2019-04-18T18:59:00Z",
      "diff_hunk" : "@@ -1,226 +1,343 @@\n-# Copyright (c) 2011 Sam Rushing\n-\"\"\"ECC secp256k1 OpenSSL wrapper.\n+# Copyright (c) 2019 Pieter Wuille\n \n-WARNING: This module does not mlock() secrets; your private keys may end up on\n-disk in swap! Use with caution!\n+\"\"\"Test-only secp256k1 elliptic curve implementation\n \n-This file is modified from python-bitcoinlib.\n+WARNING: This code is slow, uses bad randomness, does not properly protect\n+keys, and is trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n \"\"\"\n \n-import ctypes\n-import ctypes.util\n-import hashlib\n+import random\n \n-ssl = ctypes.cdll.LoadLibrary(ctypes.util.find_library ('ssl') or 'libeay32')\n-\n-ssl.BN_new.restype = ctypes.c_void_p\n-ssl.BN_new.argtypes = []\n-\n-ssl.BN_bin2bn.restype = ctypes.c_void_p\n-ssl.BN_bin2bn.argtypes = [ctypes.c_char_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.BN_CTX_free.restype = None\n-ssl.BN_CTX_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.BN_CTX_new.restype = ctypes.c_void_p\n-ssl.BN_CTX_new.argtypes = []\n-\n-ssl.ECDH_compute_key.restype = ctypes.c_int\n-ssl.ECDH_compute_key.argtypes = [ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_sign.restype = ctypes.c_int\n-ssl.ECDSA_sign.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.ECDSA_verify.restype = ctypes.c_int\n-ssl.ECDSA_verify.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p, ctypes.c_int, ctypes.c_void_p]\n-\n-ssl.EC_KEY_free.restype = None\n-ssl.EC_KEY_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_new_by_curve_name.restype = ctypes.c_void_p\n-ssl.EC_KEY_new_by_curve_name.argtypes = [ctypes.c_int]\n-\n-ssl.EC_KEY_get0_group.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_group.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_get0_public_key.restype = ctypes.c_void_p\n-ssl.EC_KEY_get0_public_key.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_private_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_private_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_KEY_set_conv_form.restype = None\n-ssl.EC_KEY_set_conv_form.argtypes = [ctypes.c_void_p, ctypes.c_int]\n-\n-ssl.EC_KEY_set_public_key.restype = ctypes.c_int\n-ssl.EC_KEY_set_public_key.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.i2o_ECPublicKey.restype = ctypes.c_void_p\n-ssl.i2o_ECPublicKey.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n-\n-ssl.EC_POINT_new.restype = ctypes.c_void_p\n-ssl.EC_POINT_new.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_free.restype = None\n-ssl.EC_POINT_free.argtypes = [ctypes.c_void_p]\n-\n-ssl.EC_POINT_mul.restype = ctypes.c_int\n-ssl.EC_POINT_mul.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p, ctypes.c_void_p]\n+def extgcd(a, b):\n+    \"\"\"Extended GCD algorithm\"\"\"\n+    if a == 0:\n+        return (b, 0, 1)\n+    else:\n+        g, y, x = extgcd(b % a, a)\n+        return (g, x - (b // a) * y, y)\n+\n+def modinv(a, m):\n+    \"\"\"Compute the modular inverse of a modulo m\"\"\"\n+    g, x, y = extgcd(a % m, m)\n+    if g != 1:\n+        return None\n+    else:\n+        return x % m\n \n-# this specifies the curve used with ECDSA.\n-NID_secp256k1 = 714 # from openssl/obj_mac.h\n+def jacobi_symbol(n, k):\n+    \"\"\"Compute the Jacobi symbol of n modulo k\n \n+    See http://en.wikipedia.org/wiki/Jacobi_symbol\n+    \"\"\"\n+    assert k > 0 and k & 1\n+    n %= k\n+    t = 0\n+    while n != 0:\n+        while n & 1 == 0:\n+            n >>= 1\n+            r = k & 7\n+            t ^= (r == 3 or r == 5)\n+        n, k = k, n\n+        t ^= (n & k & 3 == 3)\n+        n = n % k\n+    if k == 1:\n+        return -1 if t else 1\n+    return 0\n+\n+def modsqrt(a, p):\n+    \"\"\"Compute the square root of a modulo p\"\"\"\n+\n+    assert(p % 4 == 3) # Only p = 3 mod 4 is implemented\n+    sqrt = pow(a, (p + 1)//4, p)\n+    if pow(sqrt, 2, p) == a % p:\n+        return sqrt\n+    return None\n+\n+class EllipticCurve:\n+    def __init__(self, p, a, b):\n+        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n+        self.p = p\n+        self.a = a % p\n+        self.b = b % p\n+\n+    def affine(self, p1):\n+        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return None\n+        inv = modinv(z1, self.p)\n+        inv_2 = (inv**2) % self.p\n+        inv_3 = (inv_2 * inv) % self.p\n+        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n+\n+    def negate(self, p1):\n+        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n+        x1, y1, z1 = p1\n+        return (x1, (self.p - y1) % self.p, z1)\n+\n+    def on_curve(self, p1):\n+        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n+        x1, y1, z1 = p1\n+        z2 = pow(z1, 2, self.p)\n+        z4 = pow(z2, 2, self.p)\n+        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n+\n+    def is_x_coord(self, x):\n+        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n+\n+    def lift_x(self, x):\n+        \"\"\"Given an X coordinate on the curve, return a corresponding affine point.\"\"\"\n+        x_3 = pow(x, 3, self.p)\n+        v = x_3 + self.a * x + self.b\n+        y = modsqrt(v, self.p)\n+        if y is None:\n+            return None\n+        return (x, y, 1)\n+\n+    def double(self, p1):\n+        \"\"\"Double a Jacobian tuple p1\"\"\"\n+        x1, y1, z1 = p1\n+        if z1 == 0:\n+            return (0, 1, 0)\n+        y1_2 = (y1**2) % self.p\n+        y1_4 = (y1_2**2) % self.p\n+        x1_2 = (x1**2) % self.p\n+        s = (4*x1*y1_2) % self.p\n+        m = 3*x1_2\n+        if self.a:\n+            m += self.a * pow(z1, 4, self.p)\n+        m = m % self.p\n+        x3 = (m**2 - 2*s) % self.p\n+        y3 = (m*(s - x3) - 8*y1_4) % self.p\n+        z3 = (2*y1*z1) % self.p\n+        return (x3, y3, z3)\n+\n+    def add_mixed(self, p1, p2):\n+        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\"\"\"\n+        x1, y1, z1 = p1\n+        x2, y2, z2 = p2\n+        assert(z2 == 1)\n+        if z1 == 0:\n+            return p2\n+        z1_2 = (z1**2) % self.p\n+        z1_3 = (z1_2 * z1) % self.p\n+        u2 = (x2 * z1_2) % self.p\n+        s2 = (y2 * z1_3) % self.p\n+        if x1 == u2:\n+            if (y1 != s2):\n+                return (0, 1, 0)\n+            return self.double(p1)\n+        h = u2 - x1\n+        r = s2 - y1\n+        h_2 = (h**2) % self.p\n+        h_3 = (h_2 * h) % self.p\n+        u1_h_2 = (x1 * h_2) % self.p\n+        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n+        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n+        z3 = (h*z1*z2) % self.p",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/15826#discussion_r276793247",
      "id" : 276793247,
      "in_reply_to_id" : 276763899,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI3Njc5MzI0Nw==",
      "original_commit_id" : "8cc786094fb55907a25a4b46caa7f1f8fb512363",
      "original_position" : 205,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 228454136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/15826",
      "updated_at" : "2019-04-18T18:59:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/276793247",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
