[
   {
      "body" : "Concept ACK.",
      "created_at" : "2017-04-14T20:27:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-294230277",
      "id" : 294230277,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-04-14T20:27:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/294230277",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Concept OK, not so sure about implementation. This seems to be all-or-nothing with regard to recent transactions - wouldn't you want to evaluate it as a gradient (eg, maybe it makes sense to include 29-second-old txs, but not newer)?",
      "created_at" : "2017-04-19T18:46:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-295386666",
      "id" : 295386666,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-04-19T18:46:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/295386666",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r112284136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/112284136"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How does this differ from the default copy constructor?\r\n",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-04-19T18:46:46Z",
      "diff_hunk" : "@@ -26,6 +26,16 @@ static const bool DEFAULT_PRINTPRIORITY = false;\n \n struct CBlockTemplate\n {\n+    CBlockTemplate(const CBlockTemplate &tmpl) :\n+        block(tmpl.block), vTxFees(tmpl.vTxFees),\n+        vTxSigOpsCost(tmpl.vTxSigOpsCost),\n+        vchCoinbaseCommitment(tmpl.vchCoinbaseCommitment)\n+    {\n+        block.vtx = tmpl.block.vtx;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r112284136",
      "id" : 112284136,
      "original_commit_id" : "a986a97ed49099e8dda7ed65647f789af3142130",
      "original_position" : 10,
      "path" : "src/miner.h",
      "position" : null,
      "pull_request_review_id" : 33587175,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/112284136",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "@luke-jr   You could go hog wild with multiple choices,  >X, >Y, >Z second old.. but if its tuned right it should pretty much always be choosing to exclude recent transactions, and the other alternative is just so that you don't regret your decisions when some bozo sends a very high fee transaction.   The marginal gain from more options is going to be pretty small compared to the block creation delay from the CPU costs in considering more options-- and what you'll be mining on instead.  E.g. spending another 10ms mining on an empty block is probably not worth whatever gain you could have in considering another recentness level.\r\n\r\nIt's also the case that block propagation performance between miners is probably pretty consistent and narrowly spread... meaning that either you made a block that could get everywhere with 0-rtt or you didn't-- and there probably isn't a lot of space in-between.   So I think thats what this is modeling: the no-recent alternative will make it ~everywhere with no round trips, and the other one is going to take a round trip-- so you only want it if it pays enough more to justify the increased orphan risk.\r\n",
      "created_at" : "2017-04-20T00:42:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-295515125",
      "id" : 295515125,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-04-20T00:42:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/295515125",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "I didn't mean more options, just that the algorithm could evaluate the age-cost/value initially when building the template rather than building the entire template twice. :)",
      "created_at" : "2017-04-20T00:45:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-295516333",
      "id" : 295516333,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-04-20T00:45:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/295516333",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r112501675"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/112501675"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Apparently it doesn't (I was confused by whether a CBlock could be copy-constructed from another CBlock).  Will remove.\r\n\r\nRemoved in dfd4e73c97818eb57bdf9e34a9085904a5250a92",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-04-20T16:41:02Z",
      "diff_hunk" : "@@ -26,6 +26,16 @@ static const bool DEFAULT_PRINTPRIORITY = false;\n \n struct CBlockTemplate\n {\n+    CBlockTemplate(const CBlockTemplate &tmpl) :\n+        block(tmpl.block), vTxFees(tmpl.vTxFees),\n+        vTxSigOpsCost(tmpl.vTxSigOpsCost),\n+        vchCoinbaseCommitment(tmpl.vchCoinbaseCommitment)\n+    {\n+        block.vtx = tmpl.block.vtx;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r112501675",
      "id" : 112501675,
      "in_reply_to_id" : 112284136,
      "original_commit_id" : "a986a97ed49099e8dda7ed65647f789af3142130",
      "original_position" : 10,
      "path" : "src/miner.h",
      "position" : null,
      "pull_request_review_id" : 33822450,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/112501675",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "> I didn't mean more options, just that the algorithm could evaluate the age-cost/value initially when building the template rather than building the entire template twice. :)\r\n\r\n@luke-jr  Well note that this implementation doesn't build the entire template twice; it copies the template, and throws out the recent transactions and rebuilds from there.\r\n\r\nIf I understand it right, I think it's hard to make your suggestion work: the fee adjustment based on time-received is not independent of the other choices you make when selecting transactions (in modeling the binary \"0 vs >=1\" round trips to relay a block), and trying to model it with an implementation that makes a single pass, where some transactions are evaluated with only local information, is hard to get right.  Either you'll include recent transactions too often because your criteria is too loose, or if your criteria is tighter, you risk giving up too much fee income if network conditions change.",
      "created_at" : "2017-04-21T15:29:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-296223025",
      "id" : 296223025,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-04-21T15:29:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/296223025",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Rebased",
      "created_at" : "2017-05-06T09:59:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-299629274",
      "id" : 299629274,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-05-06T09:59:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/299629274",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121189676"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121189676"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Eliminate unnecessary call to UpdatePackagesForAdded\"\r\n\r\nNote: reason this call is not needed is that resetBlock is called right before addPackageTxs, so inBlock will be empty.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:11:40Z",
      "diff_hunk" : "@@ -349,10 +349,6 @@ void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpda\n     // Keep track of entries that failed inclusion, to avoid duplicate work\n     CTxMemPool::setEntries failedTx;\n \n-    // Start by adding all descendants of previously added txs to mapModifiedTx\n-    // and modifying them for their already included ancestors\n-    UpdatePackagesForAdded(inBlock, mapModifiedTx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121189676",
      "id" : 121189676,
      "original_commit_id" : "9ae85a6965f0e9599d773eecd6f681118ce866a5",
      "original_position" : 6,
      "path" : "src/miner.cpp",
      "position" : 405,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121189676",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121190072"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121190072"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Move mapModifiedTx outside of addPackageTxs\"\r\n\r\nNote: Reason for the move is to be able to reuse mapModifiedTx when a second\r\n`addPackageTxs` call is added later (to refill the block after removing recent transactions).",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:13:33Z",
      "diff_hunk" : "@@ -166,9 +166,13 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     // transaction (which in most cases can be a no-op).\n     fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;\n \n+    // mapModifiedTx will store sorted packages after they are modified\n+    // because some of their txs are already in the block\n+    indexed_modified_transaction_set mapModifiedTx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121190072",
      "id" : 121190072,
      "original_commit_id" : "1d1191ddbdcfde0757ea36f929171143f3c80c49",
      "original_position" : 6,
      "path" : "src/miner.cpp",
      "position" : 135,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121190072",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121190582"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121190582"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Encapsulate working state for a single call to CNB\"\r\n\r\nNote: Reason for moving state to this struct is to be able to make a second `addPackageTxs()` call in a later commit without losing the state of the first call.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:15:49Z",
      "diff_hunk" : "@@ -134,25 +134,30 @@ struct update_for_parent_inclusion\n class BlockAssembler\n {\n private:\n-    // The constructed block template\n-    std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    // A convenience pointer that always refers to the CBlock in pblocktemplate\n-    CBlock* pblock;\n+    struct WorkingState {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121190582",
      "id" : 121190582,
      "original_commit_id" : "1cfa4a97403599650b01fa7b8d0332d3a9017a3e",
      "original_position" : 8,
      "path" : "src/miner.h",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121190582",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121195068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121195068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Mining: Add not-yet-used option to avoid recent transactions\"\r\n\r\nI think it might be slightly better to do `|| mi->GetTime() > nTimeCutoff` here instead of modifying `SkipMapTxEntry`, both for consistency with the `mapModifiedTx` check below, and because `SkipMapTxEntry` is already a pretty overloaded function with a paragraph of text describing it, so it's not like it  needs another job.\r\n\r\n(Update: done in new version of PR)",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:36:47Z",
      "diff_hunk" : "@@ -348,7 +349,7 @@ void BlockAssembler::addPackageTxs(WorkingState &workState, int &nPackagesSelect\n     {\n         // First try to find a new transaction in mapTx to evaluate.\n         if (mi != mempool.mapTx.get<ancestor_score>().end() &&\n-                SkipMapTxEntry(workState, mempool.mapTx.project<0>(mi), mapModifiedTx, failedTx)) {\n+                SkipMapTxEntry(workState, mempool.mapTx.project<0>(mi), mapModifiedTx, failedTx, nTimeCutoff)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121195068",
      "id" : 121195068,
      "original_commit_id" : "47c933cd053f5b2bd5edb70ea6e3fdfb54a6ab54",
      "original_position" : 37,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121195068",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121197115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121197115"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add helper to remove transactions from block\"\r\n\r\nStrictly speaking `<` should probably be `<=` to be consistent with the addPackageTxs and SkipMapTxEntry code also applying the cutoff.\r\n\r\n(Update: fixed in new version of PR)",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:46:04Z",
      "diff_hunk" : "@@ -267,6 +267,54 @@ void BlockAssembler::AddToBlock(WorkingState &workState, CTxMemPool::txiter iter\n     }\n }\n \n+void BlockAssembler::RemoveRecentTransactionsFromBlock(WorkingState &workState, int64_t timeCutoff)\n+{\n+    std::vector<CTransactionRef> vtxCopy;\n+    vtxCopy.reserve(workState.pblocktemplate->block.vtx.size());\n+    std::vector<CAmount> vTxFeesCopy;\n+    vTxFeesCopy.reserve(vtxCopy.size());\n+    std::vector<int64_t> vTxSigOpsCostCopy;\n+    vTxSigOpsCostCopy.reserve(vtxCopy.size());\n+\n+    CTxMemPool::setEntries skippedTransactions;\n+    CTxMemPool::setEntries descendantTransactions;\n+    for (const CTransactionRef &ptx : workState.pblocktemplate->block.vtx) {\n+        if (vtxCopy.empty()) {\n+            // This is the coinbase placeholder; just copy its\n+            // information over.\n+            vtxCopy.push_back(ptx);\n+            vTxFeesCopy.push_back(workState.pblocktemplate->vTxFees[0]);\n+            vTxSigOpsCostCopy.push_back(workState.pblocktemplate->vTxSigOpsCost[0]);\n+            continue;\n+        }\n+        CTxMemPool::txiter it = mempool.mapTx.find(ptx->GetHash());\n+        assert(it != mempool.mapTx.end());\n+        if (it->GetTime() < timeCutoff && descendantTransactions.count(it) == 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121197115",
      "id" : 121197115,
      "original_commit_id" : "65af6c9860d7c869f2fed8568714d46e939e234a",
      "original_position" : 26,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121197115",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121199430"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121199430"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add helper to remove transactions from block\r\n\r\nMaybe should be called \"removed\" rather than \"skipped\" for consistency with the function name (especially since this gets exposed in the next commit).\r\n\r\n(Update: variable is removed in new version of PR)",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T18:56:47Z",
      "diff_hunk" : "@@ -267,6 +267,54 @@ void BlockAssembler::AddToBlock(WorkingState &workState, CTxMemPool::txiter iter\n     }\n }\n \n+void BlockAssembler::RemoveRecentTransactionsFromBlock(WorkingState &workState, int64_t timeCutoff)\n+{\n+    std::vector<CTransactionRef> vtxCopy;\n+    vtxCopy.reserve(workState.pblocktemplate->block.vtx.size());\n+    std::vector<CAmount> vTxFeesCopy;\n+    vTxFeesCopy.reserve(vtxCopy.size());\n+    std::vector<int64_t> vTxSigOpsCostCopy;\n+    vTxSigOpsCostCopy.reserve(vtxCopy.size());\n+\n+    CTxMemPool::setEntries skippedTransactions;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121199430",
      "id" : 121199430,
      "original_commit_id" : "65af6c9860d7c869f2fed8568714d46e939e234a",
      "original_position" : 13,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121199430",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121202679"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121202679"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Skip recent transactions in CNB if fee difference is small\"\r\n\r\nCould you add a comment explaining why this skips updating `mapModifiedTx` entries of transactions that were removed? I'm probably misunderstanding something, but It seems like if you skip those, you won't be updating any `mapModifiedTx` entries at all, because `RemoveRecentTransactionsFromBlock` also removes descendants.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T19:13:34Z",
      "diff_hunk" : "@@ -342,6 +366,24 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n     return nDescendantsUpdated;\n }\n \n+void BlockAssembler::UpdatePackagesForRemoved(const CTxMemPool::setEntries& removed,\n+        indexed_modified_transaction_set &mapModifiedTx)\n+{\n+    for (const CTxMemPool::txiter it : removed) {\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(it, descendants);\n+        for(CTxMemPool::txiter desc : descendants) {\n+            if (removed.count(desc)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121202679",
      "id" : 121202679,
      "original_commit_id" : "c392582000d1f5bbd07d19177c2aa8e62f9405da",
      "original_position" : 148,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121202679",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121203897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121203897"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Skip recent transactions in CNB if fee difference is small\"\r\n\r\nIt seems like this will always log information about the noRecent block even if it wasn't the winner. Maybe move nPackagesSelected and nDescendantsUpdated variables into the state struct to keep separate copies of them and print them here. (This would also cut down on the number of arguments you need to pass to addPackageTxs.)",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T19:20:29Z",
      "diff_hunk" : "@@ -159,43 +162,63 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     int nDescendantsUpdated = 0;\n     addPackageTxs(workState, nPackagesSelected, nDescendantsUpdated, std::numeric_limits<int64_t>::max(), mapModifiedTx);\n \n+    CTxMemPool::setEntries skippedTransactions;\n+\n+    // Duplicate the working state\n+    WorkingState noRecentWorkState(workState);\n+\n+    // TODO: allow the time window to be configurable\n+    RemoveRecentTransactionsFromBlock(noRecentWorkState, GetTime() - nRecentTxWindow, skippedTransactions);\n+    UpdatePackagesForRemoved(skippedTransactions, mapModifiedTx);\n+\n+    // Re-add to this block, skipping recent transactions\n+    addPackageTxs(noRecentWorkState, nPackagesSelected, nDescendantsUpdated, GetTime() - nRecentTxWindow, mapModifiedTx);\n+\n     int64_t nTime1 = GetTimeMicros();\n \n-    nLastBlockTx = workState.nBlockTx;\n-    nLastBlockSize = workState.nBlockSize;\n-    nLastBlockWeight = workState.nBlockWeight;\n+    // Now compare and decide which block to use\n+    WorkingState *winner = &workState;\n+    // TODO: replace this with a configurable threshold\n+    CAmount blockSubsidy = GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    if (blockSubsidy + noRecentWorkState.nModifiedFees >= 1.0 * (workState.nModifiedFees + blockSubsidy)) {\n+        winner = &noRecentWorkState;\n+    }\n+\n+    nLastBlockTx = winner->nBlockTx;\n+    nLastBlockSize = winner->nBlockSize;\n+    nLastBlockWeight = winner->nBlockWeight;\n \n     // Create coinbase transaction.\n     CMutableTransaction coinbaseTx;\n     coinbaseTx.vin.resize(1);\n     coinbaseTx.vin[0].prevout.SetNull();\n     coinbaseTx.vout.resize(1);\n     coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n-    coinbaseTx.vout[0].nValue = workState.nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vout[0].nValue = winner->nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n     coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n-    workState.pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\n-    workState.pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*workState.pblock, pindexPrev, chainparams.GetConsensus());\n-    workState.pblocktemplate->vTxFees[0] = -workState.nFees;\n+    winner->pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\n+    winner->pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*winner->pblock, pindexPrev, chainparams.GetConsensus());\n+    winner->pblocktemplate->vTxFees[0] = -winner->nFees;\n \n-    uint64_t nSerializeSize = GetSerializeSize(*workState.pblock, SER_NETWORK, PROTOCOL_VERSION);\n-    LogPrintf(\"CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\\n\", nSerializeSize, GetBlockWeight(*workState.pblock), workState.nBlockTx, workState.nFees, workState.nBlockSigOpsCost);\n+    uint64_t nSerializeSize = GetSerializeSize(*winner->pblock, SER_NETWORK, PROTOCOL_VERSION);\n+    LogPrintf(\"CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\\n\", nSerializeSize, GetBlockWeight(*winner->pblock), winner->nBlockTx, winner->nFees, winner->nBlockSigOpsCost);\n \n     // Fill in header\n-    workState.pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-    UpdateTime(workState.pblock, chainparams.GetConsensus(), pindexPrev);\n-    workState.pblock->nBits          = GetNextWorkRequired(pindexPrev, workState.pblock, chainparams.GetConsensus());\n-    workState.pblock->nNonce         = 0;\n-    workState.pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*workState.pblock->vtx[0]);\n+    winner->pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(winner->pblock, chainparams.GetConsensus(), pindexPrev);\n+    winner->pblock->nBits          = GetNextWorkRequired(pindexPrev, winner->pblock, chainparams.GetConsensus());\n+    winner->pblock->nNonce         = 0;\n+    winner->pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*winner->pblock->vtx[0]);\n \n     CValidationState state;\n-    if (!TestBlockValidity(state, chainparams, *workState.pblock, pindexPrev, false, false)) {\n+    if (!TestBlockValidity(state, chainparams, *winner->pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n     }\n     int64_t nTime2 = GetTimeMicros();\n \n     LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121203897",
      "id" : 121203897,
      "original_commit_id" : "c392582000d1f5bbd07d19177c2aa8e62f9405da",
      "original_position" : 97,
      "path" : "src/miner.cpp",
      "position" : 211,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121203897",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121206593"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121206593"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Mining: configure 'recency' and 'stale rate' from command line\"\r\n\r\nI would maybe say \"if a recently received transaction were included\" instead of \"given that a recently received transaction was included.\" It doesn't seem like \"given\" is right here in the probabilistic sense.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T19:35:45Z",
      "diff_hunk" : "@@ -489,6 +489,8 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n+    strUsage += HelpMessageOpt(\"-recenttxwindow=<n>\", strprintf(_(\"Set window size in milliseconds for defining transactions as 'recently received' (default: %d)\"), DEFAULT_RECENT_TX_WINDOW));\n+    strUsage += HelpMessageOpt(\"-recenttxstalerate=<n>\", strprintf(_(\"Set stale (orphan) rate for blocks that contain 'recently received' transactions. This is the probability that block income will be lost given that a recently received transaction was included; transaction selection skips over recently received transactions (defined by -recenttxwindow) unless doing so would result in a decrease of block income exceeding this rate (default: %f)\"), DEFAULT_RECENT_TX_STALE_RATE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121206593",
      "id" : 121206593,
      "original_commit_id" : "73eaf01453ae0cdb17ee87096c1c3ef7b5c6e137",
      "original_position" : 5,
      "path" : "src/init.cpp",
      "position" : 5,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121206593",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121208973"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121208973"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nCould go with `for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):` to shorten code below and avoid hardcoded 3.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T19:49:09Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121208973",
      "id" : 121208973,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 40,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121208973",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121209822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121209822"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nancestor_size unused",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T19:54:09Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121209822",
      "id" : 121209822,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 92,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121209822",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nCould move comment down closer to -blockmaxweight setting.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:02:28Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211261",
      "id" : 121211261,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 31,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211261",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211402"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nSome of the comments on top these python functions could be made into docstrings.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:03:14Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211402",
      "id" : 121211402,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 84,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211402",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211706"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\n`i` should be `0` here I think",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:05:00Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000 # 4000 reserved for coinbase\n+        total_weight = 0\n+        assert(self.get_mempool_weight(node) > block_max_weight)\n+\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert(block_weight > block_max_weight - 4000)\n+        assert(block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time())+recent_tx_window)\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has an ancestor that is also not in the block.\n+        # Call prioritisetransaction on the child tx to boost its ancestor\n+        # feerate to be above the average feerate of the last ancestor_size\n+        # space in the block, and verify that the child transaction is in the next\n+        # block template.\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_txids = [ x[\"txid\"] for x in template[\"transactions\"] ]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has at least one parent that is not in the\n+        # block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(txid=txid, verbose=False)\n+                for ancestor_txid in ancestor_txids:\n+                    if ancestor_txid not in block_txids:\n+                        txid_to_bump = txid\n+                        break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\"Not enough transactions to test ancestor feerate score (test bug?)\")\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        self.log.debug(\"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f\", txid_to_bump, ancestor_size, ancestor_fee)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be fine.\n+            if (4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate):\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if (cumulative_weight > 4*ancestor_size):\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than the\n+        # max feerate observed in the last portion of the block that we seek to\n+        # replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+\n+        node.prioritisetransaction(txid_to_bump, fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node) # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert(txid_to_bump in new_block_txids)\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid_to_bump, -fee_bump)\n+\n+    def test_recent_transactions_excluded(self, node, recent_tx_window, recent_tx_stale_rate):\n+        # Repeatedly try to call getblocktemplate, using mocktime to choose\n+        # random points at which to call gbt\n+        # If the block template contains recently-received transactions:\n+        # - Prioritise all recent transactions to 0 fee, and then call gbt again\n+        # - Verify that the fee decrease is more than the stale rate.\n+        # Otherwise:\n+        # - Verify that the block fee is within our tolerance of the highest fee\n+        #   block we've seen so far.\n+\n+        # First, convert recent_tx_window from milliseconds to seconds.\n+        recent_tx_window = int((recent_tx_window+999)/1000)\n+\n+        mempool = node.getrawmempool(verbose=True)\n+        all_times = [ value[\"time\"] for key, value in mempool.items() ]\n+        earliest_time, latest_time = sorted(all_times)[::len(all_times)-1]\n+        mock_time = latest_time + recent_tx_window - 1\n+        max_fee = 0\n+\n+        # Track how many blocks are found with/without recent transactions\n+        blocks_with_recent_tx = 0\n+        blocks_without_recent_tx = 0\n+\n+        while mock_time >= earliest_time + recent_tx_window:\n+            node.setmocktime(mock_time)\n+            self.add_empty_block(node) # bypass gbt cache\n+            template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+            template_txids = [ x['txid'] for x in template['transactions'] ]\n+\n+            block_fee = 0\n+            consensus_fee = 0\n+            contains_recent_tx = False\n+            recent_tx_weight = 0\n+            for x in template['transactions']:\n+                block_fee += int(mempool[x['txid']]['modifiedfee']*COIN)\n+                consensus_fee += x['fee']\n+                if (mempool[x['txid']]['time'] > mock_time - recent_tx_window):\n+                    self.log.debug(\"Contains recent tx %s time %d (%d, %d)\",\n+                            x['txid'], mempool[x['txid']]['time'], mock_time,\n+                            recent_tx_window)\n+                    contains_recent_tx = True\n+                    recent_tx_weight += x['weight']\n+            if block_fee > max_fee:\n+                self.log.debug(\"Setting max_fee to %d\", block_fee)\n+                max_fee = block_fee\n+            block_reward = template['coinbasevalue'] - consensus_fee\n+\n+            if (not contains_recent_tx):\n+                # If we don't have anything new, we better be close to the max\n+                # seen so far\n+                self.log.debug(\"No recent transactions, block_fee = %d, block_reward=%d\", block_fee, block_reward)\n+                assert (block_reward + block_fee >= (1-recent_tx_stale_rate)*(block_reward + max_fee))\n+                blocks_without_recent_tx += 1\n+\n+            else:\n+                # Deprioritise everything recent and re-run; the fee delta\n+                # should be significant\n+                blocks_with_recent_tx += 1\n+\n+                for txid, entry in mempool.items():\n+                    if (entry[\"time\"] > mock_time - recent_tx_window):\n+                        node.prioritisetransaction(txid, int(-(entry[\"fee\"]*COIN)))\n+                        if (txid in template_txids):\n+                            # The mining algorithm will include non-recent\n+                            # ancestors of recently included transactions.\n+                            # If this is improved in the future, this portion\n+                            # of the test would need to change.\n+                            ancestors = node.getmempoolancestors(txid)\n+                            for a in ancestors:\n+                                if (mempool[a]['time'] < mock_time - recent_tx_window):\n+                                    node.prioritisetransaction(a, int(entry[\"fee\"]*COIN))\n+\n+                self.add_empty_block(node) # bypass gbt cache\n+                new_template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+                new_fee = 0\n+                new_template_txids = [ x['txid'] for x in new_template[\"transactions\"] ]\n+                just_new_txids = list(set(new_template_txids) - set(template_txids))\n+                just_old_txids = list(set(template_txids) - set(new_template_txids))\n+                for x in just_new_txids:\n+                    self.log.debug(\"Newly included tx: %s, fee=%d, cur_time=%d, secs_ago=%d\", x, int(mempool[x]['modifiedfee']*COIN), mock_time, mock_time - mempool[x]['time'])\n+\n+                for x in just_old_txids:\n+                    self.log.debug(\"No longer included tx: %s, fee=%d, cur_time=%d, secs_ago=%d\", x, int(mempool[x]['modifiedfee']*COIN), mock_time, mock_time - mempool[x]['time'])\n+                for x in new_template['transactions']:\n+                    # Note that we're using the original mempool modified fees,\n+                    # not the current ones!\n+                    new_fee += int(mempool[x['txid']]['modifiedfee']*COIN)\n+                self.log.debug(\"Recent transactions: block_reward=%d non-recent=%d all=%d\", block_reward, new_fee, block_fee)\n+\n+                assert((1-recent_tx_stale_rate)*(block_reward+block_fee) > (block_reward+new_fee))\n+                # Re-prioritise everything\n+                for txid, entry in mempool.items():\n+                    if (entry[\"time\"] > mock_time - recent_tx_window):\n+                        node.prioritisetransaction(txid, int(entry[\"fee\"]*COIN))\n+                        if (txid in template_txids):\n+                            ancestors = node.getmempoolancestors(txid)\n+                            for a in ancestors:\n+                                if (mempool[a]['time'] < mock_time - recent_tx_window):\n+                                    node.prioritisetransaction(a, int(-(entry[\"fee\"]*COIN)))\n+\n+\n+            mock_time -= recent_tx_window\n+\n+        if (blocks_with_recent_tx == 0 or blocks_without_recent_tx == 0):\n+            self.log.info(\"Warning - test_recent_transactions_excluded(): only one branch covered (blocks_with_recent_tx = %d, blocks_without_recent_tx = %d)\", blocks_with_recent_tx, blocks_without_recent_tx)\n+\n+        # Get rid of the mocktime\n+        node.setmocktime(0)\n+\n+    def run_test(self):\n+        # Leave IBD and generate some coins to spend.\n+        # Give everyone plenty of coins\n+        self.log.info(\"Generating initial coins for all nodes\")\n+        for i in range(2):\n+            for x in self.nodes:\n+                # Building a long blockchain here will make the block reward\n+                # smaller, compared to the fees -- this is helpful for\n+                # test_recent_transactions_excluded()\n+                x.generate(201)\n+                self.sync_all()\n+\n+        # Add some segwit coins to everyone\n+        self.log.info(\"Generating segwit coins for all nodes\")\n+        self.create_segwit_coins()\n+\n+        # Run tests...\n+        self.log.info(\"Populating mempool with a lot of transactions\")\n+        self.populate_mempool(500)\n+\n+        self.log.info(\"Running test_max_block_weight\")\n+        self.test_max_block_weight(self.nodes[0])\n+\n+        self.sync_all()\n+        self.log.info(\"Running test_recent_transactions_excluded\")\n+        for i in range(3):\n+            self.test_recent_transactions_excluded(self.nodes[i], recent_tx_window=self.cnb_args[i]['window'], recent_tx_stale_rate=self.cnb_args[i]['stalerate'])\n+\n+        self.sync_all()\n+        self.log.info(\"Running test_ancestor_feerate_sort\")\n+        self.test_ancestor_feerate_sort(self.nodes[0], recent_tx_window=self.cnb_args[i]['window'])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121211706",
      "id" : 121211706,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 331,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121211706",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121212644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121212644"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nassert isn't really a function call in python, so the parentheses aren't needed. Also asserts are skipped if python is running with optimizations (`-O`), so maybe prefer to use one of the test framework assert functions.\r\n\r\nAlso lots of if statements in this test with extra parentheses.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:10:21Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000 # 4000 reserved for coinbase\n+        total_weight = 0\n+        assert(self.get_mempool_weight(node) > block_max_weight)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121212644",
      "id" : 121212644,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 99,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121212644",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121214104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121214104"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nI guess it's too late for the prioritize spelling to catch on in bitcoin.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:18:50Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000 # 4000 reserved for coinbase\n+        total_weight = 0\n+        assert(self.get_mempool_weight(node) > block_max_weight)\n+\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert(block_weight > block_max_weight - 4000)\n+        assert(block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time())+recent_tx_window)\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has an ancestor that is also not in the block.\n+        # Call prioritisetransaction on the child tx to boost its ancestor\n+        # feerate to be above the average feerate of the last ancestor_size\n+        # space in the block, and verify that the child transaction is in the next\n+        # block template.\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_txids = [ x[\"txid\"] for x in template[\"transactions\"] ]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has at least one parent that is not in the\n+        # block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(txid=txid, verbose=False)\n+                for ancestor_txid in ancestor_txids:\n+                    if ancestor_txid not in block_txids:\n+                        txid_to_bump = txid\n+                        break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\"Not enough transactions to test ancestor feerate score (test bug?)\")\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        self.log.debug(\"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f\", txid_to_bump, ancestor_size, ancestor_fee)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be fine.\n+            if (4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate):\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if (cumulative_weight > 4*ancestor_size):\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than the\n+        # max feerate observed in the last portion of the block that we seek to\n+        # replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+\n+        node.prioritisetransaction(txid_to_bump, fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node) # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert(txid_to_bump in new_block_txids)\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid_to_bump, -fee_bump)\n+\n+    def test_recent_transactions_excluded(self, node, recent_tx_window, recent_tx_stale_rate):\n+        # Repeatedly try to call getblocktemplate, using mocktime to choose\n+        # random points at which to call gbt\n+        # If the block template contains recently-received transactions:\n+        # - Prioritise all recent transactions to 0 fee, and then call gbt again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121214104",
      "id" : 121214104,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 196,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121214104",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121214405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121214405"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nCan use `//` operator for integer division in python",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:20:25Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000 # 4000 reserved for coinbase\n+        total_weight = 0\n+        assert(self.get_mempool_weight(node) > block_max_weight)\n+\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert(block_weight > block_max_weight - 4000)\n+        assert(block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time())+recent_tx_window)\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has an ancestor that is also not in the block.\n+        # Call prioritisetransaction on the child tx to boost its ancestor\n+        # feerate to be above the average feerate of the last ancestor_size\n+        # space in the block, and verify that the child transaction is in the next\n+        # block template.\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_txids = [ x[\"txid\"] for x in template[\"transactions\"] ]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has at least one parent that is not in the\n+        # block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(txid=txid, verbose=False)\n+                for ancestor_txid in ancestor_txids:\n+                    if ancestor_txid not in block_txids:\n+                        txid_to_bump = txid\n+                        break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\"Not enough transactions to test ancestor feerate score (test bug?)\")\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        self.log.debug(\"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f\", txid_to_bump, ancestor_size, ancestor_fee)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be fine.\n+            if (4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate):\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if (cumulative_weight > 4*ancestor_size):\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than the\n+        # max feerate observed in the last portion of the block that we seek to\n+        # replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+\n+        node.prioritisetransaction(txid_to_bump, fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node) # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert(txid_to_bump in new_block_txids)\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid_to_bump, -fee_bump)\n+\n+    def test_recent_transactions_excluded(self, node, recent_tx_window, recent_tx_stale_rate):\n+        # Repeatedly try to call getblocktemplate, using mocktime to choose\n+        # random points at which to call gbt\n+        # If the block template contains recently-received transactions:\n+        # - Prioritise all recent transactions to 0 fee, and then call gbt again\n+        # - Verify that the fee decrease is more than the stale rate.\n+        # Otherwise:\n+        # - Verify that the block fee is within our tolerance of the highest fee\n+        #   block we've seen so far.\n+\n+        # First, convert recent_tx_window from milliseconds to seconds.\n+        recent_tx_window = int((recent_tx_window+999)/1000)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121214405",
      "id" : 121214405,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 203,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121214405",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121218426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121218426"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add functional test for CreateNewBlock\"\r\n\r\nMaybe spell this out a little more. It seems like the point of setting fees to 0 is to force gbt to generate and return the `noRecent` block which lost the competition against the recent block. But if the `noRecent` block currently includes these ancestor transactions, then why set their fees to 0 here?",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-06-09T20:41:37Z",
      "diff_hunk" : "@@ -0,0 +1,336 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test transaction selection (CreateNewBlock).\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import *\n+from test_framework.mininode import CTransaction, ToHex, FromHex, CBlock, CTxIn, CTxOut, COutPoint, CTxInWitness, COIN\n+from test_framework.util import *\n+from test_framework.script import *\n+\n+'''\n+Test goals:\n+    - Test that block max weight is respected (no blocks too big).\n+    - Test that if the mempool has a tx that fits in a block, it will always be\n+      included unless the block is within 4000 of max weight.\n+    - Test that transaction selection takes into account feerate-with-ancestors\n+      when creating blocks.\n+    - Test that recently received transactions aren't selected unless the feerate\n+      for including them is high.\n+'''\n+\n+class MiningTest(BitcoinTestFramework):\n+    def __init__(self):\n+        self.num_nodes = 6\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        self.cnb_args = [ { 'window': 10000, 'stalerate': 0.01},\n+                          { 'window': 30000, 'stalerate': 0.1},\n+                          { 'window': 50000, 'stalerate': 0.001}\n+                        ]\n+\n+        extra_args = [[\"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\"]\n+                      for i in range(self.num_nodes)]\n+        for i in range(3):\n+            extra_args[i].extend([\"-recenttxwindow=%s\"%self.cnb_args[i]['window'],\n+                                  \"-recenttxstalerate=%s\"%self.cnb_args[i]['stalerate']])\n+        self.nodes = start_nodes(self.num_nodes, self.options.tmpdir, extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes-1):\n+            connect_nodes(self.nodes[i], i+1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def create_segwit_coins(self):\n+        for node in self.nodes:\n+            # Create 20 segwit coins on each node\n+            for i in range(20):\n+                new_addr = node.getnewaddress()\n+                witness_address = node.addwitnessaddress(new_addr)\n+                node.sendtoaddress(witness_address, 1)\n+            node.generate(1)\n+            self.sync_all()\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10)*Decimal('0.1')\n+                random_transaction(self.nodes, amount=random_amount, min_fee=Decimal(\"0.00001\"), fee_increment=Decimal(\"0.000005\"), fee_variants=5000, confirmations_required=0)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if (\"Insufficient funds\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \"+e.error['message'])\n+            except JSONRPCException as e:\n+                if (\"too-long-mempool\" in e.error['message']):\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \"+e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \"+type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        ancestor_size = 0\n+        for txid,entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+            ancestor_size += entry['ancestorsize']\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000 # 4000 reserved for coinbase\n+        total_weight = 0\n+        assert(self.get_mempool_weight(node) > block_max_weight)\n+\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert(block_weight > block_max_weight - 4000)\n+        assert(block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time())+recent_tx_window)\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has an ancestor that is also not in the block.\n+        # Call prioritisetransaction on the child tx to boost its ancestor\n+        # feerate to be above the average feerate of the last ancestor_size\n+        # space in the block, and verify that the child transaction is in the next\n+        # block template.\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        block_txids = [ x[\"txid\"] for x in template[\"transactions\"] ]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has at least one parent that is not in the\n+        # block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(txid=txid, verbose=False)\n+                for ancestor_txid in ancestor_txids:\n+                    if ancestor_txid not in block_txids:\n+                        txid_to_bump = txid\n+                        break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\"Not enough transactions to test ancestor feerate score (test bug?)\")\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        self.log.debug(\"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f\", txid_to_bump, ancestor_size, ancestor_fee)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be fine.\n+            if (4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate):\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if (cumulative_weight > 4*ancestor_size):\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than the\n+        # max feerate observed in the last portion of the block that we seek to\n+        # replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+\n+        node.prioritisetransaction(txid_to_bump, fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node) # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert(txid_to_bump in new_block_txids)\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid_to_bump, -fee_bump)\n+\n+    def test_recent_transactions_excluded(self, node, recent_tx_window, recent_tx_stale_rate):\n+        # Repeatedly try to call getblocktemplate, using mocktime to choose\n+        # random points at which to call gbt\n+        # If the block template contains recently-received transactions:\n+        # - Prioritise all recent transactions to 0 fee, and then call gbt again\n+        # - Verify that the fee decrease is more than the stale rate.\n+        # Otherwise:\n+        # - Verify that the block fee is within our tolerance of the highest fee\n+        #   block we've seen so far.\n+\n+        # First, convert recent_tx_window from milliseconds to seconds.\n+        recent_tx_window = int((recent_tx_window+999)/1000)\n+\n+        mempool = node.getrawmempool(verbose=True)\n+        all_times = [ value[\"time\"] for key, value in mempool.items() ]\n+        earliest_time, latest_time = sorted(all_times)[::len(all_times)-1]\n+        mock_time = latest_time + recent_tx_window - 1\n+        max_fee = 0\n+\n+        # Track how many blocks are found with/without recent transactions\n+        blocks_with_recent_tx = 0\n+        blocks_without_recent_tx = 0\n+\n+        while mock_time >= earliest_time + recent_tx_window:\n+            node.setmocktime(mock_time)\n+            self.add_empty_block(node) # bypass gbt cache\n+            template = node.getblocktemplate({\"rules\":[\"segwit\"]})\n+            template_txids = [ x['txid'] for x in template['transactions'] ]\n+\n+            block_fee = 0\n+            consensus_fee = 0\n+            contains_recent_tx = False\n+            recent_tx_weight = 0\n+            for x in template['transactions']:\n+                block_fee += int(mempool[x['txid']]['modifiedfee']*COIN)\n+                consensus_fee += x['fee']\n+                if (mempool[x['txid']]['time'] > mock_time - recent_tx_window):\n+                    self.log.debug(\"Contains recent tx %s time %d (%d, %d)\",\n+                            x['txid'], mempool[x['txid']]['time'], mock_time,\n+                            recent_tx_window)\n+                    contains_recent_tx = True\n+                    recent_tx_weight += x['weight']\n+            if block_fee > max_fee:\n+                self.log.debug(\"Setting max_fee to %d\", block_fee)\n+                max_fee = block_fee\n+            block_reward = template['coinbasevalue'] - consensus_fee\n+\n+            if (not contains_recent_tx):\n+                # If we don't have anything new, we better be close to the max\n+                # seen so far\n+                self.log.debug(\"No recent transactions, block_fee = %d, block_reward=%d\", block_fee, block_reward)\n+                assert (block_reward + block_fee >= (1-recent_tx_stale_rate)*(block_reward + max_fee))\n+                blocks_without_recent_tx += 1\n+\n+            else:\n+                # Deprioritise everything recent and re-run; the fee delta\n+                # should be significant\n+                blocks_with_recent_tx += 1\n+\n+                for txid, entry in mempool.items():\n+                    if (entry[\"time\"] > mock_time - recent_tx_window):\n+                        node.prioritisetransaction(txid, int(-(entry[\"fee\"]*COIN)))\n+                        if (txid in template_txids):\n+                            # The mining algorithm will include non-recent\n+                            # ancestors of recently included transactions.\n+                            # If this is improved in the future, this portion\n+                            # of the test would need to change.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r121218426",
      "id" : 121218426,
      "original_commit_id" : "5d07339a064ed48f62c696c0d5e0f1078351e551",
      "original_position" : 258,
      "path" : "test/functional/mining.py",
      "position" : null,
      "pull_request_review_id" : 43224963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/121218426",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "@sdaftuar Needs rebase soonish. Lets get this in after branching.",
      "created_at" : "2017-07-18T17:46:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-316141998",
      "id" : 316141998,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-07-18T17:46:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/316141998",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133301496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133301496"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FYI I've reworked this code in the latest version, combining the removal of transactions and updating `mapModifiedTx`, as this was needlessly inefficient (with an extra call to `CalculateDescendants`).\r\n\r\nBut to answer your question: `mapModifiedTx` contains transactions that are not in the constructed block which have ancestors that are in the block.  When we remove a transaction from the block, we need to remove any in-block descendants (which won't be in `mapModifiedTx`), but we need to update the ancestor feerate score for the entries in `mapModifiedTx`, so that the packages are properly sorted.\r\n\r\nSince we generally should never select those transactions on the next call to `addPackageTxs` (outside of reorg situations, the arrival time of a descendant should be later than the arrival time of the parent), it might be better to just remove those descendants from `mapModifiedTx` rather than correct the package information, but I think its simpler to reason about the code if `mapModifiedTx` is always sorted correctly.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-15T20:57:02Z",
      "diff_hunk" : "@@ -342,6 +366,24 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n     return nDescendantsUpdated;\n }\n \n+void BlockAssembler::UpdatePackagesForRemoved(const CTxMemPool::setEntries& removed,\n+        indexed_modified_transaction_set &mapModifiedTx)\n+{\n+    for (const CTxMemPool::txiter it : removed) {\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(it, descendants);\n+        for(CTxMemPool::txiter desc : descendants) {\n+            if (removed.count(desc)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133301496",
      "id" : 133301496,
      "in_reply_to_id" : 121202679,
      "original_commit_id" : "c392582000d1f5bbd07d19177c2aa8e62f9405da",
      "original_position" : 148,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 56467576,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133301496",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133302141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133302141"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think \"given\" is right in the probabilistic sense here; I think I do mean `P(stale block | block has recent tx)`.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-15T20:59:41Z",
      "diff_hunk" : "@@ -489,6 +489,8 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n+    strUsage += HelpMessageOpt(\"-recenttxwindow=<n>\", strprintf(_(\"Set window size in milliseconds for defining transactions as 'recently received' (default: %d)\"), DEFAULT_RECENT_TX_WINDOW));\n+    strUsage += HelpMessageOpt(\"-recenttxstalerate=<n>\", strprintf(_(\"Set stale (orphan) rate for blocks that contain 'recently received' transactions. This is the probability that block income will be lost given that a recently received transaction was included; transaction selection skips over recently received transactions (defined by -recenttxwindow) unless doing so would result in a decrease of block income exceeding this rate (default: %f)\"), DEFAULT_RECENT_TX_STALE_RATE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133302141",
      "id" : 133302141,
      "in_reply_to_id" : 121206593,
      "original_commit_id" : "73eaf01453ae0cdb17ee87096c1c3ef7b5c6e137",
      "original_position" : 5,
      "path" : "src/init.cpp",
      "position" : 5,
      "pull_request_review_id" : 56468322,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133302141",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133540494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133540494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "My thought was that `nPackagesSelected` and `nDescendantsUpdated` are mostly here to help parameterize the runtime, as we expect this to be slower the more packages are looked at and the more descendants that have to be walked to update scores.  \r\n\r\nI guess it can be a little confusing if someone might try to interpret this as the actual number of packages in the block, because that will be incorrect after this PR...",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-16T19:11:01Z",
      "diff_hunk" : "@@ -159,43 +162,63 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     int nDescendantsUpdated = 0;\n     addPackageTxs(workState, nPackagesSelected, nDescendantsUpdated, std::numeric_limits<int64_t>::max(), mapModifiedTx);\n \n+    CTxMemPool::setEntries skippedTransactions;\n+\n+    // Duplicate the working state\n+    WorkingState noRecentWorkState(workState);\n+\n+    // TODO: allow the time window to be configurable\n+    RemoveRecentTransactionsFromBlock(noRecentWorkState, GetTime() - nRecentTxWindow, skippedTransactions);\n+    UpdatePackagesForRemoved(skippedTransactions, mapModifiedTx);\n+\n+    // Re-add to this block, skipping recent transactions\n+    addPackageTxs(noRecentWorkState, nPackagesSelected, nDescendantsUpdated, GetTime() - nRecentTxWindow, mapModifiedTx);\n+\n     int64_t nTime1 = GetTimeMicros();\n \n-    nLastBlockTx = workState.nBlockTx;\n-    nLastBlockSize = workState.nBlockSize;\n-    nLastBlockWeight = workState.nBlockWeight;\n+    // Now compare and decide which block to use\n+    WorkingState *winner = &workState;\n+    // TODO: replace this with a configurable threshold\n+    CAmount blockSubsidy = GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    if (blockSubsidy + noRecentWorkState.nModifiedFees >= 1.0 * (workState.nModifiedFees + blockSubsidy)) {\n+        winner = &noRecentWorkState;\n+    }\n+\n+    nLastBlockTx = winner->nBlockTx;\n+    nLastBlockSize = winner->nBlockSize;\n+    nLastBlockWeight = winner->nBlockWeight;\n \n     // Create coinbase transaction.\n     CMutableTransaction coinbaseTx;\n     coinbaseTx.vin.resize(1);\n     coinbaseTx.vin[0].prevout.SetNull();\n     coinbaseTx.vout.resize(1);\n     coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n-    coinbaseTx.vout[0].nValue = workState.nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    coinbaseTx.vout[0].nValue = winner->nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n     coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n-    workState.pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\n-    workState.pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*workState.pblock, pindexPrev, chainparams.GetConsensus());\n-    workState.pblocktemplate->vTxFees[0] = -workState.nFees;\n+    winner->pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\n+    winner->pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*winner->pblock, pindexPrev, chainparams.GetConsensus());\n+    winner->pblocktemplate->vTxFees[0] = -winner->nFees;\n \n-    uint64_t nSerializeSize = GetSerializeSize(*workState.pblock, SER_NETWORK, PROTOCOL_VERSION);\n-    LogPrintf(\"CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\\n\", nSerializeSize, GetBlockWeight(*workState.pblock), workState.nBlockTx, workState.nFees, workState.nBlockSigOpsCost);\n+    uint64_t nSerializeSize = GetSerializeSize(*winner->pblock, SER_NETWORK, PROTOCOL_VERSION);\n+    LogPrintf(\"CreateNewBlock(): total size: %u block weight: %u txs: %u fees: %ld sigops %d\\n\", nSerializeSize, GetBlockWeight(*winner->pblock), winner->nBlockTx, winner->nFees, winner->nBlockSigOpsCost);\n \n     // Fill in header\n-    workState.pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-    UpdateTime(workState.pblock, chainparams.GetConsensus(), pindexPrev);\n-    workState.pblock->nBits          = GetNextWorkRequired(pindexPrev, workState.pblock, chainparams.GetConsensus());\n-    workState.pblock->nNonce         = 0;\n-    workState.pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*workState.pblock->vtx[0]);\n+    winner->pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n+    UpdateTime(winner->pblock, chainparams.GetConsensus(), pindexPrev);\n+    winner->pblock->nBits          = GetNextWorkRequired(pindexPrev, winner->pblock, chainparams.GetConsensus());\n+    winner->pblock->nNonce         = 0;\n+    winner->pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*winner->pblock->vtx[0]);\n \n     CValidationState state;\n-    if (!TestBlockValidity(state, chainparams, *workState.pblock, pindexPrev, false, false)) {\n+    if (!TestBlockValidity(state, chainparams, *winner->pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n     }\n     int64_t nTime2 = GetTimeMicros();\n \n     LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r133540494",
      "id" : 133540494,
      "in_reply_to_id" : 121203897,
      "original_commit_id" : "c392582000d1f5bbd07d19177c2aa8e62f9405da",
      "original_position" : 97,
      "path" : "src/miner.cpp",
      "position" : 211,
      "pull_request_review_id" : 56734218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/133540494",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Rebased.",
      "created_at" : "2017-08-16T19:11:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-322870496",
      "id" : 322870496,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-08-16T19:11:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/322870496",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136094399"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136094399"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Encapsulate working state for a single call to CreateNewBlock()\"\r\n\r\nMight be good to make these 4000/1000 values constants since they are used in other places.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T15:00:49Z",
      "diff_hunk" : "@@ -132,25 +132,52 @@ struct update_for_parent_inclusion\n class BlockAssembler\n {\n private:\n-    // The constructed block template\n-    std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    // A convenience pointer that always refers to the CBlock in pblocktemplate\n-    CBlock* pblock;\n+    // The state associated with construction of a block.\n+    struct WorkingState {\n+        WorkingState() :\n+            pblocktemplate(new CBlockTemplate()),\n+            pblock(&pblocktemplate->block),\n+            // Reserve space for coinbase tx\n+            nBlockWeight(4000),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136094399",
      "id" : 136094399,
      "original_commit_id" : "86cf1386db813734b35a587ba02b650c0ec5fb9d",
      "original_position" : 14,
      "path" : "src/miner.h",
      "position" : 32,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136094399",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136097428"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136097428"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Encapsulate working state for a single call to CreateNewBlock()\"\r\n\r\nLooks like AddToBlock, addPackageTxs, onlyUnconfirmed, TestPackageTransactions, SkipMapTxEntry, SortForBlock, and UpdatePackagesForAdded could all be const methods now.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T15:09:43Z",
      "diff_hunk" : "@@ -172,32 +199,30 @@ class BlockAssembler\n \n private:\n     // utility functions\n-    /** Clear the block's state and prepare for assembling a new block */\n-    void resetBlock();\n     /** Add a tx to the block */\n-    void AddToBlock(CTxMemPool::txiter iter);\n+    void AddToBlock(WorkingState &workState, CTxMemPool::txiter iter);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136097428",
      "id" : 136097428,
      "original_commit_id" : "86cf1386db813734b35a587ba02b650c0ec5fb9d",
      "original_position" : 73,
      "path" : "src/miner.h",
      "position" : null,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136097428",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136112193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136112193"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Makes sense. I don't actually remember what I meant in that comment.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T15:56:53Z",
      "diff_hunk" : "@@ -489,6 +489,8 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n     strUsage += HelpMessageOpt(\"-blockmaxsize=<n>\", strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE));\n     strUsage += HelpMessageOpt(\"-blockmintxfee=<amt>\", strprintf(_(\"Set lowest fee rate (in %s/kB) for transactions to be included in block creation. (default: %s)\"), CURRENCY_UNIT, FormatMoney(DEFAULT_BLOCK_MIN_TX_FEE)));\n+    strUsage += HelpMessageOpt(\"-recenttxwindow=<n>\", strprintf(_(\"Set window size in milliseconds for defining transactions as 'recently received' (default: %d)\"), DEFAULT_RECENT_TX_WINDOW));\n+    strUsage += HelpMessageOpt(\"-recenttxstalerate=<n>\", strprintf(_(\"Set stale (orphan) rate for blocks that contain 'recently received' transactions. This is the probability that block income will be lost given that a recently received transaction was included; transaction selection skips over recently received transactions (defined by -recenttxwindow) unless doing so would result in a decrease of block income exceeding this rate (default: %f)\"), DEFAULT_RECENT_TX_STALE_RATE));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136112193",
      "id" : 136112193,
      "in_reply_to_id" : 121206593,
      "original_commit_id" : "73eaf01453ae0cdb17ee87096c1c3ef7b5c6e137",
      "original_position" : 5,
      "path" : "src/init.cpp",
      "position" : 5,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136112193",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136118045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136118045"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Skip recent transactions in CNB if fee difference is small\"\r\n\r\nSince this isn't penalizing recent transactions yet, does this commit change behavior at all? Might be worth mentioning if it does in the commit message.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T16:18:40Z",
      "diff_hunk" : "@@ -153,45 +181,67 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n \n     int nPackagesSelected = 0;\n     int nDescendantsUpdated = 0;\n+\n+    // First, we add transactions without regard to received time of\n+    // transactions, based on ancestor feerate score.\n     addPackageTxs(workState, nPackagesSelected, nDescendantsUpdated, std::numeric_limits<int64_t>::max(), mapModifiedTx);\n \n+    // Duplicate the working state, and remove the recently received\n+    // transactions from the block.\n+    WorkingState noRecentWorkState(workState);\n+\n+    // TODO: allow the time window to be configurable\n+    int64_t nTimeCutoff = GetTime() - nRecentTxWindow;\n+    RemoveRecentTransactionsFromBlockAndUpdatePackages(noRecentWorkState, nTimeCutoff, mapModifiedTx);\n+\n+    // Re-add to this block, skipping recent transactions from transaction selection.\n+    addPackageTxs(noRecentWorkState, nPackagesSelected, nDescendantsUpdated, nTimeCutoff, mapModifiedTx);\n+\n     int64_t nTime1 = GetTimeMicros();\n \n-    nLastBlockTx = workState.nBlockTx;\n-    nLastBlockSize = workState.nBlockSize;\n-    nLastBlockWeight = workState.nBlockWeight;\n+    // Now compare and decide which block to use\n+    WorkingState *winner = &workState;\n+    // TODO: replace this with a configurable threshold\n+    CAmount blockSubsidy = GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    if (blockSubsidy + noRecentWorkState.nModifiedFees >= 1.0 * (workState.nModifiedFees + blockSubsidy)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136118045",
      "id" : 136118045,
      "original_commit_id" : "e8dcf5018c29a2609b673d7cae88144ad82ad5bb",
      "original_position" : 83,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136118045",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136142314"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136142314"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Skip recent transactions in CNB if fee difference is small\"\r\n\r\nShould this say older? Child having a newer arrival time sounds like the normal case.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T17:50:17Z",
      "diff_hunk" : "@@ -263,6 +314,74 @@ void BlockAssembler::AddToBlock(WorkingState &workState, CTxMemPool::txiter iter\n     }\n }\n \n+void BlockAssembler::RemoveRecentTransactionsFromBlockAndUpdatePackages(WorkingState &workState, int64_t timeCutoff, indexed_modified_transaction_set &mapModifiedTx)\n+{\n+    std::vector<CTransactionRef> vtxCopy;\n+    vtxCopy.reserve(workState.pblocktemplate->block.vtx.size());\n+    std::vector<CAmount> vTxFeesCopy;\n+    vTxFeesCopy.reserve(vtxCopy.size());\n+    std::vector<int64_t> vTxSigOpsCostCopy;\n+    vTxSigOpsCostCopy.reserve(vtxCopy.size());\n+\n+    CTxMemPool::setEntries descendantTransactions;\n+    for (const CTransactionRef &ptx : workState.pblocktemplate->block.vtx) {\n+        if (vtxCopy.empty()) {\n+            // This is the coinbase placeholder; just copy its\n+            // information over.\n+            vtxCopy.push_back(ptx);\n+            vTxFeesCopy.push_back(workState.pblocktemplate->vTxFees[0]);\n+            vTxSigOpsCostCopy.push_back(workState.pblocktemplate->vTxSigOpsCost[0]);\n+            continue;\n+        }\n+        // TODO: Store the mempool entry iterators in another vector to save this\n+        // lookup.\n+        CTxMemPool::txiter it = mempool.mapTx.find(ptx->GetHash());\n+        assert(it != mempool.mapTx.end());\n+        // Keep any transactions that are sufficiently old, but skip transactions\n+        // that depend on removed transactions.  (Note that it's technically",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136142314",
      "id" : 136142314,
      "original_commit_id" : "e8dcf5018c29a2609b673d7cae88144ad82ad5bb",
      "original_position" : 174,
      "path" : "src/miner.cpp",
      "position" : 314,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136142314",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136151439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136151439"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[qa] Add functional test for CreateNewBlock\"\r\n\r\nDon't need to pass max_income and cur_time variables as arguments since they are already in scope.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T18:23:57Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({\n+                \"rules\": [\"segwit\"]\n+                })['coinbasevalue']\n+\n+            # Check that calling gbt on the given node produces a block\n+            # within the expected tolerance of max_income.\n+            # Return true if the returned block includes recent transactions;\n+            # false otherwise\n+            def check_gbt_results(node, max_income, cnb_args, cur_time):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136151439",
      "id" : 136151439,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 247,
      "path" : "test/functional/createnewblock.py",
      "position" : null,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136151439",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136152186"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136152186"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Mining: configure 'recency' and 'stale rate' from command line\"\r\n\r\nShould convert milliseconds -> seconds?",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T18:26:39Z",
      "diff_hunk" : "@@ -65,7 +66,8 @@ BlockAssembler::Options::Options() {\n     blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n     nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n-    nRecentTxWindow = 10; // TODO: make this configurable\n+    nRecentTxWindow = DEFAULT_RECENT_TX_WINDOW;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136152186",
      "id" : 136152186,
      "original_commit_id" : "72e2ab0378c2baa13b6f1e80b3adcc302787c367",
      "original_position" : 13,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136152186",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136156848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136156848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[qa] Add functional test for CreateNewBlock\"\r\n\r\nCould you add a comment saying why it is right to treat node 3 income as max income. This seems like it would be correct if node 3 were started with `-recenttxwindow=0 -recenttxstalerate=0`, but nodes 0 & 2 have shorter recent window and stale rate values (respectively) than node 3.\r\n",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T18:44:39Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136156848",
      "id" : 136156848,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 239,
      "path" : "test/functional/createnewblock.py",
      "position" : 249,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136156848",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136158939"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136158939"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[qa] Add functional test for CreateNewBlock\"\r\n\r\nCan you expand comment to say why the transaction should exactly one ancestor not in the block. I notice in the previous version of the test it was looking for a transaction with at least one ancestor not in the block.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T18:53:20Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136158939",
      "id" : 136158939,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 160,
      "path" : "test/functional/createnewblock.py",
      "position" : null,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136158939",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136160667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136160667"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"[qa] Add functional test for CreateNewBlock\"\r\n\r\nDoes it make sense to warn if no block contains recent transactions?",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-30T19:00:49Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({\n+                \"rules\": [\"segwit\"]\n+                })['coinbasevalue']\n+\n+            # Check that calling gbt on the given node produces a block\n+            # within the expected tolerance of max_income.\n+            # Return true if the returned block includes recent transactions;\n+            # false otherwise\n+            def check_gbt_results(node, max_income, cnb_args, cur_time):\n+                template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+                mempool = node.getrawmempool(verbose=True)\n+                stale_rate = cnb_args['stalerate']\n+                # Convert window from milliseconds to seconds\n+                window = (cnb_args['window'] + 999) // 1000\n+\n+                # We should always be within stale_rate of best possible block\n+                assert template['coinbasevalue'] >= stale_rate * max_income\n+\n+                # Check that if we're including any recent transactions, then\n+                # we achieve the max_income\n+                includes_recent_transactions = False\n+                for x in template['transactions']:\n+                    if mempool[x['txid']]['time'] > cur_time - window:\n+                        includes_recent_transactions = True\n+                        break\n+\n+                if includes_recent_transactions:\n+                    assert template['coinbasevalue'] == max_income\n+\n+                return includes_recent_transactions\n+\n+            for j in range(3):\n+                if check_gbt_results(self.nodes[j], max_income,\n+                                     self.cnb_args[j], cur_time):\n+                    recent_tx_block_count[j] += 1\n+\n+            # Drain the mempool if it gets big\n+            if self.nodes[0].getmempoolinfo()['bytes'] > 400000:\n+                self.nodes[0].generate(1)\n+            else:\n+                [node.setmocktime(0) for node in self.nodes]\n+                self.add_empty_block(self.nodes[0])\n+            self.sync_all()\n+\n+        if sum(recent_tx_block_count) == 3 * max_iterations:\n+            self.log.warn(\n+                \"Warning: every block contained recent transactions!\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136160667",
      "id" : 136160667,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 285,
      "path" : "test/functional/createnewblock.py",
      "position" : 294,
      "pull_request_review_id" : 59585338,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136160667",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136400820"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136400820"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah that's worth explaining.  The issue was that if you got unlucky you might find a transaction with, eg, 2 ancestors, one in the block and one not in the block.  Then the ancestor feerate stats for the child tx would not be correct for determining how much to fee bump (eg you might be including some higher feerate parent in the calculation!) which could cause the test to fail.\r\n\r\nBy requiring that we look for a transaction with exactly one not-in-block parent, we can exclude edge cases where other transactions might affect the package feerate used in CNB.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-31T17:40:39Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136400820",
      "id" : 136400820,
      "in_reply_to_id" : 136158939,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 160,
      "path" : "test/functional/createnewblock.py",
      "position" : null,
      "pull_request_review_id" : 59935924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136400820",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136407145"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136407145"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This does change behavior, both performance and there's some chance that you choose different transactions (eg if you get the same fees or higher by looking at only an older set of transactions, which is possible, eg if all the fees in the mempool were the same, or just by chance due to what ends up fitting in the block etc).",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-08-31T18:05:09Z",
      "diff_hunk" : "@@ -153,45 +181,67 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n \n     int nPackagesSelected = 0;\n     int nDescendantsUpdated = 0;\n+\n+    // First, we add transactions without regard to received time of\n+    // transactions, based on ancestor feerate score.\n     addPackageTxs(workState, nPackagesSelected, nDescendantsUpdated, std::numeric_limits<int64_t>::max(), mapModifiedTx);\n \n+    // Duplicate the working state, and remove the recently received\n+    // transactions from the block.\n+    WorkingState noRecentWorkState(workState);\n+\n+    // TODO: allow the time window to be configurable\n+    int64_t nTimeCutoff = GetTime() - nRecentTxWindow;\n+    RemoveRecentTransactionsFromBlockAndUpdatePackages(noRecentWorkState, nTimeCutoff, mapModifiedTx);\n+\n+    // Re-add to this block, skipping recent transactions from transaction selection.\n+    addPackageTxs(noRecentWorkState, nPackagesSelected, nDescendantsUpdated, nTimeCutoff, mapModifiedTx);\n+\n     int64_t nTime1 = GetTimeMicros();\n \n-    nLastBlockTx = workState.nBlockTx;\n-    nLastBlockSize = workState.nBlockSize;\n-    nLastBlockWeight = workState.nBlockWeight;\n+    // Now compare and decide which block to use\n+    WorkingState *winner = &workState;\n+    // TODO: replace this with a configurable threshold\n+    CAmount blockSubsidy = GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n+    if (blockSubsidy + noRecentWorkState.nModifiedFees >= 1.0 * (workState.nModifiedFees + blockSubsidy)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r136407145",
      "id" : 136407145,
      "in_reply_to_id" : 136118045,
      "original_commit_id" : "e8dcf5018c29a2609b673d7cae88144ad82ad5bb",
      "original_position" : 83,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 59942957,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136407145",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137058357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137058357"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I made the functional tests default to having -recenttxstalerate=0, to avoid breakage of existing tests due to this new behavior (see the change to `test_node.py` in https://github.com/bitcoin/bitcoin/pull/10200/commits/72e2ab0378c2baa13b6f1e80b3adcc302787c367#diff-86294e5ae5283eebdd9f98d79007a0e1).  I can add a comment as well...",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T17:17:09Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137058357",
      "id" : 137058357,
      "in_reply_to_id" : 136156848,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 239,
      "path" : "test/functional/createnewblock.py",
      "position" : 249,
      "pull_request_review_id" : 60677520,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:40:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137058357",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094068"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done in 97d439af0feb8b4ccc34e7226cd11a791393c93a",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:42:01Z",
      "diff_hunk" : "@@ -172,32 +199,30 @@ class BlockAssembler\n \n private:\n     // utility functions\n-    /** Clear the block's state and prepare for assembling a new block */\n-    void resetBlock();\n     /** Add a tx to the block */\n-    void AddToBlock(CTxMemPool::txiter iter);\n+    void AddToBlock(WorkingState &workState, CTxMemPool::txiter iter);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094068",
      "id" : 137094068,
      "in_reply_to_id" : 136097428,
      "original_commit_id" : "86cf1386db813734b35a587ba02b650c0ec5fb9d",
      "original_position" : 73,
      "path" : "src/miner.h",
      "position" : null,
      "pull_request_review_id" : 60717228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:42:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094068",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094100"
         }
      },
      "author_association" : "MEMBER",
      "body" : "done",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:42:09Z",
      "diff_hunk" : "@@ -65,7 +66,8 @@ BlockAssembler::Options::Options() {\n     blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n     nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n     nBlockMaxSize = DEFAULT_BLOCK_MAX_SIZE;\n-    nRecentTxWindow = 10; // TODO: make this configurable\n+    nRecentTxWindow = DEFAULT_RECENT_TX_WINDOW;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094100",
      "id" : 137094100,
      "in_reply_to_id" : 136152186,
      "original_commit_id" : "72e2ab0378c2baa13b6f1e80b3adcc302787c367",
      "original_position" : 13,
      "path" : "src/miner.cpp",
      "position" : null,
      "pull_request_review_id" : 60717265,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:42:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094100",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094149"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks, fixed.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:42:22Z",
      "diff_hunk" : "@@ -263,6 +314,74 @@ void BlockAssembler::AddToBlock(WorkingState &workState, CTxMemPool::txiter iter\n     }\n }\n \n+void BlockAssembler::RemoveRecentTransactionsFromBlockAndUpdatePackages(WorkingState &workState, int64_t timeCutoff, indexed_modified_transaction_set &mapModifiedTx)\n+{\n+    std::vector<CTransactionRef> vtxCopy;\n+    vtxCopy.reserve(workState.pblocktemplate->block.vtx.size());\n+    std::vector<CAmount> vTxFeesCopy;\n+    vTxFeesCopy.reserve(vtxCopy.size());\n+    std::vector<int64_t> vTxSigOpsCostCopy;\n+    vTxSigOpsCostCopy.reserve(vtxCopy.size());\n+\n+    CTxMemPool::setEntries descendantTransactions;\n+    for (const CTransactionRef &ptx : workState.pblocktemplate->block.vtx) {\n+        if (vtxCopy.empty()) {\n+            // This is the coinbase placeholder; just copy its\n+            // information over.\n+            vtxCopy.push_back(ptx);\n+            vTxFeesCopy.push_back(workState.pblocktemplate->vTxFees[0]);\n+            vTxSigOpsCostCopy.push_back(workState.pblocktemplate->vTxSigOpsCost[0]);\n+            continue;\n+        }\n+        // TODO: Store the mempool entry iterators in another vector to save this\n+        // lookup.\n+        CTxMemPool::txiter it = mempool.mapTx.find(ptx->GetHash());\n+        assert(it != mempool.mapTx.end());\n+        // Keep any transactions that are sufficiently old, but skip transactions\n+        // that depend on removed transactions.  (Note that it's technically",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094149",
      "id" : 137094149,
      "in_reply_to_id" : 136142314,
      "original_commit_id" : "e8dcf5018c29a2609b673d7cae88144ad82ad5bb",
      "original_position" : 174,
      "path" : "src/miner.cpp",
      "position" : 314,
      "pull_request_review_id" : 60717314,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:42:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094149",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed in 497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:43:06Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({\n+                \"rules\": [\"segwit\"]\n+                })['coinbasevalue']\n+\n+            # Check that calling gbt on the given node produces a block\n+            # within the expected tolerance of max_income.\n+            # Return true if the returned block includes recent transactions;\n+            # false otherwise\n+            def check_gbt_results(node, max_income, cnb_args, cur_time):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094366",
      "id" : 137094366,
      "in_reply_to_id" : 136151439,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 247,
      "path" : "test/functional/createnewblock.py",
      "position" : null,
      "pull_request_review_id" : 60717515,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:43:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094366",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done in 497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:43:14Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test transaction selection (CreateNewBlock).\n+\n+  - Test that block max weight is respected (no blocks too big).\n+  - Test that if the mempool has a tx that fits in a block, it will always be\n+    included unless the block is within 4000 of max weight.\n+  - Test that transaction selection takes into account feerate-with-ancestors\n+    when creating blocks.\n+  - Test that recently received transactions aren't selected unless the\n+    feerate for including them is high.\n+\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.blocktools import create_block, create_coinbase\n+from test_framework.mininode import ToHex\n+from test_framework.util import (\n+    random_transaction,\n+    connect_nodes,\n+)\n+from test_framework.authproxy import JSONRPCException\n+from decimal import Decimal\n+import random\n+import time\n+\n+class CreateNewBlockTest(BitcoinTestFramework):\n+    def __init__(self):\n+        super().__init__()\n+        self.num_nodes = 4\n+        self.setup_clean_chain = True\n+\n+    def setup_network(self, split=False):\n+        self.cnb_args = [{\n+            'window': 10000,\n+            'stalerate': 0.02\n+        }, {\n+            'window': 30000,\n+            'stalerate': 0.1\n+        }, {\n+            'window': 50000,\n+            'stalerate': 0.001\n+        }]\n+\n+        # Ancestor/descendant size limits are boosted because this test will\n+        # populate and sync mempools using unconfirmed transaction chains, and\n+        # failure to sync the mempool between nodes (eg due to descendant\n+        # counts differing between nodes that see transactions in different\n+        # order) will cause test failure.\n+        # Set blockmaxweight to be low, to require fewer transactions\n+        # to fill up a block.\n+        extra_args = [[\n+            \"-debug\", \"-blockmaxweight=400000\", \"-minrelaytxfee=0\",\n+            \"-limitancestorcount=100\", \"-limitdescendantcount=100\"\n+        ] for i in range(self.num_nodes)]\n+        for extra_arg, cnb_arg in zip(extra_args, self.cnb_args):\n+            extra_arg.extend([\n+                \"-recenttxwindow=%s\" % cnb_arg['window'],\n+                \"-recenttxstalerate=%s\" % cnb_arg['stalerate']\n+            ])\n+        self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir,\n+                                      extra_args)\n+\n+        # Connect the network in a loop\n+        for i in range(self.num_nodes - 1):\n+            connect_nodes(self.nodes[i], i + 1)\n+        connect_nodes(self.nodes[-1], 0)\n+\n+        self.is_network_split = False\n+\n+    def populate_mempool(self, desired_transactions):\n+        num_transactions = 0\n+        while (num_transactions < desired_transactions):\n+            try:\n+                random_amount = random.randint(1, 10) * Decimal('0.1')\n+                random_transaction(\n+                    self.nodes,\n+                    amount=random_amount,\n+                    min_fee=Decimal(\"0.00001\"),\n+                    fee_increment=Decimal(\"0.000005\"),\n+                    fee_variants=5000,\n+                    confirmations_required=0,\n+                    allow_segwit=True)\n+                num_transactions += 1\n+            except RuntimeError as e:\n+                # We might run out of funds; just count these as valid attempts\n+                if \"Insufficient funds\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected run time error: \" +\n+                                         e.error['message'])\n+            except JSONRPCException as e:\n+                if \"too-long-mempool\" in e.error['message']:\n+                    num_transactions += 1\n+                else:\n+                    raise AssertionError(\"Unexpected JSON-RPC error: \" +\n+                                         e.error['message'])\n+            except Exception as e:\n+                raise AssertionError(\"Unexpected exception raised: \" +\n+                                     type(e).__name__)\n+        self.sync_all()\n+\n+    # Approximate weight of the transactions in the mempool\n+    def get_mempool_weight(self, node):\n+        mempool = node.getrawmempool(verbose=True)\n+        weight = 0\n+        for txid, entry in mempool.items():\n+            # Scale by the witness multiplier, since we get vsize back\n+            weight += entry['size'] * 4\n+        return weight\n+\n+    # Requires mempool to be populated ahead of time\n+    def test_max_block_weight(self, node):\n+        block_max_weight = 400000 - 4000  # 4000 reserved for coinbase\n+        assert self.get_mempool_weight(node) > block_max_weight\n+\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_weight = 0\n+        for x in template['transactions']:\n+            block_weight += x['weight']\n+        assert (block_weight > block_max_weight - 4000)\n+        assert (block_weight < block_max_weight)\n+\n+    def add_empty_block(self, node):\n+        height = node.getblockcount()\n+        tip = node.getbestblockhash()\n+        mtp = node.getblockheader(tip)['mediantime']\n+        block = create_block(\n+            int(tip, 16), create_coinbase(height + 1), mtp + 1)\n+        block.nVersion = 4\n+        block.solve()\n+        node.submitblock(ToHex(block))\n+\n+        # Log the hash to make it easier to figure out where we are in the\n+        # test, when debugging.\n+        self.log.debug(\"Added empty block %s\", block.hash)\n+\n+    # Test that transaction selection is via ancestor feerate, by showing that\n+    # it's sufficient to bump a child tx's fee to get it and its parent\n+    # included.\n+    def test_ancestor_feerate_sort(self, node, recent_tx_window):\n+\n+        # Advance time to the future, to ensure recent-transaction-filtering\n+        # isn't affecting the test.\n+        node.setmocktime(int(time.time()) + (recent_tx_window + 999) // 1000 + 1)\n+        self.add_empty_block(node)  # bypass the gbt cache\n+\n+        # Call getblocktemplate.  Find a transaction in the mempool that is not\n+        # in the block, which has exactly 1 ancestor that is also not in the\n+        # block.  Call prioritisetransaction on the child tx to boost its\n+        # ancestor feerate to be above the maximum feerate of transactions in\n+        # the last ancestor_size space in the block, and verify that the child\n+        # transaction is in the next block template.\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+        mempool_txids = node.getrawmempool()\n+\n+        # Find a transaction that has exactly one ancestor that is also not in\n+        # the block.\n+        txid_to_bump = None\n+\n+        for txid in mempool_txids:\n+            if txid not in block_txids:\n+                ancestor_txids = node.getmempoolancestors(\n+                    txid=txid, verbose=False)\n+                if len(ancestor_txids) != 1:\n+                    continue\n+                if ancestor_txids[0] not in block_txids:\n+                    txid_to_bump = txid\n+                    break\n+            if txid_to_bump is not None:\n+                break\n+        if txid_to_bump is None:\n+            raise AssertionError(\n+                \"Can't find candidate to test ancestor feerate score (test setup bug)\"\n+            )\n+\n+        # Calculate the ancestor feerate of the candidate transaction.\n+        mempool_entry = node.getmempoolentry(txid_to_bump)\n+        ancestor_size = mempool_entry['ancestorsize']\n+        ancestor_fee = mempool_entry['ancestorfees']\n+        tx_fee = mempool_entry['modifiedfee']\n+        tx_size = mempool_entry['size']\n+        self.log.debug(\n+                \"Found txid to bump: %s, ancestor_size = %d, ancestor_fee = %f (ancestor feerate: %f) size = %d mod_fee = %d (feerate: %f)\",\n+            txid_to_bump, ancestor_size, ancestor_fee, ancestor_fee/ancestor_size, tx_size, tx_fee, tx_fee/tx_size)\n+\n+        # Determine feerate of the last ancestor_size portion of the block.\n+        cumulative_weight = 0\n+        max_feerate = 0\n+        for block_tx in reversed(template[\"transactions\"]):\n+            # The fee is the consensus correct one, not the policy modified\n+            # one, but we haven't prioritized anything yet, so this should be\n+            # fine.\n+            self.log.debug(\"End of block tx: txid %s, fee %d, weight %d\",\n+                    block_tx[\"txid\"], block_tx[\"fee\"], block_tx[\"weight\"])\n+            if 4 * block_tx[\"fee\"] / block_tx[\"weight\"] > max_feerate:\n+                max_feerate = 4 * block_tx[\"fee\"] / block_tx[\"weight\"]\n+            cumulative_weight += block_tx[\"weight\"]\n+            if cumulative_weight > 4 * ancestor_size:\n+                break\n+\n+        # Bump the candidate transaction so that it has a higher feerate than\n+        # the max feerate observed in the last portion of the block that we\n+        # seek to replace\n+        fee_bump = int(max_feerate * ancestor_size - ancestor_fee) + 1\n+        self.log.debug(\"Setting fee_bump to %d\", fee_bump)\n+\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=fee_bump)\n+\n+        # Check that the next block template has txid_to_bump in it.\n+        self.add_empty_block(node)  # bypass the gbt cache\n+        template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+        new_block_txids = [x[\"txid\"] for x in template[\"transactions\"]]\n+\n+        assert txid_to_bump in new_block_txids\n+\n+        # Get rid of our prioritisation\n+        node.prioritisetransaction(txid=txid_to_bump, fee_delta=-fee_bump)\n+\n+    def test_recent_transactions(self):\n+        # Populate the mempool with some transactions, and compare gbt results\n+        # across the nodes.  Repeat.\n+        self.add_empty_block(self.nodes[0])  # Bypass gbt cache.\n+        self.sync_all()\n+        recent_tx_block_count = [0, 0, 0]\n+\n+        max_iterations = 20\n+        for i in range(max_iterations):\n+            self.populate_mempool(random.randint(5, 15))  # 5-15 transactions\n+\n+            # Freeze current time, so that our recent tx window calculations\n+            # will be consistent.\n+            cur_time = int(time.time())\n+            [node.setmocktime(cur_time) for node in self.nodes]\n+\n+            # Check that total block reward is within stale_rate of node3\n+            max_income = self.nodes[3].getblocktemplate({\n+                \"rules\": [\"segwit\"]\n+                })['coinbasevalue']\n+\n+            # Check that calling gbt on the given node produces a block\n+            # within the expected tolerance of max_income.\n+            # Return true if the returned block includes recent transactions;\n+            # false otherwise\n+            def check_gbt_results(node, max_income, cnb_args, cur_time):\n+                template = node.getblocktemplate({\"rules\": [\"segwit\"]})\n+                mempool = node.getrawmempool(verbose=True)\n+                stale_rate = cnb_args['stalerate']\n+                # Convert window from milliseconds to seconds\n+                window = (cnb_args['window'] + 999) // 1000\n+\n+                # We should always be within stale_rate of best possible block\n+                assert template['coinbasevalue'] >= stale_rate * max_income\n+\n+                # Check that if we're including any recent transactions, then\n+                # we achieve the max_income\n+                includes_recent_transactions = False\n+                for x in template['transactions']:\n+                    if mempool[x['txid']]['time'] > cur_time - window:\n+                        includes_recent_transactions = True\n+                        break\n+\n+                if includes_recent_transactions:\n+                    assert template['coinbasevalue'] == max_income\n+\n+                return includes_recent_transactions\n+\n+            for j in range(3):\n+                if check_gbt_results(self.nodes[j], max_income,\n+                                     self.cnb_args[j], cur_time):\n+                    recent_tx_block_count[j] += 1\n+\n+            # Drain the mempool if it gets big\n+            if self.nodes[0].getmempoolinfo()['bytes'] > 400000:\n+                self.nodes[0].generate(1)\n+            else:\n+                [node.setmocktime(0) for node in self.nodes]\n+                self.add_empty_block(self.nodes[0])\n+            self.sync_all()\n+\n+        if sum(recent_tx_block_count) == 3 * max_iterations:\n+            self.log.warn(\n+                \"Warning: every block contained recent transactions!\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094398",
      "id" : 137094398,
      "in_reply_to_id" : 136160667,
      "original_commit_id" : "9662d42142e7efa8e5add8e6953566c95e7735cc",
      "original_position" : 285,
      "path" : "test/functional/createnewblock.py",
      "position" : 294,
      "pull_request_review_id" : 60717542,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:43:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094398",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Holding off on this one until after #11100, which I think will cause a rebase for this PR anyway.",
      "commit_id" : "497ae4844922caf4e2244b847a5a63fd2d1a999a",
      "created_at" : "2017-09-05T19:43:57Z",
      "diff_hunk" : "@@ -132,25 +132,52 @@ struct update_for_parent_inclusion\n class BlockAssembler\n {\n private:\n-    // The constructed block template\n-    std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    // A convenience pointer that always refers to the CBlock in pblocktemplate\n-    CBlock* pblock;\n+    // The state associated with construction of a block.\n+    struct WorkingState {\n+        WorkingState() :\n+            pblocktemplate(new CBlockTemplate()),\n+            pblock(&pblocktemplate->block),\n+            // Reserve space for coinbase tx\n+            nBlockWeight(4000),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#discussion_r137094552",
      "id" : 137094552,
      "in_reply_to_id" : 136094399,
      "original_commit_id" : "86cf1386db813734b35a587ba02b650c0ec5fb9d",
      "original_position" : 14,
      "path" : "src/miner.h",
      "position" : 32,
      "pull_request_review_id" : 60717706,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10200",
      "updated_at" : "2017-09-05T19:43:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137094552",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated to address @ryanofsky's comments.  I think I managed to avoid a rebase due to test framework changes with a hacky change to the new test in this PR, but I can squash/rebase whenever reviewers are ready.",
      "created_at" : "2017-09-05T19:44:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-327282610",
      "id" : 327282610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-09-05T19:44:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327282610",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Not sure if/when I'll pick this up, so closing for now.",
      "created_at" : "2017-10-05T17:02:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-334528553",
      "id" : 334528553,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-10-05T17:02:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/334528553",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sdaftuar, I'd volunteer to periodically rebase this & respond to review comments if that's the only thing holding this back.",
      "created_at" : "2017-10-05T17:32:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-334536485",
      "id" : 334536485,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-10-05T17:32:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/334536485",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I would also like to see this one happen, sorry I've been lax on review, too many PRs :(.",
      "created_at" : "2017-10-05T21:55:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-334603232",
      "id" : 334603232,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-10-05T21:55:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/334603232",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky gmaxwell made a good suggestion on IRC recently for simplifying the feature/functionality provided here.  If I remember right, I think he suggested that we could just keep a cache of the last block generated in the BlockAssembler, and when a new call to CNB is made, after we addPackages, but before we call TBV, check to see if this criteria for recent transactions has been met -- if not, return the old template and skip the TBV call.\r\n\r\nThis should speed up calls to CreateNewBlock substantially (most of the time spent is in TestBlockValidity), and provide the benefit of only including recent transactions when its economically beneficial, with a relatively small code change.  \r\n\r\nI think we'd also reduce the window on the cache that already exists in getblocktemplate.",
      "created_at" : "2017-10-13T19:20:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-336544515",
      "id" : 336544515,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "updated_at" : "2017-10-13T19:20:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/336544515",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "According to my simulation(see [source code](https://github.com/naumenkogs/bitcoin_network_analysis/tree/master/propagation_cmpct_blocks)), current strategy (assuming that only coinbase tx is missing) works almost perfect (0.2 RTT or 10% overhead comparing to the best case (relaying empty block), in terms of end-to-end compact block relay between two random private nodes in the network).\r\n\r\nErlay makes it even closer to optimal (0.04 RT or 2% overhead ), so it seems like this feature won't provide much benefit at this point.",
      "created_at" : "2019-07-11T18:07:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10200#issuecomment-510593304",
      "id" : 510593304,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10200",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUxMDU5MzMwNA==",
      "updated_at" : "2019-07-11T18:07:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/510593304",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   }
]
