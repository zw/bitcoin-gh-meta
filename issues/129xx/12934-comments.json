[
   {
      "author_association" : "MEMBER",
      "body" : "cc @theuni\r\n@skeees Have you looked through the current work being done to refactor the P2P code? See [here](https://github.com/bitcoin/bitcoin/projects/4) for an overview.",
      "created_at" : "2018-04-11T04:28:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-380323422",
      "id" : 380323422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-11T04:29:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380323422",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Thanks, yes I have looked through those. This is more focused on separation between net_processing (PeerLogicValidation) and validation, whereas those primarily tackle socket handling and other ConnMan stuff. I don't think there's anything here that's redundant or incompatible with those refactors",
      "created_at" : "2018-04-11T13:27:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-380451284",
      "id" : 380451284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-11T13:27:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380451284",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @TheBlueMatt ",
      "created_at" : "2018-04-13T02:26:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-381001882",
      "id" : 381001882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-13T02:26:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/381001882",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183498792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183498792"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think you could replace this class with `using WorkItem = std::function<void()>;`. Less code and would make queue interface more generic.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T18:44:01Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183498792",
      "id" : 183498792,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzQ5ODc5Mg==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 17,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183498792",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183500740"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183500740"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could maybe use TraceThread from util.h to make the thread name visible to the os.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T18:50:50Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};\n+    void operator()()\n+    {\n+        std::thread::id id = m_consumer.m_thread.get_id();\n+        if(std::this_thread::get_id() != id) {\n+            // this ShutdownPill was intended for another thread\n+\n+            // we haven't seen this pill before\n+            if(!m_threads_observed.count(id) || 0) {\n+                m_threads_observed.insert(std::this_thread::get_id());\n+\n+                // resubmit it so that it gets a chance to get to the right thread\n+                // when resubmitting, do not block and do not care about failures\n+                // theres a potential deadlock where we try to push this to a queue thats\n+                // full and there are no other threads still consuming\n+                // since the only purpose of reinjecting this is to terminate threads that\n+                // may be blocking on an empty queue when the queue is full we do not need to do this\n+                ShutdownPill * copy = new ShutdownPill(std::move(*this));\n+                m_consumer.m_queue->Push(std::unique_ptr<ShutdownPill>(copy), WorkerMode::NONBLOCKING);\n+            }\n+\n+            // if the same pill has been seen by the same thread previously then it can safely be discarded\n+            // the intended thread has either terminated or is currently processing a work item and will terminate\n+            // after completing that item and before blocking on the queue\n+        }\n+    };\n+\n+    ConsumerThread<MODE> &m_consumer;\n+    std::set<std::thread::id> m_threads_observed;\n+};\n+\n+template<WorkerMode PRODUCER_MODE>\n+using WorkQueue = BlockingConsumerQueue<std::unique_ptr<WorkItem<PRODUCER_MODE>>,PRODUCER_MODE>;\n+\n+/**\n+ * A worker thread that interoperates with a BlockingConsumerQueue\n+ *\n+ * Blocks on the queue, pulls WorkItem() tasks and executes them\n+ * No assumptions are made about number of threads operating on this queue\n+ *\n+ * @see WorkItem\n+ * @see WorkQueue\n+ * @see BlockingConsumerQueue\n+ * @see ProducerConsumerQueue\n+ */\n+template<WorkerMode PRODUCER_POLICY>\n+class ConsumerThread {\n+    friend ShutdownPill<PRODUCER_POLICY>; //<! needs to introspect in order to cleanly terminate this thread\n+\n+public:\n+    //! Default constructor: not a valid thread\n+    ConsumerThread() :m_active(false) {};\n+\n+    //! Constructs a ConsumerThread: RAII\n+    //! @param queue the queue from which this thread will pull work\n+    ConsumerThread(std::shared_ptr<WorkQueue<PRODUCER_POLICY>> queue, const std::string id = \"\")\n+        :m_id(id), m_queue(queue), m_active(true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183500740",
      "id" : 183500740,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwMDc0MA==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 88,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183500740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183502878"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183502878"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ShutdownPill seems a little complicated. What advantages does it provide over just adding `bool m_active` to  `ProducerConsumerQueue` with a simple method to set it to false and cancel blocked Pop() calls?",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T18:58:05Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183502878",
      "id" : 183502878,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwMjg3OA==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 32,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183502878",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183505818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183505818"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could use make_shared here, MakeUnique below",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T19:09:03Z",
      "diff_hunk" : "@@ -0,0 +1,106 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+class ValidationLayer;\n+\n+template<typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING> {\n+    friend class ValidationLayer;\n+protected:\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+struct BlockValidationResponse {\n+    const bool is_new;\n+    const bool not_immediately_invalid;\n+\n+    BlockValidationResponse(bool _not_immediately_invalid, bool _is_new)\n+      :is_new(_is_new), not_immediately_invalid(_not_immediately_invalid) {};\n+};\n+\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse> {\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+    :m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready) {};\n+\n+    void operator()();\n+\n+    const ValidationLayer& m_validation_layer;\n+    const std::shared_ptr<const CBlock> m_block;\n+    const bool m_force_processing;\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block and header validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: Submitforvalidation(object) -> future<Response>\n+ *  - synchronous: Validate(object) -> Response\n+ * object may be a block or block header\n+ */\n+class ValidationLayer {\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        :m_chainparams(chainparams), m_validation_queue(std::shared_ptr<ValidationQueue>(new ValidationQueue(100))) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183505818",
      "id" : 183505818,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwNTgxOA==",
      "original_commit_id" : "c10466c7a25a3b38c0e81337f56ab5fa59ac4bef",
      "original_position" : 62,
      "path" : "src/validation_layer.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183505818",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183507013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183507013"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Probably should take unique_ptr instead of raw argument to clarify ownership",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T19:13:22Z",
      "diff_hunk" : "@@ -0,0 +1,106 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VALIDATION_LAYER_H\n+#define BITCOIN_VALIDATION_LAYER_H\n+\n+#include <future>\n+\n+#include <chainparams.h>\n+#include <core/consumerthread.h>\n+#include <core/producerconsumerqueue.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+class ValidationLayer;\n+\n+template<typename RESPONSE>\n+class ValidationRequest : public WorkItem<WorkerMode::BLOCKING> {\n+    friend class ValidationLayer;\n+protected:\n+    std::promise<RESPONSE> m_promise;\n+};\n+\n+struct BlockValidationResponse {\n+    const bool is_new;\n+    const bool not_immediately_invalid;\n+\n+    BlockValidationResponse(bool _not_immediately_invalid, bool _is_new)\n+      :is_new(_is_new), not_immediately_invalid(_not_immediately_invalid) {};\n+};\n+\n+class BlockValidationRequest : public ValidationRequest<BlockValidationResponse> {\n+    friend ValidationLayer;\n+\n+private:\n+    BlockValidationRequest(ValidationLayer& validation_layer, const std::shared_ptr<const CBlock> block, bool force_processing, const std::function<void()> on_ready)\n+    :m_validation_layer(validation_layer), m_block(block), m_force_processing(force_processing), m_on_ready(on_ready) {};\n+\n+    void operator()();\n+\n+    const ValidationLayer& m_validation_layer;\n+    const std::shared_ptr<const CBlock> m_block;\n+    const bool m_force_processing;\n+    const std::function<void()> m_on_ready;\n+};\n+\n+/**\n+ * Public interface to block and header validation\n+ *\n+ * Two apis:\n+ *  - asynchronous: Submitforvalidation(object) -> future<Response>\n+ *  - synchronous: Validate(object) -> Response\n+ * object may be a block or block header\n+ */\n+class ValidationLayer {\n+    typedef WorkQueue<WorkerMode::BLOCKING> ValidationQueue;\n+    typedef ConsumerThread<WorkerMode::BLOCKING> ValidationThread;\n+\n+public:\n+    ValidationLayer(const CChainParams& chainparams)\n+        :m_chainparams(chainparams), m_validation_queue(std::shared_ptr<ValidationQueue>(new ValidationQueue(100))) {}\n+\n+    ~ValidationLayer() {};\n+\n+    void Start()\n+    {\n+        assert(!m_thread || !m_thread->IsActive());\n+        m_thread = std::unique_ptr<ValidationThread>(new ValidationThread(m_validation_queue));\n+    };\n+\n+    void Stop()\n+    {\n+        assert(m_thread);\n+        m_thread->Terminate();\n+    };\n+\n+    std::future<BlockValidationResponse> SubmitForValidation(const std::shared_ptr<const CBlock> block, bool force_processing, std::function<void()> on_ready=[](){})\n+    {\n+        BlockValidationRequest * req = new BlockValidationRequest(*this, block, force_processing, on_ready);\n+        return SubmitForValidation<BlockValidationResponse>(req);\n+    };\n+\n+    BlockValidationResponse Validate(const std::shared_ptr<const CBlock> block, bool force_processing) const\n+    {\n+        bool is_new = false;\n+        bool block_valid = ProcessNewBlock(m_chainparams, block, force_processing, &is_new);\n+        return BlockValidationResponse(block_valid, is_new);\n+    };\n+\n+ private:\n+    template<typename RESPONSE>\n+    std::future<RESPONSE> SubmitForValidation(ValidationRequest<RESPONSE> * request)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183507013",
      "id" : 183507013,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzUwNzAxMw==",
      "original_commit_id" : "c10466c7a25a3b38c0e81337f56ab5fa59ac4bef",
      "original_position" : 93,
      "path" : "src/validation_layer.h",
      "position" : null,
      "pull_request_review_id" : 114508551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183507013",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thank you for the review - one thing (general design related) to add to the discussion here:\r\n\r\nSince I've submitted this request - I happened to stumble upon two race conditions in validation that stem from concurrent calls to ProcessNewBlock (#12988, #13023) \r\nThis pr should simplify the concurrency model for block validation (a single validation thread pulls a block to validate from the queue and validates it completely before moving on to the next block) and would have inadvertently fixed those two referenced race conditions.\r\n\r\nExplicitly simplifying the concurrency model hopefully reduces a bit the cognitive burden of future code changes in validation and I don't think makes anything substantially less efficient - much of validation is already single threaded (because of cs_main), and certain pieces fundamentally cannot be concurrent (i.e. connecttip). Validation is already complicated enough to understand on its own without worrying about concurrency.\r\n\r\nSeems like the clarity gains will outweigh the minor efficiency hit here - +the async api into should allow all the stuff around validation to be more easily be parallelized with less risk of inadvertently introducing a consensus bug. And it makes process separation / alternate p2p more natural if that's ever to be a thing in the future.\r\n\r\nIf this design seems useful - my intention is to finish this pr up (some stuff around compact blocks that I still have to work through + refit the couple of places in rpc that call ProcessNewBlock) and explore subsequent prs to put a similar model in place around the mempool. I'd also like to explore feasibility for header processing.",
      "created_at" : "2018-04-23T22:52:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-383747761",
      "id" : 383747761,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-23T22:52:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383747761",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183562777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183562777"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah - it is pretty complicated. I didn't want to poke through the queue api just to enable shutdown - you'd have to have `T Pop()` potentially not return a `T` (i.e. throw an exception) - which seemed less desirable and maybe equally complicated.\r\n\r\nHaving said that - a lot of the complexity here is introduced to handle:\r\n- being able to shutdown a specific ConsumerThread without shutting down others (in reality you probably only ever want to shut down all of them when you terminate the process)\r\n- allowing for a queue with fewer slots than the number of threads servicing it (unlikely)\r\n\r\nOnly reason I allowed for these is so that the APIs to the queue work the way they sound like they should work and for unit test completeness. If I discard the above the code gets much simpler and it will just be broken for two use cases that seem pretty unlikely to ever happen right now (but you never know - and then maybe somebody gets frustrated one day).",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-04-23T23:03:21Z",
      "diff_hunk" : "@@ -0,0 +1,172 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSUMERTHREAD_H\n+#define BITCOIN_CONSUMERTHREAD_H\n+\n+#include <thread>\n+#include <core/producerconsumerqueue.h>\n+\n+template<WorkerMode MODE>\n+class ConsumerThread;\n+\n+//! A WorkItem() encapsulates a task that can be processed by a ConsumerThread()\n+//! @see ConsumerThread()\n+template<WorkerMode MODE>\n+class WorkItem\n+{\n+    friend ConsumerThread<MODE>; //<! only a consumer thread can execute a WorkItem\n+\n+protected:\n+    WorkItem(){};\n+    virtual void operator()(){};\n+};\n+\n+//! A special WorkItem() that is used to interrupt a blocked ConsumerThread() so that it can terminate\n+template<WorkerMode MODE>\n+class ShutdownPill : public WorkItem<MODE> {\n+    friend ConsumerThread<MODE>;\n+\n+private:\n+    ShutdownPill(ConsumerThread<MODE>& consumer) : m_consumer(consumer) {};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r183562777",
      "id" : 183562777,
      "in_reply_to_id" : 183502878,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE4MzU2Mjc3Nw==",
      "original_commit_id" : "5b880d2590686eb674c7bf350e16f58a124ddb44",
      "original_position" : 32,
      "path" : "src/core/consumerthread.h",
      "position" : null,
      "pull_request_review_id" : 114585105,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183562777",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I do think the general approach is fine. It's not going to be really at all useful until we do a ton of locking cleanups in net_processing (it'll let us run ahead to the next message, which almost always requires cs_main, and we'll end up blocking on validation anyway). It's probably simpler than multiple net_processing threads (with the same cleanups required) which was most of my previous work, but they'll end up looking pretty similar on the net_processing end, we were gonna need this blocking-on-response logic either way. Should definitely get brought up at a meeting, though, to get wider feedback. @theuni probably has some thoughts, too.",
      "created_at" : "2018-04-28T01:57:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-385131498",
      "id" : 385131498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "updated_at" : "2018-04-28T01:57:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385131498",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "PR updated with latest commits, ready for review\r\nAlso, for reference, a discussion on high level design for this PR at the IRC meeting a couple weeks ago:\r\nhttps://bitcoincore.org/en/meetings/2018/05/03/\r\n",
      "created_at" : "2018-06-05T11:54:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-394681515",
      "id" : 394681515,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NDY4MTUxNQ==",
      "updated_at" : "2018-06-05T11:54:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/394681515",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r195502312"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195502312"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nShould probably emplace_back to avoid creating a temporary.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-06-14T17:11:53Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r195502312",
      "id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NTUwMjMxMg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/195502312",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-06-15T20:08:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-397728959",
      "id" : 397728959,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDM5NzcyODk1OQ==",
      "updated_at" : "2018-06-15T20:08:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/397728959",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196532632"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nI don't think it's a good idea for blocking and nonblocking defaults to be attributes of the Queue data structure, instead of arguments to (or variants of) the push and pop methods. Advantages to dropping these template arguments:\r\n\r\n1) Readability. It would be nice to be able to see if a push or pop call is blocking just by looking at the call, without have to check another part of the code to see how the queue data structure was initially declared.\r\n2) Code size. Dropping these arguments would avoid compiler potentially having to instantiate many copies of this code for different combinations of template arguments.\r\n3) Extensibility. There could be other useful blocking methods added in the future (like methods to wait for low/high water marks or for empty/full events) and it would either be verbose to have to add new classwide blocking/nonblocking defaults for new methods, or confusing to have to somehow tie existing defaults to new methods.\r\n4) Consistency. If you look at other C++ objects that support optional blocking like std::mutex or std::future, the blocking behaviour is determined only by the particular method call, not by template arguments from where the object was declared.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-06-19T18:28:51Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632",
      "id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjUzMjYzMg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196532632",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196533649"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196533649"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Implement a thread-safe FIFO (producer/consumer style) queue\" (d8106146e7511837decb4b45de35dec654454b69)\r\n\r\nCould return std::future\\<T> in the case of a non-blocking Pop() to support it instead of having this asymmetry.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-06-19T18:32:02Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196533649",
      "id" : 196533649,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5NjUzMzY0OQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 124,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 124,
      "pull_request_review_id" : 128885288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-06-19T19:58:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/196533649",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199506587"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199506587"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "not sure i completely understand - data is already constructed when it is passed into the function - thought the most economical thing to do was std::forward which should use the move constructor when possible? is that different from what emplace_back would do?",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-02T13:59:22Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199506587",
      "id" : 199506587,
      "in_reply_to_id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwNjU4Nw==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 133637301,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-02T13:59:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199506587",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508335"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Doing that would complicate internal implementation a bit - you'd have to hang on to the promise that satisfies the future internally - and either you'd have too many of those and need to block - or potentially allow your buffer holding promises to grow unbounded - so actually it might not be safely implementable. \r\n\r\nAlso I don't really see an immediate use case for this - you'd have to later wait on the future (blocking or non-blocking) - but you could just alternately wait on the queue. I can't think of any use cases right now where you'd want to reserve a place in line in a non-blocking fashion and then later claim that item.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-02T14:04:56Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));\n+        }\n+        m_consumer_cv.notify_one();\n+        return true;\n+    };\n+\n+    /**\n+     * Try to pop the oldest element from the front of the queue, if present\n+     * Blocking consumer mode: will always eventually succeed\n+     * Nonblocking consumer mode: Pop() returns failure when the queue is empty\n+     * @param[out] the data popped, if the operation was successful\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    bool Pop(T& data, WorkerMode mode = m_consumer_mode)\n+    {\n+        // attempting a pop from a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() <= 0) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_consumer_cv.wait(l, [&]() { return m_data.size() > 0; });\n+            }\n+\n+            data = std::move(m_data.front());\n+            m_data.pop_front();\n+        }\n+        m_producer_cv.notify_one();\n+        return true;\n+    }\n+\n+    /**\n+     * Shortcut for bool Pop(T&) when consumer mode is blocking\n+     * This must always succeed and thus may only be called in producer blocking mode\n+     * @return the element popped\n+     */\n+    T Pop()\n+    {\n+        static_assert(m_consumer_mode == WorkerMode::BLOCKING, \"\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508335",
      "id" : 199508335,
      "in_reply_to_id" : 196533649,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwODMzNQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 124,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 124,
      "pull_request_review_id" : 133639425,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-02T14:04:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508335",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508852"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I can see this either way - i wrote it with defaults essentially as constructor args because - at least for the use cases i can imagine you almost always want a default mode of operation for a given queue except for certain edge cases (shutdown is the most apparent one) - and i've seen data structures that handle this sort of initialization both ways (defaults on construction vs with every method call) but i'm also happy to change this up if the prevailing opinion is the other way.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-02T14:06:33Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199508852",
      "id" : 199508852,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUwODg1Mg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 133640052,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-02T14:06:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199508852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199527845"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199527845"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Talked about this offline with @ryanofsky, @skeees; this form is equivalent (in terms of constructor calls) to what @ryanofsky initially suggested so no need to change.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-02T15:03:42Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });\n+            }\n+\n+            m_data.push_back(std::forward<TT>(data));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199527845",
      "id" : 199527845,
      "in_reply_to_id" : 195502312,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTUyNzg0NQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 81,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 81,
      "pull_request_review_id" : 133663218,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-02T15:03:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199527845",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199757735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199757735"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMight be nice to use vector\\<unique_ptr\\<Q>> to make this code exception safe and avoid need for manual deletion.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T10:25:19Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199757735",
      "id" : 199757735,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc1NzczNQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 90,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 90,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199757735",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199768981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199768981"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe give this function a more descriptive name like `PushThenPop`.\r\n\r\nMaybe add a summary comment like \"Push \\`elements_pushed\\` consecutive ints to the \r\n\\`push\\` queue, starting from (id * elements_to_values). Then pop \\`elements_pushed\\` values from the \\`recv\\` queue and verify all ints in the range (-elements_pushed, 0] are received, in any order.\"",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T11:13:13Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199768981",
      "id" : 199768981,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc2ODk4MQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 21,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 21,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199768981",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199770536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199770536"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe give this function a more descriptive name like `PopAndPush`.\r\n\r\nMaybe add a summary comment like \"Pop \\`elements_pushed\\` values from the \\`work\\` queue. For each value \\`w\\` received, push value -(w % bucket_size) to the push[w / bucket_size] output queue.\"\r\n",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T11:19:35Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199770536",
      "id" : 199770536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3MDUzNg==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 54,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 54,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199770536",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199772365"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199772365"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nIt could be nice to avoid this encoding (and the negative int encoding) by declaring a simple struct like:\r\n\r\n```c++\r\nstruct TestValue { int producer_id; int value; };\r\n```\r\n\r\nand using `ProducerConsumerQueue<TestValue>` in the test.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T11:28:09Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199772365",
      "id" : 199772365,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3MjM2NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 63,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 63,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199772365",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199775175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199775175"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nSeems like this could more specifically assert (latest == -1) or (i == latest + 1). But perhaps the current way is more compact or less fragile.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T11:40:15Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199775175",
      "id" : 199775175,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc3NTE3NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 66,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 66,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199775175",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199781485"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199781485"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Test simple queue pushes and pops which don't block.\"",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T12:05:58Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199781485",
      "id" : 199781485,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTc4MTQ4NQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 120,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 120,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199781485",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199808121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199808121"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Re: https://github.com/bitcoin/bitcoin/pull/12934#discussion_r196532632\r\n\r\n> I can see this either way - i wrote it with defaults essentially as constructor args because - at least for the use cases i can imagine you almost always want a default mode of operation for a given queue except for certain edge cases (shutdown is the most apparent one) - and i've seen data structures that handle this sort of initialization both ways (defaults on construction vs with every method call) but i'm also happy to change this up if the prevailing opinion is the other way.\r\n\r\nWhat about having Push, Pop, TryPush, and TryPop methods and dropping the enum entirely? I think this would make code using the queue easier to understand, and easier to write, since it would avoid the need to with an enum that triggers compile time and runtime errrors and whose final value is determined by a combination of method argument, class template argument, method argument default, and class template argument default values.\r\n\r\nI do understand the enum is useful in tests for listing all possible combinations of behavior, but it could just be moved into the test file since enumerating queue operation types isn't something that would actually be useful anywhere else.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T13:33:17Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199808121",
      "id" : 199808121,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgwODEyMQ==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199808121",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199811991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199811991"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Generate messages in \\`n_producers\\` producer threads and push them on to a single \\`push\\` queue. Pop messages from the queue in \\`n_consumers\\` consumer threads, and forward them back to the original producer threads through \\`n_producers\\` different \\`pull\\` queues. Verify all the queues are empty after the threads exit.\"",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T13:44:35Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199811991",
      "id" : 199811991,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgxMTk5MQ==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 85,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 85,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199811991",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199812982"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199812982"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Unit tests for ProducerConsumerQueue\" (52ac3b5469e514f9288683bcb944e58c02606346)\r\n\r\nMaybe add a simple test description like \"Run QueueTest with different numbers of messages and threads and different queue capacities.\"",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-03T13:47:13Z",
      "diff_hunk" : "@@ -0,0 +1,178 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <boost/test/unit_test.hpp>\n+#include <iostream>\n+#include <test/test_bitcoin.h>\n+\n+#include <core/producerconsumerqueue.h>\n+\n+BOOST_FIXTURE_TEST_SUITE(producerconsumerqueue_tests, BasicTestingSetup)\n+\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::BLOCKING> QueueBB;\n+typedef ProducerConsumerQueue<int, WorkerMode::BLOCKING, WorkerMode::NONBLOCKING> QueueBN;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::BLOCKING> QueueNB;\n+typedef ProducerConsumerQueue<int, WorkerMode::NONBLOCKING, WorkerMode::NONBLOCKING> QueueNN;\n+\n+typedef boost::mpl::list<QueueBB, QueueBN, QueueNB, QueueNN> queue_types;\n+\n+template <typename Q>\n+void Producer(Q& push, Q& recv, int id, int elements_to_push)\n+{\n+    // push all of these elements to one queue\n+    int elements_pushed = 0;\n+    while (elements_pushed < elements_to_push) {\n+        if (push.Push(id * elements_to_push + elements_pushed)) {\n+            elements_pushed++;\n+        } else if (push.GetProducerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking push should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    std::set<int> received;\n+    while (received.size() < (unsigned)elements_to_push) {\n+        int e;\n+        if (recv.Pop(e)) {\n+            assert(!received.count(e));\n+            received.insert(e);\n+        } else if (recv.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+\n+    for (int i = 0; i < elements_to_push; i++) {\n+        assert(received.count(-i));\n+    }\n+}\n+\n+template <typename Q>\n+void Consumer(Q& work, std::vector<Q*> push, int id, int n_producers, int bucket_size, int elements_to_receive)\n+{\n+    int elements_received = 0;\n+    std::vector<int> latest(n_producers, -1);\n+\n+    while (elements_received != elements_to_receive) {\n+        int w;\n+        if (work.Pop(w)) {\n+            int producer_id = w / bucket_size;\n+            int i = w % bucket_size;\n+\n+            assert(producer_id < n_producers);\n+            assert(i > latest[producer_id]);\n+            latest[producer_id] = i;\n+\n+            while (!push[producer_id]->Push(-i)) {\n+                if (push[producer_id]->GetProducerMode() == WorkerMode::BLOCKING) {\n+                    BOOST_FAIL(\"a blocking push should always succeed\");\n+                }\n+                std::this_thread::yield();\n+            }\n+            elements_received++;\n+        } else if (work.GetConsumerMode() == WorkerMode::BLOCKING) {\n+            BOOST_FAIL(\"a blocking pop should always succeed\");\n+        } else {\n+            std::this_thread::yield();\n+        }\n+    }\n+}\n+\n+template <typename Q>\n+void QueueTest(int capacity, int n_elements, int n_producers, int n_consumers)\n+{\n+    int bucket_size = n_elements / n_producers;\n+\n+    Q push(capacity);\n+    std::vector<Q*> pull;\n+    for (int i = 0; i < n_producers; i++)\n+        pull.push_back(new Q(bucket_size));\n+\n+    boost::thread_group test_threads;\n+\n+    for (int i = 0; i < n_producers; i++) {\n+        test_threads.create_thread([&, i] { Producer(push, *(pull[i]), i, bucket_size); });\n+    }\n+\n+    for (int i = 0; i < n_consumers; i++) {\n+        test_threads.create_thread([&, i] { Consumer(push, pull, i, n_producers, bucket_size, n_elements / n_consumers); });\n+    }\n+\n+    test_threads.join_all();\n+\n+    // queue should be empty\n+    BOOST_CHECK_EQUAL(push.size(), 0);\n+    for (int i = 0; i < n_producers; i++) {\n+        BOOST_CHECK_EQUAL(pull[i]->size(), 0);\n+        delete pull[i];\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(invalid_queue, Q, queue_types)\n+{\n+    Q q;\n+    BOOST_CHECK(q.GetCapacity() == 0);\n+}\n+\n+BOOST_AUTO_TEST_CASE(basic_operation)\n+{\n+    int n = 10;\n+    QueueBB qBB(n);\n+    QueueBN qBN(n);\n+    QueueNB qNB(n);\n+    QueueNN qNN(n);\n+\n+    BOOST_CHECK((int)qBB.GetCapacity() == n);\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK(qBB.Push(i));\n+        BOOST_CHECK(qBN.Push(i));\n+        BOOST_CHECK(qNB.Push(i));\n+        BOOST_CHECK(qNN.Push(i));\n+    }\n+\n+    BOOST_CHECK(!qNB.Push(0));\n+    BOOST_CHECK(!qNN.Push(0));\n+\n+    int t;\n+    for (int i = 0; i < n; i++) {\n+        BOOST_CHECK_EQUAL(qBB.Pop(), i);\n+\n+        BOOST_CHECK(qBN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+\n+        BOOST_CHECK_EQUAL(qNB.Pop(), i);\n+\n+        BOOST_CHECK(qNN.Pop(t));\n+        BOOST_CHECK_EQUAL(t, i);\n+    }\n+\n+    int ret;\n+    BOOST_CHECK(!qBN.Pop(ret));\n+    BOOST_CHECK(!qNN.Pop(ret));\n+}\n+\n+BOOST_AUTO_TEST_CASE_TEMPLATE(multithreaded_operation, Q, queue_types)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r199812982",
      "id" : 199812982,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTgxMjk4Mg==",
      "original_commit_id" : "52ac3b5469e514f9288683bcb944e58c02606346",
      "original_position" : 157,
      "path" : "src/test/producerconsumerqueue_tests.cpp",
      "position" : 157,
      "pull_request_review_id" : 133936770,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T11:19:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199812982",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thakns @ryanofsky - agree with basically everything you've said re commit 52ac3b5 - going to wait for some more comments to accumulate and address all at once so i don't mess up any other reviews that might be in progress",
      "created_at" : "2018-07-04T13:56:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#issuecomment-402486739",
      "id" : 402486739,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12934",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMjQ4NjczOQ==",
      "updated_at" : "2018-07-04T13:56:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/402486739",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200205851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200205851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why this scope? I think `notify_one()` below can be called while `m_queue_lock` is held.  same in `Pop()`.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-04T22:11:19Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200205851",
      "id" : 200205851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNTg1MQ==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 71,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 71,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200205851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206332"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206332"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, could drop `()`.  same in `Pop()`.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-04T22:20:41Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {\n+            std::unique_lock<std::mutex> l(m_queue_lock);\n+            if (m_data.size() >= m_capacity) {\n+                if (mode == WorkerMode::NONBLOCKING) {\n+                    return false;\n+                }\n+\n+                m_producer_cv.wait(l, [&]() { return m_data.size() < m_capacity; });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206332",
      "id" : 200206332,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNjMzMg==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 78,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 78,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206332",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206716"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206716"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Readability. It would be nice to be able to see if a push or pop call is blocking just by looking at the call\r\n\r\nI think this comment is spot on.\r\n\r\n>  If you look at other C++ objects that support optional blocking like std::mutex or std::future, the blocking behaviour is determined only by the particular method call\r\n\r\n> What about having Push, Pop, TryPush, and TryPop methods and dropping the enum entirely?\r\n\r\nAgree.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-04T22:27:31Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200206716",
      "id" : 200206716,
      "in_reply_to_id" : 196532632,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDIwNjcxNg==",
      "original_commit_id" : "d8106146e7511837decb4b45de35dec654454b69",
      "original_position" : 32,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 32,
      "pull_request_review_id" : 134475746,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-04T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200206716",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200255149"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200255149"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You can - but its less efficient to notify on a cv while holding a lock - the thread that you notify will wake up and immediately block again on the lock until you release it. It is safe to call notify without the lock held.\r\n\r\nfrom: https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one\r\n>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this \"hurry up and wait\" scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.",
      "commit_id" : "65ae792d78eb24d8572237d301a04a1cbeaadae3",
      "created_at" : "2018-07-05T07:30:34Z",
      "diff_hunk" : "@@ -0,0 +1,156 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+#define BITCOIN_CORE_PRODUCERCONSUMERQUEUE_H\n+\n+#include <assert.h>\n+#include <deque>\n+#include <sync.h>\n+#include <type_traits>\n+\n+/**\n+ * The mode in which the queue operates\n+ * Modes may be specified for both producers and consumers\n+ */\n+enum class WorkerMode {\n+    BLOCKING,   //!< cv_wait until the action may proceed\n+    NONBLOCKING //!< do not block, immediately return failure if the action is not possible\n+};\n+\n+/**\n+ * A FIFO thread safe producer consumer queue with two operations Push() and Pop()\n+ * Producers Push() and Consumers Pop()\n+ *\n+ * @param T the type of the data contained\n+ * @param m_producer_mode queue behavior when calling Push() on a full queue (block till space becomes available, or immediately fail)\n+ * @param m_consumer_mode queue behavior when calling Pop() on an empty queue (block until there is data, or immediately fail)\n+ *\n+ * @see WorkerMode\n+ */\n+template <typename T, WorkerMode m_producer_mode = WorkerMode::BLOCKING, WorkerMode m_consumer_mode = WorkerMode::BLOCKING>\n+class ProducerConsumerQueue\n+{\n+public:\n+    /**\n+     * Constructs a ProducerConsumerQueue()\n+     * @param[in] capacity the maximum size of this queue\n+     */\n+    ProducerConsumerQueue(int capacity)\n+        : m_capacity(capacity)\n+    {\n+        assert(m_capacity > 0);\n+    };\n+\n+    /**\n+     * Constructs an empty ProducerConsumerQueue with capacity 0\n+     * In nonblocking mode all operations will immediately fail\n+     * In blocking mode all operations will fail an assertion to avoid blocking forever\n+     */\n+    ProducerConsumerQueue()\n+        : m_capacity(0){};\n+    ~ProducerConsumerQueue(){};\n+\n+    /**\n+     * Push an element to the back of the queue\n+     * Blocking producer mode: will always eventually succeed\n+     * Non-blocking producer mode: Push() returns failure when the queue is at capacity\n+     * @param[in] data the data to be pushed\n+     * @return the success of the operation\n+     * @see WorkerMode\n+     */\n+    template <typename TT>\n+    bool Push(TT&& data, WorkerMode mode = m_producer_mode)\n+    {\n+        // TT needed for perfect forwarding to vector::push_back\n+\n+        // attempting a push to a queue of capacity 0 is likely unintended\n+        assert(m_capacity > 0);\n+\n+        {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12934#discussion_r200255149",
      "id" : 200255149,
      "in_reply_to_id" : 200205851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIwMDI1NTE0OQ==",
      "original_commit_id" : "9668666b27a9e828c6593cf51b0a1e50a819e08c",
      "original_position" : 71,
      "path" : "src/core/producerconsumerqueue.h",
      "position" : 71,
      "pull_request_review_id" : 134533204,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12934",
      "updated_at" : "2018-07-05T07:30:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/200255149",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/195769?v=4",
         "events_url" : "https://api.github.com/users/skeees/events{/privacy}",
         "followers_url" : "https://api.github.com/users/skeees/followers",
         "following_url" : "https://api.github.com/users/skeees/following{/other_user}",
         "gists_url" : "https://api.github.com/users/skeees/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/skeees",
         "id" : 195769,
         "login" : "skeees",
         "node_id" : "MDQ6VXNlcjE5NTc2OQ==",
         "organizations_url" : "https://api.github.com/users/skeees/orgs",
         "received_events_url" : "https://api.github.com/users/skeees/received_events",
         "repos_url" : "https://api.github.com/users/skeees/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/skeees/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/skeees/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/skeees"
      }
   }
]
