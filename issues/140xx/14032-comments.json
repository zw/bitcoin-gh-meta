[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212404219"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212404219"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Should this be Ã¢ÂÂenvelopeÃ¢ÂÂ instead of Ã¢ÂÂenvelopÃ¢ÂÂ? If so, change applies throughout this PR and also the BIP.",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-08-23T18:03:45Z",
      "diff_hunk" : "@@ -746,43 +764,70 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n-        if (vRecvMsg.empty() ||\n-            vRecvMsg.back().complete())\n-            vRecvMsg.push_back(CNetMessage(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n-\n-        CNetMessage& msg = vRecvMsg.back();\n+        if (vRecvMsg.empty() || vRecvMsg.back()->complete()) {\n+            if (m_encryption_handler && m_encryption_handler->shouldCryptMsg()) {\n+                vRecvMsg.emplace_back(std::make_shared<NetCryptedMessageEnvelop>(m_encryption_handler, Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212404219",
      "id" : 212404219,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNDIxOQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 51,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 149030580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212404219",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405404"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If IÃ¢ÂÂm reading the logic correct then this should be Ã¢ÂÂevery 10 seconds _or_ after 10kb of dataÃ¢ÂÂ?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-08-23T18:07:22Z",
      "diff_hunk" : "@@ -477,6 +478,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-maxtxfee=<amt>\", strprintf(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\",\n         CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-netencryptionfastrekey\", \"Rekeys every 10 seconds and after 10kb of data\", true, OptionsCategory::DEBUG_TEST);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405404",
      "id" : 212405404,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNTQwNA==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 12,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 149032015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405404",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405909"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂtreatÃ¢ÂÂ",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-08-23T18:08:57Z",
      "diff_hunk" : "@@ -746,43 +764,70 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n-        if (vRecvMsg.empty() ||\n-            vRecvMsg.back().complete())\n-            vRecvMsg.push_back(CNetMessage(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n-\n-        CNetMessage& msg = vRecvMsg.back();\n+        if (vRecvMsg.empty() || vRecvMsg.back()->complete()) {\n+            if (m_encryption_handler && m_encryption_handler->shouldCryptMsg()) {\n+                vRecvMsg.emplace_back(std::make_shared<NetCryptedMessageEnvelop>(m_encryption_handler, Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            } else if (gArgs.GetBoolArg(\"-netencryption\", DEFAULT_ALLOW_NET_ENCRYPTION) && nRecvBytes == nBytes /* first message */) {\n+                // first bytes can be a network encryption handshake\n+                // use a NetMessageEncryptionHandshake with option to fallback to a standard NetMessage (if valid version message is detected)\n+                vRecvMsg.emplace_back(std::make_shared<NetMessageEncryptionHandshake>(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            } else {\n+                vRecvMsg.emplace_back(std::make_shared<NetMessage>(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            }\n+        }\n+        NetMessageBaseRef msg = vRecvMsg.back();\n \n         // absorb network data\n-        int handled;\n-        if (!msg.in_data)\n-            handled = msg.readHeader(pch, nBytes);\n-        else\n-            handled = msg.readData(pch, nBytes);\n+        int handled = msg->read(pch, nBytes);\n \n         if (handled < 0)\n             return false;\n \n-        if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n+        if (msg->getMessageSize() > MAX_PROTOCOL_MESSAGE_LENGTH) {\n             LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n             return false;\n         }\n \n         pch += handled;\n         nBytes -= handled;\n \n-        if (msg.complete()) {\n+        if (msg->complete()) {\n+            msg->nTime = nTimeMicros;\n+            if (msg->m_type == NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE && !msg->verifyHeader()) {\n+                // message contains expected network magic and \"version\" message command\n+                // threat as version message",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405909",
      "id" : 212405909,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNTkwOQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 87,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 149032670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405909",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212406669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212406669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂthereforeÃ¢ÂÂ?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-08-23T18:11:13Z",
      "diff_hunk" : "@@ -0,0 +1,375 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessageEnvelop::read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->getAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->getAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->getLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 31));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 31);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->getAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->getTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->authenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::verifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+int NetCryptedMessage::read(const char* pch, unsigned int nBytes)\n+{\n+    // not supported\n+    return -1;\n+}\n+\n+bool NetCryptedMessage::decompose_from_stream(CDataStream& stream)\n+{\n+    // decompose a single massage from a multimessage envelop\n+    try {\n+        stream >> m_command_name;\n+        stream >> m_message_size;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (m_message_size > MAX_PROTOCOL_MESSAGE_LENGTH || m_message_size > stream.size()) {\n+        return false;\n+    }\n+\n+    // copy the extracted message to the internal message buffer\n+    if (m_message_size > 0) {\n+        assert(vRecv.size() == 0);\n+        vRecv.write(&stream.begin()[0], m_message_size);\n+\n+        // skip the message payload\n+        stream.ignore(m_message_size);\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::authenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefor abort connection when counterparty failed to respect rekey limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212406669",
      "id" : 212406669,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNjY2OQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 156,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 149033591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212406669",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212407341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212407341"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂhasÃ¢ÂÂ?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-08-23T18:13:18Z",
      "diff_hunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_MESSAGE_H\n+#define BITCOIN_NET_MESSAGE_H\n+\n+#include <hash.h>\n+#include <protocol.h>\n+#include <streams.h>\n+#include <uint256.h>\n+\n+/** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n+\n+enum class NetMessageType {\n+    PLAINTEXT,\n+    PLAINTEXT_ENCRYPTION_HANDSHAKE,\n+    BIP151_ENVELOP,\n+    BIP151_MSG\n+};\n+\n+// base class for format agnostic network messages\n+class NetMessageBase\n+{\n+public:\n+    CDataStream vRecv; // received message data\n+    int64_t nTime;     // time (in microseconds) of message receipt.\n+    NetMessageType m_type;\n+\n+    NetMessageBase(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : vRecv(nTypeIn, nVersionIn)\n+    {\n+        nTime = 0;\n+    }\n+\n+    virtual bool complete() const = 0;\n+    virtual uint32_t getMessageSize() const = 0;           //returns 0 when message hat not yet been parsed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212407341",
      "id" : 212407341,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNzM0MQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 37,
      "path" : "src/net_message.h",
      "position" : null,
      "pull_request_review_id" : 149034437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212407341",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#15654](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15654.html) (net: Remove unused unsanitized user agent string CNode::strSubVer by MarcoFalke)\n* [#15649](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15649.html) (Add ChaCha20Poly1305@Bitcoin AEAD by jonasschnelli)\n* [#15644](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15644.html) (Make orphan processing interruptible by sipa)\n* [#15519](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15519.html) (Add Poly1305 implementation by jonasschnelli)\n* [#15512](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15512.html) (Add ChaCha20 encryption option (XOR) by jonasschnelli)\n* [#15505](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15505.html) ([p2p] Request NOTFOUND transactions immediately from other outbound peers, when possible by sdaftuar)\n* [#15437](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15437.html) (p2p: Remove BIP61 reject messages by MarcoFalke)\n* [#15206](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15206.html) (Immediately disconnect on invalid net message checksum by jonasschnelli)\n* [#15197](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15197.html) (Refactor and slightly stricter p2p message processing by jonasschnelli)\n* [#14047](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14047.html) (Add HKDF_HMAC256_L32 and method to negate a private key by jonasschnelli)\n* [#14046](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14046.html) (net: Refactor message parsing (CNetMessage), adds flexibility by jonasschnelli)\n* [#10102](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/10102.html) ([experimental] Multiprocess bitcoin by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-08-23T18:28:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415521431",
      "id" : 415521431,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTUyMTQzMQ==",
      "updated_at" : "2019-03-25T00:43:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415521431",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed @practicalswift points.",
      "created_at" : "2018-08-23T19:50:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415549299",
      "id" : 415549299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTU0OTI5OQ==",
      "updated_at" : "2018-08-23T19:50:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415549299",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Great work!\r\n\r\nAlthough optimized crypto is certainly out of scope, we do want to be mindful of making any protocol decisions that would preclude using them. :)",
      "created_at" : "2018-08-23T20:26:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415559982",
      "id" : 415559982,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTU1OTk4Mg==",
      "updated_at" : "2018-08-23T20:26:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415559982",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Note to reviewers: please review...\r\n* #14046 Refactor message parsing (CNetMessage), adds flexibility \r\n* #14047 Add HKDF_HMAC256_L32 and method to negate a private key\r\n* #14049 Enable libsecp256k1 ecdh module, add ECDH function to CKey\r\n* #14050 Add chacha20/poly1305 and chacha20poly1305_AEAD from openssh\r\n... first (extracted commits from this PR)",
      "created_at" : "2018-08-24T09:22:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415704147",
      "id" : 415704147,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTcwNDE0Nw==",
      "updated_at" : "2018-08-24T15:13:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415704147",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "What is the point of `NODE_ENCRYPTED`? Service bits shouldn't be used for mere protocol negotiation...",
      "created_at" : "2018-08-29T18:20:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417054311",
      "id" : 417054311,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzA1NDMxMQ==",
      "updated_at" : "2018-08-29T18:20:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417054311",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> What is the point of NODE_ENCRYPTED? Service bits shouldn't be used for mere protocol negotiation...\r\n\r\nThis has now been discussed on IRC:\r\nhttps://botbot.me/freenode/bitcoin-core-dev/2018-08-29/?msg=103889728&page=3",
      "created_at" : "2018-08-29T19:11:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417070832",
      "id" : 417070832,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzA3MDgzMg==",
      "updated_at" : "2018-08-29T19:11:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417070832",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523047"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂresetÃ¢ÂÂ?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-01T21:07:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC\n+\n+            // initially check the message\n+            try {\n+                vRecv >> m_command_name;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with resetted nonce",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523047",
      "id" : 214523047,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUyMzA0Nw==",
      "original_commit_id" : "93f64ad566b014f69f797e8911c5ff75bb257758",
      "original_position" : 163,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151603394,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523047",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Ã¢ÂÂresetÃ¢ÂÂ?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-01T21:07:17Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC\n+\n+            // initially check the message\n+            try {\n+                vRecv >> m_command_name;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with resetted nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and resetted sequence)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523056",
      "id" : 214523056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUyMzA1Ng==",
      "original_commit_id" : "93f64ad566b014f69f797e8911c5ff75bb257758",
      "original_position" : 171,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151603405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523056",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214532174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532174"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: exluding",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-02T08:00:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214532174",
      "id" : 214532174,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMjE3NA==",
      "original_commit_id" : "9c2fd588ebd29478c72b3add6acd549d5742e870",
      "original_position" : 81,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151612586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532174",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Lightly tested on macOS. I was able to establish an encrypted connection and sync headers to afresh node. It didn't (immediately) sync blocks though, but maybe that's normal behavior when you only have 1 peer?\r\n\r\nQT Peers Window doesn't show the new service flag next to Services, and it also doesn't show the encryption info, but that can be done in another PR. \r\n\r\nI would move the TODO `add option to -connect=` to a different PR. I'd also like a way to only accept inbound encrypted peers, and only connect to outbound encrypted peers.\r\n\r\nCan you add more functional tests, e.g. to check that it rotates the key after N bytes? \r\n\r\nI would be nice to have a fork of @sipa's [DNS seeder](https://github.com/sipa/bitcoin-seeder) that finds these nodes on testnet. I'd be happy to switch mine over.",
      "created_at" : "2018-09-02T08:40:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417914339",
      "id" : 417914339,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzkxNDMzOQ==",
      "updated_at" : "2018-09-02T10:12:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417914339",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214533260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214533260"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed those spelling issues.",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-02T08:48:09Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214533260",
      "id" : 214533260,
      "in_reply_to_id" : 214532174,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMzI2MA==",
      "original_commit_id" : "9c2fd588ebd29478c72b3add6acd549d5742e870",
      "original_position" : 81,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151613701,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214533260",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're using the term \"stealth encryption\" in various places, but this term isn't used in the BIP.",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-02T11:03:40Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;\n+        serialized_envelope.reserve(3 /* <- packet length */ + serialized_command_size + nMessageSize + pnode->m_encryption_handler->GetTagLen());\n \n-    size_t nBytesSent = 0;\n-    {\n-        LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        // convert the host 32 bit size into a LE 24bit\n+        envelope_payload_length = htole32(envelope_payload_length);\n+        uint8_t int24[3];\n+        memcpy(int24, &envelope_payload_length, 3);\n \n-        //log total amount of bytes per command\n-        pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n-        pnode->nSendSize += nTotalSize;\n+        CVectorWriter vector_writer(SER_NETWORK, INIT_PROTO_VERSION, serialized_envelope, 0, int24[0], int24[1], int24[2]);\n+        if (cmd_short_id) {\n+            // append the single byte short ID...\n+            vector_writer << cmd_short_id;\n+        } else {\n+            // or the ASCII command string\n+            vector_writer << msg.command;\n+        }\n+        //append the message itself (if there is a message)\n+        if (nMessageSize) serialized_envelope.insert(serialized_envelope.end(), msg.data.begin(), msg.data.end());\n \n-        if (pnode->nSendSize > nSendBufferMaxSize)\n-            pnode->fPauseSend = true;\n-        pnode->vSendMsg.push_back(std::move(serializedHeader));\n-        if (nMessageSize)\n-            pnode->vSendMsg.push_back(std::move(msg.data));\n+        //form the AAED (encipher and append tag)\n+        if (!pnode->m_encryption_handler->EncryptAppendMAC(serialized_envelope)) {\n+            LogPrintf(\"Encryption failed, peer=%d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+            return;\n+        }\n+        {\n+            LOCK(pnode->cs_vSend);\n+            bool optimisticSend(pnode->vSendMsg.empty());\n \n-        // If write queue empty, attempt \"optimistic write\"\n-        if (optimisticSend == true)\n-            nBytesSent = SocketSendData(pnode);\n+            //log total amount of bytes per command\n+            pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n+            pnode->nSendSize += nTotalSize;\n+\n+            if (pnode->nSendSize > nSendBufferMaxSize)\n+                pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back(std::move(serialized_envelope));\n+\n+            // If write queue empty, attempt \"optimistic write\"\n+            if (optimisticSend == true)\n+                nBytesSent = SocketSendData(pnode);\n+        }\n+    } else {\n+        std::vector<unsigned char> serializedHeader;\n+        serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n+        uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n+        CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n+        memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+\n+        CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+        {\n+            LOCK(pnode->cs_vSend);\n+            bool optimisticSend(pnode->vSendMsg.empty());\n+\n+            //log total amount of bytes per command\n+            pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n+            pnode->nSendSize += nTotalSize;\n+\n+            if (pnode->nSendSize > nSendBufferMaxSize)\n+                pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back(std::move(serializedHeader));\n+            if (nMessageSize)\n+                pnode->vSendMsg.push_back(std::move(msg.data));\n+\n+            // If write queue empty, attempt \"optimistic write\"\n+            if (optimisticSend == true)\n+                nBytesSent = SocketSendData(pnode);\n+        }\n     }\n     if (nBytesSent)\n         RecordBytesSent(nBytesSent);\n }\n \n+void CConnman::SendStealthEncryptionHandshakeData(CNode* pnode)\n+{\n+    // initialize encryption, generate ephemeral key\n+    assert(pnode->m_encryption_handler == nullptr);\n+    pnode->m_encryption_handler = std::make_shared<BIP151Encryption>();\n+\n+    // get encryption handshake data\n+    std::vector<unsigned char> handshake_data;\n+    pnode->m_encryption_handler->GetHandshakeRequestData(handshake_data);\n+\n+    // push handshake data\n+    LogPrint(BCLog::NET, \"Send stealth encryption handshake payload of %d bytes, peer=%d\\n\", handshake_data.size(), pnode->GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536556",
      "id" : 214536556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzNjU1Ng==",
      "original_commit_id" : "d98eedb3f8765e1909c58da637e187eb872c708d",
      "original_position" : 360,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 151616903,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536621"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536621"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"does accept\"? Maybe change to \"NODE_ENCRYPTED: node accepts encrypted communication, see BIP151\"?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-02T11:06:35Z",
      "diff_hunk" : "@@ -268,6 +268,9 @@ enum ServiceFlags : uint64_t {\n     // serving the last 288 (2 day) blocks\n     // See BIP159 for details on how this is implemented.\n     NODE_NETWORK_LIMITED = (1 << 10),\n+    // NODE_ENCRYPTED means that the node does accept encrypted communication after BIP151",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536621",
      "id" : 214536621,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzNjYyMQ==",
      "original_commit_id" : "0971380cca98d80724c0fd6707e3ee571362d8cb",
      "original_position" : 4,
      "path" : "src/protocol.h",
      "position" : null,
      "pull_request_review_id" : 151616979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536621",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I removed the term \"stealth encryption\" from the source code (plus code comments). Also fixed the protocol.h `NODE_ENCRYPTED` comment.",
      "created_at" : "2018-09-03T11:23:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-418086026",
      "id" : 418086026,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODA4NjAyNg==",
      "updated_at" : "2018-09-03T11:23:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418086026",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r215158004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215158004"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`m_inbound` is not initialized in the constructor?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-05T07:14:46Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r215158004",
      "id" : 215158004,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE1ODAwNA==",
      "original_commit_id" : "d98eedb3f8765e1909c58da637e187eb872c708d",
      "original_position" : 59,
      "path" : "src/net_encryption.h",
      "position" : 61,
      "pull_request_review_id" : 152360948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215158004",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-09-05T20:13:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-418865816",
      "id" : 418865816,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODg2NTgxNg==",
      "updated_at" : "2018-09-05T20:13:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418865816",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2018-09-18T07:54:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-422293012",
      "id" : 422293012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMjI5MzAxMg==",
      "updated_at" : "2018-09-18T07:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/422293012",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This PR does not seem to compile after rebasing on `master` :-)",
      "created_at" : "2018-09-21T08:19:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-423453904",
      "id" : 423453904,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzQ1MzkwNA==",
      "updated_at" : "2018-09-21T08:19:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423453904",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219417941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219417941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net.cpp:2824:13: warning: implicit conversion 'uint8_t' (aka 'unsigned char') -> bool [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:20:45Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;\n+        serialized_envelope.reserve(3 /* <- packet length */ + serialized_command_size + nMessageSize + pnode->m_encryption_handler->GetTagLen());\n \n-    size_t nBytesSent = 0;\n-    {\n-        LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        // convert the host 32 bit size into a LE 24bit\n+        envelope_payload_length = htole32(envelope_payload_length);\n+        uint8_t int24[3];\n+        memcpy(int24, &envelope_payload_length, 3);\n \n-        //log total amount of bytes per command\n-        pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n-        pnode->nSendSize += nTotalSize;\n+        CVectorWriter vector_writer(SER_NETWORK, INIT_PROTO_VERSION, serialized_envelope, 0, int24[0], int24[1], int24[2]);\n+        if (cmd_short_id) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219417941",
      "id" : 219417941,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxNzk0MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 278,
      "path" : "src/net.cpp",
      "position" : 278,
      "pull_request_review_id" : 157588517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:20:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219417941",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418243"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/./net_encryption.h:141:9: warning: function 'NetMessageEncryptionHandshake::Read' has a definition with different parameter names [readability-inconsistent-declaration-parameter-name]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:22:00Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)\n+    {\n+        m_data_pos = 0;\n+        m_type = NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        return (m_data_pos == 32);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return \"\";\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418243",
      "id" : 219418243,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODI0Mw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 141,
      "path" : "src/net_encryption.h",
      "position" : 141,
      "pull_request_review_id" : 157588910,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:22:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418243",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418290"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418290"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/./net_encryption.h:199:9: warning: function 'NetCryptedMessage::Read' has a definition with different parameter names [readability-inconsistent-declaration-parameter-name]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:22:15Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)\n+    {\n+        m_data_pos = 0;\n+        m_type = NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        return (m_data_pos == 32);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return \"\";\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;\n+\n+    bool VerifyMessageStart() const override { return true; }\n+    bool VerifyHeader() const override;\n+    bool VerifyChecksum(std::string& error) const override { return true; }\n+};\n+\n+//encrypted network message envelope after BIP151\n+class NetCryptedMessage : public NetMessageBase\n+{\n+public:\n+    bool m_in_data;\n+    uint32_t m_message_size;\n+    bool m_rekey_flag;\n+    unsigned int m_hdr_pos;\n+    uint32_t m_data_pos;\n+    std::string m_command_name;\n+\n+    EncryptionHandlerRef m_encryption_handler;\n+\n+    NetCryptedMessage(EncryptionHandlerRef encryption_handler, const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn)\n+        : NetMessageBase(nTypeIn, nVersionIn),\n+          m_encryption_handler(encryption_handler)\n+    {\n+        // resize the message buffer to the AADlen (3 byte packet size for BIP151)\n+        vRecv.resize(m_encryption_handler->GetAADLen());\n+        m_message_size = 0;\n+        m_hdr_pos = 0;\n+        m_data_pos = 0;\n+        m_in_data = 0;\n+        m_type = NetMessageType::ENCRYPTED_MSG;\n+        m_command_name.clear();\n+        m_rekey_flag = false;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        if (!m_in_data) {\n+            return false;\n+        }\n+        return (m_message_size + m_encryption_handler->GetTagLen() == m_data_pos);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return m_message_size; //is size(strCommand & playload), where v1 is only size(playload)\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return m_message_size + sizeof(m_message_size) + m_encryption_handler->GetAADLen() + m_encryption_handler->GetTagLen();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return m_command_name;\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418290",
      "id" : 219418290,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODI5MA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 199,
      "path" : "src/net_encryption.h",
      "position" : 199,
      "pull_request_review_id" : 157588998,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:22:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418290",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:39:24: warning: implicit conversion 'unsigned int' -> bool [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:22:41Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418402",
      "id" : 219418402,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODQwMg==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 39,
      "path" : "src/net_encryption.cpp",
      "position" : 39,
      "pull_request_review_id" : 157589134,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:22:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418402",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418564"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:39:43: warning: use of a signed integer operand with a binary bitwise operator [hicpp-signed-bitwise]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:23:22Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418564",
      "id" : 219418564,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODU2NA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 39,
      "path" : "src/net_encryption.cpp",
      "position" : 39,
      "pull_request_review_id" : 157589346,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:23:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418564",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:42:33: warning: use of a signed integer operand with a binary bitwise operator [hicpp-signed-bitwise]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:23:31Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418592",
      "id" : 219418592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODU5Mg==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 42,
      "path" : "src/net_encryption.cpp",
      "position" : 42,
      "pull_request_review_id" : 157589389,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:23:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418592",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:75:24: warning: implicit conversion bool -> 'int' [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:24:38Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418831",
      "id" : 219418831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODgzMQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 75,
      "path" : "src/net_encryption.cpp",
      "position" : 75,
      "pull_request_review_id" : 157589716,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:24:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418831",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418907"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418907"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:88:24: warning: implicit conversion bool -> 'int' [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:24:58Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418907",
      "id" : 219418907,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODkwNw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 88,
      "path" : "src/net_encryption.cpp",
      "position" : 88,
      "pull_request_review_id" : 157589830,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:24:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418907",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418952"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418952"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:90:46: warning: implicit conversion bool -> 'int' [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:25:10Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219418952",
      "id" : 219418952,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxODk1Mg==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 90,
      "path" : "src/net_encryption.cpp",
      "position" : 90,
      "pull_request_review_id" : 157589890,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:25:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219418952",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419001"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:93:60: warning: implicit conversion bool -> 'int' [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:25:23Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419001",
      "id" : 219419001,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTAwMQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 93,
      "path" : "src/net_encryption.cpp",
      "position" : 93,
      "pull_request_review_id" : 157589963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:25:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419001",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419049"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:101:28: warning: implicit conversion bool -> 'int' [readability-implicit-bool-conversion]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:25:35Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419049",
      "id" : 219419049,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTA0OQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 101,
      "path" : "src/net_encryption.cpp",
      "position" : 101,
      "pull_request_review_id" : 157590020,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:25:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419049",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419105"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:139:16: warning: redundant boolean literal in conditional return statement [readability-simplify-boolean-expr]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:25:47Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419105",
      "id" : 219419105,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTEwNQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 139,
      "path" : "src/net_encryption.cpp",
      "position" : 139,
      "pull_request_review_id" : 157590096,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:25:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419105",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419271"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419271"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:179:9: warning: implicit conversion 'unsigned int' -> bool [readability-implicit-bool-conversion]\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:179:27: warning: use of a signed integer operand with a binary bitwise operator [hicpp-signed-bitwise]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:26:31Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with reset nonce\n+    if (data_in_out[2] & (1u << 7)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419271",
      "id" : 219419271,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTI3MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 179,
      "path" : "src/net_encryption.cpp",
      "position" : 179,
      "pull_request_review_id" : 157590323,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:26:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419271",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419315"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:188:28: warning: use of a signed integer operand with a binary bitwise operator [hicpp-signed-bitwise]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:26:40Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with reset nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and reset sequence)\n+        // rekey flag is the most significant bit encoded in LE (Bitcoin serialization rule)\n+        data_in_out[2] |= (1u << 7);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419315",
      "id" : 219419315,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTMxNQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 188,
      "path" : "src/net_encryption.cpp",
      "position" : 188,
      "pull_request_review_id" : 157590368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:26:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419315",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419461"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419461"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:222:16: warning: redundant boolean literal in conditional return statement [readability-simplify-boolean-expr]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:27:14Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with reset nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and reset sequence)\n+        // rekey flag is the most significant bit encoded in LE (Bitcoin serialization rule)\n+        data_in_out[2] |= (1u << 7);\n+    }\n+\n+    // create a buffer for the encrypted payload\n+    std::vector<unsigned char> buf_enc;\n+    buf_enc.resize(data_in_out.size() + TAG_LEN);\n+\n+    // encrypt and add MAC tag\n+    LOCK(cs);\n+    chacha20poly1305_crypt(&m_send_aead_ctx, m_send_seq_nr++, &buf_enc[0], &data_in_out[0],\n+        data_in_out.size() - AAD_LEN, AAD_LEN, 1);\n+\n+    // Count total bytes encrypted\n+    m_bytes_encrypted += data_in_out.size() - AAD_LEN;\n+\n+    // clear data_in and append the decrypted data\n+    data_in_out.clear();\n+    data_in_out.insert(data_in_out.begin(), buf_enc.begin(), buf_enc.end());\n+\n+    // if it is time to rekey, rekey post encryption\n+    if (should_rekey) {\n+        Rekey(true);\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::GetLength(CDataStream& data_in, uint32_t& len_out)\n+{\n+    if (data_in.size() < AAD_LEN) {\n+        return false;\n+    }\n+\n+    LOCK(cs);\n+    if (chacha20poly1305_get_length24(&m_recv_aead_ctx, &len_out, m_recv_seq_nr, (const uint8_t*)&data_in.data()[0]) == -1) {\n+        return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419461",
      "id" : 219419461,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTQ2MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 222,
      "path" : "src/net_encryption.cpp",
      "position" : 222,
      "pull_request_review_id" : 157590550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:27:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419461",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419536"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419536"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:06:03 clang-tidy(pr=14032): src/net_encryption.cpp:300:1: warning: constructor does not initialize these fields: m_inbound, m_send_aead_ctx, m_recv_aead_ctx [cppcoreguidelines-pro-type-member-init]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-21T08:27:38Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with reset nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and reset sequence)\n+        // rekey flag is the most significant bit encoded in LE (Bitcoin serialization rule)\n+        data_in_out[2] |= (1u << 7);\n+    }\n+\n+    // create a buffer for the encrypted payload\n+    std::vector<unsigned char> buf_enc;\n+    buf_enc.resize(data_in_out.size() + TAG_LEN);\n+\n+    // encrypt and add MAC tag\n+    LOCK(cs);\n+    chacha20poly1305_crypt(&m_send_aead_ctx, m_send_seq_nr++, &buf_enc[0], &data_in_out[0],\n+        data_in_out.size() - AAD_LEN, AAD_LEN, 1);\n+\n+    // Count total bytes encrypted\n+    m_bytes_encrypted += data_in_out.size() - AAD_LEN;\n+\n+    // clear data_in and append the decrypted data\n+    data_in_out.clear();\n+    data_in_out.insert(data_in_out.begin(), buf_enc.begin(), buf_enc.end());\n+\n+    // if it is time to rekey, rekey post encryption\n+    if (should_rekey) {\n+        Rekey(true);\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::GetLength(CDataStream& data_in, uint32_t& len_out)\n+{\n+    if (data_in.size() < AAD_LEN) {\n+        return false;\n+    }\n+\n+    LOCK(cs);\n+    if (chacha20poly1305_get_length24(&m_recv_aead_ctx, &len_out, m_recv_seq_nr, (const uint8_t*)&data_in.data()[0]) == -1) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool BIP151Encryption::ShouldCryptMsg()\n+{\n+    return handshake_done;\n+}\n+\n+uint256 BIP151Encryption::GetSessionID()\n+{\n+    LOCK(cs);\n+    return m_session_id;\n+}\n+\n+void BIP151Encryption::EnableEncryption(bool inbound)\n+{\n+    LOCK(cs);\n+    if (m_raw_ecdh_secret.size() != 32) {\n+        return;\n+    }\n+    m_inbound = inbound;\n+    // extract 2 keys for each direction with HKDF HMAC_SHA256 with length 32\n+    CHKDF_HMAC_SHA256_L32 hkdf_32(&m_raw_ecdh_secret[0], 32, \"BitcoinSharedSecret\");\n+    hkdf_32.Expand32(\"BitcoinK1A\", &m_k1_encryption_keypack[0]);\n+    hkdf_32.Expand32(\"BitcoinK1B\", &m_k1_encryption_keypack[32]);\n+    hkdf_32.Expand32(\"BitcoinK2A\", &m_k2_encryption_keypack[0]);\n+    hkdf_32.Expand32(\"BitcoinK2B\", &m_k2_encryption_keypack[32]);\n+    hkdf_32.Expand32(\"BitcoinSessionID\", m_session_id.begin());\n+\n+    m_bytes_encrypted = 0;\n+    m_time_last_rekey_send = GetTime();\n+    m_time_last_rekey_recv = m_time_last_rekey_send;\n+\n+    // enabling k1 for send channel on requesting peer and for recv channel on responding peer\n+    // enabling k2 for recv channel on requesting peer and for send channel on responding peer\n+    chacha20poly1305_init(&m_send_aead_ctx, inbound ? m_k2_encryption_keypack.data() : m_k1_encryption_keypack.data(), m_k1_encryption_keypack.size());\n+    chacha20poly1305_init(&m_recv_aead_ctx, inbound ? m_k1_encryption_keypack.data() : m_k2_encryption_keypack.data(), m_k1_encryption_keypack.size());\n+\n+    handshake_done = true;\n+}\n+\n+bool BIP151Encryption::GetHandshakeRequestData(std::vector<unsigned char>& handshake_data)\n+{\n+    LOCK(cs);\n+    CPubKey pubkey = m_ecdh_key.GetPubKey();\n+    m_ecdh_key.VerifyPubKey(pubkey); //verify the pubkey\n+    assert(pubkey[0] == 2);\n+\n+    handshake_data.insert(handshake_data.begin(), pubkey.begin() + 1, pubkey.end());\n+    return true;\n+}\n+\n+bool BIP151Encryption::ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data)\n+{\n+    CPubKey pubkey;\n+    if (handshake_data.size() != 32) {\n+        return false;\n+    }\n+    std::vector<unsigned char> handshake_data_even_pubkey;\n+    handshake_data_even_pubkey.push_back(2);\n+    handshake_data_even_pubkey.insert(handshake_data_even_pubkey.begin() + 1, handshake_data.begin(), handshake_data.end());\n+    pubkey.Set(handshake_data_even_pubkey.begin(), handshake_data_even_pubkey.end());\n+    if (!pubkey.IsFullyValid()) {\n+        return false;\n+    }\n+\n+    // calculate ECDH secret\n+    LOCK(cs);\n+    bool ret = m_ecdh_key.ComputeECDHSecret(pubkey, m_raw_ecdh_secret);\n+\n+    // After calculating the ECDH secret, the ephemeral key can be cleansed from memory\n+    m_ecdh_key.SetNull();\n+    return ret;\n+}\n+\n+BIP151Encryption::BIP151Encryption() : handshake_done(false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419536",
      "id" : 219419536,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTUzNg==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 300,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 157590664,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419536",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419787"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419787"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:09:57 flake8(pr=14032): test/functional/p2p_encryption.py:34:25: E231 missing whitespace after ','\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:28:34Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Tests NODE_ENCRYPTED (v2 protocol, encryption after BIP151).\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, connect_nodes\n+\n+class EncryptionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [['-netencryption'], ['-netencryption'], ['-netencryption=0'], ['-netencryption']]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[2], 1)\n+        connect_nodes(self.nodes[2], 3)\n+        connect_nodes(self.nodes[3], 1)\n+        self.sync_all()\n+\n+    def getEncryptionSessions(self, node):\n+        session_ids = []\n+        for peer in node.getpeerinfo():\n+            if peer['encrypted']:\n+                session_ids.append(peer['encryption_session_id'])\n+        return session_ids\n+\n+    def run_test(self):\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+        nodes_session_id = []\n+        for i in range(0,4):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419787",
      "id" : 219419787,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTc4Nw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 34,
      "path" : "test/functional/p2p_encryption.py",
      "position" : 34,
      "pull_request_review_id" : 157591012,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:28:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419787",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419892"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:10:08 pvs-studio-analyzer(pr=14032): src/net_message.h:28 [err] V730 Not all members of a class are initialized inside the constructor. Consider inspecting: m_type.\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-21T08:28:55Z",
      "diff_hunk" : "@@ -0,0 +1,122 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_MESSAGE_H\n+#define BITCOIN_NET_MESSAGE_H\n+\n+#include <hash.h>\n+#include <protocol.h>\n+#include <streams.h>\n+#include <uint256.h>\n+\n+/** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n+\n+enum class NetMessageType {\n+    PLAINTEXT,\n+    PLAINTEXT_ENCRYPTION_HANDSHAKE,\n+    ENCRYPTED_MSG\n+};\n+\n+// base class for format agnostic network messages\n+class NetMessageBase\n+{\n+public:\n+    CDataStream vRecv; // received message data\n+    int64_t nTime;     // time (in microseconds) of message receipt.\n+    NetMessageType m_type;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419892",
      "id" : 219419892,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTg5Mg==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 28,
      "path" : "src/net_message.h",
      "position" : 28,
      "pull_request_review_id" : 157591132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-21T08:28:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419892",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419987"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:10:08 pvs-studio-analyzer(pr=14032): src/net_encryption.cpp:300 [err] V730 Not all members of a class are initialized inside the constructor. Consider inspecting: m_inbound, m_send_aead_ctx, m_recv_aead_ctx.\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-21T08:29:16Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size excluding the MAC\n+\n+            // initially check the message\n+            // the first byte of the message is a ASCII command string size from 1-12\n+            // or a short ID (>12)\n+            uint8_t size_or_shortid;\n+            try {\n+                vRecv >> size_or_shortid;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            if (size_or_shortid == 0) return false; //0 is invalid\n+            if (size_or_shortid <= 12) {\n+                // string command\n+                if (vRecv.size() < size_or_shortid) return false;\n+\n+                m_command_name.resize(size_or_shortid);\n+                vRecv.read(&m_command_name[0], size_or_shortid);\n+            }\n+            else {\n+                // must be a short ID\n+                if (!GetCommandFromShortCommandID(size_or_shortid, m_command_name)) {\n+                    return false; // short ID not found\n+                }\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with reset nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and reset sequence)\n+        // rekey flag is the most significant bit encoded in LE (Bitcoin serialization rule)\n+        data_in_out[2] |= (1u << 7);\n+    }\n+\n+    // create a buffer for the encrypted payload\n+    std::vector<unsigned char> buf_enc;\n+    buf_enc.resize(data_in_out.size() + TAG_LEN);\n+\n+    // encrypt and add MAC tag\n+    LOCK(cs);\n+    chacha20poly1305_crypt(&m_send_aead_ctx, m_send_seq_nr++, &buf_enc[0], &data_in_out[0],\n+        data_in_out.size() - AAD_LEN, AAD_LEN, 1);\n+\n+    // Count total bytes encrypted\n+    m_bytes_encrypted += data_in_out.size() - AAD_LEN;\n+\n+    // clear data_in and append the decrypted data\n+    data_in_out.clear();\n+    data_in_out.insert(data_in_out.begin(), buf_enc.begin(), buf_enc.end());\n+\n+    // if it is time to rekey, rekey post encryption\n+    if (should_rekey) {\n+        Rekey(true);\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::GetLength(CDataStream& data_in, uint32_t& len_out)\n+{\n+    if (data_in.size() < AAD_LEN) {\n+        return false;\n+    }\n+\n+    LOCK(cs);\n+    if (chacha20poly1305_get_length24(&m_recv_aead_ctx, &len_out, m_recv_seq_nr, (const uint8_t*)&data_in.data()[0]) == -1) {\n+        return false;\n+    }\n+\n+    return true;\n+}\n+\n+bool BIP151Encryption::ShouldCryptMsg()\n+{\n+    return handshake_done;\n+}\n+\n+uint256 BIP151Encryption::GetSessionID()\n+{\n+    LOCK(cs);\n+    return m_session_id;\n+}\n+\n+void BIP151Encryption::EnableEncryption(bool inbound)\n+{\n+    LOCK(cs);\n+    if (m_raw_ecdh_secret.size() != 32) {\n+        return;\n+    }\n+    m_inbound = inbound;\n+    // extract 2 keys for each direction with HKDF HMAC_SHA256 with length 32\n+    CHKDF_HMAC_SHA256_L32 hkdf_32(&m_raw_ecdh_secret[0], 32, \"BitcoinSharedSecret\");\n+    hkdf_32.Expand32(\"BitcoinK1A\", &m_k1_encryption_keypack[0]);\n+    hkdf_32.Expand32(\"BitcoinK1B\", &m_k1_encryption_keypack[32]);\n+    hkdf_32.Expand32(\"BitcoinK2A\", &m_k2_encryption_keypack[0]);\n+    hkdf_32.Expand32(\"BitcoinK2B\", &m_k2_encryption_keypack[32]);\n+    hkdf_32.Expand32(\"BitcoinSessionID\", m_session_id.begin());\n+\n+    m_bytes_encrypted = 0;\n+    m_time_last_rekey_send = GetTime();\n+    m_time_last_rekey_recv = m_time_last_rekey_send;\n+\n+    // enabling k1 for send channel on requesting peer and for recv channel on responding peer\n+    // enabling k2 for recv channel on requesting peer and for send channel on responding peer\n+    chacha20poly1305_init(&m_send_aead_ctx, inbound ? m_k2_encryption_keypack.data() : m_k1_encryption_keypack.data(), m_k1_encryption_keypack.size());\n+    chacha20poly1305_init(&m_recv_aead_ctx, inbound ? m_k1_encryption_keypack.data() : m_k2_encryption_keypack.data(), m_k1_encryption_keypack.size());\n+\n+    handshake_done = true;\n+}\n+\n+bool BIP151Encryption::GetHandshakeRequestData(std::vector<unsigned char>& handshake_data)\n+{\n+    LOCK(cs);\n+    CPubKey pubkey = m_ecdh_key.GetPubKey();\n+    m_ecdh_key.VerifyPubKey(pubkey); //verify the pubkey\n+    assert(pubkey[0] == 2);\n+\n+    handshake_data.insert(handshake_data.begin(), pubkey.begin() + 1, pubkey.end());\n+    return true;\n+}\n+\n+bool BIP151Encryption::ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data)\n+{\n+    CPubKey pubkey;\n+    if (handshake_data.size() != 32) {\n+        return false;\n+    }\n+    std::vector<unsigned char> handshake_data_even_pubkey;\n+    handshake_data_even_pubkey.push_back(2);\n+    handshake_data_even_pubkey.insert(handshake_data_even_pubkey.begin() + 1, handshake_data.begin(), handshake_data.end());\n+    pubkey.Set(handshake_data_even_pubkey.begin(), handshake_data_even_pubkey.end());\n+    if (!pubkey.IsFullyValid()) {\n+        return false;\n+    }\n+\n+    // calculate ECDH secret\n+    LOCK(cs);\n+    bool ret = m_ecdh_key.ComputeECDHSecret(pubkey, m_raw_ecdh_secret);\n+\n+    // After calculating the ECDH secret, the ephemeral key can be cleansed from memory\n+    m_ecdh_key.SetNull();\n+    return ret;\n+}\n+\n+BIP151Encryption::BIP151Encryption() : handshake_done(false)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219419987",
      "id" : 219419987,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQxOTk4Nw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 300,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 157591231,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219419987",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691387"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691387"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 21:25:19 cpplint(pr=14032): src/bench/chacha20poly1305.cpp:29:  Missing space after ,  [whitespace/comma] [3]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-23T08:06:47Z",
      "diff_hunk" : "@@ -0,0 +1,66 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <iostream>\n+\n+#include <bench/bench.h>\n+#include <hash.h>\n+#include <utiltime.h>\n+#include <crypto/chachapoly_aead.h>\n+\n+/* Number of bytes to crypt/hash per iteration */\n+static const uint64_t BUFFER_SIZE_A = 1000*1000;\n+static const uint64_t BUFFER_SIZE_B = 256;\n+\n+static void CHACHA20POLY1305AEAD_(benchmark::State& state, uint64_t bufsize)\n+{\n+    struct chachapolyaead_ctx aead_ctx;\n+    static const uint32_t seqnr = 100;\n+    static const uint8_t aead_keys[64] = {\n+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n+        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n+        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n+\n+    chacha20poly1305_init(&aead_ctx, aead_keys, 64);\n+    std::vector<uint8_t> in(bufsize,0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691387",
      "id" : 219691387,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTM4Nw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 29,
      "path" : "src/bench/chacha20poly1305.cpp",
      "position" : null,
      "pull_request_review_id" : 157931991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691387",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691396"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 21:25:19 cpplint(pr=14032): src/bench/chacha20poly1305.cpp:30:  Missing space after ,  [whitespace/comma] [3]\r\n```\r\n",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-23T08:07:00Z",
      "diff_hunk" : "@@ -0,0 +1,66 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <iostream>\n+\n+#include <bench/bench.h>\n+#include <hash.h>\n+#include <utiltime.h>\n+#include <crypto/chachapoly_aead.h>\n+\n+/* Number of bytes to crypt/hash per iteration */\n+static const uint64_t BUFFER_SIZE_A = 1000*1000;\n+static const uint64_t BUFFER_SIZE_B = 256;\n+\n+static void CHACHA20POLY1305AEAD_(benchmark::State& state, uint64_t bufsize)\n+{\n+    struct chachapolyaead_ctx aead_ctx;\n+    static const uint32_t seqnr = 100;\n+    static const uint8_t aead_keys[64] = {\n+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n+        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n+        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n+\n+    chacha20poly1305_init(&aead_ctx, aead_keys, 64);\n+    std::vector<uint8_t> in(bufsize,0);\n+    std::vector<uint8_t> out(bufsize,0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691396",
      "id" : 219691396,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTM5Ng==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 30,
      "path" : "src/bench/chacha20poly1305.cpp",
      "position" : null,
      "pull_request_review_id" : 157931997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691396",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691411"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 21:25:19 cpplint(pr=14032): src/bench/chacha20poly1305.cpp:51:  Missing space after ,  [whitespace/comma] [3]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-23T08:07:25Z",
      "diff_hunk" : "@@ -0,0 +1,66 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <iostream>\n+\n+#include <bench/bench.h>\n+#include <hash.h>\n+#include <utiltime.h>\n+#include <crypto/chachapoly_aead.h>\n+\n+/* Number of bytes to crypt/hash per iteration */\n+static const uint64_t BUFFER_SIZE_A = 1000*1000;\n+static const uint64_t BUFFER_SIZE_B = 256;\n+\n+static void CHACHA20POLY1305AEAD_(benchmark::State& state, uint64_t bufsize)\n+{\n+    struct chachapolyaead_ctx aead_ctx;\n+    static const uint32_t seqnr = 100;\n+    static const uint8_t aead_keys[64] = {\n+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n+        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,\n+        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n+\n+    chacha20poly1305_init(&aead_ctx, aead_keys, 64);\n+    std::vector<uint8_t> in(bufsize,0);\n+    std::vector<uint8_t> out(bufsize,0);\n+\n+    while (state.KeepRunning()) {\n+        chacha20poly1305_crypt(&aead_ctx, seqnr, in.data(), out.data(), in.size()-16,\n+            4, 1);\n+    }\n+}\n+\n+static void CHACHA20POLY1305AEAD_BIG(benchmark::State& state)\n+{\n+    CHACHA20POLY1305AEAD_(state, BUFFER_SIZE_A);\n+}\n+\n+static void CHACHA20POLY1305AEAD_SMALL(benchmark::State& state)\n+{\n+    CHACHA20POLY1305AEAD_(state, BUFFER_SIZE_B);\n+}\n+\n+static void HASH256_(benchmark::State& state, uint64_t bufsize)\n+{\n+    uint8_t hash[CHash256::OUTPUT_SIZE];\n+    std::vector<uint8_t> in(bufsize,0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r219691411",
      "id" : 219691411,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTQxMQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 51,
      "path" : "src/bench/chacha20poly1305.cpp",
      "position" : null,
      "pull_request_review_id" : 157932011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691411",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220339631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220339631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net_encryption.h:77:5: warning: '~BIP151Encryption' overrides a destructor but is not marked 'override' [-Winconsistent-missing-destructor-override]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-25T20:17:40Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220339631",
      "id" : 220339631,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDMzOTYzMQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 77,
      "path" : "src/net_encryption.h",
      "position" : null,
      "pull_request_review_id" : 158726040,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220339631",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220339788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220339788"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net_encryption.h:115:76: warning: unused parameter 'pchMessageStartIn' [-Wunused-parameter]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-25T20:17:59Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220339788",
      "id" : 220339788,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDMzOTc4OA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 115,
      "path" : "src/net_encryption.h",
      "position" : 115,
      "pull_request_review_id" : 158726165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-25T20:17:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220339788",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340025"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net_encryption.h:145:38: warning: unused parameter 'error' [-Wunused-parameter]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-25T20:18:47Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)\n+    {\n+        m_data_pos = 0;\n+        m_type = NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        return (m_data_pos == 32);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return \"\";\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;\n+\n+    bool VerifyMessageStart() const override { return true; }\n+    bool VerifyHeader() const override;\n+    bool VerifyChecksum(std::string& error) const override { return true; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340025",
      "id" : 220340025,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM0MDAyNQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 145,
      "path" : "src/net_encryption.h",
      "position" : 145,
      "pull_request_review_id" : 158726525,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-25T20:18:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340025",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340103"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340103"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net_encryption.h:161:105: warning: unused parameter 'pchMessageStartIn' [-Wunused-parameter]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-25T20:19:03Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)\n+    {\n+        m_data_pos = 0;\n+        m_type = NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        return (m_data_pos == 32);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return \"\";\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;\n+\n+    bool VerifyMessageStart() const override { return true; }\n+    bool VerifyHeader() const override;\n+    bool VerifyChecksum(std::string& error) const override { return true; }\n+};\n+\n+//encrypted network message envelope after BIP151\n+class NetCryptedMessage : public NetMessageBase\n+{\n+public:\n+    bool m_in_data;\n+    uint32_t m_message_size;\n+    bool m_rekey_flag;\n+    unsigned int m_hdr_pos;\n+    uint32_t m_data_pos;\n+    std::string m_command_name;\n+\n+    EncryptionHandlerRef m_encryption_handler;\n+\n+    NetCryptedMessage(EncryptionHandlerRef encryption_handler, const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340103",
      "id" : 220340103,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM0MDEwMw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 161,
      "path" : "src/net_encryption.h",
      "position" : null,
      "pull_request_review_id" : 158726613,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340103",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net_encryption.h:203:38: warning: unused parameter 'error' [-Wunused-parameter]\r\n```",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-25T20:19:19Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;\n+    std::atomic_bool handshake_done;\n+    int64_t m_time_last_rekey_send = 0;\n+    int64_t m_time_last_rekey_recv = 0;\n+    uint64_t m_bytes_encrypted = 0; //counter of bytes encrypted with same key\n+    uint64_t m_bytes_decrypted = 0; //counter of bytes decrypted with same key\n+\n+    CCriticalSection cs;\n+    struct chachapolyaead_ctx m_send_aead_ctx;\n+    struct chachapolyaead_ctx m_recv_aead_ctx;\n+    uint32_t m_recv_seq_nr = 0;\n+    uint32_t m_send_seq_nr = 0;\n+\n+    // check if send channel should rekey\n+    bool ShouldRekeySend();\n+\n+public:\n+    BIP151Encryption();\n+    ~BIP151Encryption()\n+    {\n+        memory_cleanse(&m_send_aead_ctx, sizeof(m_send_aead_ctx));\n+        memory_cleanse(&m_recv_aead_ctx, sizeof(m_recv_aead_ctx));\n+    }\n+    bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) override;\n+    bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) override;\n+\n+    bool GetLength(CDataStream& data_in, uint32_t& len_out) override;\n+    bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) override;\n+    bool AuthenticatedAndDecrypt(CDataStream& data_in_out) override;\n+\n+    bool ShouldCryptMsg() override;\n+    void EnableEncryption(bool inbound) override;\n+    uint256 GetSessionID() override;\n+\n+    inline unsigned int GetTagLen() const override\n+    {\n+        return TAG_LEN;\n+    }\n+\n+    inline unsigned int GetAADLen() const override\n+    {\n+        return AAD_LEN;\n+    }\n+\n+    // rekey for either the send or recv channel\n+    // may return false if recv channel rekey did not respect limits\n+    bool Rekey(bool send_channel) override;\n+};\n+typedef std::shared_ptr<EncryptionHandlerInterface> EncryptionHandlerRef;\n+\n+//network message for 32byte encryption handshake with fallback option\n+class NetMessageEncryptionHandshake : public NetMessageBase\n+{\n+public:\n+    unsigned int m_data_pos;\n+\n+    NetMessageEncryptionHandshake(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : NetMessageBase(nTypeIn, nVersionIn)\n+    {\n+        m_data_pos = 0;\n+        m_type = NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        return (m_data_pos == 32);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return vRecv.size();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return \"\";\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;\n+\n+    bool VerifyMessageStart() const override { return true; }\n+    bool VerifyHeader() const override;\n+    bool VerifyChecksum(std::string& error) const override { return true; }\n+};\n+\n+//encrypted network message envelope after BIP151\n+class NetCryptedMessage : public NetMessageBase\n+{\n+public:\n+    bool m_in_data;\n+    uint32_t m_message_size;\n+    bool m_rekey_flag;\n+    unsigned int m_hdr_pos;\n+    uint32_t m_data_pos;\n+    std::string m_command_name;\n+\n+    EncryptionHandlerRef m_encryption_handler;\n+\n+    NetCryptedMessage(EncryptionHandlerRef encryption_handler, const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn)\n+        : NetMessageBase(nTypeIn, nVersionIn),\n+          m_encryption_handler(encryption_handler)\n+    {\n+        // resize the message buffer to the AADlen (3 byte packet size for BIP151)\n+        vRecv.resize(m_encryption_handler->GetAADLen());\n+        m_message_size = 0;\n+        m_hdr_pos = 0;\n+        m_data_pos = 0;\n+        m_in_data = 0;\n+        m_type = NetMessageType::ENCRYPTED_MSG;\n+        m_command_name.clear();\n+        m_rekey_flag = false;\n+    }\n+\n+    bool Complete() const override\n+    {\n+        if (!m_in_data) {\n+            return false;\n+        }\n+        return (m_message_size + m_encryption_handler->GetTagLen() == m_data_pos);\n+    }\n+\n+    uint32_t GetMessageSize() const override\n+    {\n+        return m_message_size; //is size(strCommand & playload), where v1 is only size(playload)\n+    }\n+\n+    uint32_t GetMessageSizeWithHeader() const override\n+    {\n+        return m_message_size + sizeof(m_message_size) + m_encryption_handler->GetAADLen() + m_encryption_handler->GetTagLen();\n+    }\n+\n+    std::string GetCommandName() const override\n+    {\n+        return m_command_name;\n+    }\n+\n+    int Read(const char* pch, unsigned int nBytes) override;\n+\n+    bool VerifyMessageStart() const override { return true; }\n+    bool VerifyHeader() const override { return true; }\n+    bool VerifyChecksum(std::string& error) const override { return true; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220340217",
      "id" : 220340217,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM0MDIxNw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 203,
      "path" : "src/net_encryption.h",
      "position" : 203,
      "pull_request_review_id" : 158726740,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-25T20:19:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220340217",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220341324"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220341324"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-25 21:57:17 clang(pr=14032): net.cpp:2815:68: warning: implicit conversion loses integer precision: 'unsigned long' to 'uint32_t' (aka 'unsigned int') [-Wshorten-64-to-32]\r\n```",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-25T20:22:53Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220341324",
      "id" : 220341324,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM0MTMyNA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 262,
      "path" : "src/net.cpp",
      "position" : 237,
      "pull_request_review_id" : 158728127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220341324",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220346225"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220346225"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@practicalswift Could you slow down the rate of these nits?\r\n\r\nThey're useful, but my mailbox is full of basically just these style of comments. Perhaps these are things to point out when a PR is active, and basically ready for merging, not when it's laid dormant for weeks. This way it litters the PR page with loads of information that's distracting for someone who hasn't even gone to give a concept ACK.\r\n\r\n",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-25T20:37:21Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220346225",
      "id" : 220346225,
      "in_reply_to_id" : 220341324,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM0NjIyNQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 262,
      "path" : "src/net.cpp",
      "position" : 237,
      "pull_request_review_id" : 158733927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220346225",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220355440"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220355440"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@sipa Absolutely! I'm still calibrating this reporting to increase the signal to noise, so feedback is appreciated!\r\n\r\nI'll try to find the right threshold for things that are worth commenting about, and also some heuristic for determining which PR:s to analyze. Currently I'm analyzing all open PR:s but that is perhaps overkill.\r\n\r\nThere should probably be a max comment count per PR too. This PR is a good example Ã¢ÂÂ it is massive (+1800 lines) which gives a high warning count even if the warning ratio is comparable with other PRs (say one warning per 50 lines of code).\r\n\r\nAs said - feedback appreciated! :-)",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-25T21:06:18Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220355440",
      "id" : 220355440,
      "in_reply_to_id" : 220341324,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDM1NTQ0MA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 262,
      "path" : "src/net.cpp",
      "position" : 237,
      "pull_request_review_id" : 158745536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220355440",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220551168"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220551168"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think waiting for either two concept ACK or one utACK / ACK / tACK would make sense.",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-26T13:02:29Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r220551168",
      "id" : 220551168,
      "in_reply_to_id" : 220341324,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMDU1MTE2OA==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 262,
      "path" : "src/net.cpp",
      "position" : 237,
      "pull_request_review_id" : 158982889,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/220551168",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464261"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be `get_encryption_sessions`? Could also be a function instead of method since `self` is not used?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-30T16:06:20Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Tests NODE_ENCRYPTED (v2 protocol, encryption after BIP151).\"\"\"\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal, connect_nodes\n+\n+class EncryptionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 4\n+        self.extra_args = [['-netencryption'], ['-netencryption'], ['-netencryption=0'], ['-netencryption']]\n+\n+    def setup_network(self):\n+        self.setup_nodes()\n+        connect_nodes(self.nodes[0], 1)\n+        connect_nodes(self.nodes[2], 1)\n+        connect_nodes(self.nodes[2], 3)\n+        connect_nodes(self.nodes[3], 1)\n+        self.sync_all()\n+\n+    def getEncryptionSessions(self, node):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464261",
      "id" : 221464261,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NDI2MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 23,
      "path" : "test/functional/p2p_encryption.py",
      "position" : 23,
      "pull_request_review_id" : 160119600,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464261",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464337"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464337"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could drop this `else` statement (and keep the block as-is but one indentation level to the left) to make the code easier to follow?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-30T16:08:19Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464337",
      "id" : 221464337,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NDMzNw==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 55,
      "path" : "src/net_encryption.cpp",
      "position" : 58,
      "pull_request_review_id" : 160119658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464337",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Invert logic here to handle the `!Complete()` case first? That would simplify the code and reduce indentation.",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-09-30T16:12:33Z",
      "diff_hunk" : "@@ -0,0 +1,373 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r221464481",
      "id" : 221464481,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ2NDQ4MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 71,
      "path" : "src/net_encryption.cpp",
      "position" : 74,
      "pull_request_review_id" : 160119796,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221464481",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r225694991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225694991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be \"version\" :-)",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2018-10-16T20:24:06Z",
      "diff_hunk" : "@@ -1569,9 +1578,44 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n     return true;\n }\n \n-bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61)\n+bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool enable_bip61, const NetMessageType msg_type)\n {\n-    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n+    /* handling encryption handshake */\n+    if (pfrom->nVersion == 0 && msg_type == NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE) {\n+        LogPrint(BCLog::NET, \"Encryption handshake payload received, peer=%i\\n\", pfrom->GetId());\n+\n+        std::vector<unsigned char> handshake_msg;\n+        handshake_msg.resize(vRecv.size());\n+        memcpy(&handshake_msg[0], &vRecv[0], handshake_msg.size());\n+\n+        if (!pfrom->fInbound && pfrom->m_encryption_handler) {\n+            // we have initiated the encryption\n+            // the message does now contain the remote pubkey\n+            if (!pfrom->m_encryption_handler->ProcessHandshakeRequestData(handshake_msg)) {\n+                LogPrint(BCLog::NET, \"Invalid handshake received, peer=%d\\n\", pfrom->GetId());\n+                return false;\n+            }\n+            pfrom->m_encryption_handler->EnableEncryption(false);\n+            LogPrint(BCLog::NET, \"Enabling encryption as handshake-initiator, sessionID=%s, peer=%d\\n\", pfrom->m_encryption_handler->GetSessionID().ToString(), pfrom->GetId());\n+\n+            // set the trigger to send the vesrion",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r225694991",
      "id" : 225694991,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5NDk5MQ==",
      "original_commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "original_position" : 66,
      "path" : "src/net_processing.cpp",
      "position" : 56,
      "pull_request_review_id" : 165351289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225694991",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-10-20T09:51:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-431566277",
      "id" : 431566277,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzMTU2NjI3Nw==",
      "updated_at" : "2018-10-20T09:51:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/431566277",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265345892"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265345892"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Scope could be reduced?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2019-03-13T21:49:59Z",
      "diff_hunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <crypto/chacha_poly_aead.h>\n+\n+#include <crypto/common.h>\n+#include <crypto/poly1305.h>\n+#include <support/cleanse.h>\n+\n+#include <assert.h>\n+#include <cstdio>\n+#include <limits>\n+#include <string.h>\n+\n+#define XOR(v, w) ((v) ^ (w))\n+\n+#ifndef HAVE_TIMINGSAFE_BCMP\n+\n+int timingsafe_bcmp(const unsigned char *b1, const unsigned char *b2, size_t n) {\n+  const unsigned char *p1 = b1, *p2 = b2;\n+  int ret = 0;\n+\n+  for (; n > 0; n--)\n+    ret |= *p1++ ^ *p2++;\n+  return (ret != 0);\n+}\n+\n+#endif // TIMINGSAFE_BCMP\n+\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char *K_1, size_t K_1_len, const unsigned char *K_2, size_t K_2_len) {\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    m_chacha_main.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    m_chacha_header.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+    // set the cached sequence number to uint64 max which hints for an unset cache.\n+    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n+    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+}\n+\n+bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr, unsigned char* dest, const unsigned char* src, uint32_t len, bool is_encrypt) {\n+  unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n+  uint64_t seqnr64 = seqnr;\n+  uint64_t aad_chacha_iv_hdr = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265345892",
      "id" : 265345892,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NTM0NTg5Mg==",
      "original_commit_id" : "fe3be2d82f1293e3b6d7d15b9e0180199b3cc376",
      "original_position" : 45,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : null,
      "pull_request_review_id" : 214230117,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265345892",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265346596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265346596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Initialize to zero here (or in constructor) to be on the safe side?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2019-03-13T21:52:15Z",
      "diff_hunk" : "@@ -0,0 +1,123 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n+#define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n+\n+#include <crypto/chacha20.h>\n+\n+#include <cmath>\n+\n+static constexpr int CHACHA20_POLY1305_AEAD_KEY_LEN = 32;\n+static constexpr int CHACHA20_POLY1305_AEAD_AAD_LEN = 3; /* 3 bytes length */\n+static constexpr int CHACHA20_ROUND_OUTPUT = 64; /* 64 bytes per round */\n+static constexpr int AAD_PACKAGES_PER_ROUND = 21; /* 64 / 3 round down*/\n+\n+/* A AEAD class for ChaCha20-Poly1305@bitcoin.\n+ *\n+ * ChaCha20 is a stream cipher designed by Daniel Bernstein and described in\n+ * http://cr.yp.to/chacha/chacha-20080128.pdf\n+ * It operates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit\n+ * nonce and a 64 bit counter into 64 bytes of output. This output is used as a\n+ * keystream, with any unused bytes simply discarded.\n+ * Poly1305 (http://cr.yp.to/mac/poly1305-20050329.pdf), also by Daniel\n+ * Bernstein, is a one-time Carter-Wegman MAC that computes a 128 bit integrity\n+ * tag given a message and a single-use 256 bit secret key.\n+ *\n+ * The chacha20-poly1305@bitcoin combines these two primitives into an\n+ * authenticated encryption mode. The construction used is based on that\n+ * proposed for TLS by Adam Langley in\n+ * http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03, but differs in\n+ * the layout of data passed to the MAC and in the addition of encyption of the\n+ * packet lengths.\n+ *\n+ * ==== Detailed Construction ====\n+ *\n+ * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material\n+ * as output from the key exchange. Each key (K_1 and K_2) are used by two\n+ * separate instances of chacha20.\n+ *\n+ * The instance keyed by K_1 is a stream cipher that is used only to encrypt\n+ * the 3 byte packet length field. The second instance, keyed by K_2, is used\n+ * in conjunction with poly1305 to build an AEAD (Authenticated Encryption\n+ * with Associated Data) that is used to encrypt and authenticate the entire\n+ * packet.\n+ *\n+ * Two separate cipher instances are used here so as to keep the packet lengths\n+ * confidential but not create an oracle for the packet payload cipher by\n+ * decrypting and using the packet length prior to checking the MAC. By using\n+ * an independently-keyed cipher instance to encrypt the length, an active\n+ * attacker seeking to exploit the packet input handling as a decryption oracle\n+ * can learn nothing about the payload contents or its MAC (assuming key\n+ * derivation, ChaCha20 and Poly1305 are secure).\n+ *\n+ * The AEAD is constructed as follows: for each packet, generate a Poly1305 key\n+ * by taking the first 256 bits of ChaCha20 stream output generated using K_2,\n+ * an IV consisting of the packet sequence number encoded as an uint64 under\n+ * the SSH wire encoding rules and a ChaCha20 block counter of zero. The K_2\n+ * ChaCha20 block counter is then set to the little-endian encoding of 1 (i.e.\n+ * {1, 0, 0, 0, 0, 0, 0, 0}) and this instance is used for encryption of the\n+ * packet payload.\n+ *\n+ * The initial value of the sequence number is 0.\n+ *\n+ * ==== Packet Handling ====\n+ * When receiving a packet, the length must be decrypted first. When 3 bytes of\n+ * ciphertext length have been received, they may be decrypted using the K_1\n+ * key, a nonce consisting of the packet sequence number encoded as a LE uint64\n+ * and a zero block counter to obtain the plaintext length.\n+ *\n+ * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n+ * times a 3 bytes length field (21*3 = 63). The packet sequence number must be\n+ * divided by 21 and rounded down to calculate the internal sequence number\n+ * nonce for the length-cipher ChaCha20 instance (K_1). The length field must\n+ * be enc-/decrypted with the ChaCha20 keystream defined by block counter 0 and\n+ * the internal sequence number. The position in the keystream is defined by\n+ * the internal sequence number modulo 21 times 3 (seek always 3 bytes forward\n+ * but ignore last byte (byte 64) per ChaCha20 round).\n+ *\n+ * Once the entire packet has been received, the MAC MUST be checked before\n+ * decryption. A per-packet Poly1305 key is generated as described above and\n+ * the MAC tag calculated using Poly1305 with this key over the ciphertext of\n+ * the packet length and the payload together. The calculated MAC is then\n+ * compared in constant time with the one appended to the packet and the packet\n+ * decrypted using ChaCha20 as described above (with K_2, the packet sequence\n+ * number as nonce and a starting block counter of 1).\n+ *\n+ * Detection of an invalid MAC MUST lead to immediate connection termination.\n+ *\n+ * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n+ * described above. Encrypt the packet payload (using K_2) and append it to the\n+ * encrypted length. Finally, calculate a MAC tag and append it.\n+ *\n+ * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages\n+ * on the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt\n+ * messages on the receive channel.\n+ *\n+ * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages\n+ * on the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt\n+ * messages on the send channel.\n+ *\n+ * ChaCha20 must never reuse a {key, nonce} for encryption nor may it be used\n+ * to encrypt more than 2^70 bytes under the same {key, nonce}.\n+ *\n+ * We use a message sequence number for both communication directions as\n+ * ChaCha20 nonce.\n+*/\n+\n+class ChaCha20Poly1305AEAD\n+{\n+private:\n+    ChaCha20 m_chacha_main;\n+    ChaCha20 m_chacha_header;\n+    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265346596",
      "id" : 265346596,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NTM0NjU5Ng==",
      "original_commit_id" : "fe3be2d82f1293e3b6d7d15b9e0180199b3cc376",
      "original_position" : 114,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 214231000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265346596",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265348618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265348618"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is the non-ref const string here intentional? Assuming SSO will take place?",
      "commit_id" : "bdc9b75b3e6fdd09d29c9e8e16b4ca358e5a169f",
      "created_at" : "2019-03-13T21:58:54Z",
      "diff_hunk" : "@@ -201,3 +201,30 @@ const std::vector<std::string> &getAllNetMessageTypes()\n {\n     return allNetMessageTypesVec;\n }\n+\n+uint8_t GetShortCommandIDFromCommand(const std::string cmd) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r265348618",
      "id" : 265348618,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI2NTM0ODYxOA==",
      "original_commit_id" : "fe3be2d82f1293e3b6d7d15b9e0180199b3cc376",
      "original_position" : 5,
      "path" : "src/protocol.cpp",
      "position" : 5,
      "pull_request_review_id" : 214233494,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2019-03-22T20:18:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/265348618",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
