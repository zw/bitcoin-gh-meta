[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146549693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146549693"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Assert to detect if `receive_address` is incorrecly changed?",
      "commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "created_at" : "2017-10-24T12:55:55Z",
      "diff_hunk" : "@@ -72,62 +72,135 @@ def run_test(self):\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         node.sendfrom(\"\", common_address, fee)\n-        accounts = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n         amount_to_send = 1.0\n-        account_addresses = dict()\n+\n+        # Create accounts and make sure subsequent account API calls\n+        # recognize the account/address associations.\n+        accounts = [Account(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            account_addresses[account] = address\n-            \n-            node.getnewaddress(account)\n-            assert_equal(node.getaccount(address), account)\n-            assert(address in node.getaddressesbyaccount(account))\n-            \n-            node.sendfrom(\"\", address, amount_to_send)\n-        \n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Send a transaction to each account, and make sure this forces\n+        # getaccountaddress to generate a new receiving address.\n+        for account in accounts:\n+            node.sendtoaddress(account.receive_address, amount_to_send)\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Check the amounts received.\n         node.generate(1)\n+        for account in accounts:\n+            assert_equal(\n+                node.getreceivedbyaddress(account.addresses[0]), amount_to_send)\n+            assert_equal(node.getreceivedbyaccount(account.name), amount_to_send)\n         \n-        for i in range(len(accounts)):\n-            from_account = accounts[i]\n+        # Check that sendfrom account reduces listaccounts balances.\n+        for i, account in enumerate(accounts):\n             to_account = accounts[(i+1) % len(accounts)]\n-            to_address = account_addresses[to_account]\n-            node.sendfrom(from_account, to_address, amount_to_send)\n-        \n+            node.sendfrom(account.name, to_account.receive_address, amount_to_send)\n         node.generate(1)\n-        \n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            assert(address != account_addresses[account])\n-            assert_equal(node.getreceivedbyaccount(account), 2)\n-            node.move(account, \"\", node.getbalance(account))\n-\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+            assert_equal(node.getreceivedbyaccount(account.name), 2)\n+            node.move(account.name, \"\", node.getbalance(account.name))\n+            account.verify(node)\n         node.generate(101)\n-        \n         expected_account_balances = {\"\": 5200}\n         for account in accounts:\n-            expected_account_balances[account] = 0\n-        \n+            expected_account_balances[account.name] = 0\n         assert_equal(node.listaccounts(), expected_account_balances)\n-        \n         assert_equal(node.getbalance(\"\"), 5200)\n         \n+        # Check that setaccount can assign an account to a new unused address.\n         for account in accounts:\n             address = node.getaccountaddress(\"\")\n-            node.setaccount(address, account)\n-            assert(address in node.getaddressesbyaccount(account))\n+            node.setaccount(address, account.name)\n+            account.add_address(address)\n+            account.verify(node)\n             assert(address not in node.getaddressesbyaccount(\"\"))\n         \n+        # Check that addmultisigaddress can assign accounts.\n         for account in accounts:\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account)\n+            multisig_address = node.addmultisigaddress(5, addresses, account.name)\n+            account.add_address(multisig_address)\n+            account.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)\n-        \n         node.generate(101)\n-        \n         for account in accounts:\n-            assert_equal(node.getbalance(account), 50)\n+            assert_equal(node.getbalance(account.name), 50)\n+\n+        # Check that setaccount can change the account of an address from a\n+        # different account.\n+        change_account(node, accounts[0].addresses[0], accounts[0], accounts[1])\n+\n+        # Check that setaccount can change the account of an address which\n+        # is the receiving address of a different account.\n+        change_account(node, accounts[0].receive_address, accounts[0], accounts[1])\n+\n+        # Check that setaccount can set the account of an address already\n+        # in the account. This is a no-op.\n+        change_account(node, accounts[2].addresses[0], accounts[2], accounts[2])\n+\n+        # Check that setaccount can set the account of an address which is\n+        # already the receiving address of the account. It would probably make\n+        # sense for this to be a no-op, but right now it resets the receiving\n+        # address, causing getaccountaddress to return a brand new address.\n+        change_account(node, accounts[2].receive_address, accounts[2], accounts[2])\n+\n+class Account:\n+    def __init__(self, name):\n+        # Account name\n+        self.name = name\n+        # Current receiving address associated with this account.\n+        self.receive_address = None\n+        # List of all addresses assigned with this account\n+        self.addresses = []\n+\n+    def add_address(self, address):\n+        assert_equal(address not in self.addresses, True)\n+        self.addresses.append(address)\n+\n+    def add_receive_address(self, address):\n+        self.add_address(address)\n+        self.receive_address = address\n+\n+    def verify(self, node):\n+        if self.receive_address is not None:\n+            assert self.receive_address in self.addresses",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146549693",
      "id" : 146549693,
      "original_commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "original_position" : 135,
      "path" : "test/functional/wallet-accounts.py",
      "position" : 135,
      "pull_request_review_id" : 71506486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552",
      "updated_at" : "2017-10-24T13:09:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146549693",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146551327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551327"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`assert ... not in ...;`?",
      "commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "created_at" : "2017-10-24T13:02:08Z",
      "diff_hunk" : "@@ -72,62 +72,135 @@ def run_test(self):\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         node.sendfrom(\"\", common_address, fee)\n-        accounts = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n         amount_to_send = 1.0\n-        account_addresses = dict()\n+\n+        # Create accounts and make sure subsequent account API calls\n+        # recognize the account/address associations.\n+        accounts = [Account(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            account_addresses[account] = address\n-            \n-            node.getnewaddress(account)\n-            assert_equal(node.getaccount(address), account)\n-            assert(address in node.getaddressesbyaccount(account))\n-            \n-            node.sendfrom(\"\", address, amount_to_send)\n-        \n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Send a transaction to each account, and make sure this forces\n+        # getaccountaddress to generate a new receiving address.\n+        for account in accounts:\n+            node.sendtoaddress(account.receive_address, amount_to_send)\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Check the amounts received.\n         node.generate(1)\n+        for account in accounts:\n+            assert_equal(\n+                node.getreceivedbyaddress(account.addresses[0]), amount_to_send)\n+            assert_equal(node.getreceivedbyaccount(account.name), amount_to_send)\n         \n-        for i in range(len(accounts)):\n-            from_account = accounts[i]\n+        # Check that sendfrom account reduces listaccounts balances.\n+        for i, account in enumerate(accounts):\n             to_account = accounts[(i+1) % len(accounts)]\n-            to_address = account_addresses[to_account]\n-            node.sendfrom(from_account, to_address, amount_to_send)\n-        \n+            node.sendfrom(account.name, to_account.receive_address, amount_to_send)\n         node.generate(1)\n-        \n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            assert(address != account_addresses[account])\n-            assert_equal(node.getreceivedbyaccount(account), 2)\n-            node.move(account, \"\", node.getbalance(account))\n-\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+            assert_equal(node.getreceivedbyaccount(account.name), 2)\n+            node.move(account.name, \"\", node.getbalance(account.name))\n+            account.verify(node)\n         node.generate(101)\n-        \n         expected_account_balances = {\"\": 5200}\n         for account in accounts:\n-            expected_account_balances[account] = 0\n-        \n+            expected_account_balances[account.name] = 0\n         assert_equal(node.listaccounts(), expected_account_balances)\n-        \n         assert_equal(node.getbalance(\"\"), 5200)\n         \n+        # Check that setaccount can assign an account to a new unused address.\n         for account in accounts:\n             address = node.getaccountaddress(\"\")\n-            node.setaccount(address, account)\n-            assert(address in node.getaddressesbyaccount(account))\n+            node.setaccount(address, account.name)\n+            account.add_address(address)\n+            account.verify(node)\n             assert(address not in node.getaddressesbyaccount(\"\"))\n         \n+        # Check that addmultisigaddress can assign accounts.\n         for account in accounts:\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account)\n+            multisig_address = node.addmultisigaddress(5, addresses, account.name)\n+            account.add_address(multisig_address)\n+            account.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)\n-        \n         node.generate(101)\n-        \n         for account in accounts:\n-            assert_equal(node.getbalance(account), 50)\n+            assert_equal(node.getbalance(account.name), 50)\n+\n+        # Check that setaccount can change the account of an address from a\n+        # different account.\n+        change_account(node, accounts[0].addresses[0], accounts[0], accounts[1])\n+\n+        # Check that setaccount can change the account of an address which\n+        # is the receiving address of a different account.\n+        change_account(node, accounts[0].receive_address, accounts[0], accounts[1])\n+\n+        # Check that setaccount can set the account of an address already\n+        # in the account. This is a no-op.\n+        change_account(node, accounts[2].addresses[0], accounts[2], accounts[2])\n+\n+        # Check that setaccount can set the account of an address which is\n+        # already the receiving address of the account. It would probably make\n+        # sense for this to be a no-op, but right now it resets the receiving\n+        # address, causing getaccountaddress to return a brand new address.\n+        change_account(node, accounts[2].receive_address, accounts[2], accounts[2])\n+\n+class Account:\n+    def __init__(self, name):\n+        # Account name\n+        self.name = name\n+        # Current receiving address associated with this account.\n+        self.receive_address = None\n+        # List of all addresses assigned with this account\n+        self.addresses = []\n+\n+    def add_address(self, address):\n+        assert_equal(address not in self.addresses, True)\n+        self.addresses.append(address)\n+\n+    def add_receive_address(self, address):\n+        self.add_address(address)\n+        self.receive_address = address\n+\n+    def verify(self, node):\n+        if self.receive_address is not None:\n+            assert self.receive_address in self.addresses\n+            assert_equal(node.getaccountaddress(self.name), self.receive_address)\n+\n+        for address in self.addresses:\n+            assert_equal(node.getaccount(address), self.name)\n+\n+        assert_equal(\n+            set(node.getaddressesbyaccount(self.name)), set(self.addresses))\n+\n+\n+def change_account(node, address, old_account, new_account):\n+    assert_equal(address in old_account.addresses, True)\n+    node.setaccount(address, new_account.name)\n+\n+    old_account.addresses.remove(address)\n+    new_account.add_address(address)\n+\n+    # Calling setaccount on an address which was previously the receiving\n+    # address of a different account should reset the receiving address of\n+    # the old account, causing getaccountaddress to return a brand new\n+    # address.\n+    if address == old_account.receive_address:\n+        new_address = node.getaccountaddress(old_account.name)\n+        assert_equal(new_address not in old_account.addresses, True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146551327",
      "id" : 146551327,
      "original_commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "original_position" : 158,
      "path" : "test/functional/wallet-accounts.py",
      "position" : 158,
      "pull_request_review_id" : 71506486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552",
      "updated_at" : "2017-10-24T13:09:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Is it worth since accounts is deprecated?\r\n\r\nYes, all of the new tests apply to both accounts and labels. The new tests helped me identify two bugs in #7729.",
      "created_at" : "2017-10-24T13:23:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#issuecomment-338988187",
      "id" : 338988187,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11552",
      "updated_at" : "2017-10-24T13:23:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/338988187",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146559305"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146559305"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> assert ... not in ...;?\r\n\r\nAssert statements are skipped when python is run in optimized mode. I only use assert statements in tests when asserting conditions that indicate bugs in test setup, as opposed to conditions that could be caused by bugs in the code under test. (If you're familiar with google test framework, this is the distinction between CHECK and ASSERT_TRUE).\r\n",
      "commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "created_at" : "2017-10-24T13:30:23Z",
      "diff_hunk" : "@@ -72,62 +72,135 @@ def run_test(self):\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         node.sendfrom(\"\", common_address, fee)\n-        accounts = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n         amount_to_send = 1.0\n-        account_addresses = dict()\n+\n+        # Create accounts and make sure subsequent account API calls\n+        # recognize the account/address associations.\n+        accounts = [Account(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            account_addresses[account] = address\n-            \n-            node.getnewaddress(account)\n-            assert_equal(node.getaccount(address), account)\n-            assert(address in node.getaddressesbyaccount(account))\n-            \n-            node.sendfrom(\"\", address, amount_to_send)\n-        \n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Send a transaction to each account, and make sure this forces\n+        # getaccountaddress to generate a new receiving address.\n+        for account in accounts:\n+            node.sendtoaddress(account.receive_address, amount_to_send)\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Check the amounts received.\n         node.generate(1)\n+        for account in accounts:\n+            assert_equal(\n+                node.getreceivedbyaddress(account.addresses[0]), amount_to_send)\n+            assert_equal(node.getreceivedbyaccount(account.name), amount_to_send)\n         \n-        for i in range(len(accounts)):\n-            from_account = accounts[i]\n+        # Check that sendfrom account reduces listaccounts balances.\n+        for i, account in enumerate(accounts):\n             to_account = accounts[(i+1) % len(accounts)]\n-            to_address = account_addresses[to_account]\n-            node.sendfrom(from_account, to_address, amount_to_send)\n-        \n+            node.sendfrom(account.name, to_account.receive_address, amount_to_send)\n         node.generate(1)\n-        \n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            assert(address != account_addresses[account])\n-            assert_equal(node.getreceivedbyaccount(account), 2)\n-            node.move(account, \"\", node.getbalance(account))\n-\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+            assert_equal(node.getreceivedbyaccount(account.name), 2)\n+            node.move(account.name, \"\", node.getbalance(account.name))\n+            account.verify(node)\n         node.generate(101)\n-        \n         expected_account_balances = {\"\": 5200}\n         for account in accounts:\n-            expected_account_balances[account] = 0\n-        \n+            expected_account_balances[account.name] = 0\n         assert_equal(node.listaccounts(), expected_account_balances)\n-        \n         assert_equal(node.getbalance(\"\"), 5200)\n         \n+        # Check that setaccount can assign an account to a new unused address.\n         for account in accounts:\n             address = node.getaccountaddress(\"\")\n-            node.setaccount(address, account)\n-            assert(address in node.getaddressesbyaccount(account))\n+            node.setaccount(address, account.name)\n+            account.add_address(address)\n+            account.verify(node)\n             assert(address not in node.getaddressesbyaccount(\"\"))\n         \n+        # Check that addmultisigaddress can assign accounts.\n         for account in accounts:\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account)\n+            multisig_address = node.addmultisigaddress(5, addresses, account.name)\n+            account.add_address(multisig_address)\n+            account.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)\n-        \n         node.generate(101)\n-        \n         for account in accounts:\n-            assert_equal(node.getbalance(account), 50)\n+            assert_equal(node.getbalance(account.name), 50)\n+\n+        # Check that setaccount can change the account of an address from a\n+        # different account.\n+        change_account(node, accounts[0].addresses[0], accounts[0], accounts[1])\n+\n+        # Check that setaccount can change the account of an address which\n+        # is the receiving address of a different account.\n+        change_account(node, accounts[0].receive_address, accounts[0], accounts[1])\n+\n+        # Check that setaccount can set the account of an address already\n+        # in the account. This is a no-op.\n+        change_account(node, accounts[2].addresses[0], accounts[2], accounts[2])\n+\n+        # Check that setaccount can set the account of an address which is\n+        # already the receiving address of the account. It would probably make\n+        # sense for this to be a no-op, but right now it resets the receiving\n+        # address, causing getaccountaddress to return a brand new address.\n+        change_account(node, accounts[2].receive_address, accounts[2], accounts[2])\n+\n+class Account:\n+    def __init__(self, name):\n+        # Account name\n+        self.name = name\n+        # Current receiving address associated with this account.\n+        self.receive_address = None\n+        # List of all addresses assigned with this account\n+        self.addresses = []\n+\n+    def add_address(self, address):\n+        assert_equal(address not in self.addresses, True)\n+        self.addresses.append(address)\n+\n+    def add_receive_address(self, address):\n+        self.add_address(address)\n+        self.receive_address = address\n+\n+    def verify(self, node):\n+        if self.receive_address is not None:\n+            assert self.receive_address in self.addresses\n+            assert_equal(node.getaccountaddress(self.name), self.receive_address)\n+\n+        for address in self.addresses:\n+            assert_equal(node.getaccount(address), self.name)\n+\n+        assert_equal(\n+            set(node.getaddressesbyaccount(self.name)), set(self.addresses))\n+\n+\n+def change_account(node, address, old_account, new_account):\n+    assert_equal(address in old_account.addresses, True)\n+    node.setaccount(address, new_account.name)\n+\n+    old_account.addresses.remove(address)\n+    new_account.add_address(address)\n+\n+    # Calling setaccount on an address which was previously the receiving\n+    # address of a different account should reset the receiving address of\n+    # the old account, causing getaccountaddress to return a brand new\n+    # address.\n+    if address == old_account.receive_address:\n+        new_address = node.getaccountaddress(old_account.name)\n+        assert_equal(new_address not in old_account.addresses, True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146559305",
      "id" : 146559305,
      "in_reply_to_id" : 146551327,
      "original_commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "original_position" : 158,
      "path" : "test/functional/wallet-accounts.py",
      "position" : 158,
      "pull_request_review_id" : 71517909,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552",
      "updated_at" : "2017-10-24T13:30:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146559305",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146560275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146560275"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the explanation, wasn't aware of this.",
      "commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "created_at" : "2017-10-24T13:33:45Z",
      "diff_hunk" : "@@ -72,62 +72,135 @@ def run_test(self):\n         # otherwise we're off by exactly the fee amount as that's mined\n         # and matures in the next 100 blocks\n         node.sendfrom(\"\", common_address, fee)\n-        accounts = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n         amount_to_send = 1.0\n-        account_addresses = dict()\n+\n+        # Create accounts and make sure subsequent account API calls\n+        # recognize the account/address associations.\n+        accounts = [Account(name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")]\n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            account_addresses[account] = address\n-            \n-            node.getnewaddress(account)\n-            assert_equal(node.getaccount(address), account)\n-            assert(address in node.getaddressesbyaccount(account))\n-            \n-            node.sendfrom(\"\", address, amount_to_send)\n-        \n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Send a transaction to each account, and make sure this forces\n+        # getaccountaddress to generate a new receiving address.\n+        for account in accounts:\n+            node.sendtoaddress(account.receive_address, amount_to_send)\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+\n+        # Check the amounts received.\n         node.generate(1)\n+        for account in accounts:\n+            assert_equal(\n+                node.getreceivedbyaddress(account.addresses[0]), amount_to_send)\n+            assert_equal(node.getreceivedbyaccount(account.name), amount_to_send)\n         \n-        for i in range(len(accounts)):\n-            from_account = accounts[i]\n+        # Check that sendfrom account reduces listaccounts balances.\n+        for i, account in enumerate(accounts):\n             to_account = accounts[(i+1) % len(accounts)]\n-            to_address = account_addresses[to_account]\n-            node.sendfrom(from_account, to_address, amount_to_send)\n-        \n+            node.sendfrom(account.name, to_account.receive_address, amount_to_send)\n         node.generate(1)\n-        \n         for account in accounts:\n-            address = node.getaccountaddress(account)\n-            assert(address != account_addresses[account])\n-            assert_equal(node.getreceivedbyaccount(account), 2)\n-            node.move(account, \"\", node.getbalance(account))\n-\n+            account.add_receive_address(node.getaccountaddress(account.name))\n+            account.verify(node)\n+            assert_equal(node.getreceivedbyaccount(account.name), 2)\n+            node.move(account.name, \"\", node.getbalance(account.name))\n+            account.verify(node)\n         node.generate(101)\n-        \n         expected_account_balances = {\"\": 5200}\n         for account in accounts:\n-            expected_account_balances[account] = 0\n-        \n+            expected_account_balances[account.name] = 0\n         assert_equal(node.listaccounts(), expected_account_balances)\n-        \n         assert_equal(node.getbalance(\"\"), 5200)\n         \n+        # Check that setaccount can assign an account to a new unused address.\n         for account in accounts:\n             address = node.getaccountaddress(\"\")\n-            node.setaccount(address, account)\n-            assert(address in node.getaddressesbyaccount(account))\n+            node.setaccount(address, account.name)\n+            account.add_address(address)\n+            account.verify(node)\n             assert(address not in node.getaddressesbyaccount(\"\"))\n         \n+        # Check that addmultisigaddress can assign accounts.\n         for account in accounts:\n             addresses = []\n             for x in range(10):\n                 addresses.append(node.getnewaddress())\n-            multisig_address = node.addmultisigaddress(5, addresses, account)\n+            multisig_address = node.addmultisigaddress(5, addresses, account.name)\n+            account.add_address(multisig_address)\n+            account.verify(node)\n             node.sendfrom(\"\", multisig_address, 50)\n-        \n         node.generate(101)\n-        \n         for account in accounts:\n-            assert_equal(node.getbalance(account), 50)\n+            assert_equal(node.getbalance(account.name), 50)\n+\n+        # Check that setaccount can change the account of an address from a\n+        # different account.\n+        change_account(node, accounts[0].addresses[0], accounts[0], accounts[1])\n+\n+        # Check that setaccount can change the account of an address which\n+        # is the receiving address of a different account.\n+        change_account(node, accounts[0].receive_address, accounts[0], accounts[1])\n+\n+        # Check that setaccount can set the account of an address already\n+        # in the account. This is a no-op.\n+        change_account(node, accounts[2].addresses[0], accounts[2], accounts[2])\n+\n+        # Check that setaccount can set the account of an address which is\n+        # already the receiving address of the account. It would probably make\n+        # sense for this to be a no-op, but right now it resets the receiving\n+        # address, causing getaccountaddress to return a brand new address.\n+        change_account(node, accounts[2].receive_address, accounts[2], accounts[2])\n+\n+class Account:\n+    def __init__(self, name):\n+        # Account name\n+        self.name = name\n+        # Current receiving address associated with this account.\n+        self.receive_address = None\n+        # List of all addresses assigned with this account\n+        self.addresses = []\n+\n+    def add_address(self, address):\n+        assert_equal(address not in self.addresses, True)\n+        self.addresses.append(address)\n+\n+    def add_receive_address(self, address):\n+        self.add_address(address)\n+        self.receive_address = address\n+\n+    def verify(self, node):\n+        if self.receive_address is not None:\n+            assert self.receive_address in self.addresses\n+            assert_equal(node.getaccountaddress(self.name), self.receive_address)\n+\n+        for address in self.addresses:\n+            assert_equal(node.getaccount(address), self.name)\n+\n+        assert_equal(\n+            set(node.getaddressesbyaccount(self.name)), set(self.addresses))\n+\n+\n+def change_account(node, address, old_account, new_account):\n+    assert_equal(address in old_account.addresses, True)\n+    node.setaccount(address, new_account.name)\n+\n+    old_account.addresses.remove(address)\n+    new_account.add_address(address)\n+\n+    # Calling setaccount on an address which was previously the receiving\n+    # address of a different account should reset the receiving address of\n+    # the old account, causing getaccountaddress to return a brand new\n+    # address.\n+    if address == old_account.receive_address:\n+        new_address = node.getaccountaddress(old_account.name)\n+        assert_equal(new_address not in old_account.addresses, True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#discussion_r146560275",
      "id" : 146560275,
      "in_reply_to_id" : 146551327,
      "original_commit_id" : "bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "original_position" : 158,
      "path" : "test/functional/wallet-accounts.py",
      "position" : 158,
      "pull_request_review_id" : 71519056,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11552",
      "updated_at" : "2017-10-24T13:33:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146560275",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "utACK https://github.com/bitcoin/bitcoin/pull/11552/commits/bc9c0a7b74eab853fc21402d62a30dacd77a8843",
      "created_at" : "2017-11-09T12:07:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#issuecomment-343135539",
      "id" : 343135539,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11552",
      "updated_at" : "2017-11-09T12:07:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/343135539",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "post merge utACK bc9c0a7",
      "created_at" : "2017-11-09T20:40:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11552#issuecomment-343284478",
      "id" : 343284478,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11552",
      "updated_at" : "2017-11-09T20:40:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/343284478",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
