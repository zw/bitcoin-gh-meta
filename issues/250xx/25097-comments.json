[
   {
      "author_association" : "NONE",
      "body" : "(`Win64 native [msvc]` failed above in functional test `feature_index_prune.py` - this test has been reported recently as flaky, see #25031.)",
      "created_at" : "2022-05-10T03:52:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1121866886",
      "id" : 1121866886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585C3lSG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1121866886/reactions"
      },
      "updated_at" : "2022-05-10T03:52:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1121866886",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Squashed and rebased this branch to master and seeing this when running the tests:\r\n```\r\n$  ./src/test/test_bitcoin -t script_tapscript_tests\r\nRunning 12 test cases...\r\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\r\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\r\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\r\n```\r\n",
      "created_at" : "2022-05-18T06:47:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129634277",
      "id" : 1129634277,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVNnl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129634277/reactions"
      },
      "updated_at" : "2022-05-18T06:47:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129634277",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> Squashed and rebased this branch to master and seeing this when running the tests:\r\n> \r\n> ```\r\n> $  ./src/test/test_bitcoin -t script_tapscript_tests\r\n> Running 12 test cases...\r\n> test_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\n\r\n\r\nYes - that's actually expected.  Those are death tests - testing asserts.  The Boost Test framework will print that the assertion failed but then it is properly caught with an `ExecutionMonitor` so the test actually succeeds.\r\n\r\n**[Following paragraph was initially wrong but now is correct:]**\r\nThe reason for these tests is that I wanted to get 100% coverage.  This routine implements the Schnorr signature hash - which is specified in a BIP and of course is part of the consensus - and it is a very complicated routine - it takes several structs as inputs and those structs can have \"optional\" fields (but not `std::optional`) - which may or may not be initialized.  I thought it was important to make sure that the logic errors in callers actually caused the asserts to happen.  Plus, it makes it easier to look at the coverage report and say, yep, everything in here is tested.\r\n\r\nDo you have any suggestions on how I can improve the documentation or the test to avoid confusion such as this?  Perhaps I could use `BOOST_TEST_MESSAGE` to emit a message: \"These following assertions are _expected_\"??\r\n\r\n(There's a big comment explaining this in the code [@1366](https://github.com/bitcoin/bitcoin/pull/25097/files#diff-21483d0e032747850208f21325b29cde89e9c1f55f83a7a166a388cc5c27115aR1366) but of course people will just see the logs first ...)\r\n\r\nP.S. _Thank you_ for checking this PR out!  Very encouraging for me...",
      "created_at" : "2022-05-18T06:50:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129636628",
      "id" : 1129636628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVOMU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129636628/reactions"
      },
      "updated_at" : "2022-05-18T07:02:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129636628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oh ok, I hadn't looked at the code yet (the fixup and merge commits really need to be squashed to encourage people to look at it) but indeed there is a large comment. Agree, logging a message to explain would be helpful.",
      "created_at" : "2022-05-18T07:04:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129647169",
      "id" : 1129647169,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVQxB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129647169/reactions"
      },
      "updated_at" : "2022-05-18T07:04:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129647169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I will squash now (actually, in the morning ...) - I was waiting until I finished the last couple of tasks but no problem doing it now.  Thanks for the tip.\r\n\r\nAlso, unfortunately, `BOOST_TEST_MESSAGE` messages aren't displayed unless you set a `log_level`, like `--log_level=message` - so most people still won't see it ...",
      "created_at" : "2022-05-18T07:05:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129648074",
      "id" : 1129648074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVQ_K",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129648074/reactions"
      },
      "updated_at" : "2022-05-18T07:19:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129648074",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I tend to run individual tests with `-l test_suite` or `-l all` if anything unusual occurs when running it without a log level.\r\n\r\n In any case, the unit test runner invoked with `make check` runs it fine locally for me and it looks like you solved your CI issue.\r\n\r\nEdit: nit fixups signaled by `test/lint/lint-spelling.py`\r\n```\r\n$ test/lint/lint-spelling.py\r\nsrc/test/script_tapscript_tests.cpp:650: tranaction ==> transaction\r\nsrc/test/script_tapscript_tests.cpp:1048: suceeds ==> succeeds\r\n```\r\n\r\nEdit 2: I did see this error with `make check`, unsure if it was with your latest push:\r\n```\r\nRunning tests: from test/script_tapscript_tests.cpp\r\ncat: test/script_tapscript_tests.cpp: No such file or directory\r\nMissing an argument value for the parameter run_test in the argument \r\n\r\n  run_test\r\n    Filters which tests to execute.\r\n    --run_test=<test unit filter>\r\n    -t <test unit filter>\r\n\r\n\r\n  Use\r\n      test_bitcoin --help\r\n  or  test_bitcoin --help=<parameter name>\r\n  for detailed help on Boost.Test parameters.\r\nmake[3]: *** [Makefile:20940: test/script_tapscript_tests.cpp.test] Error 1\r\nmake[3]: *** Waiting for unfinished jobs....\r\n```\r\n",
      "created_at" : "2022-05-18T07:45:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129682494",
      "id" : 1129682494,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVZY-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129682494/reactions"
      },
      "updated_at" : "2022-05-18T08:38:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129682494",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r875574299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Noticed this in the test output.\r\n```suggestion\r\n        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \" scenarios\");\r\n```",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-18T07:46:30Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r875574299",
      "id" : 875574299,
      "line" : 602,
      "node_id" : "PRRC_kwDOABII5840MDQb",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 602,
      "original_position" : 602,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 602,
      "pull_request_review_id" : 976500374,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-18T07:46:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876048956"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876048956"
         }
      },
      "author_association" : "MEMBER",
      "body" : "At some point (maybe before this exits draft state) you might want to run clang format on this whole file.",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-18T15:33:38Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876048956",
      "id" : 876048956,
      "line" : 163,
      "node_id" : "PRRC_kwDOABII5840N3I8",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 163,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 163,
      "pull_request_review_id" : 977185276,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876048956/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-18T16:38:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876048956",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876110013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876110013"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Wow, TIL about user-defined literals in C++11.\r\n\r\nSo these are cool, but is the \"xx\"_hex stuff actually used in taproot-specific tests anywhere here? I can't find any usages, which would make that facility (and these tests) unnecessary if I'm reading right.",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-18T16:33:32Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn ( this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876110013",
      "id" : 876110013,
      "line" : 1201,
      "node_id" : "PRRC_kwDOABII5840OGC9",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 1201,
      "original_position" : 1201,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 1201,
      "pull_request_review_id" : 977185276,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876110013/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-18T16:38:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876110013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> Edit: nit fixups signaled by `test/lint/lint-spelling.py`\r\n\r\nFixed, and I'll run `lint-spelling` on my own from now on.\r\n\r\n> Edit 2: I did see this error with `make check`, unsure if it was with your latest push:\r\n> \r\n> ```\r\n> Running tests: from test/script_tapscript_tests.cpp\r\n> cat: test/script_tapscript_tests.cpp: No such file or directory\r\n> Missing an argument value for the parameter run_test in the argument \r\n> \r\n>   run_test\r\n> ...\r\n> ```\r\n\r\nI do not see this when running `make check` or when running `test_bitcoin` either with or without `--run_test=script_tapscript_tests`.  Relevant section of my terminal spew when running `make check` locally:\r\n\r\n```\r\n...\r\nRunning tests: script_tapscript_tests from test/script_tapscript_tests.cpp\r\nexport TEST_LOGFILE=/workspace/bitcoin/src/$( echo test/script_tapscript_tests.cpp | grep -E -o \"(wallet/test/.*\\.cpp|test/.*\\.cpp)\" | /usr/bin/sed -e s/\\.cpp/.log/ ) && \\\r\ntest/test_bitcoin --catch_system_errors=no -l test_suite -t \"$( cat test/script_tapscript_tests.cpp | grep -E \"(BOOST_FIXTURE_TEST_SUITE\\\\(|BOOST_AUTO_TEST_SUITE\\\\()\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1 )\" -- DEBUG_LOG_OUT > \"$TEST_LOGFILE\" 2>&1 || (cat \"$TEST_LOGFILE\" && false)\r\nRunning tests: script_tests from test/script_tests.cpp\r\n...\r\n```\r\nAnd the CI checks all pass too.  Not sure how to proceed on this report.",
      "created_at" : "2022-05-19T20:16:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1132163610",
      "id" : 1132163610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585De3Ia",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1132163610/reactions"
      },
      "updated_at" : "2022-05-19T20:16:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1132163610",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877503897"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877503897"
         }
      },
      "author_association" : "NONE",
      "body" : "Fixed.",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-19T20:16:57Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877503897",
      "id" : 877503897,
      "in_reply_to_id" : 875574299,
      "line" : 602,
      "node_id" : "PRRC_kwDOABII5840TaWZ",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 602,
      "original_position" : 602,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 602,
      "pull_request_review_id" : 979210647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877503897/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-19T20:16:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877503897",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877504162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877504162"
         }
      },
      "author_association" : "NONE",
      "body" : "OK!",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-19T20:17:15Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877504162",
      "id" : 877504162,
      "in_reply_to_id" : 876048956,
      "line" : 163,
      "node_id" : "PRRC_kwDOABII5840Taai",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 163,
      "original_position" : 163,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 163,
      "pull_request_review_id" : 979210986,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877504162/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-19T20:17:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877504162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877505159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877505159"
         }
      },
      "author_association" : "NONE",
      "body" : "I'm going to move all of these helpers off into homes in `src/test/util` where they can be used to make unit tests easier to write/read/maintain.  But reduce the set of them at the same time - there's some redundancy, as you've noticed.  (In a subsequent push to this PR.)",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-19T20:18:34Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn ( this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877505159",
      "id" : 877505159,
      "in_reply_to_id" : 876110013,
      "line" : 1201,
      "node_id" : "PRRC_kwDOABII5840TaqH",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 1201,
      "original_position" : 1201,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 1201,
      "pull_request_review_id" : 979212648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877505159/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-19T20:18:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877505159",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Squashed now as requested.  Still 2 tests left to write: They're tough ones as both are for `static` free functions well hidden by an accessible public free function, and no easy hooks like polymorphic classes to mock/fake to get in there with.\r\n\r\nHowever, all general-purpose \"test only\" internal helpers - data structures, functions for visibility, etc. - are now in `src/test/util` headers, with tests for them in `src/test/test_util_tests.cpp`.",
      "created_at" : "2022-05-21T04:31:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1133529339",
      "id" : 1133529339,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DkEj7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1133529339/reactions"
      },
      "updated_at" : "2022-05-21T04:33:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1133529339",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r878645117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/878645117"
         }
      },
      "author_association" : "NONE",
      "body" : "And that's done now.",
      "commit_id" : "8f96865fd960d1eed0321381bc527ade81efd56a",
      "created_at" : "2022-05-21T05:00:33Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn ( this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r878645117",
      "id" : 878645117,
      "in_reply_to_id" : 876110013,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5840Xw99",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 1201,
      "original_position" : 1201,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 980786990,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/878645117/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-21T05:00:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/878645117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25648](https://github.com/bitcoin/bitcoin/pull/25648) (refactor: Remove all policy globals by MarcoFalke)\n* [#25325](https://github.com/bitcoin/bitcoin/pull/25325) (Add pool based memory resource by martinus)\n* [#22954](https://github.com/bitcoin/bitcoin/pull/22954) ([TESTS] Allow tx_invalid.json tests to include flag rules for if_unset: [A,B,C] then_unset: [D] by JeremyRubin)\n* [#22876](https://github.com/bitcoin/bitcoin/pull/22876) ([TESTS] Update Transaction Tests to permit setting a flag as always on and disabling the exhaustive failure test by JeremyRubin)\n* [#22793](https://github.com/bitcoin/bitcoin/pull/22793) (Simplify BaseSignatureChecker virtual functions and GenericTransactionSignatureChecker constructors by achow101)\n* [#22338](https://github.com/bitcoin/bitcoin/pull/22338) ([Refactor]: Rename Script methods that only work on PreTapScript scripts by sanket1729)\n* [#20100](https://github.com/bitcoin/bitcoin/pull/20100) (Script: split policy/error consensus codes for CLEANSTACK, MINIMALIF by sanket1729)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-05-24T13:48:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1135947784",
      "id" : 1135947784,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DtTAI",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1135947784/reactions"
      },
      "updated_at" : "2022-07-21T21:49:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1135947784",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "DrahtBot said:\r\n> ### Conflicts\r\n> Reviewers, this pull request conflicts with the following ones:\r\n> \r\n> * [#25152](https://github.com/bitcoin/bitcoin/pull/25152) (refactor: Split util/system into exception, shell, and fs-specific files by Empact)\r\n\r\nReferenced PR is a refactoring PR.  I tried it out in my branch.  Only merge conflict here is to `src/Makefile.test.include` (and it's not a \"real\" conflict: just two lines changed, one in each PR, which happen to be adjacent (due to the alphabet)) which will be easily merged whichever PR lands first.\r\n\r\n",
      "created_at" : "2022-05-24T17:50:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1136260199",
      "id" : 1136260199,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DufRn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1136260199/reactions"
      },
      "updated_at" : "2022-05-24T17:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1136260199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "DrahtBot said:\r\n> ### Conflicts\r\n> Reviewers, this pull request conflicts with the following ones:\r\n> \r\n> * [#22793](https://github.com/bitcoin/bitcoin/pull/22793) (Simplify BaseSignatureChecker virtual functions and GenericTransactionSignatureChecker constructors by achow101)\r\n\r\nReferenced PR updates `BaseSignatureChecker` and `GenericSignatureChecker` which are used in these tests, and also various the internals of some routines in `interpreter.cpp` including `CheckSchnorrSignature`.\r\n\r\nMost of the resulting conflicts are easy to resolve; the tricky one was the update to `CheckSchnorrSignature` which changed its behavior in such a way that one of these tests became invalid.\r\n- This was exactly the case I was referring to in the PR header comment when I said:\r\n  \r\n  > This makes those specific tests somewhat fragile as they depend on code paths in the caller, which may change in the future. However, such tests are written so they will fail if the unit-under-test isn't actually called. This is noted in the code of those specific tests.\r\n\r\n  And naturally it was immediately hit! But it was also easily fixable.\r\n\r\nSo in fact I am ready to update this PR if #22793 lands first.  And also, _except_ for that, I can update this code _now_ so that there won't be any conflict if #22793 lands later.\r\n\r\n(I am of the opinion that there are routines in `interpreter.cpp` which are defined there `static` which needn't be.  They could just be file-scoped.  And thus these unit tests could call them _directly_ (by providing the prototype) and test them _directly_ rather than having to go indirectly through `CheckSchnorrSignature`, and so on.  But I didn't want to change `interpreter.cpp` to add unit tests after-the-fact.  I thought it would make it easier to get approvals for _this_ PR if I didn't make changes _there_.)",
      "created_at" : "2022-06-06T04:50:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1147041689",
      "id" : 1147041689,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585EXneZ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1147041689/reactions"
      },
      "updated_at" : "2022-06-06T04:53:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1147041689",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917134721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917134721"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nYou may want to move these `BOOST_ERROR(...)` changes back to the previous commit (where this file is introduced), since attempting to build the previous commit fails with this error:\r\n```\r\n/usr/bin/ld: /usr/bin/ld: DWARF error: could not find variable specification at offset 7218\r\nlibtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptFlags(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:138: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptFlags(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:138: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `FormatScriptError[abi:cxx11](ScriptError_t, bool)':\r\n./src/test/util/pretty_data.cpp:167: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `FormatScriptError[abi:cxx11](ScriptError_t, bool)':\r\n./src/test/util/pretty_data.cpp:167: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptError(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:176: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptError(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:176: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `_GLOBAL__sub_I_pretty_data.cpp':\r\n/usr/include/boost/test/unit_test_log.hpp:227: undefined reference to `boost::unit_test::unit_test_log_t::instance()'\r\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\r\n```",
      "commit_id" : "eeefec343592c6de85048e3b055ba49755cfb072",
      "created_at" : "2022-07-08T20:58:11Z",
      "diff_hunk" : "@@ -156,23 +153,22 @@ std::string FormatScriptFlags(unsigned int flags)\n         }\n         it++;\n     }\n+    if (ret.empty()) return \"\";\n     return ret.substr(0, ret.size() - 1);\n }\n \n-std::string FormatScriptError(ScriptError_t err, bool issue_boost_error)\n+std::optional<std::string> FormatScriptError(ScriptError_t err)\n {\n     for (const auto& se : script_errors)\n         if (se.err == err)\n             return std::string(se.name);\n-    if (issue_boost_error) BOOST_ERROR(\"Unknown scripterror enumeration value, update script_errors in script_tests.cpp.\");\n-    return \"\";\n+    return {};\n }\n \n-ScriptError_t ParseScriptError(std::string_view name, bool issue_boost_error)\n+std::optional<ScriptError_t> ParseScriptError(std::string_view name)\n {\n     for (const auto& se : script_errors)\n         if (se.name == name)\n             return se.err;\n-    if (issue_boost_error) BOOST_ERROR(\"Unknown scripterror \\\"\" << name << \"\\\" in test description\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917134721",
      "id" : 917134721,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5842ql2B",
      "original_commit_id" : "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_line" : 176,
      "original_position" : 76,
      "original_start_line" : null,
      "path" : "src/test/util/pretty_data.cpp",
      "position" : 76,
      "pull_request_review_id" : 1033377314,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917134721/reactions"
      },
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-08T20:58:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917134721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917142704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917142704"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/pull/25097/commits/12ae33708ee1978e2a215954e41e6ccf4f0a25fd\r\n\r\nIs there a reason to include this test case? This doesn't look like it's testing any non-std functionality. It also seems like a direct adaptation of the example usage here: https://en.cppreference.com/w/cpp/types/is_base_of",
      "commit_id" : "eeefec343592c6de85048e3b055ba49755cfb072",
      "created_at" : "2022-07-08T21:15:21Z",
      "diff_hunk" : "@@ -0,0 +1,308 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/traits.h>\n+#include <test/util/vector.h>\n+#include <uint256.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <iomanip>\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <string_view>\n+#include <type_traits>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+BOOST_FIXTURE_TEST_SUITE(test_util_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(as_string_tests)\n+{\n+    // Some typical values, independent of integral type\n+    BOOST_TEST(as_string(0) == \"0\"s);\n+    BOOST_TEST(as_string(1) == \"1\"s);\n+    BOOST_TEST(as_string(-1) == \"-1\"s);\n+    BOOST_TEST(as_string(12) == \"12\"s);\n+    BOOST_TEST(as_string(123) == \"123\"s);\n+    BOOST_TEST(as_string(1234) == \"1234\"s);\n+\n+    // Now some larger values\n+    BOOST_TEST(as_string(1'000'000'000'000ULL) == \"1000000000000\"s);\n+    BOOST_TEST(as_string(-1'234'567'890'123LL) == \"-1234567890123\"s);\n+}\n+\n+BOOST_AUTO_TEST_CASE(hex_to_stream)\n+{\n+    auto ToStream = [](auto v) {\n+        std::ostringstream oss;\n+        oss << Hex(v);\n+        return oss.str();\n+    };\n+\n+    {\n+        // integral types\n+        BOOST_TEST(ToStream(static_cast<int8_t>(0x75)) == \"0x75\");\n+        BOOST_TEST(ToStream(static_cast<uint8_t>(0x75)) == \"0x75\");\n+        BOOST_TEST(ToStream(0x75) == \"0x00000075\");\n+        BOOST_TEST(ToStream(0x75U) == \"0x00000075\");\n+        BOOST_TEST(ToStream(0x75LL) == \"0x0000000000000075\");\n+        BOOST_TEST(ToStream(0x75ULL) == \"0x0000000000000075\");\n+    }\n+\n+    {\n+        // `uint256` which acts like a container\n+        BOOST_TEST(ToStream(uint256::ZERO) == \"0x0000000000000000000000000000000000000000000000000000000000000000\");\n+        BOOST_TEST(ToStream(uint256::ONE) == \"0x0000000000000000000000000000000000000000000000000000000000000001\");\n+        BOOST_TEST(ToStream(uint256S(\"fedcba9876543210\"s)) == \"0x000000000000000000000000000000000000000000000000fedcba9876543210\");\n+        BOOST_TEST(ToStream(uint256S(\"0123456789abcdef00000000000000000000000000000000fedcba9876543210\")) == \"0x0123456789abcdef00000000000000000000000000000000fedcba9876543210\");\n+    }\n+\n+    {\n+        // `uint160` also acts like a container\n+\n+        // when initialized from a vector it is little-endian; but when written as a hex string it is big-endian\n+        std::vector<unsigned char> v160{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n+                                        0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6};\n+        BOOST_TEST(ToStream(uint160(v160)) == \"0xf6f7f8f9fafbfcfdfeff0a090807060504030201\");\n+    }\n+\n+    {\n+        // Span of unsigned char\n+        std::vector<unsigned char> v{0x10, 0x11, 0x12, 0x13, 0x14, 0x15};\n+        BOOST_TEST(ToStream(Span(v)) == \"0x101112131415\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(string_hex_to_bytes_and_back)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));\n+    BOOST_TEST(\"0a\"_hex == valtype(1, 0x0a));\n+    BOOST_TEST(\"A0\"_hex == valtype(1, 0xa0));\n+    BOOST_TEST(\"a0\"_hex == valtype(1, 0xa0));\n+    BOOST_TEST(\"aA\"_hex == valtype(1, 0xaa));\n+    BOOST_TEST(\"Aa\"_hex == valtype(1, 0xaa));\n+\n+    BOOST_TEST((\"12\"_hex == valtype{0x12}));\n+    BOOST_TEST((\"1234\"_hex == valtype{0x12, 0x34}));\n+    BOOST_TEST((\"123456\"_hex == valtype{0x12, 0x34, 0x56}));\n+\n+    // Invalid hex string literals\n+    BOOST_CHECK_THROW(\"1\"_hex, std::logic_error);\n+    BOOST_CHECK_THROW(\"123\"_hex, std::logic_error);\n+    BOOST_CHECK_THROW(\"1234xyz\"_hex, std::logic_error);\n+\n+    // Binary to hex string\n+    BOOST_TEST(\"12345678abcd\"s == HexStr(\"12345678abcd\"_hex));\n+    BOOST_TEST(std::string(64, '0') == HexStr(uint256::ZERO));\n+    BOOST_TEST((std::string{'0', '1'} + std::string(62, '0') == HexStr(uint256::ONE)));\n+}\n+\n+BOOST_AUTO_TEST_CASE(string_to_bytes)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    BOOST_TEST((\"Aa\"_bv == valtype{'A', 'a'}));\n+    BOOST_TEST((\"ABCD-0123-xyz\"_bv == valtype{'A', 'B', 'C', 'D', '-', '0', '1', '2', '3', '-', 'x', 'y', 'z'}));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HexStr_problem)\n+{\n+    std::vector<unsigned char> a5(1, 0xa5);\n+    auto a5_r = HexStr(Span<unsigned char>(a5));\n+    BOOST_TEST(a5_r == \"a5\"s);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ex_vector_tests)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    using namespace test::util::vector_ops;\n+\n+    {\n+        // Conversion via unary `+`\n+        std::vector<int> v{10, 20, 30};\n+        auto ev = +v;\n+        BOOST_TEST(ev == v);\n+    }\n+\n+    {\n+        // Subrange operation\n+        ex_vector<unsigned char> c1{\"ABCDEFGH\"_bv};\n+\n+        BOOST_TEST((c1[{0, 2}] == \"AB\"_bv));\n+        BOOST_TEST((c1[{1, 4}] == \"BCD\"_bv));\n+        BOOST_TEST((c1[{3, 7}] == \"DEFG\"_bv));\n+        BOOST_TEST((c1[{0, 8}] == c1));\n+    }\n+\n+    {\n+        // Creating ex_vector from a `uint256`.\n+        //\n+        // (w.r.t. these tests note there is an endianness issue - HexStr will print little-endian,\n+        // as a byte array, NOT big-endian like an integer\n+        ex_vector<unsigned char> exv_ZERO = from_base_blob(uint256::ZERO);\n+        BOOST_TEST(HexStr(exv_ZERO) == \"0000000000000000000000000000000000000000000000000000000000000000\");\n+        ex_vector<unsigned char> exv_ONE = from_base_blob(uint256::ONE);\n+        BOOST_TEST(HexStr(exv_ONE) == \"0100000000000000000000000000000000000000000000000000000000000000\");\n+        ex_vector<unsigned char> exv_other = from_base_blob(uint256S(\n+            \"0123456789abcdef00000000000000000000000000000000fedcba9876543210\"));\n+        BOOST_TEST(HexStr(exv_other) == \"1032547698badcfe00000000000000000000000000000000efcdab8967452301\");\n+    }\n+\n+    {\n+        // Concatenating vectors via `operator||` (producing ex_vectors)\n+        valtype c0{};\n+        valtype c1{\"ABCDEFGH\"_bv};\n+        valtype c2{\"1234\"_bv};\n+\n+        BOOST_TEST(((c0 || c0) == c0));\n+        BOOST_TEST(((c0 || c1) == c1));\n+        BOOST_TEST(((c2 || c0) == c2));\n+        BOOST_TEST(((c1 || c2) == \"ABCDEFGH1234\"_bv));\n+        BOOST_TEST(((c2 || c1) == \"1234ABCDEFGH\"_bv));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(pretty_flags)\n+{\n+    // A small assortment\n+    BOOST_TEST(SCRIPT_VERIFY_P2SH == ParseScriptFlags(\"P2SH\"sv, false));\n+    BOOST_TEST(SCRIPT_VERIFY_SIGPUSHONLY == ParseScriptFlags(\"SIGPUSHONLY\"sv, false));\n+    BOOST_TEST(SCRIPT_VERIFY_TAPROOT == ParseScriptFlags(\"TAPROOT\"sv, false));\n+    BOOST_TEST((SCRIPT_VERIFY_MINIMALIF | SCRIPT_VERIFY_WITNESS) == ParseScriptFlags(\"MINIMALIF,WITNESS\"sv, false));\n+    BOOST_TEST((SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_DERSIG) == ParseScriptFlags(\"TAPROOT,LOW_S,DERSIG\"sv, false));\n+    BOOST_TEST(0 == ParseScriptFlags(\"F00BAR\"sv, false));\n+    BOOST_TEST(0 == ParseScriptFlags(\"witness\"sv, false));        // case-sensitive\n+    BOOST_TEST(0 == ParseScriptFlags(\"P2SH , WITNESS\"sv, false)); // Underlying function \"split\" doesn't trim\n+\n+    BOOST_TEST(\"STRICTENC\"sv == FormatScriptFlags(SCRIPT_VERIFY_STRICTENC));\n+    BOOST_TEST(\"WITNESS_PUBKEYTYPE\"sv == FormatScriptFlags(SCRIPT_VERIFY_WITNESS_PUBKEYTYPE));\n+    BOOST_TEST(\"CONST_SCRIPTCODE,TAPROOT\"sv == FormatScriptFlags(SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_CONST_SCRIPTCODE));\n+    BOOST_TEST(\"CLEANSTACK,NULLDUMMY,NULLFAIL\"sv == FormatScriptFlags(SCRIPT_VERIFY_NULLDUMMY | SCRIPT_VERIFY_CLEANSTACK | SCRIPT_VERIFY_NULLFAIL));\n+    BOOST_TEST(\"\"sv == FormatScriptFlags(0));\n+    BOOST_TEST(\"\"sv == FormatScriptFlags(1U << 30)); // invalid flags just ignored\n+    BOOST_TEST(\"WITNESS\"sv == FormatScriptFlags((1U << 30) | SCRIPT_VERIFY_WITNESS));\n+\n+    // Systematic\n+    auto flag_map = MapFlagNames();\n+    for (auto [name1, value1] : flag_map) {\n+        BOOST_TEST(value1 == ParseScriptFlags(name1));\n+        BOOST_TEST(name1 == FormatScriptFlags(value1));\n+\n+        for (auto [name2, value2] : flag_map) {\n+            if (value1 == value2) continue;\n+            BOOST_TEST((value1 | value2) == ParseScriptFlags(std::string(name1) + \",\" + std::string(name2), false));\n+            BOOST_TEST(std::string(name1 < name2 ? name1 : name2) + \",\" + std::string(name1 < name2 ? name2 : name1) == FormatScriptFlags(value1 | value2));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(pretty_script_errors)\n+{\n+    // A small assortment\n+    BOOST_TEST(\"OK\"sv == FormatScriptError(SCRIPT_ERR_OK, false));\n+    BOOST_TEST(\"UNKNOWN_ERROR\"sv == FormatScriptError(SCRIPT_ERR_UNKNOWN_ERROR, false));\n+    BOOST_TEST(\"\"sv == FormatScriptError(SCRIPT_ERR_ERROR_COUNT, false));\n+\n+    BOOST_TEST(SCRIPT_ERR_OK == ParseScriptError(\"OK\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_SCHNORR_SIG_SIZE == ParseScriptError(\"SCHNORR_SIG_SIZE\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"F00Bar\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"Schnorr_Sig\"sv, false)); // case-sensitive\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"MINIMALIF \"sv, false));  // doesn't trim arg\n+\n+    // Systematic\n+    for (size_t i = 0; i < SCRIPT_ERR_ERROR_COUNT; ++i) {\n+        const auto name = FormatScriptError(static_cast<ScriptError_t>(i));\n+        BOOST_TEST(!name.empty());\n+        BOOST_TEST(i == ParseScriptError(name));\n+    }\n+}\n+\n+#define EVAL(...) []() -> bool { return __VA_ARGS__; }()\n+\n+BOOST_AUTO_TEST_CASE(is_base_of_trait)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917142704",
      "id" : 917142704,
      "line" : 235,
      "node_id" : "PRRC_kwDOABII5842qnyw",
      "original_commit_id" : "12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
      "original_line" : 235,
      "original_position" : 235,
      "original_start_line" : null,
      "path" : "src/test/test_util_tests.cpp",
      "position" : 235,
      "pull_request_review_id" : 1033389106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917142704/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-08T21:37:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917142704",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Partial review done\r\n\r\nAddressing these comments now.\r\n\r\n> \r\n> Code is high quality so far (if not a little complex), and I really like the look of these tests. Will finish review early next week, probably Monday.\r\n\r\nThank you, and looking forward to more comments!\r\n\r\nIs it preferred (i.e., do you prefer) squashing _during_ a review or should I fix things in an additional commit on top of this one while you're in progress and squash it later?",
      "created_at" : "2022-07-11T14:41:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1180497110",
      "id" : 1180497110,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585GXPTW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1180497110/reactions"
      },
      "updated_at" : "2022-07-11T14:41:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1180497110",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Is it preferred (i.e., do you prefer) squashing during a review or should I fix things in an additional commit on top of this one while you're in progress and squash it later?\r\n\r\nTypically squashes are done immediately because if you squash at some point later, all reviewers will have to re-review to ensure that the code hasn't actually changed unexpectedly during the squash.",
      "created_at" : "2022-07-12T13:39:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1181773388",
      "id" : 1181773388,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585GcG5M",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1181773388/reactions"
      },
      "updated_at" : "2022-07-12T13:39:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1181773388",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-08-03T09:24:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1203703815",
      "id" : 1203703815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585HvxAH",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1203703815/reactions"
      },
      "updated_at" : "2022-08-03T09:24:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1203703815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Are you still working on this?",
      "created_at" : "2022-10-12T19:20:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276634618",
      "id" : 1276634618,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585MF-X6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276634618/reactions"
      },
      "updated_at" : "2022-10-12T19:20:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276634618",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "yes sorry - i will update by tomorrow!\n\n\nOn Wed, Oct 12, 2022 at 12:21 PM Andrew Chow ***@***.***>\nwrote:\n\n> Are you still working on this?\n>\n> \n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276634618>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AA7YLBE6IOKK4MJDCZ47JYDWC4FUPANCNFSM5VOZLXLQ>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
      "created_at" : "2022-10-12T20:00:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276671362",
      "id" : 1276671362,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585MGHWC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276671362/reactions"
      },
      "updated_at" : "2022-10-12T20:00:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276671362",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   }
]
