[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26257](https://github.com/bitcoin/bitcoin/pull/26257) (script, test: python linter fixups and updates by jonatack)\n* [#24005](https://github.com/bitcoin/bitcoin/pull/24005) (test: add python implementation of Elligator swift by stratospher)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2022-10-01T19:02:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1264453668",
      "id" : 1264453668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585LXggk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668/reactions"
      },
      "updated_at" : "2023-01-01T16:57:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050"
         }
      },
      "author_association" : "NONE",
      "body" : "I'm curious as to why the return value isnt self - a?\r\nis it because this function calls the previously declared  `__add__ ` and requires a negative input to evaluate properly?\r\nor (-a) is calling the `__mul__`",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:09:48Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050",
      "id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uB7a",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127567653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:15:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45839100?v=4",
         "events_url" : "https://api.github.com/users/amovfx/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amovfx/followers",
         "following_url" : "https://api.github.com/users/amovfx/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amovfx/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amovfx",
         "id" : 45839100,
         "login" : "amovfx",
         "node_id" : "MDQ6VXNlcjQ1ODM5MTAw",
         "organizations_url" : "https://api.github.com/users/amovfx/orgs",
         "received_events_url" : "https://api.github.com/users/amovfx/received_events",
         "repos_url" : "https://api.github.com/users/amovfx/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amovfx/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amovfx/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amovfx"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`self - a` would just trigger infinite recursion, as it's equivalent to `self.__sub__(a)`.\r\n\r\nWriting `self + (-a)` on the other hand is `self.__add__(a.__neg__())`.\r\n\r\nThere is no \"negative input\"; these objects represent field elements (integers modulo 2^256 - 2^32 - 977), which have no concept of positive/negative. This function is implementing how to compute `self - a`; we do that by adding `self` to the negation of `a`.",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:18:22Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867",
      "id" : 985145867,
      "in_reply_to_id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uCIL",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127568198,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:47:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2022-12-13T16:22:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1348977342",
      "id" : 1348977342,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585QZ8K-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342/reactions"
      },
      "updated_at" : "2022-12-13T16:22:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "shouldn't this be `b.num`?",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2022-12-22T09:53:59Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752",
      "id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584-5loo",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i didn't understand how `n = (self.num * self.den) % FE.SIZE`?\r\n(and not `n = int(self) % FE.SIZE`)",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-03T12:01:42Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793",
      "id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_NkNZ",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-03T22:20:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1370283260",
      "id" : 1370283260,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585RrNz8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260/reactions"
      },
      "updated_at" : "2023-01-03T22:20:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed. Fixed!",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:20:28Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160",
      "id" : 1061852160,
      "in_reply_to_id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584_SpQA",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1236432569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:20:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah!\r\n\r\nThe squareness of `num/den` = `(num*den) / den^2` is the same as that of `num*den`, because they're related by a factor `den^2`, which is always square.\r\n\r\nI've added a comment to clarify.",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:21:40Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938",
      "id" : 1061852938,
      "in_reply_to_id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_SpcK",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1236433777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:21:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's a typo I guess?\r\n```suggestion\r\n        raising the argument to the power (p + 1) / 4.\r\n```",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-03-31T13:04:54Z",
      "diff_hunk" : "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161",
      "id" : 1154452161,
      "line" : 113,
      "node_id" : "PRRC_kwDOABII585Ez4rB",
      "original_commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "original_line" : 113,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 173,
      "pull_request_review_id" : 1366903430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-31T13:12:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   }
]
