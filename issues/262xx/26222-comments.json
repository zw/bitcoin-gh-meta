[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1501307590), [stratospher](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1502244056), [achow101](https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1612048492) |\n| Concept ACK | [hebasto](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424459844), [pinheadmz](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424673767), [real-or-random](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1425172202) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27653](https://github.com/bitcoin/bitcoin/pull/27653) (test: add unit test coverage for Python ECDSA implementation by theStack)\n* [#24005](https://github.com/bitcoin/bitcoin/pull/24005) (test: add python implementation of Elligator swift by stratospher)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2022-10-01T19:02:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1264453668",
      "id" : 1264453668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585LXggk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668/reactions"
      },
      "updated_at" : "2023-06-28T20:20:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050"
         }
      },
      "author_association" : "NONE",
      "body" : "I'm curious as to why the return value isnt self - a?\r\nis it because this function calls the previously declared  `__add__ ` and requires a negative input to evaluate properly?\r\nor (-a) is calling the `__mul__`",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:09:48Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050",
      "id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uB7a",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127567653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:15:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45839100?v=4",
         "events_url" : "https://api.github.com/users/amovfx/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amovfx/followers",
         "following_url" : "https://api.github.com/users/amovfx/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amovfx/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amovfx",
         "id" : 45839100,
         "login" : "amovfx",
         "node_id" : "MDQ6VXNlcjQ1ODM5MTAw",
         "organizations_url" : "https://api.github.com/users/amovfx/orgs",
         "received_events_url" : "https://api.github.com/users/amovfx/received_events",
         "repos_url" : "https://api.github.com/users/amovfx/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amovfx/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amovfx/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amovfx"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`self - a` would just trigger infinite recursion, as it's equivalent to `self.__sub__(a)`.\r\n\r\nWriting `self + (-a)` on the other hand is `self.__add__(a.__neg__())`.\r\n\r\nThere is no \"negative input\"; these objects represent field elements (integers modulo 2^256 - 2^32 - 977), which have no concept of positive/negative. This function is implementing how to compute `self - a`; we do that by adding `self` to the negation of `a`.",
      "commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "created_at" : "2022-10-01T21:18:22Z",
      "diff_hunk" : "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867",
      "id" : 985145867,
      "in_reply_to_id" : 985145050,
      "line" : 218,
      "node_id" : "PRRC_kwDOABII5846uCIL",
      "original_commit_id" : "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "original_line" : 218,
      "original_position" : 375,
      "original_start_line" : 214,
      "path" : "test/functional/test_framework/key.py",
      "position" : 375,
      "pull_request_review_id" : 1127568198,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 214,
      "start_side" : "RIGHT",
      "updated_at" : "2022-10-01T21:47:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2022-12-13T16:22:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1348977342",
      "id" : 1348977342,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585QZ8K-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342/reactions"
      },
      "updated_at" : "2022-12-13T16:22:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "shouldn't this be `b.num`?",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2022-12-22T09:53:59Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752",
      "id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584-5loo",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i didn't understand how `n = (self.num * self.den) % FE.SIZE`?\r\n(and not `n = int(self) % FE.SIZE`)",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-03T12:01:42Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793",
      "id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_NkNZ",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1227403349,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T19:57:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-03T22:20:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1370283260",
      "id" : 1370283260,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585RrNz8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260/reactions"
      },
      "updated_at" : "2023-01-03T22:20:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1370283260",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Indeed. Fixed!",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:20:28Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160",
      "id" : 1061852160,
      "in_reply_to_id" : 1055283752,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584_SpQA",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 44,
      "original_position" : 104,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1236432569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:20:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah!\r\n\r\nThe squareness of `num/den` = `(num*den) / den^2` is the same as that of `num*den`, because they're related by a factor `den^2`, which is always square.\r\n\r\nI've added a comment to clarify.",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-01-04T20:21:40Z",
      "diff_hunk" : "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938",
      "id" : 1061852938,
      "in_reply_to_id" : 1060520793,
      "line" : 134,
      "node_id" : "PRRC_kwDOABII584_SpcK",
      "original_commit_id" : "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "original_line" : 134,
      "original_position" : 192,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 194,
      "pull_request_review_id" : 1236433777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-01-04T20:21:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's a typo I guess?\r\n```suggestion\r\n        raising the argument to the power (p + 1) / 4.\r\n```",
      "commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "created_at" : "2023-03-31T13:04:54Z",
      "diff_hunk" : "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161",
      "id" : 1154452161,
      "line" : 113,
      "node_id" : "PRRC_kwDOABII585Ez4rB",
      "original_commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "original_line" : 113,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 173,
      "pull_request_review_id" : 1366903430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-31T13:12:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-04-28T10:44:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1527373023",
      "id" : 1527373023,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585bCdzf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527373023/reactions"
      },
      "updated_at" : "2023-04-28T10:44:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1527373023",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192016465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice catch, fixed.",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T07:35:03Z",
      "diff_hunk" : "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192016465",
      "id" : 1192016465,
      "in_reply_to_id" : 1154452161,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585HDLpR",
      "original_commit_id" : "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "original_line" : 111,
      "original_position" : 173,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1423941466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T07:35:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@theStack I've included your commit to add the precomputed G table. The speedup is significant enough that it's worth it, I think.\r\n\r\nYou've indeed discovered one of the techniques that are used for speeding up EC multiplications with precomputed tables. Libsecp256k1 today uses a more advanced version of that idea, where all multiples of the form `i*16^j*G` for all i=0..15, and j=0..63 are precomputed, leaving us with ~63 point additions. An even more advanced approach is discussed in https://github.com/bitcoin-core/secp256k1/pull/1058, if you're interested. All of that is IMO out of scope for the test framework, though.",
      "created_at" : "2023-05-12T07:39:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545314256",
      "id" : 1545314256,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cG5_Q",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545314256/reactions"
      },
      "updated_at" : "2023-05-12T07:41:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545314256",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "cc @real-or-random ",
      "created_at" : "2023-05-12T08:48:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545399444",
      "id" : 1545399444,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cHOyU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545399444/reactions"
      },
      "updated_at" : "2023-05-12T08:48:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545399444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192479969"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not using hex here?",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T14:53:38Z",
      "diff_hunk" : "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192479969",
      "id" : 1192479969,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585HE8zh",
      "original_commit_id" : "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "original_line" : 328,
      "original_position" : 496,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 495,
      "pull_request_review_id" : 1424673767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T15:57:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2084648?v=4",
         "events_url" : "https://api.github.com/users/pinheadmz/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pinheadmz/followers",
         "following_url" : "https://api.github.com/users/pinheadmz/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pinheadmz/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pinheadmz",
         "id" : 2084648,
         "login" : "pinheadmz",
         "node_id" : "MDQ6VXNlcjIwODQ2NDg=",
         "organizations_url" : "https://api.github.com/users/pinheadmz/orgs",
         "received_events_url" : "https://api.github.com/users/pinheadmz/received_events",
         "repos_url" : "https://api.github.com/users/pinheadmz/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pinheadmz/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pinheadmz/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pinheadmz"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192653577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "it's defined by `FE` as hex, so should be fine?",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-12T17:53:31Z",
      "diff_hunk" : "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192653577",
      "id" : 1192653577,
      "in_reply_to_id" : 1192479969,
      "line" : 328,
      "node_id" : "PRRC_kwDOABII585HFnMJ",
      "original_commit_id" : "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "original_line" : 328,
      "original_position" : 496,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 495,
      "pull_request_review_id" : 1424936684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-12T17:53:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reads fine to me from my not-even-cryptographer-on-tv level of understanding.\r\n\r\nGoes from 27 to 31 seconds on my machine with the precomputed table, which is very easy to understand. Without the table it hikes up to 53 seconds.",
      "created_at" : "2023-05-12T18:15:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546111610",
      "id" : 1546111610,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cJ8p6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546111610/reactions"
      },
      "updated_at" : "2023-05-12T18:15:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546111610",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@real-or-random Makes sense, that simplifies some things too. Done.",
      "created_at" : "2023-05-13T06:35:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546544187",
      "id" : 1546544187,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cLmQ7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546544187/reactions"
      },
      "updated_at" : "2023-05-13T06:35:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546544187",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "outdated comment",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-13T08:34:57Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949389",
      "id" : 1192949389,
      "line" : 179,
      "node_id" : "PRRC_kwDOABII585HGvaN",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 179,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 339,
      "pull_request_review_id" : 1425361344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T08:38:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949775"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This one too. I suggest iterating over the all doc comments, also to make \"group element\" vs \"point\" consistent. (`__repr__` uses group element.)",
      "commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "created_at" : "2023-05-13T08:38:27Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        if self.infinity:\n+            return self\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949775",
      "id" : 1192949775,
      "line" : 207,
      "node_id" : "PRRC_kwDOABII585HGvgP",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 207,
      "original_position" : 367,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : 367,
      "pull_request_review_id" : 1425361344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T08:38:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-13T12:05:04Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972870",
      "id" : 1192972870,
      "in_reply_to_id" : 1192949389,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585HG1JG",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 179,
      "original_position" : 339,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1425384774,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T12:05:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972961"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-13T12:05:39Z",
      "diff_hunk" : "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        if self.infinity:\n+            return self\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972961",
      "id" : 1192972961,
      "in_reply_to_id" : 1192949775,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585HG1Kh",
      "original_commit_id" : "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "original_line" : 207,
      "original_position" : 367,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1425384904,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972961/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-13T12:05:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've made a number of changes.\r\n\r\n* (Done earlier) Made the `GE` class represent infinity explicitly.\r\n* The new classes / code are in a new module `test_framework.secp256k1`, which removes the implementation details from `test_framework.key`, and also feels a bit better namespace-wise (`secp256k1.GE` is probably more informative to an unfamiliar reviewer than just `GE`, at least indicating it has something to do with elliptic curve cryptography).\r\n* Dropped a number of unused functions / operators.\r\n* Swapped the order of arguments in scalar multiplication (it's `int * GE` now instead of `GE * int`).\r\n* Renamed `GE.mmul` to just `GE.mul`, as it can be used for both single or multi-multiplication.\r\n* Shortened/simplified the `FE.__init__` method a bit.\r\n* Some simplifications that may worsen performance slightly, but help readability:\r\n  * `GE.__rmul__` is now written in function of `GE.mul`, avoiding duplication of logic.\r\n  * `GE.double` is gone; to perform doubling, simply add a point to itself.\r\n  * `GE.mul` (and thus also `GE.__rmul__`) now reduces the input scalars mod the curve order, which means it can deal with negative inputs or inputs exceeding the order. This makes the ECDSA and Schnorr verification formula closer to its typical mathematical description.\r\n* Added/rewrote a lot of comments.\r\n\r\nI'm now benchmarking `feature_taproot.py` on a test machine as:\r\n* master: ~42s \r\n* this PR (just first commit): ~79s\r\n* this PR (both commits): ~49s",
      "created_at" : "2023-05-13T12:14:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546636677",
      "id" : 1546636677,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585cL82F",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546636677/reactions"
      },
      "updated_at" : "2023-05-13T12:28:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546636677",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054125"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054125"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "8990668: s/infinite/infinity",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T16:39:12Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054125",
      "id" : 1207054125,
      "line" : 312,
      "node_id" : "PRRC_kwDOABII585H8i8t",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 310,
      "original_position" : 310,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 312,
      "pull_request_review_id" : 1446591335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054125/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054125",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054357"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054357"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "8990668: s/infinite/infinity\r\nmaybe make infinity representation in str and repr consistent too.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T16:39:22Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:\n+            return \"(inf)\"\n+        return f\"({self.x},{self.y})\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation for this group element.\"\"\"\n+        if self.infinite:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054357",
      "id" : 1207054357,
      "line" : 318,
      "node_id" : "PRRC_kwDOABII585H8jAV",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 316,
      "original_position" : 316,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 318,
      "pull_request_review_id" : 1446591335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054357/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054357",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207066672"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207066672"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "8990668: isn't the result updated and not cached here?",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T16:48:51Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207066672",
      "id" : 1207066672,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585H8mAw",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 82,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 82,
      "pull_request_review_id" : 1446591335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207066672/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207066672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207067694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207067694"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "89906684: any particular reason why `v >= FE.SIZE` isn't supported? (have only thought about `ellswift_decode` [scenario](https://github.com/bitcoin/bips/blob/master/bip-0324/ellswift_decode_test_vectors.csv#L77) where v could be greater than `FE.SIZE`)",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T16:49:47Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207067694",
      "id" : 1207067694,
      "line" : 147,
      "node_id" : "PRRC_kwDOABII585H8mQu",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 147,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 147,
      "pull_request_review_id" : 1446591335,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207067694/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207067694",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207264222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207264222"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't understand.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T19:49:50Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207264222",
      "id" : 1207264222,
      "in_reply_to_id" : 1207066672,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585H9WPe",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 82,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 82,
      "pull_request_review_id" : 1446854207,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207264222/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:49:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207264222",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207265123"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207265123"
         }
      },
      "author_association" : "MEMBER",
      "body" : "__repr__ is supposed to produce a string that is valid Python code.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-26T19:50:45Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:\n+            return \"(inf)\"\n+        return f\"({self.x},{self.y})\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation for this group element.\"\"\"\n+        if self.infinite:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207265123",
      "id" : 1207265123,
      "in_reply_to_id" : 1207054357,
      "line" : 318,
      "node_id" : "PRRC_kwDOABII585H9Wdj",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 316,
      "original_position" : 316,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 318,
      "pull_request_review_id" : 1446855011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207265123/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-26T19:50:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207265123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207644980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207644980"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "when defining classes in python, don't we skip parentheses?\r\nusing `class ECPubKey:` and `class ECKey:` instead of `class ECPubKey():` and  `class ECKey():`",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-27T04:04:39Z",
      "diff_hunk" : "@@ -13,268 +13,54 @@\n import random\n import unittest\n \n+from test_framework import secp256k1\n+\n # Point with no known discrete log.\n H_POINT = \"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\"\n \n+# Order of the secp256k1 curve\n+ORDER = secp256k1.GE.ORDER\n \n def TaggedHash(tag, data):\n     ss = hashlib.sha256(tag.encode('utf-8')).digest()\n     ss += ss\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n-    \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n-            return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n-        for i in range(255, -1, -1):\n-            r = self.double(r)\n-            for (p, n) in ps:\n-                if ((n >> i) & 1):\n-                    r = self.add(r, p)\n-        return r\n-\n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n class ECPubKey():",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207644980",
      "id" : 1207644980,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585H-zM0",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 31,
      "original_position" : 224,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1447142151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207644980/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T14:42:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207644980",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207758013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207758013"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I thought of \"The result is cached.\" as:\r\n1.  someone calls `int()`\r\n2.  we do operations inside `int()`, compute what num and den should be and store it locally+lazily without updating actual `self.num`, `self.den` \r\n3.  someone calls another FE function\r\n4.  the newly computed value of `self.num`, `self.den` gets actually updated only here\r\n\r\nisn't this what caching a variable conceptually means? (even though it doesn't matter here where `self.num`, `self.den` gets actually updated) what did you actually mean by cached in this context?",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-27T07:29:26Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207758013",
      "id" : 1207758013,
      "in_reply_to_id" : 1207066672,
      "line" : 82,
      "node_id" : "PRRC_kwDOABII585H_Oy9",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 82,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 82,
      "pull_request_review_id" : 1447142151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207758013/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-27T15:03:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207758013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207999486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207999486"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "never mind, just reviewed key.py and saw how this is being used in `verify_schnorr`, `tweak_add_pubkey`. agree that it's better/simpler to keep it as it is.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-27T14:07:24Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207999486",
      "id" : 1207999486,
      "in_reply_to_id" : 1207067694,
      "line" : 147,
      "node_id" : "PRRC_kwDOABII585IAJv-",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 147,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 147,
      "pull_request_review_id" : 1447142151,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207999486/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-27T15:03:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207999486",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1209080001"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1209080001"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Perhaps the comment should be explicit about the behavior when `v >= FE.SIZE`",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-29T08:42:19Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1209080001",
      "id" : 1209080001,
      "in_reply_to_id" : 1207067694,
      "line" : 147,
      "node_id" : "PRRC_kwDOABII585IERjB",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 147,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 147,
      "pull_request_review_id" : 1449126701,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1209080001/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-29T08:42:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1209080001",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1071625?v=4",
         "events_url" : "https://api.github.com/users/real-or-random/events{/privacy}",
         "followers_url" : "https://api.github.com/users/real-or-random/followers",
         "following_url" : "https://api.github.com/users/real-or-random/following{/other_user}",
         "gists_url" : "https://api.github.com/users/real-or-random/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/real-or-random",
         "id" : 1071625,
         "login" : "real-or-random",
         "node_id" : "MDQ6VXNlcjEwNzE2MjU=",
         "organizations_url" : "https://api.github.com/users/real-or-random/orgs",
         "received_events_url" : "https://api.github.com/users/real-or-random/received_events",
         "repos_url" : "https://api.github.com/users/real-or-random/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/real-or-random/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/real-or-random/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/real-or-random"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1210987152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210987152"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Regarding the goal of simple implementation, is there a strong need to keep the `FE.is_square` method? Right now this is the only call-site, which I think could be replaced by\r\n```suggestion\r\n        return (FE(x)**3 + 7).sqrt() is not None\r\n```\r\nI assume trying to actually square is way slower than computing the Jacobi symbol, but since `is_valid_x` doesn't appear to be in a critical code-path, that's probably fine? At least for `feature_taproot.py` I didn't see a decrease in performance.",
      "commit_id" : "112928c08a18e57f04b63177c578695fa080b3ee",
      "created_at" : "2023-05-31T01:24:31Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1210987152",
      "id" : 1210987152,
      "line" : 308,
      "node_id" : "PRRC_kwDOABII585ILjKQ",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 306,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 308,
      "pull_request_review_id" : 1452064815,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210987152/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T01:24:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210987152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212094169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212094169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "8990668: it would be useful to have radd and rsub back for [these operations in `xswiftec_inv`](https://github.com/bitcoin/bips/blob/master/bip-0324/reference.py#L367-L370).\r\n(to keep #24005 consistent with BIP's reference python implementation for easy review.)",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T17:56:31Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212094169",
      "id" : 1212094169,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII585IPxbZ",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 47,
      "pull_request_review_id" : 1453838769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212094169/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:00:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212094169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212129551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212129551"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I mean that the computation won't be repeated if called a second time (due to self.den being set to 1, which triggers the fast path). Whether that's accomplished through actually remembering the int-converted form or some other mechanism is an implementation detail a user of the class shouldn't need to care about.\r\n\r\nI realize I didn't mark the FE members `num` and `den` as private; I've done so now. Perhaps that helps? The way FE values are represented inside the class is an unobservable implementation detail, so calling `int(FE)` doesn't \"update\" the FE object in any observable way - it just makes future calls more efficient.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:23:20Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212129551",
      "id" : 1212129551,
      "in_reply_to_id" : 1207066672,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585IP6EP",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 90,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 90,
      "pull_request_review_id" : 1453892963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212129551/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:43:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212129551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163089"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess we should; the parentheses are for listing parent classes, but I believe that an empty list or no parentheses at all don't make a difference.\r\n\r\nFixed.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:49:33Z",
      "diff_hunk" : "@@ -13,268 +13,54 @@\n import random\n import unittest\n \n+from test_framework import secp256k1\n+\n # Point with no known discrete log.\n H_POINT = \"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\"\n \n+# Order of the secp256k1 curve\n+ORDER = secp256k1.GE.ORDER\n \n def TaggedHash(tag, data):\n     ss = hashlib.sha256(tag.encode('utf-8')).digest()\n     ss += ss\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n-    \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n-            return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n-        for i in range(255, -1, -1):\n-            r = self.double(r)\n-            for (p, n) in ps:\n-                if ((n >> i) & 1):\n-                    r = self.add(r, p)\n-        return r\n-\n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n class ECPubKey():",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163089",
      "id" : 1212163089,
      "in_reply_to_id" : 1207644980,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585IQCQR",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 31,
      "original_position" : 224,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/key.py",
      "position" : null,
      "pull_request_review_id" : 1453933035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163089/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:52:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163658"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163658"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, I added back.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:49:53Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163658",
      "id" : 1212163658,
      "in_reply_to_id" : 1212094169,
      "line" : 47,
      "node_id" : "PRRC_kwDOABII585IQCZK",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 47,
      "pull_request_review_id" : 1453933035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163658/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:52:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163658",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212164841"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212164841"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a `\"no overflow allowed\"` to the comment.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:50:37Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212164841",
      "id" : 1212164841,
      "in_reply_to_id" : 1207067694,
      "line" : 139,
      "node_id" : "PRRC_kwDOABII585IQCrp",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 139,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 139,
      "pull_request_review_id" : 1453933035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212164841/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:52:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212164841",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212166978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212166978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've kept the `FE.is_square()` function, but replaced it with just a `x.sqrt() is not None` plus a comment that a more efficient algorithm is possible.\r\n\r\nThis leaves the option of easily adding a more efficient implementation back later if really worth it.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:51:19Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212166978",
      "id" : 1212166978,
      "in_reply_to_id" : 1210987152,
      "line" : 300,
      "node_id" : "PRRC_kwDOABII585IQDNC",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 300,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 300,
      "pull_request_review_id" : 1453933035,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 3,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 3,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212166978/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:52:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212166978",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212172722"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212172722"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-05-31T18:54:25Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212172722",
      "id" : 1212172722,
      "in_reply_to_id" : 1207054125,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585IQEmy",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 310,
      "original_position" : 310,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : null,
      "pull_request_review_id" : 1453946859,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212172722/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-05-31T18:54:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212172722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Addressed review comments. I've also renamed `FE.num` and `FE.den` to `FE._num` and `FE._den` to mark them as private (to the extent that Python allows that). All interactions with these objects should be done through their methods.",
      "created_at" : "2023-05-31T18:55:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1570755789",
      "id" : 1570755789,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585dn9TN",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1570755789/reactions"
      },
      "updated_at" : "2023-05-31T18:55:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1570755789",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212736489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212736489"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ee6e289:\r\n```suggestion\r\n    def __rsub__(self, a):\r\n```",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-06-01T07:46:48Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a._num\n+            den = a._den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b._num) % FE.SIZE\n+            num = (num * b._den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self._num = num\n+        self._den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den + self._den * a._num, self._den * a._den)\n+        return FE(self._num + self._den * a, self._den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(a) + self\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den - self._den * a._num, self._den * a._den)\n+        return FE(self._num - self._den * a, self._den)\n+\n+    def __rsub(self, a):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212736489",
      "id" : 1212736489,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585ISOPp",
      "original_commit_id" : "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : null,
      "pull_request_review_id" : 1454810878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212736489/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-01T10:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212736489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212950016"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212950016"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> The way FE values are represented inside the class is an unobservable implementation detail, so calling int(FE) doesn't \"update\" the FE object in any observable way - it just makes future calls more efficient.\r\n\r\nthinking of it this way makes sense. thanks!",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-06-01T10:32:49Z",
      "diff_hunk" : "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212950016",
      "id" : 1212950016,
      "in_reply_to_id" : 1207066672,
      "line" : 90,
      "node_id" : "PRRC_kwDOABII585ITCYA",
      "original_commit_id" : "899066847359a8f16aded60814794fab9ea884e1",
      "original_line" : 90,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 90,
      "pull_request_review_id" : 1454810878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212950016/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-01T10:33:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212950016",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1234198187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1234198187"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "ping @sipa, can you address this open suggestion from @stratospher for fixing the reverse subtraction operator overload (`s/__rsub/__rsub__/`). With that in, I think I'm pretty close then to ACK the PR.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-06-19T15:18:25Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a._num\n+            den = a._den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b._num) % FE.SIZE\n+            num = (num * b._den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self._num = num\n+        self._den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den + self._den * a._num, self._den * a._den)\n+        return FE(self._num + self._den * a, self._den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(a) + self\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den - self._den * a._num, self._den * a._den)\n+        return FE(self._num - self._den * a, self._den)\n+\n+    def __rsub(self, a):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1234198187",
      "id" : 1234198187,
      "in_reply_to_id" : 1212736489,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585JkF6r",
      "original_commit_id" : "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : null,
      "pull_request_review_id" : 1486453398,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1234198187/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-19T15:18:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1234198187",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1235629994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235629994"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-06-20T18:03:16Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a._num\n+            den = a._den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b._num) % FE.SIZE\n+            num = (num * b._den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self._num = num\n+        self._den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den + self._den * a._num, self._den * a._den)\n+        return FE(self._num + self._den * a, self._den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(a) + self\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den - self._den * a._num, self._den * a._den)\n+        return FE(self._num - self._den * a, self._den)\n+\n+    def __rsub(self, a):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1235629994",
      "id" : 1235629994,
      "in_reply_to_id" : 1212736489,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Jpjeq",
      "original_commit_id" : "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : null,
      "pull_request_review_id" : 1488719849,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235629994/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-20T18:03:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235629994",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1235947681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235947681"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: like `from_bytes_xonly` does, could throw an assertion error here if the size of the passed encoding is invalid (if a test writer e.g. accidentally passes an x-only-pubkey to `from_bytes`, getting an assertion is likely more helpful than only getting `None`):\r\n```suggestion\r\n        assert len(b) in (33, 65)\r\n        if len(b) == 33:\r\n```\r\n(or alternatively, add an `else:` branch below with `assert False, \"size must be 33 or 65\"` or something alike)",
      "commit_id" : "ab30e81b3bb9e9b02ca1ac835eef04efdf87b4e1",
      "created_at" : "2023-06-20T22:07:51Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a._num\n+            den = a._den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b._num) % FE.SIZE\n+            num = (num * b._den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self._num = num\n+        self._den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den + self._den * a._num, self._den * a._den)\n+        return FE(self._num + self._den * a, self._den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(a) + self\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den - self._den * a._num, self._den * a._den)\n+        return FE(self._num - self._den * a, self._den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference of an integer and a field element.\"\"\"\n+        return FE(a) - self\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._num, self._den * a._den)\n+        return FE(self._num * a, self._den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(a) * self\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self._num, a, FE.SIZE), pow(self._den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self._num, self._den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self._den != 1:\n+            self._num = (self._num * pow(self._den, -1, FE.SIZE)) % FE.SIZE\n+            self._den = 1\n+        return self._num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # A more efficient algorithm is possible here (Jacobi symbol).\n+        return self.sqrt() is not None\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self._num * a._den - self._den * a._num) % FE.SIZE == 0\n+        return (self._num - self._den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (BE byte order).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (BE byte order, no overflow allowed).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1235947681",
      "id" : 1235947681,
      "line" : 267,
      "node_id" : "PRRC_kwDOABII585JqxCh",
      "original_commit_id" : "9b8650d23034b59c8c19a38cedc13bb550359c76",
      "original_line" : 265,
      "original_position" : 265,
      "original_start_line" : null,
      "path" : "test/functional/test_framework/secp256k1.py",
      "position" : 267,
      "pull_request_review_id" : 1489179801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235947681/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-06-20T22:20:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1235947681",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK d4fb58ae8ae9772d025ead184ef8f2c0ea50df3e\r\n\r\nMuch simpler to understand, and the more complicated stuff matches up with the descriptions in WIkipedia.",
      "created_at" : "2023-06-28T20:20:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1612048492",
      "id" : 1612048492,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
      "node_id" : "IC_kwDOABII585gFehs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1612048492/reactions"
      },
      "updated_at" : "2023-06-28T20:20:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1612048492",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
