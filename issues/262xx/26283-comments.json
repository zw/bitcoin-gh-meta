[
   {
      "author_association" : "MEMBER",
      "body" : "Marking this draft until:\r\n1. ~~[Previous PR is merged](https://github.com/bitcoin/bitcoin/pull/23443)~~ [Follow-up is merged](https://github.com/bitcoin/bitcoin/pull/26359)\r\n2. There is one in-code TODO I have to resolve (it is minor, but it has to be improved)\r\n3. I add unit and functional tests for these features.\r\n\r\nAnother task is to sync [parent PR](https://github.com/bitcoin/bitcoin/pull/21515) with this version. I have a local branch that compiles, but tests of the full Erlay there needs a little care. If you want to see how this PR works in the broader context, the parent should be good enough to get it. Otherwise, I intend to update it soon.",
      "created_at" : "2022-10-08T07:33:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272254249",
      "id" : 1272254249,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585L1Q8p",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249/reactions"
      },
      "updated_at" : "2022-10-28T09:07:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26359](https://github.com/bitcoin/bitcoin/pull/26359) (p2p: Erlay support signaling follow-ups by naumenkogs)\n* [#26140](https://github.com/bitcoin/bitcoin/pull/26140) (refactor: Move CNodeState members guarded by g_msgproc_mutex to Peer by dergoegge)\n* [#25572](https://github.com/bitcoin/bitcoin/pull/25572) (refactor: Introduce EvictionManager and use it for the inbound eviction logic by dergoegge)\n* [#25268](https://github.com/bitcoin/bitcoin/pull/25268) (refactor: Introduce EvictionManager by dergoegge)\n* [#24125](https://github.com/bitcoin/bitcoin/pull/24125) (p2p: Replace RecursiveMutex `m_tx_inventory_mutex` with Mutex and rename it by w0xlt)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2022-10-08T16:15:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272351013",
      "id" : 1272351013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585L1okl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013/reactions"
      },
      "updated_at" : "2022-11-30T12:36:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/reocnciliation set/reconciliation set/g",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:17:12Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613",
      "id" : 998568613,
      "line" : 5744,
      "node_id" : "PRRC_kwDOABII5847hPKl",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5744,
      "original_position" : 297,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 297,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be `<=` as `MAX_PEER_TX_ANNOUNCEMENTS` should be the maximum number of elements/transactions we announce to our peers. Note, while only strictly inferior transaction requests are considered L1409 in `net_processing.cpp`, this is different for the processing of `NOTFOUND`, L4793, still in `net_processing.cpp`.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:41:23Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937",
      "id" : 998588937,
      "line" : 5781,
      "node_id" : "PRRC_kwDOABII5847hUIJ",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5781,
      "original_position" : 334,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 334,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be called `IsAlreadyInPeerSet` or something more speaking than transaction is already in peer local set but not announced yet. ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:52:19Z",
      "diff_hunk" : "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n+\n+    /**\n+     * Returns the size of the reconciliation set we have locally for the given peer.\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    size_t GetPeerSetSize(NodeId peer_id) const;\n+\n+    /**\n+     * Attempts to forget txreconciliation-related state of the peer (if we previously stored any).\n+     * After this, we won't be able to reconcile transactions with the peer.\n+     */\n+    void ForgetPeer(NodeId peer_id);\n+\n+    /**\n+     * Check if a peer is registered to reconcile transactions with us.\n+     */\n+    bool IsPeerRegistered(NodeId peer_id) const;\n+\n+    /**\n+     * Returns whether for the given call the peer is chosen as a low-fanout destination.\n+     */\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n+\n+    /**\n+     * Check whether a particular transaction is being currently reconciled with a given peer.\n+     */\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182",
      "id" : 998598182,
      "line" : 125,
      "node_id" : "PRRC_kwDOABII5847hWYm",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 125,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note, current inv-based transaction announcement (L5812) isn't gated on IBD being over though I agree it makes sense to save bandwidth as the node is unlikely to be able to validate most of the transactions received for inaccuracy of its local UTXO set. ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:07:34Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903",
      "id" : 998610903,
      "line" : 5839,
      "node_id" : "PRRC_kwDOABII5847hZfX",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5839,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 366,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/if a it's time/if it's time/g",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:10:45Z",
      "diff_hunk" : "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472",
      "id" : 998613472,
      "line" : 91,
      "node_id" : "PRRC_kwDOABII5847haHg",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 91,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`reconciliation_request_data` could be called `reconciliation_request_parameters` to dissociate clearly we're sending reconciliation config info and not the set itself.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:18:32Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId())) {\n+                    auto reconciliation_request_data = m_txreconciliation->MaybeRequestReconciliation(pto->GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645",
      "id" : 998619645,
      "line" : 5841,
      "node_id" : "PRRC_kwDOABII5847hbn9",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5841,
      "original_position" : 368,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 368,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure what you aimed to achieve here with the `std::max` between `INBOUND_INVENTORY_BROADCAST_INTERVAL` and `INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON` as the former is always superior to the latter. Maybe could be rather a `static_assert` to enforce the order at compilation time in case of future changes.  ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:29:51Z",
      "diff_hunk" : "@@ -143,17 +146,22 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL{2s};\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{1s};\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND *\n+    count_seconds(std::max(INBOUND_INVENTORY_BROADCAST_INTERVAL, INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718",
      "id" : 998628718,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII5847hd1u",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 164,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 41,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you can develop the comment here why \"we need to make faster\" or point towards another code comment or BIP section where it's explained.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:31:04Z",
      "diff_hunk" : "@@ -5488,12 +5589,35 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 LOCK(tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n+                const bool supports_recon = m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId());\n+\n                 if (tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        tx_relay->m_next_inv_send_time = NextInvToInbounds(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        if (supports_recon) {\n+                            // Use shorter intervals for reconciliation peers because we use\n+                            // low-fanout, and 1) we need to make faster; 2) we won't get much",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668",
      "id" : 998629668,
      "line" : 5599,
      "node_id" : "PRRC_kwDOABII5847heEk",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5599,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 217,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could add comment if the rational behind those values selection is specified in the BIP, paper or other research.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:36:25Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914",
      "id" : 998633914,
      "line" : 25,
      "node_id" : "PRRC_kwDOABII5847hfG6",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 25,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 25,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Curious, what we care about a low transaction relay latency ? Like I would say lower latency makes it a) harder to observe original transaction broadcast by deanonymization attacker b) disincentive transaction issuers front-running the standard tx-relay rules to place their transactions first in the mempools in case of congestion and c) for instant/0confs flows improve UX, do we have more properties ?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:44:50Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600",
      "id" : 998640600,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII5847hgvY",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 36,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"which are unlikely to game this timer in a serious way\", though is there a timeout in the rest of the patchset to evict lazy/buggy outbound peers which would stuck the reconciliation, making us stale on `Phase::INIT_REQUESTED` and which would prevent `MaybeRequestReconciliation()` to move forward due to the check L258 ?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T20:00:37Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688",
      "id" : 998653688,
      "line" : 136,
      "node_id" : "PRRC_kwDOABII5847hj74",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 136,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f\r\n```suggestion\r\n                    if (!txs_to_reconcile.empty()) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:36:31Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672",
      "id" : 1005384672,
      "line" : 5827,
      "node_id" : "PRRC_kwDOABII58477PPg",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5827,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 354,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195"
         }
      },
      "author_association" : "MEMBER",
      "body" : "5070c97459282346cdcff7af08914c702462fe0d\r\n```suggestion\r\nenum class Phase {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:36:58Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195",
      "id" : 1005385195,
      "line" : 43,
      "node_id" : "PRRC_kwDOABII58477PXr",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 43,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "7cffb4cc0211b0494a7563d9a80a67633fa61255\r\n```suggestion\r\n                const auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:38:01Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331",
      "id" : 1005386331,
      "line" : 139,
      "node_id" : "PRRC_kwDOABII58477Ppb",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 139,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        if (!m_queue.empty()) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:38:49Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197",
      "id" : 1005387197,
      "line" : 249,
      "node_id" : "PRRC_kwDOABII58477P29",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 249,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n    bool ShouldFloodTo(const uint256& wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:39:49Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347",
      "id" : 1005388347,
      "line" : 305,
      "node_id" : "PRRC_kwDOABII58477QI7",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 305,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 305,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n                const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:40:23Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029",
      "id" : 1005389029,
      "line" : 320,
      "node_id" : "PRRC_kwDOABII58477QTl",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 320,
      "original_position" : 320,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 320,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n            [&eligible_peers, we_initiate](auto indexed_state) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:41:20Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951",
      "id" : 1005389951,
      "line" : 319,
      "node_id" : "PRRC_kwDOABII58477Qh_",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 319,
      "original_position" : 319,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 319,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f: there are other instances where wtxid is not passed by ref\r\n```suggestion\r\n    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:41:50Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+            }\n+        );\n+\n+        // TODO: there should be a cleaner way to do this.\n+        size_t flood_index_modulo;\n+        if (we_initiate) {\n+            flood_index_modulo = 1.0 / OUTBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        } else {\n+            flood_index_modulo = 1.0 / INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        assert(it != eligible_peers.end());\n+\n+        const size_t peer_index = it - eligible_peers.begin();\n+        return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n+    }\n+\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504",
      "id" : 1005390504,
      "line" : 340,
      "node_id" : "PRRC_kwDOABII58477Qqo",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 340,
      "original_position" : 340,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 340,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        assert(!they_initiate || !we_initiate));\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T09:02:41Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595",
      "id" : 1005414595,
      "line" : 195,
      "node_id" : "PRRC_kwDOABII58477WjD",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 126,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 100,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        if (!they_initiate && !we_initiate) return PROTOCOL_VIOLATION;\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T09:03:01Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156",
      "id" : 1005415156,
      "line" : 198,
      "node_id" : "PRRC_kwDOABII58477Wr0",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 129,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 103,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Applied `<=`, but I don't get the second sentence :(",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T09:26:34Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316",
      "id" : 1013791316,
      "in_reply_to_id" : 998588937,
      "line" : 5781,
      "node_id" : "PRRC_kwDOABII5848bTpU",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5781,
      "original_position" : 334,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 334,
      "pull_request_review_id" : 1168195546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T09:26:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I thought it's kinda obvious for 0conf experience, yes. Not even accepting payment, but at least seeing it in the network... Not sure what to include in the codebase.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T10:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477",
      "id" : 1013848477,
      "in_reply_to_id" : 998640600,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII5848bhmd",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 36,
      "pull_request_review_id" : 1168276941,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T10:26:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think `Phase::INIT_REQUESTED` is somehow related to being stuck... if one peer stays in that state, it doesn't prevent us from requesting recon from other peers. Only will delay by `m_next_recon_request` once?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T10:29:12Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then its\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793",
      "id" : 1013850793,
      "in_reply_to_id" : 998653688,
      "line" : 136,
      "node_id" : "PRRC_kwDOABII5848biKp",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 136,
      "pull_request_review_id" : 1168280370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T10:29:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure it's any better",
      "commit_id" : "4c3bf8f43148b46bf55a09ed53d47dc7aa69441b",
      "created_at" : "2022-11-04T12:46:02Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776",
      "id" : 1013981776,
      "in_reply_to_id" : 1005414595,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5848cCJQ",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 126,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1168466518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T12:46:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-04T16:29:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1303841621",
      "id" : 1303841621,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585NtwtV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1303841621/reactions"
      },
      "updated_at" : "2022-11-04T16:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1303841621",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Using PRNGs is usually discouraged, is this safe here?",
      "commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "created_at" : "2022-11-11T12:48:21Z",
      "diff_hunk" : "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507",
      "id" : 1020190507,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII5848zt8r",
      "original_commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "original_line" : 358,
      "original_position" : 341,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 341,
      "pull_request_review_id" : 1177296531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-11T12:51:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think so since txidHasher is salted, the peer would have no control of it, and thus can't exploit this rand. But I'll keep this comment in case someone has an objection, just in case.",
      "commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "created_at" : "2022-11-11T13:08:41Z",
      "diff_hunk" : "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771",
      "id" : 1020204771,
      "in_reply_to_id" : 1020190507,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII5848zxbj",
      "original_commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "original_line" : 358,
      "original_position" : 341,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 341,
      "pull_request_review_id" : 1177318100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-11T13:08:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\n This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-30T12:05:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1332047452",
      "id" : 1332047452,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585PZW5c",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1332047452/reactions"
      },
      "updated_at" : "2022-11-30T12:05:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1332047452",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036137603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will lock `m_txreconciliation_mutex` inside `IsPeerRegistered()`, check the state, and unlock again. On the next line we will then lock it again, and get a reference to the actual state. I don't think that's what we want:\r\n\r\n* It doesn't guarantee that the state didn't change in between the unlocking in `IsPeerRegistered` and getting the state two lines below, so the assertion doesn't actually prevent race conditions.\r\n* It's inefficient to lock and unlock twice.\r\n\r\nYou should check the `TxReconciliationState` within the same critical section as using it (perhaps by making `IsPeerRegistered` require `m_txreconciliation_mutex` being held?).",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:45:13Z",
      "diff_hunk" : "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036137603",
      "id" : 1036137603,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wjSD",
      "original_commit_id" : "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "original_line" : 139,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036138757"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same thing here: check the state within the same critical section as using it.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:46:15Z",
      "diff_hunk" : "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036138757",
      "id" : 1036138757,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wjkF",
      "original_commit_id" : "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "original_line" : 157,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036140210"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Shorter: `added += recon_state.m_local_set.insert(wtxid).second;`.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:47:27Z",
      "diff_hunk" : "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036140210",
      "id" : 1036140210,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wj6y",
      "original_commit_id" : "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "original_line" : 145,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036141026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Style nit (feel free to ignore, it's not in the style guide, but I don't think we use anything like this anywhere): space before `:`.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:48:05Z",
      "diff_hunk" : "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036141026",
      "id" : 1036141026,
      "line" : 217,
      "node_id" : "PRRC_kwDOABII5849wkHi",
      "original_commit_id" : "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "original_line" : 217,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 134,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036143555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You should really use our own PRNG (`FastRandomContext`), not the standard library built-in one which has no guarantees about its quality or performance. If you really can't use FastRandomContext for some reason, use C++ RNG functions, not C ones (`rand()` is not thread-safe, in addition to possibly being poor quality).",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:50:07Z",
      "diff_hunk" : "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036143555",
      "id" : 1036143555,
      "in_reply_to_id" : 1020190507,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wkvD",
      "original_commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "original_line" : 360,
      "original_position" : 341,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:58:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036145460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This creates a copy of the `TxReconciliationState`. Sure you don't want to get a reference here?",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:51:40Z",
      "diff_hunk" : "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036145460",
      "id" : 1036145460,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wlM0",
      "original_commit_id" : "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "original_line" : 207,
      "original_position" : 53,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036146412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Style: `m_txid_hasher`.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:52:15Z",
      "diff_hunk" : "@@ -72,6 +86,12 @@ class TxReconciliationTracker::Impl\n private:\n     mutable Mutex m_txreconciliation_mutex;\n \n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036146412",
      "id" : 1036146412,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wlbs",
      "original_commit_id" : "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "original_line" : 93,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036149162"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No need for `floor()` here. Casting a floating-point type to integer type will automatically round down.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-11-30T15:54:20Z",
      "diff_hunk" : "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036149162",
      "id" : 1036149162,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5849wmGq",
      "original_commit_id" : "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "original_line" : 235,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1199573032,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T15:56:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038334384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The comment could be descriptive of actually what is contains and which protocol phase it's triggering (as other p2p messages coments). From the BIP:  \"The reqrecon message initiates a reconciliation round\" ",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T16:49:28Z",
      "diff_hunk" : "@@ -264,6 +264,11 @@ extern const char* WTXIDRELAY;\n  * txreconciliation, as described by BIP 330.\n  */\n extern const char* SENDTXRCNCL;\n+/**\n+ * Contains a 4-byte local reconciliation set size and 4-byte q-coefficient.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038334384",
      "id" : 1038334384,
      "line" : 268,
      "node_id" : "PRRC_kwDOABII584947mw",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 268,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/protocol.h",
      "position" : 5,
      "pull_request_review_id" : 1202785461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T18:54:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038404614"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you can use the same wording than the BIP here \"The initiator of the P2P connection assumes the role of reconciliation initiator\" otherwise it's obscure how the initiator/responder overlaps with connection direction.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T18:17:56Z",
      "diff_hunk" : "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038404614",
      "id" : 1038404614,
      "line" : 314,
      "node_id" : "PRRC_kwDOABII58495MwG",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 314,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 234,
      "pull_request_review_id" : 1202785461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T18:54:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038421101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Have you considered to enforce policy checks like feefilter at `REQTXRCNCL` sending instead of at reconciliation set fulfilling in INV sending ?\r\n\r\nDue to `RECON_REQUEST_INTERVAL`, I think some transactions could become stalled, wasting bandwidth in case of fast-paced mempool congestion change (not to exclude when we see few transactions issuers on the network provoking spikes by themselves). Though if correct, more likely a marginal performance improvement better left for follow-up. ",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T18:33:42Z",
      "diff_hunk" : "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038421101",
      "id" : 1038421101,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII58495Qxt",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 94,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 58,
      "pull_request_review_id" : 1202785461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T18:54:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038424477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can update this logger and few other to `BCLog::TXRECONCILIATION`",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T18:38:27Z",
      "diff_hunk" : "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038424477",
      "id" : 1038424477,
      "line" : 221,
      "node_id" : "PRRC_kwDOABII58495Rmd",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 221,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 138,
      "pull_request_review_id" : 1202785461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T18:54:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038465392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If adding is logged, maybe also log removal similarly?",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T19:34:22Z",
      "diff_hunk" : "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038465392",
      "id" : 1038465392,
      "line" : 232,
      "node_id" : "PRRC_kwDOABII58495blw",
      "original_commit_id" : "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "original_line" : 159,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 43,
      "pull_request_review_id" : 1202979648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T23:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038564473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Using `==` to compare floating-point numbers seems not ideal due to precision issues, but it seems like we can never hit the return here anyway since we assert that `eligible_peers.size() > 0` above, so maybe the entire line could be deleted or be an assert?",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T21:42:31Z",
      "diff_hunk" : "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038564473",
      "id" : 1038564473,
      "line" : 337,
      "node_id" : "PRRC_kwDOABII58495zx5",
      "original_commit_id" : "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "original_line" : 236,
      "original_position" : 78,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 78,
      "pull_request_review_id" : 1202979648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T23:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038589117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "since you later use `insecure_rand.randrange`, \"no randomness\" seems a bit misleading.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T22:05:42Z",
      "diff_hunk" : "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038589117",
      "id" : 1038589117,
      "line" : 347,
      "node_id" : "PRRC_kwDOABII584955y9",
      "original_commit_id" : "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "original_line" : 246,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 88,
      "pull_request_review_id" : 1202979648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T23:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038591870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: wtxid",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T22:09:57Z",
      "diff_hunk" : "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038591870",
      "id" : 1038591870,
      "line" : 349,
      "node_id" : "PRRC_kwDOABII584956d-",
      "original_commit_id" : "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "original_line" : 248,
      "original_position" : 90,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 90,
      "pull_request_review_id" : 1202979648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T23:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038600759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think I understand this algorithm yet. Say we have 20 inbound peers (0...19), as in the example. What if the starting point is 19 because of the hash of the wtxid? Then we'd only flood the tx to peer 19, but not to peer 0 (because the algorithm doesn't wrap around) - so we'd flood it to 1 target out of 20, not meeting the goal of flooding to 2.4 targets even ignoring the fraction - is that intended?",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-02T22:29:22Z",
      "diff_hunk" : "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038600759",
      "id" : 1038600759,
      "line" : 345,
      "node_id" : "PRRC_kwDOABII584958o3",
      "original_commit_id" : "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "original_line" : 244,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 86,
      "pull_request_review_id" : 1202979648,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-02T23:48:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039262264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment was outdated, i think it's not needed here at all... deleting for now.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-05T07:55:53Z",
      "diff_hunk" : "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039262264",
      "id" : 1039262264,
      "in_reply_to_id" : 1038404614,
      "line" : 314,
      "node_id" : "PRRC_kwDOABII58498eI4",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 314,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 234,
      "pull_request_review_id" : 1204047515,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-05T07:55:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039265857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This would largely complicate the code I think.... Policy check stuff should be moved out of `net_processing.cpp`.\r\nYeah, I see your concern (although I tested Erlay in mainnet and it was ok), let's see if other reviewers think it's needed now.",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-05T08:00:28Z",
      "diff_hunk" : "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039265857",
      "id" : 1039265857,
      "in_reply_to_id" : 1038421101,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII58498fBB",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 94,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 58,
      "pull_request_review_id" : 1204052484,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-05T08:00:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039272601"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The removal is currently per-tx (not batched), so it would make the logs really annoying... Which raises another question: should I refactor it to make it batched where possible (on hearing INV batch from the given peer)?",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-05T08:09:50Z",
      "diff_hunk" : "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039272601",
      "id" : 1039272601,
      "in_reply_to_id" : 1038465392,
      "line" : 232,
      "node_id" : "PRRC_kwDOABII58498gqZ",
      "original_commit_id" : "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "original_line" : 159,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 43,
      "pull_request_review_id" : 1204063482,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-05T08:09:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039308165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You are right, it is broken. At least it was documented well enough you found the issue :)\r\n",
      "commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "created_at" : "2022-12-05T08:47:43Z",
      "diff_hunk" : "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039308165",
      "id" : 1039308165,
      "in_reply_to_id" : 1038600759,
      "line" : 345,
      "node_id" : "PRRC_kwDOABII58498pWF",
      "original_commit_id" : "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "original_line" : 244,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 86,
      "pull_request_review_id" : 1204115844,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-05T08:47:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041146278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I would suggest not to have an assert here. Generally (imo) we should only add asserts when crashing the node is better than continuing. In this case simply adding a `if(!IsPeerRegistered()) return;` is better than crashing if the user of the API makes a mistake. You would be treating non-existence of the peer the same as the peer having an empty set (i.e. nothing is removed as it didn't exist in the first place).\r\n\r\nAdditionally, the way you are using this API right now is not generally safe.\r\n```c++\r\nif (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId())) {\r\n    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\r\n}\r\n```\r\n\r\nThe peer could be de-registered from the tracker in between the `IsPeerRegistered` and `TryRemovingFromSet` calls causing the node to crash for no good reason. This is only safe right now because `cs_main` is held here as well as when a peer is forgotten from the tracker. Since the tracker has its own mutex it should not rely on another mutex such as `cs_main`.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T15:48:37Z",
      "diff_hunk" : "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041146278",
      "id" : 1041146278,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII584-DqGm",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 230,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 147,
      "pull_request_review_id" : 1206848088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T16:17:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041165539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it would make sense to move this block to its own function. This entire block for the tx announcement logic in SendMessages is already quite big.\r\n\r\nMaybe this can even move to the tracker?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T16:04:46Z",
      "diff_hunk" : "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041165539",
      "id" : 1041165539,
      "line" : 5725,
      "node_id" : "PRRC_kwDOABII584-Duzj",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 5725,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 120,
      "pull_request_review_id" : 1206848088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T16:17:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041171241"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same thing here about the assert.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T16:09:35Z",
      "diff_hunk" : "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041171241",
      "id" : 1041171241,
      "line" : 213,
      "node_id" : "PRRC_kwDOABII584-DwMp",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 213,
      "original_position" : 130,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 130,
      "pull_request_review_id" : 1206848088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T16:17:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041434849"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "One more conceptual question for the flooding algorithm:\r\nDoesn't this still leak internal order by flooding preferentially to adjacent nodes in `eligible_peers` if `flood_targets > 1`?\r\n\r\nWould it be a simpler alternative to have a deterministic randomizer that takes the wtxid, and then pick `flood_targets` random peers (and pick a last one only with an appropiate probability if `flood_targets` is not an integer), in the same way that way `PeerManagerImpl::RelayAddress()` picks 2 peers for addr relay? (but without the 24h reset happening there)",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T20:38:07Z",
      "diff_hunk" : "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041434849",
      "id" : 1041434849,
      "line" : 344,
      "node_id" : "PRRC_kwDOABII584-Ewjh",
      "original_commit_id" : "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "original_line" : 243,
      "original_position" : 84,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 84,
      "pull_request_review_id" : 1207285454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T23:44:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041516794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Trying to understand commit 869c6824235ff2af09d24b13cfab9a6cabd52b00: \"It's possible that a parent will be scheduled to relay same time as child, but a child arrives earlier. \"\r\nIs this only possible with reconciliation? The previous commit tries to make sure that the child is also scheduled for recon, if the parent was - so can it only happen in the case where the recon set is at max capacity?\r\n\r\nAlso, since now twice as many entries will be saved in `m_recently_announced_invs`, does it need a larger capacity?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T22:16:45Z",
      "diff_hunk" : "@@ -5678,7 +5678,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041516794",
      "id" : 1041516794,
      "line" : 5720,
      "node_id" : "PRRC_kwDOABII584-FEj6",
      "original_commit_id" : "869c6824235ff2af09d24b13cfab9a6cabd52b00",
      "original_line" : 5684,
      "original_position" : 8,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 8,
      "pull_request_review_id" : 1207285454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T23:44:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041544419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Commit 9f64cfe63e3b833e0f9faf17004cf51c4c925aec:\r\n\"Note that for privacy reasons the ratio between inbound and outbound\r\ndelays matter much more than the actual delays. That ratio is preserved\r\nhere, so it is not a privacy degradation.\"\r\nThe ratio is not exactly preserved, the old one was 5s/2s, now it's 2s/1s.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T22:45:45Z",
      "diff_hunk" : "@@ -147,12 +147,29 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is chosen according the following\n+ *  considerations:\n+ *  1. Reconciliation. When the transaction is reconciled, this delay is applied to adding to\n+ *     reconciliation sets, not actual reconciliation (less frequent). That should happen rather\n+ *     fast, so that sets are in sync and reconciliation is efficient. At the same time, not too\n+ *     fast to avoid privacy leaks (e.g., infer connections via set probing).\n+ *  2. Low-fanout. In rare cases when the reconciling peer is chosen for low-fanout\n+ *     flooding, it will apply to the actual broadcast. Then, regular trickle considerations apply,\n+ *     but since this is a rare occasion, the following risks are much lower:\n+ *     2a) announcing both ways simultaneously (inefficiency);\n+ *     2b) inference based on the announced transactions (privacy leak).\n+ *     That's why it's ok to make this delay low as well, and lower delay is generally good to\n+ *     facilitate good transaction relay speed when slow reconciliations prevail. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041544419",
      "id" : 1041544419,
      "line" : 165,
      "node_id" : "PRRC_kwDOABII584-FLTj",
      "original_commit_id" : "9f64cfe63e3b833e0f9faf17004cf51c4c925aec",
      "original_line" : 165,
      "original_position" : 20,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 20,
      "pull_request_review_id" : 1207285454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T23:44:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041586275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it might be possible for a peer to abuse this logic and prevent us from reconciling with other peers: If an attacker sends a `SENDTXRCNCL` but stalls the `VERACK`, they would be registered and added to `m_queue` - but `SendMessages()` will never get to the part where `REQTXRCNCL` is sent for this peer because we abort early [here](https://github.com/bitcoin/bitcoin/blob/0596aa40f77a630d8a21035856fa5fd6838b292e/src/net_processing.cpp#L5367) before hanshake completion. Therefore, once that peer is in the front of the queue, it won't get cleared and prevents us from reconciling with other peers while connected (up to `DEFAULT_PEER_CONNECT_TIMEOUT = 60` seconds).",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-06T23:40:07Z",
      "diff_hunk" : "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041586275",
      "id" : 1041586275,
      "line" : 250,
      "node_id" : "PRRC_kwDOABII584-FVhj",
      "original_commit_id" : "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "original_line" : 250,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 56,
      "pull_request_review_id" : 1207285454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-06T23:44:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042310934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934"
         }
      },
      "author_association" : "MEMBER",
      "body" : "To clarify, we're considering the scenario in which our peer's fee filter changes between adding tx to `txs_to_reconcile` and sending the `inv` after reconciliation? Given that `RECON_REQUEST_INTERVAL` is 8sec and `AVG_FEEFILTER_BROADCAST_INTERVAL` is 10min, I don't think this is too much of a concern (at least for this PR)?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T14:58:09Z",
      "diff_hunk" : "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042310934",
      "id" : 1042310934,
      "in_reply_to_id" : 1038421101,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII584-IGcW",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 94,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 58,
      "pull_request_review_id" : 1208575387,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T14:58:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042366525"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, though it wouldn't make sense to have txreconciliation module depend on mempool. Would probably recommend grabbing the txiter ahead of time and passing in the parent wtxids.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T15:39:47Z",
      "diff_hunk" : "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042366525",
      "id" : 1042366525,
      "in_reply_to_id" : 1041165539,
      "line" : 5725,
      "node_id" : "PRRC_kwDOABII584-IUA9",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 5725,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 120,
      "pull_request_review_id" : 1208638733,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042385456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456"
         }
      },
      "author_association" : "MEMBER",
      "body" : "in ffbb2b814e82284c7c77c5a5b23058cbc7c0149c:\r\n\r\nBased on this, is the \"The requirements to this algorithm is the following: 1. Every transaction should be assigned to *some* peer.\" a hard requirement? If so, it seems the logic in f0685a1781 net_processing if recon parent -> recon child seems to break this, since you might have chosen just 1 peer to flood the child to, but then switch to recon because you're reconing the parent with that peer. It doesn't seem like `ShouldFloodTo` uses any state about whether we've chosen other peers for flooding, so we might end up not flooding the tx to anybody? Am I missing something / is this okay?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T15:54:24Z",
      "diff_hunk" : "@@ -17,6 +19,41 @@ namespace {\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n \n+/**\n+ * Announce transactions via full wtxid to a limited number of inbound and outbound peers.\n+ * Justification for these values are provided here:\n+ * https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-902165806 */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS = 1;\n+/**\n+ * If there's a chance a transaction is not streamlined along the first couple hops, it would take\n+ *  very long to relay.\n+ */\n+static_assert(OUTBOUND_FANOUT_DESTINATIONS >= 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042385456",
      "id" : 1042385456,
      "line" : 32,
      "node_id" : "PRRC_kwDOABII584-IYow",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 32,
      "original_position" : 25,
      "original_start_line" : 29,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 25,
      "pull_request_review_id" : 1208638733,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 29,
      "start_side" : "RIGHT",
      "updated_at" : "2022-12-07T16:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042412529"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529"
         }
      },
      "author_association" : "MEMBER",
      "body" : "IIUC with this PR we'll request reconciliation with each other but since no `NetMsgType::REQTXRCNCL` handling is added, we ignore the request. That's fine, but should we also have the logic for falling back to flooding the wtxids in the reconciliation set when it gets full / after a timeout?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T16:16:45Z",
      "diff_hunk" : "@@ -5703,11 +5835,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload() && m_txreconciliation) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042412529",
      "id" : 1042412529,
      "line" : 5851,
      "node_id" : "PRRC_kwDOABII584-IfPx",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 5851,
      "original_position" : 220,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 220,
      "pull_request_review_id" : 1208638733,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:31:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It would be useful if this returned the number of added wtxids.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T16:17:17Z",
      "diff_hunk" : "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413082",
      "id" : 1042413082,
      "line" : 84,
      "node_id" : "PRRC_kwDOABII584-IfYa",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 84,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 9,
      "pull_request_review_id" : 1208726536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:28:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413751"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It would be useful if this returned whether or not the wtxid was removed.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T16:17:50Z",
      "diff_hunk" : "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413751",
      "id" : 1042413751,
      "line" : 91,
      "node_id" : "PRRC_kwDOABII584-Ifi3",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 91,
      "original_position" : 16,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 16,
      "pull_request_review_id" : 1208726536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:28:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042417507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\r\n```suggestion\r\n    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id, std::chrono::microsecond now);\r\n```\r\n\r\nPassing in the time here would be nice for testing. \r\n* We only have one global mock time currently (globals are always a bit annoying when writing unit/fuzz tests, as you have to reset state after each test)\r\n* The current global mock time is only accurate in intervals of seconds",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T16:21:06Z",
      "diff_hunk" : "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042417507",
      "id" : 1042417507,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII584-Igdj",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 101,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 26,
      "pull_request_review_id" : 1208726536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:28:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042420561"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Adding to this:\r\n\r\nAfaict it's impossible for our fuzzers to exercise this code at the moment. Encapsulating this logic within the TxReconciliationTracker would make that possible.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T16:23:45Z",
      "diff_hunk" : "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042420561",
      "id" : 1042420561,
      "in_reply_to_id" : 1041165539,
      "line" : 5725,
      "node_id" : "PRRC_kwDOABII584-IhNR",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 5725,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 120,
      "pull_request_review_id" : 1208726536,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T16:28:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This throws a `std::bad_variant_access` for peers that aren't fully registered yet (found by the fuzzer).\r\n\r\nMaybe create an internal helper method that only iterates through all fully registered peers/states to avoid this entirely?",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-07T17:02:17Z",
      "diff_hunk" : "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                  \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406",
      "id" : 1042464406,
      "line" : 320,
      "node_id" : "PRRC_kwDOABII584-Ir6W",
      "original_commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "original_line" : 320,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 240,
      "pull_request_review_id" : 1208800680,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-07T17:02:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8077169?v=4",
         "events_url" : "https://api.github.com/users/dergoegge/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dergoegge/followers",
         "following_url" : "https://api.github.com/users/dergoegge/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dergoegge/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dergoegge",
         "id" : 8077169,
         "login" : "dergoegge",
         "node_id" : "MDQ6VXNlcjgwNzcxNjk=",
         "organizations_url" : "https://api.github.com/users/dergoegge/orgs",
         "received_events_url" : "https://api.github.com/users/dergoegge/received_events",
         "repos_url" : "https://api.github.com/users/dergoegge/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dergoegge/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dergoegge/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dergoegge"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044199932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I thought this could happen even without explicit fee filter changes, but rather the following:\r\n1. A transaction marginally passed the given fee filter.\r\n2. In 8 seconds when it's time to send, it doesn't pass the filter, but is sent anyway.",
      "commit_id" : "e480bed66158971493c2af51a72acaec582e8f01",
      "created_at" : "2022-12-09T08:26:21Z",
      "diff_hunk" : "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044199932",
      "id" : 1044199932,
      "in_reply_to_id" : 1038421101,
      "line" : 94,
      "node_id" : "PRRC_kwDOABII584-PTn8",
      "original_commit_id" : "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "original_line" : 94,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 58,
      "pull_request_review_id" : 1211290010,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-12-09T08:26:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   }
]
