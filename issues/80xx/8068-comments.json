[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r63647803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/63647803"
         }
      },
      "body" : "clang warns about `lsb` and `msb` used uninitialized.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-05-18T05:41:59Z",
      "diff_hunk" : "@@ -0,0 +1,202 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        size_t indexes_size = indexes.size();\n+        READWRITE(VARINT(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min(1000 + indexes.size(), indexes_size));\n+                for (; i < indexes.size(); i++)\n+                    READWRITE(VARINT(indexes[i]));\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint32_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(VARINT(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        size_t txn_size = txn.size();\n+        READWRITE(VARINT(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min(1000 + txn.size(), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(VARINT(index));\n+        READWRITE(REF(TransactionCompressor(tx)));\n+    }\n+};\n+\n+typedef enum ReadStatus_t\n+{\n+    READ_STATUS_OK,\n+    READ_STATUS_INVALID, // Invalid object, peer is sending bogus crap\n+    READ_STATUS_FAILED, // Failed to process object\n+} ReadStatus;\n+\n+class CBlockHeaderAndShortTxIDs {\n+private:\n+    mutable uint64_t shorttxidk0, shorttxidk1;\n+    uint64_t nonce;\n+\n+    void FillShortTxIDSelector() const;\n+\n+    friend class PartiallyDownloadedBlock;\n+\n+    static const int SHORTTXIDS_LENGTH = 6;\n+protected:\n+    std::vector<uint64_t> shorttxids;\n+    std::vector<PrefilledTransaction> prefilledtxn;\n+\n+public:\n+    CBlockHeader header;\n+\n+    // Dummy for deserialization\n+    CBlockHeaderAndShortTxIDs() {}\n+\n+    CBlockHeaderAndShortTxIDs(const CBlock& block);\n+\n+    uint64_t GetShortID(const uint256& txhash) const;\n+\n+    size_t BlockTxCount() const { return shorttxids.size() + prefilledtxn.size(); }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(header);\n+        READWRITE(nonce);\n+\n+        size_t shorttxids_size = shorttxids.size();\n+        READWRITE(VARINT(shorttxids_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (shorttxids.size() < shorttxids_size) {\n+                shorttxids.resize(std::min(1000 + shorttxids.size(), shorttxids_size));\n+                for (; i < shorttxids.size(); i++) {\n+                    uint32_t lsb; uint16_t msb;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r63647803",
      "id" : 63647803,
      "original_commit_id" : "816956e8dae6c122dfde63a46ea110cca187b836",
      "original_position" : 152,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/63647803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "`test/test_bitcoin` failures in travis are strange. Can't reproduce locally. Hmm, we should probably include `src/test-suite.log` in the travis output in such cases.\r\n\r\n... just a second after I wrote this, I see this failure in my logs:\r\n\r\n```\r\nRunning 200 test cases...\r\ntest/net_tests.cpp:92: error in \"caddrdb_read\": check addrman1.size() == 3 failed\r\ntest/net_tests.cpp:102: error in \"caddrdb_read\": check addrman2.size() == 3 failed\r\n\r\n*** 2 failures detected in test suite \"Bitcoin Test Suite\"\r\n```\r\n\r\nI will compare many runs in master and this PR:\r\n\r\n```\r\nmaster: 8 failures\r\n8068: 6 failures\r\n```\r\n\r\nAs this is present in master already, it is not caused by this PR. I'll investigate...\r\n\r\nThe question is, if the travis failure in `test_bitcoin` is the same I see here...\r\n\r\nLooks like the same problem was already reported by me: https://github.com/bitcoin/bitcoin/pull/7696#issuecomment-197200010\r\n\r\nSeparate issue now: #8069\r\n",
      "created_at" : "2016-05-18T05:52:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219931715",
      "id" : 219931715,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T07:36:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/219931715",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Needs rebase to remove the siphash commits from the top. :)",
      "created_at" : "2016-05-18T09:47:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219977952",
      "id" : 219977952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T09:47:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/219977952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Rebased and fixed @paveljanik's clang compile-warning.",
      "created_at" : "2016-05-18T20:23:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146640",
      "id" : 220146640,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T20:23:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220146640",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Also removed the varint stuff...turns out it wasnt as big a gain as I thought.",
      "created_at" : "2016-05-18T20:23:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146749",
      "id" : 220146749,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T20:23:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220146749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2016-05-19T01:43:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220206517",
      "id" : 220206517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-19T01:43:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220206517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "Thinking more about this (and seeing more pull requests touching the mempool), I think having the mempool store its CTransaction objects using shared_ptr's would make sense.\r\n\r\n* During erasing from the mempool, we return the deleted entries upwards (for signalling to wallets etc). This requires expensive copying that could be avoided with shared_ptr (alternatively, see #8099)\r\n* During transaction relay, BIP35 processing, and tx getdata, we fetch mempool transactions (copying them!) before determining whether they can be relayed. Especially with filters active, this is a pretty expensive operation for omitted cases. As none of the things done with the result (filtering, inving, serializing) require a full copy, shared_ptr would be far more efficient.\n* mapRelay often contains transactions that are also stored in the mempool. Shared_ptr's would alleviate duplicate storage space.\r\n* In this PR, it would avoid the need for manual reference counting and for giving the CTxMempool the weird responsibility for owning transactions that aren't even in the mempool anymore.\r\n",
      "created_at" : "2016-05-26T13:00:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-221863723",
      "id" : 221863723,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-28T17:22:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221863723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Will test that during next week, I need to use it for one of my project",
      "created_at" : "2016-05-29T00:59:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222336764",
      "id" : 222336764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-29T00:59:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222336764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "This should update the implemented BIPs list.",
      "created_at" : "2016-05-30T16:06:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222521282",
      "id" : 222521282,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-30T16:06:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222521282",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Here is a rebase on top of #8126, using shared_ptr's for partial block transactions: https://github.com/sipa/bitcoin/commits/compactblocks",
      "created_at" : "2016-06-01T01:35:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222869545",
      "id" : 222869545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T13:10:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222869545",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Ok, some comments after looking through the code and working to rebase:\r\n* `CBlockHeaderAndShortTxIDs::FillShortTxIDSelector` should use `htole64` before serializing the nonce (endianness correctness)\r\n* `PartiallyDownloadedBlock::InitData`'s `have_txn` can use a `vector<bool>` (which is bitpacked internally) instead of manual bit logic (nit)\r\n* The code in `ProcessMessage` to add a peer as a direct compact block request peer is duplicated.\r\n* A lot of calls to `error()` that should be LogPrintf's or nothing at all.",
      "created_at" : "2016-06-01T13:27:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222991558",
      "id" : 222991558,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T13:27:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222991558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "It would be nice if the getpeerinfo showed the sendcmpct status (maybe hex for the version?).",
      "created_at" : "2016-06-01T17:16:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223062347",
      "id" : 223062347,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T17:16:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223062347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "> (maybe hex for the version?)\r\n\r\nHow to display numbers is a client-side thing, and I'm not sure it makes sense to bloat up bitcoin-cli with this kind of logic?",
      "created_at" : "2016-06-01T17:39:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223068790",
      "id" : 223068790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T17:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223068790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "> (maybe hex for the version?)\r\n\r\nWorth nothing this issue has [come up before](https://github.com/bitcoin/bitcoin/pull/7774) and was added as `versionHex`.",
      "created_at" : "2016-06-02T02:58:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223183123",
      "id" : 223183123,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-02T02:59:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223183123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65798257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65798257"
         }
      },
      "body" : "No need for taking lock on pool->cs ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T06:19:04Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65798257",
      "id" : 65798257,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65798257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799356"
         }
      },
      "body" : "If you intend to do it later, it's better removing it from the PR. Just for curiosity, if it is later included, the goal will be to use sendcmpct's version to decide the type of serialization of the transactions ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T08:08:15Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799356",
      "id" : 65799356,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799753"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799753"
         }
      },
      "body" : "`fAnnounceUsingCMPCTBLOCK` is the way with which the remote node prefer to receive block notifications.\r\n\r\nIt gives no information about whether the remote node itself provide or not header and IDs.\r\nImho it should be fixed to:\r\n\r\n`State(pfrom->GetId())->fProvidesHeaderAndIDs = pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION && pfrom->nServices & NODE_NETWORK;`\r\n\r\nMoved when we the node receive the VERSION message.\r\n\r\nBecause even if fAnnounceUsingCMPCTBLOCK is `false` (low bandwidth relaying case), the node still provide header and ids.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T08:47:46Z",
      "diff_hunk" : "@@ -4789,6 +4836,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::SENDCMPCT)\n+    {\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        if (nCMPCTBLOCKVersion == 1) {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fProvidesHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799753",
      "id" : 65799753,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 156,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65802242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65802242"
         }
      },
      "body" : "nit: constant would be nice, 3 is reused on https://github.com/bitcoin/bitcoin/pull/8068/files#diff-7ec3c68a81efff79b6ca22ac1f1eabbaR5499\r\n\r\nActually I think that this whole code about unsubscribing from CMPCTBLOCK of other node and registering to this node is duplicated below.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T12:56:50Z",
      "diff_hunk" : "@@ -4835,10 +4894,39 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                        vToFetch.push_back(inv);\n+                        if (nodestate->fProvidesHeaderAndIDs)\n+                            vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n+                        else\n+                            vToFetch.push_back(inv);\n                         // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n                         // later (within the same cs_main lock, though).\n                         MarkBlockAsInFlight(pfrom->GetId(), inv.hash, chainparams.GetConsensus());\n+                        if (mapBlocksInFlight.size() <= 2) {\n+                            // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n+                            // with this block! Let's get them to announce using compact blocks in the future.\n+                            if (nodestate->fProvidesHeaderAndIDs) {\n+                                bool fAlreadyAnnouncing = false;\n+                                BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n+                                    if (nodeid == pfrom->GetId())\n+                                        fAlreadyAnnouncing = true;\n+                                if (!fAlreadyAnnouncing) {\n+                                    bool fAnnounceUsingCMPCTBLOCK = false;\n+                                    uint64_t nCMPCTBLOCKVersion = 1;\n+                                    if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65802242",
      "id" : 65802242,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 187,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65802242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65803246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65803246"
         }
      },
      "body" : "typo: indicies",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T14:32:29Z",
      "diff_hunk" : "@@ -4930,6 +5018,35 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::GETBLOCKTXN)\n+    {\n+        BlockTransactionsRequest req;\n+        vRecv >> req;\n+\n+        BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n+        if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n+            Misbehaving(pfrom->GetId(), 100);\n+            return error(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+        }\n+\n+        if (it->second->nHeight < chainActive.Height() - 10)\n+            return error(\"Peer %d sent us a getblocktxn for a block > 10 deep\", pfrom->id);\n+\n+        CBlock block;\n+        assert(ReadBlockFromDisk(block, it->second, chainparams.GetConsensus()));\n+\n+        BlockTransactions resp(req);\n+        for (size_t i = 0; i < req.indexes.size(); i++) {\n+            if (req.indexes[i] >= block.vtx.size()) {\n+                Misbehaving(pfrom->GetId(), 100);\n+                return error(\"Peer %d sent us a getblocktxn with out-of-bounds tx indicies\", pfrom->id);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65803246",
      "id" : 65803246,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 230,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65803246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "@TheBlueMatt when you continue this you should probably continue from Pieter's rebase.",
      "created_at" : "2016-06-04T17:48:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223768784",
      "id" : 223768784,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-04T17:48:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223768784",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848221"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848221"
         }
      },
      "body" : "Not sure what you're asking? There is no explicit lock on cs here, but ReleaseTxLock does LOCK(cs) itself.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T07:45:33Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848221",
      "id" : 65848221,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848221",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848308"
         }
      },
      "body" : "Yes, use the version field in cmpctblock is the upgrade mechanism here.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T07:46:09Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848308",
      "id" : 65848308,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848308",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65850726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65850726"
         }
      },
      "body" : "Yup, they were just inverted, fixed.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T08:07:05Z",
      "diff_hunk" : "@@ -4789,6 +4836,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::SENDCMPCT)\n+    {\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        if (nCMPCTBLOCKVersion == 1) {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fProvidesHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65850726",
      "id" : 65850726,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 156,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65850726",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Rebased on latest master (Pieter's is an insignificant change here, I'll just rebase when it gets merged), and addressed all the comments I saw above, though I didnt add cmpctblock status to getpeerinfo since its already there (in the form of message size info) and I dont want to be bikeshedded for getpeerinfo api....\r\n\r\nNote for LogPrints in network processing, I tried to use the rule \"LogPrint(\"net\" in general, but LogPrintf( if you're gonna set a DoS score, since it always irritates me when I see nodes getting DoS scores and nothing to tell me why in debug.log.",
      "created_at" : "2016-06-06T08:18:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223895608",
      "id" : 223895608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-06T08:18:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223895608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "From Travis:\r\n\r\n```\r\nEXCEPTION: St12out_of_range       \r\nCInv::GetCommand(): type=4 unknown type       \r\nbitcoin in ProcessMessages()\r\n```",
      "created_at" : "2016-06-06T12:00:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223939085",
      "id" : 223939085,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-06T12:00:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223939085",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65925840"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925840"
         }
      },
      "body" : "ok, it responds to my question thanks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T16:50:42Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65925840",
      "id" : 65925840,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925840",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66210588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66210588"
         }
      },
      "body" : "nit: You can early return here instead of using a boolean.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:18:30Z",
      "diff_hunk" : "@@ -432,6 +460,31 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom) {\n+    if (nodestate->fProvidesHeaderAndIDs) {\n+        bool fAlreadyAnnouncing = false;\n+        BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n+            if (nodeid == pfrom->GetId())\n+                fAlreadyAnnouncing = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66210588",
      "id" : 66210588,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 103,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66210588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66212626"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66212626"
         }
      },
      "body" : "Are locks recursive ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:32:00Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66212626",
      "id" : 66212626,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 366,
      "path" : "src/main.cpp",
      "position" : 421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66212626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66213351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66213351"
         }
      },
      "body" : "nit: typo rquset, also should add a space after '//'",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:35:39Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66213351",
      "id" : 66213351,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 380,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66213351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66219767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66219767"
         }
      },
      "body" : "nit: typo \"didnt\" and \"Its\"",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T09:11:28Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);\n+        if (status == READ_STATUS_INVALID) {\n+            Misbehaving(pfrom->GetId(), 100);\n+            LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\", pfrom->id);\n+            return true;\n+        } else if (status == READ_STATUS_FAILED) {\n+            // Might have collided, fall back to getdata now :(\n+            std::vector<CInv> invs;\n+            invs.push_back(CInv(MSG_BLOCK, resp.blockhash));\n+            pfrom->PushMessage(NetMsgType::GETDATA, invs);\n+        } else {\n+            CValidationState state;\n+            ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                if (state.CorruptionPossible()) {\n+                    // Its possible there was a collision we didnt detect...request the block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66219767",
      "id" : 66219767,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 403,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66219767",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "Code Review ACK (except small nits about typo and one question about recursive lock, as you are calling ProcessMessage recursively)\r\n\r\nI'll compile and test it myself. (my tests will be in C# though)",
      "created_at" : "2016-06-08T09:14:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224533796",
      "id" : 224533796,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-08T09:14:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224533796",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66226140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66226140"
         }
      },
      "body" : "Yes. Otherwise we'd have ~infinity deadlocks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T09:52:14Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66226140",
      "id" : 66226140,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 366,
      "path" : "src/main.cpp",
      "position" : 421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66226140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Rebased. Had to throw in a fix for CheckBlockHeader requiring context instead of using ContextualCheckBlockHeader so that blockencodings.cpp was insane to fix a bug (though it still is...who's idea was it to have a flag in CBlock about a block being checked by a function in main?)",
      "created_at" : "2016-06-09T00:07:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224767800",
      "id" : 224767800,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-09T00:07:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224767800",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "To clarify: the bug was that the merkle root check would result in a DoS ban, but could happen due to conflicting short IDs. The solution was to check merkle root in blockencodings.cpp to keep all the \"maybe-short-id-collision\" checks in one place. In order to avoid checking the merkle tree twice (which is incredibly expensive), I had to call CheckBlock, which required three #includes (including main.h) to blockencodings.cpp, despite them being really unrelated.",
      "created_at" : "2016-06-09T01:50:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224781229",
      "id" : 224781229,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-09T01:50:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224781229",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66508975"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66508975"
         }
      },
      "body" : "Won't this put us in an infinite loop if our peer has a broken implementation?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-09T19:47:10Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66508975",
      "id" : 66508975,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66508975",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Some thoughts on the overall design and implementation. I think points 1, ~~2~~, and 7 are the most immediate.\r\n\r\n1. Can I suggest adding code to disable this mode when you have a max block size (and hence number of transactions) that makes the failure rate untenable? Or code that expands the number of bits used in the hash to keep mean-time-to-failure constant.\r\n2.  ~~Perhaps having sendcmpct have more than two modes (perhaps a bytes worth) would be a good design choice for future expansion of more compact modes.~~ I missed the version number, should be sufficient.\r\n3.  I would also like to see some analysis of the benefit of siphash compared to truncated sha256 for this use case -- it's just performance, right? It may be good perhaps to have an option to fall back to this case.\r\n4.  I am also slightly skeptical of the need for a per individual salt. It may be sufficient to have a global salt that changes, say, every hour. This would result in less hashing of the mempool without much increase in adversarial ability as well as the ability to precompute the short ids. Although siphash seems to be cheap so perhaps this is overkill, but reducing the latency at time of receipt is a worthwhile goal maybe. Perhaps a good waypoint is to pre-receive a nonce from all peers and upon getting an inv in low bandwidth mode, one begins hashing the mempool.\r\n5. On BlockTransactionsRequest, (if and only if it is common to be missing a lot of transactions) I would advise a bitfield which indicates more than half missing and then \"inverts\" the differential encoding. This keeps the cost of sending slightly smaller when many are missing. \r\n6. Prefilledtxn should, I believe, be delivered as a separate struct to HeaderAndShortIDs. This allows for processing to begin while potentially a lot of data is delivered.\r\n7. If node B receives from A a block and requests transactions {1,2,3}, then B should relay to node C in prefilledtxn {1,2,3} as well as C is likely to not have those txns.",
      "created_at" : "2016-06-09T21:43:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225035887",
      "id" : 225035887,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-09T22:42:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225035887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66535697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66535697"
         }
      },
      "body" : "Yes, but do we care? I'm not sure how to fix this without adding a bunch more per-node state, but I'm sure there are other infinite loops somewhere in the protocol if people are broken in the right way. ",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-09T22:48:14Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66535697",
      "id" : 66535697,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66535697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "> Can I suggest adding code to disable this mode when you have a max block size (and hence number of transactions) that makes the failure rate untenable? Or code that expands the number of bits used in the hash to keep mean-time-to-failure constant.\r\n\r\nThis is already designed targeting several times the maximum size permitted in the protocol. Also the size of the block does not weigh that strongly in the result (mempool size dominates), and the implementation deals fairly gracefully with small numbers of collisions.\r\n\r\n> Perhaps having sendcmpct have more than two modes (perhaps a bytes worth) would be a good design choice for future expansion of more compact modes. \r\n\r\nThe protocol is versioned, any change would need to be a new version, so I don't see what extra states would do there.\r\n\r\n> I would also like to see some analysis of the benefit of siphash compared to truncated sha256 for this use case\r\n\r\nIt's 27 times faster in a performance important path. Siphash was an upgrade from using an even simpler function previously.\r\n\r\n> I am also slightly skeptical of the need for a per individual salt. It may be sufficient to have a global salt that changes, say, every hour. This would result in less hashing of the mempool without much increase in adversarial ability as well as the ability to precompute the short ids. Although siphash seems to be cheap so perhaps this is overkill, but reducing the latency at time of receipt is a worthwhile goal maybe. Perhaps a good waypoint is to pre-receive a nonce from all peers and upon getting an inv in low bandwidth mode, one begins hashing the mempool.\r\n\r\nA global salt would provide absolutely no protection against the collision attack. The value must be unpredictable to an attacker and cannot be precomputed.   There should be no total reduction in hashing the mempool- it's just once per received block.  Avoiding latency is important but time taken for siphash a maxed out mempool on a single 3GHz core is 0.17ms, this is insubstantial compared to the rest of block processing.\r\n\r\n> On BlockTransactionsRequest, (if and only if it is common to be missing a lot of transactions) I would advise a bitfield which indicates more than half missing and then \"inverts\" the differential encoding. This keeps the cost of sending slightly smaller when many are missing. \r\n\r\nI originally implemented that, in fact. But low hitrates are unobservably rare after the initial start... spending a byte to signal it is a net loss.. plus the code is more complex.  It's also the case that low hitrate data is naturally smaller because all the differences will be very small.\r\n\r\n> Prefilledtxn should, I believe, be delivered as a separate struct to HeaderAndShortIDs. This allows for processing to begin while potentially a lot of data is delivered.\r\n\r\nThat is an interesting point however, the coinbase txn is always required; so doing exactly that would not improve anything.  \r\n\r\nIgnoring the coinbase implementation would be rather complex: ... if you complete the decode and the prefilled haven't arrived yet, do you wait? how long? or do you just gettxn potentially redundantly with the transactions in flight? if you wait and time out do you ban the peer when it doesn't respond or?  Basically when thinking about implementation complexity you should think about the complexity being exponential with the number of communication states you might have with a peer. :)\r\n\r\n> If node B receives from A a block and requests transactions {1,2,3}, then B should relay to node C in prefilledtxn {1,2,3} as well as C is likely to not have those txns.\r\n\r\nI've tested this and it works great. The recommendations in BIP152 were based precisely on doing this. It's not included in this PR to minimize the scope as it doesn't change the protocol and can be added any point. (there are further refinements you can do, like leaving out txn that a target peer has INVed to you, even if you didn't know them)\r\n",
      "created_at" : "2016-06-09T23:10:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225053543",
      "id" : 225053543,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-09T23:10:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225053543",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66549905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66549905"
         }
      },
      "body" : "Well my guess is that this isn't a theoretical problem, but an actual one -- I just started grepping the debug logs on one of my nodes, and I'm seeing roughly 1 message/day of the form \"ERROR: AcceptBlockHeader: prev block not found\".  I didn't check in depth, but I believe that corresponds to the condition that the handling of getheaders messages is broken, which would mean the infinite loop behavior would be triggered.\r\n\r\nNot obvious to me what the best solution is.  We could add more per-node state, perhaps a single `bool fBadHeadersImplementation` that is set to false whenever a valid headers message is processed from a peer, and when processing a headers message that doesn't connect, set it to true and request more headers, unless it's already true, in which case we give up?  But I haven't tried to implement so not sure how tricky this would be...",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T01:31:05Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66549905",
      "id" : 66549905,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66549905",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66619669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66619669"
         }
      },
      "body" : "What is the reasoning for uint16 here? Local space savings? ( I know this practically isn't a big deal due to realistic near future blocksizes but still)",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T14:14:52Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;\n+                }\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(COMPACTSIZE(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t txn_size = (uint64_t)txn.size();\n+        READWRITE(COMPACTSIZE(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        uint64_t idx = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66619669",
      "id" : 66619669,
      "original_commit_id" : "27d56369d58ab8d46c18e9267c2df5a03062a801",
      "original_position" : 105,
      "path" : "src/blockencodings.h",
      "position" : 113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66619669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66661338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66661338"
         }
      },
      "body" : "Can't we just apply a small ban score each time?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:37:03Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66661338",
      "id" : 66661338,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66661338",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66662351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66662351"
         }
      },
      "body" : "Though it doesn't have to be done now,  it would be good to simply mark both txn that collide in the compact block as missing instead of immediately falling back.  I've been testing in this way, and finding that even with 16-bit short IDs a super-majority of blocks are successfully reconstructed with only a relatively small number of gettxn. ",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:43:47Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66662351",
      "id" : 66662351,
      "original_commit_id" : "c270f63c318e6588aa2f8e3d7cd556d156924781",
      "original_position" : 85,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66662351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663232"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663232"
         }
      },
      "body" : "Dunno, easier to be careful about using the \"right\" types so that any assumptions you might make later about range of a value dont blow up in your face...probably no real reason for this, but...it just is",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:49:39Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;\n+                }\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(COMPACTSIZE(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t txn_size = (uint64_t)txn.size();\n+        READWRITE(COMPACTSIZE(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        uint64_t idx = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663232",
      "id" : 66663232,
      "original_commit_id" : "27d56369d58ab8d46c18e9267c2df5a03062a801",
      "original_position" : 105,
      "path" : "src/blockencodings.h",
      "position" : 113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663232",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663860"
         }
      },
      "body" : "Well the point of this was also to ensure that peers can enable us to do headers-sync without them needing to keep lots of state about where our blockchain is. The fact that headers messages /must/ connect seems rather insane to me from a protocol-design perspective (also because its not written that way in the BIP). \r\n\r\nWithin that context, the only state you could add to fix this is to try to track when a headers message was a response to a getheaders like the above, where we expect that it must connect or the peer is actually violating the spec.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:54:06Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663860",
      "id" : 66663860,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663860",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66664155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66664155"
         }
      },
      "body" : "Added a //TODO note so that someone who goes through and cleans up all the optimizations later can track them.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:55:59Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66664155",
      "id" : 66664155,
      "original_commit_id" : "c270f63c318e6588aa2f8e3d7cd556d156924781",
      "original_position" : 85,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66664155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "> This is already designed targeting several times the maximum size permitted in the protocol. Also the size of the block does not weigh that strongly in the result (mempool size dominates), and the implementation deals fairly gracefully with small numbers of collisions.\r\n\r\nYes, mempool size should dominate. This seems like a completely-other issue. Mining nodes who keep large mempools will run into large collision frequencies and this will be less useful.\r\n\r\nThis is furthermore troubling because the size used in the bip (m=100000 txns or m*225 bytes not including overhead) is around 22 megabytes whereas the defaults in policy.h seems to be 300 mb of mempool, unless I'm mistaken. Adding a factor of 10 txns to m puts the bits above 48. 56 bits allows for up to 20 gigabytes or so, which seems more appropriate. Although it may make the most sense to have peers communicate to each other how full their mempools are and set hash length based on that.\r\n\r\n\r\n> The protocol is versioned, any change would need to be a new version, so I don't see what extra states would do there.\r\n\r\n \r\nyup I struck that one out before you replied :) \r\n\r\n> It's 27 times faster in a performance important path. Siphash was an upgrade from using an even simpler function previously.\r\n\r\n> A global salt would provide absolutely no protection against the collision attack. The value must be unpredictable to an attacker and cannot be precomputed. There should be no total reduction in hashing the mempool- it's just once per received block. Avoiding latency is important but time taken for siphash a maxed out mempool on a single 3GHz core is 0.17ms, this is insubstantial compared to the rest of block processing.\r\n\r\nI'd like to see more of a threat model on this. What's the attack? An attacker makes a block that they mined slow to propagate? Why would they do that, and not just withhold the block? An attacker broadcasts transactions to be included which would cause a lot of conflicts into the networks mempool on every block? This is expensive to do. Overall, I don't think there is any real security concern with making the nonce be deterministically based on the previous block.\r\n\r\nLet's say we pick a more difficult hash to compute, but make it possible to compute before receiving the block this minimizes the hash-grinding concern, right? But this also still makes it possible to precompute the table which removes the 0.17 ms latency in the hot path. If the goal is < 10ms validation of a block, then 0.17 is not nothing if it can be shaved off. (Furthermore, currently the code re-hashes on a per-peer basis rather than implementing the BIP implementation note 6, which would be a bit better)\r\n\r\n> I originally implemented that, in fact. But low hitrates are unobservably rare after the initial start... spending a byte to signal it is a net loss.. plus the code is more complex. It's also the case that low hitrate data is naturally smaller because all the differences will be very small.\r\n\r\n \r\n\r\n> That is an interesting point however, the coinbase txn is always required; so doing exactly that would not improve anything.\r\n>Ignoring the coinbase implementation would be rather complex: ... if you complete the decode and the prefilled haven't arrived yet, do you wait? how long? or do you just gettxn potentially redundantly with the transactions in flight? if you wait and time out do you ban the peer when it doesn't respond or? Basically when thinking about implementation complexity you should think about the complexity being exponential with the number of communication states you might have with a peer. :)\r\n\r\nWell coinbase txn could always be included outside of the prefilled separate block. I actually like that as a design anyways -- perhaps there should be a difference between txns we KNOW to not be in their mempool and ones we EXPECT to not be in the mempool. At the cost of an extra length field, perhaps not worth it, but if it is just the coinbase (not needing length) perhaps it is worth it.\r\n\r\n\r\n> I've tested this and it works great. The recommendations in BIP152 were based precisely on doing this. It's not included in this PR to minimize the scope as it doesn't change the protocol and can be added any point. (there are further refinements you can do, like leaving out txn that a target peer has INVed to you, even if you didn't know them)\r\n\r\n \r\n\r\nI don't see these recommendations specifically in the BIP, but I support adding this later.",
      "created_at" : "2016-06-11T01:48:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225330119",
      "id" : 225330119,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-11T01:48:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225330119",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "> This seems like a completely-other issue. Mining nodes who keep large mempools will run into large collision frequencies and this will be less useful.\r\n\r\nThis isn't the case. The numbers here are sized for their targets assuming a mempool roughly 10 times what we see with the current maximum.  There is little reason to run with multiple days worth of mempool in any case (transactions will expire after 72 hours). \r\n\r\nWhen reaching that figure the result isn't a \"large collision frequency\", it is a per-link failure rate of 1/281474.  Even if many links fail, the block will still propagate quickly through the network.\r\n\r\nIt's also the case that one can simply look only at the top N of the mempool (which is overwhelmingly more likely to get mined) to achieve whatever effect one wants. \r\n\r\n> This is furthermore troubling because the size used in the bip (m=100000 txns or m*225 bytes not including overhead) is around 22 megabytes whereas the defaults in policy.h seems to be 300 mb of mempool, unless I'm mistaken.\r\n\r\nYou are mistaken. \r\n\r\n$ ./bitcoin-cli getmempoolinfo\r\n{\r\n  \"size\": 13297,\r\n  \"bytes\": 160454650,\r\n  \"usage\": 295521312,\r\n  \"maxmempool\": 300000000,\r\n  \"mempoolminfee\": 0.00001420\r\n}\r\n\r\nSo at the moment a full mempool is ~13499 transactions. (I was actually surprised at how high that was, but I remember now that we just increased the efficiency, in 0.12 it's more like 9800 txn IIRC).\r\n\r\nYour 225 is more like the median txn size than the mean, and the limit is based on memory usage not the size of the compactly serialized transaction-- they're bigger in memory due to a multitude of overheads.\r\n\r\n> Although it may make the most sense to have peers communicate to each other how full their mempools are and set hash length based on that.\r\n\r\nIf there is a need for more or more flexible IDs in the future, the protocol is extensible for that reason. \r\n\r\nDoubly so here, since one can use only as much of the node's feerate (thus probability) sorted mempool as makes sense for them to use.\r\n\r\nMy experience is that lots of bells and whistles ahead of time end up just being implementation complexity that goes unused 99.9% of the time. Testing complexity also grows exponentially with the amount of options.\r\n\r\n> I'd like to see more of a threat model on this. What's the attack? \r\n\r\nThis is described in the BIP: \"Collision resistance It should be hard for network participants to create transactions that cause collisions. If an attacker were able to cause such collisions, filling mempools (and, thus, blocks) with them would cause poor network propagation of new (or non-attacker, in the case of a miner) blocks.\"\r\n\r\nIf the IDs are not salted you can trivially compute colliding sets of transactions and send them to the network, making compact block transmission always fail. A miner doesn't need to do this, anyone can. (though a miner could perhaps profitability avoid it by intentionally avoiding mining those booby-trap transactions-- but profit is irrelevant for trivial vandalism anyone can do).\r\n\r\n>  But this also still makes it possible to precompute the table which removes the 0.17 ms latency in the hot path. If the goal is < 10ms validation of a block, then 0.17 is not nothing if it can be shaved off.\r\n\r\nMost of the time all the solutions are found in the first two megabytes of the mempool, so if it terminates early the 0.17ms wouldn't be there either.  Removing the salting would require increasing the IDs to 16 bytes or so to eliminate this kind of shenanigans. Adding many packets and tens of kilobytes of transmission costs a _lot_ more than 0.17ms on most links.\r\n\r\n> Let's say we pick a more difficult hash to compute, but make it possible to compute before receiving the block this minimizes the hash-grinding concern, right?\r\n\r\nThere is no guaranteed \"minimum time between blocks\" during which you can do this computation, and slowing the hash function down gives only a linear slowdown for the attacker. If X is attackable, X*10 is likely attackable too.\r\n\r\n> currently the code re-hashes on a per-peer basis \r\n\r\nThis is on the sending side, which means it is only running over the transactions in a block, 0.17ms was for a full mempool (receiver size). \r\n\r\n> perhaps there should be a difference between txns we KNOW to not be in their mempool\r\n\r\nWe never \"KNOW\"-- not physically possible. If we want to be particular about it, they could have the txn already but the light cone from that event may not have reached us by the time we transmit.\r\n\r\n> At the cost of an extra length field, perhaps not worth it, but if it is just the coinbase\r\n\r\nThe cost of a length field would be irrelevant (from a size perspective-- it's 16 bytes of Bitcoin protocol overhead plus 40 bytes of TCP/IP overhead are much worse then the length). But the size cost isn't my concern... the cost that I think matters is that a message would be received without actually having enough data to fully act on it but while not being an immediate error condition, requiring another state in the state machine. \"I have the first part of a compact block, but not the rest\"-- along with the mess of additional corner cases and error handling involving that extra state. Otherwise I'd totally support this.\r\n\r\nEspecially when you consider that the hope is to revise this over time with improved protocols (this design is a long way from the most efficient we know how to design) there is a good reason to not put in a lot of doodads and options, as they just turn into extra technical debt in older versions which are carried around for compatibility.  We don't need to design for forever here. I would have even left out high-bandwidth mode and the ability to have predicted transactions, but those were minimums required to get rid of any need to have a separate fast block relay network protocol.",
      "created_at" : "2016-06-11T04:52:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225336886",
      "id" : 225336886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-11T04:58:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225336886",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@JeremyRubin @gmaxwell The number 0.17ms you're citing is not actually relevant in this discussion.\r\n\r\nFor the receiver, the reconstruction time is likely dominated by iterating over the mempool (the memory accesses needed per mempool entry are way slower than the SipHash calculation), so being able to use a preconstructred mempool index with shortids would likely very significantly reduce it. Unfortunately, indeed, to make collision attacks infeasible in that case, we'd likely need ~16-byte short ids.\r\n\r\nIf the reconstruction time ever becomes significant enough to optimize, the low hanging fruit is creating a continuous in-memory block with all mempool txids, perhaps subdivided in a few tiers (sorted by feerate).",
      "created_at" : "2016-06-11T13:17:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225361053",
      "id" : 225361053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-11T13:18:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225361053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728455"
         }
      },
      "body" : "Using `std::make_shared(cmpctblock.prefilledtxn[i].tx)` is slightly more efficient, as it allocates the reference counter and the CTransaction in a single malloc, while the normal std::shared_ptr constructor needs two separate ones.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:04:22Z",
      "diff_hunk" : "@@ -0,0 +1,147 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728455",
      "id" : 66728455,
      "original_commit_id" : "c63626aeae2ed8f3174108b26ce940ac25951071",
      "original_position" : 74,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728565"
         }
      },
      "body" : "I'd rather say \"// Future transaction compression standards could be implemented here\" rather than TODO, as there is no actionable change you could make right now.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:10:24Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728565",
      "id" : 66728565,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729306"
         }
      },
      "body" : "Is it necessary that we treat a non-connecting header as an inv? If the peer is not tracking any headers tree and just relaying headers, requesting anything from them won't do us any good anyway, and that seems to be the only use case for this?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:58:14Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729306",
      "id" : 66729306,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729475"
         }
      },
      "body" : "What is the reason for this? I think we should check early and dosban peers who getdata a CMPCT_BLOCK that was not recently inved.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:11:59Z",
      "diff_hunk" : "@@ -4512,6 +4518,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // else\n                             // no response\n                     }\n+                    else if (inv.type == MSG_CMPCT_BLOCK)\n+                    {\n+                        // Note that while we will respond to all MSG_CMPCT_BLOCK requests here,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729475",
      "id" : 66729475,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 44,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729475",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "ACK (+/- various in-flight nits). Beyond reviewing the spec and code, I've had a network of hosts running this (and earlier versions) for over a month with good results, public testing looks good, and and four the last week I've had a network running a modified version with 16-bit IDs to test all the collision corner cases. That network has reliably stayed in sync (except for one bug I encountered which is fixed here).\r\n\r\nThere is room for further improvement, including prediction, using the orphan map in recovery, better interaction with fetching logic (e.g. in initial block download case); but those can and should be in other PRs done at other times. Should some problem show up in this in the future it's versioned and negotiated, so it could simply be turned off. \r\n",
      "created_at" : "2016-06-12T23:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225466329",
      "id" : 225466329,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-12T23:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225466329",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729707"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729707"
         }
      },
      "body" : "I don't think this test should be here. The block below (that builds vHeaders) can skip things from vBlockHashesToAnnounce.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:28:10Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729707",
      "id" : 66729707,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729737"
         }
      },
      "body" : "... continued. This if block could be replaced by the if inside of it, and making it reset vHeaders. No code movement for the normal headers inv is necessary in that case.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:29:38Z",
      "diff_hunk" : "@@ -5854,6 +5916,33 @@ bool SendMessages(CNode* pto)\n                     }\n                 }\n             }\n+            if (!fRevertToInv && !vHeaders.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729737",
      "id" : 66729737,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 128,
      "path" : "src/main.cpp",
      "position" : 528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729795"
         }
      },
      "body" : "s/COMPRBLOCK/CMPCTBLOCK/",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:33:21Z",
      "diff_hunk" : "@@ -197,8 +198,9 @@ namespace {\n     /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n     struct QueuedBlock {\n         uint256 hash;\n-        CBlockIndex* pindex;     //!< Optional.\n-        bool fValidatedHeaders;  //!< Whether this block has validated headers at the time of request.\n+        CBlockIndex* pindex;                                     //!< Optional.\n+        bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n+        std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for COMPRBLOCK downloads",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729795",
      "id" : 66729795,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 16,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729990"
         }
      },
      "body" : "An auto type may be worth it here.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:46:53Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n+    // Short-circuit most stuff in case its from the same node\n+    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729990",
      "id" : 66729990,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 33,
      "path" : "src/main.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729997"
         }
      },
      "body" : "The current code requires that you track the state of each of your peer's headers chain or risk getting DoS banned (which is not mentioned in the spec, and is something which we actually do not fully do currently without races - resulting in these prints appearing occasionally in debug.log). I'd say its a pretty non-trivial bug.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:47:09Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729997",
      "id" : 66729997,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730022"
         }
      },
      "body" : "Sorry if I'm not clear. I suggest changing it so that we don't DoS in that case, but also don't respond with a getheaders. Or rather, I'm wondering whether that suffices for your use case.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:49:12Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730022",
      "id" : 66730022,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730022",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730069"
         }
      },
      "body" : "That's pretty unintuitive behaviour, and I don't think it's necessary to put that much decision logic in this function. I think it could just return a `QueuedBlock*` always, and then the caller can then insert a new partialBlock if needed.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:52:19Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730069",
      "id" : 66730069,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 27,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730088"
         }
      },
      "body" : "I tend to prefer not auto-typing when I'm gonna actually use some part of the type (ie I'd like to ensure there be a compiler error if  I'm accessing a variable and it changes type).",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:53:43Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n+    // Short-circuit most stuff in case its from the same node\n+    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730088",
      "id" : 66730088,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 33,
      "path" : "src/main.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730088",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730648"
         }
      },
      "body" : "Perhaps this part can be factored out into a separate function, that can be called from the codepath for CMPCTBLOCKs that don't have any missing txn?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T00:24:20Z",
      "diff_hunk" : "@@ -5205,6 +5234,159 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730648",
      "id" : 66730648,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 212,
      "path" : "src/main.cpp",
      "position" : 441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730648",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735226"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735226"
         }
      },
      "body" : "There is no DoS score involved in a request for which we did not send an inv (ie something which is buried in our chain), only for those which request something with !BLOCK_HAVE_DATA. For those, we definitely wont even send a CMPCTBLOCK, because its covered by the surrounding if statement. \r\n\r\nAs for not sending the compact block if the block is >= 10 deep, yes, I can add an if statement and simply not respond to the getdata for those.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T02:53:23Z",
      "diff_hunk" : "@@ -4512,6 +4518,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // else\n                             // no response\n                     }\n+                    else if (inv.type == MSG_CMPCT_BLOCK)\n+                    {\n+                        // Note that while we will respond to all MSG_CMPCT_BLOCK requests here,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735226",
      "id" : 66735226,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 44,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735226",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735956"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735956"
         }
      },
      "body" : "For now I swapped in the same call-headers-msg code from CMPCTBLOCK handling into the CMPCTBLOCK code  call ::BLOCKTXN handling. Its a dirty hack to serialize and then immediately deserialize a message, but its a short message so it doesnt cost much, and I'm assuming the network stack will be (properly) rewritten soonish anyway, so then it can be called like the individual function it should be.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T03:11:22Z",
      "diff_hunk" : "@@ -5205,6 +5234,159 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735956",
      "id" : 66735956,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 212,
      "path" : "src/main.cpp",
      "position" : 441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735956",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66738999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66738999"
         }
      },
      "body" : "I don't immediately see how to resolve this in the way you're suggesting.  Because I want to share the code in the first if (!fRevertToInv) block I need to change the definition of fRevertToInv (or the condition for that block) slightly.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:24:18Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66738999",
      "id" : 66738999,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66738999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739056"
         }
      },
      "body" : "I think this may be possible by bending over backwards to change fRevertToInv in the right way between the !fRevertToInv and fRevertToInv conditionals, but I think that just makes the already hard-to-read code even worse, which is not worth saving a tiny bit of code movement to me.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:25:43Z",
      "diff_hunk" : "@@ -5854,6 +5916,33 @@ bool SendMessages(CNode* pto)\n                     }\n                 }\n             }\n+            if (!fRevertToInv && !vHeaders.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739056",
      "id" : 66739056,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 128,
      "path" : "src/main.cpp",
      "position" : 528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739275"
         }
      },
      "body" : "Differing philosophy, I guess...Indeed, this already isnt an issue for the CMPCTBLOCK handling, but I really don't like the idea that our peer might notify us that they have some blocks available and we will simply ignore them because they aren't keeping track of our chainstate. Can we use hashLastUnknownBlock to track if we hit the infinite-loop condition without adding additional state here?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:33:33Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739275",
      "id" : 66739275,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "I believe I either responded to all code comments or fixed them.\r\n\r\nAlso added a few commits to optimize PartiallyDownloadedBlock::InitData. Just iterating over the mempool costs quite a bit of CPU time, which would near being a DoS-issue if it werent for the fact that you have to do a disconnect/reconnect cycle to trigger the code again. By limiting its worst-case runtime in the case that someone significantly increases their mempool size and priming the memory access a bit, its mostly fine, though further changes may be required for the UDP code based on this stuff.",
      "created_at" : "2016-06-13T04:41:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225488055",
      "id" : 225488055,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-13T04:41:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225488055",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806224"
         }
      },
      "body" : "I don't think the xor helps at all. Groups of short ids that were close together (and thus had a high chance of ending up in the same bucket) remain close together.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T14:55:52Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806224",
      "id" : 66806224,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806224",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806934"
         }
      },
      "body" : "Thinking more about this, I think it is fine. Assuming the peer responds with a headers chain that indeed matches the locator we send, the same condition won't trigger again.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T14:59:21Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806934",
      "id" : 66806934,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66807276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66807276"
         }
      },
      "body" : "A better suggestion than what I said before: just replace this whole block with `stream << header << nonce`.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:00:30Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66807276",
      "id" : 66807276,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 37,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66807276",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66808314"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66808314"
         }
      },
      "body" : "Why is this moved?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:06:22Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66808314",
      "id" : 66808314,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66808314",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa thanks for the clarification.",
      "created_at" : "2016-06-13T15:21:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225614170",
      "id" : 225614170,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-13T15:21:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225614170",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66811617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66811617"
         }
      },
      "body" : "I mean like here: https://github.com/sipa/bitcoin/commit/526a02c114a5f34fef053d3550438ebb9e741b42",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:22:32Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66811617",
      "id" : 66811617,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66811617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "slightly tested ACK\r\n\r\nI've been running versions of this for smoothly about a month and compiling stats/graphing the results. ",
      "created_at" : "2016-06-13T17:10:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225646123",
      "id" : 225646123,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-13T17:10:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225646123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835159"
         }
      },
      "body" : "LOL, I must've been really tired when I thought that one through....anyway, I'll do the bucket-count thing.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:43:07Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835159",
      "id" : 66835159,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835159",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835192"
         }
      },
      "body" : "Heh, good point.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:43:17Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835192",
      "id" : 66835192,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 37,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835600"
         }
      },
      "body" : "I believe that was exactly Suhas' concern - that a peer might respond to a headers request with a chain that was disconnected from our locator.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:46:02Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835600",
      "id" : 66835600,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835690"
         }
      },
      "body" : "To prevent yet more includes and the crazy-looking GetAdjustedTime call from within the GetBlock stuff. See https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224781229",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:46:33Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835690",
      "id" : 66835690,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66868501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66868501"
         }
      },
      "body" : "Fair enough.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:08:41Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66868501",
      "id" : 66868501,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66868501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869150"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869150"
         }
      },
      "body" : "nit of some incoherences: \r\n\r\n1. ushort were used in PrefilledTransaction to represent an index but here it is uint. \r\n2. PrefilledTransaction->index represent a differential index, but BlockTransactionsRequest->indexes represent absolute indexes (because the translation from diff to absolute is done during seria/deseria)",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:12:30Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869150",
      "id" : 66869150,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 30,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869150",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869151"
         }
      },
      "body" : "What would work is multiplying by a random odd 64-bit integer, but I agree - bucket counting sounds better. You could do a chi-square test.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:12:30Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869151",
      "id" : 66869151,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66871970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66871970"
         }
      },
      "body" : "maybe should check\r\n\r\n```\r\nif(index > std::numeric_limits<uint32_t>::max())\r\n                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\r\n```",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:29:27Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66871970",
      "id" : 66871970,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 46,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66871970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "The travis failure seems to be a travis issue, not a real failure",
      "created_at" : "2016-06-14T00:14:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225746202",
      "id" : 225746202,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-14T00:24:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225746202",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "@TheBlueMatt Travis passed now.",
      "created_at" : "2016-06-14T09:19:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225825656",
      "id" : 225825656,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-14T09:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225825656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "body" : "@TheBlueMatt can you consider to cherry pick https://github.com/NicolasDorier/bitcoin/commit/5a156ebc6f402f60c2e5faa880e3cdc2c6bb5b32 ?\r\n\r\nPrefilledTransaction.index becomes an absolute index instead of a differential one. Differential index should only be used on wire.",
      "created_at" : "2016-06-14T15:43:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-225923963",
      "id" : 225923963,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-14T15:49:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/225923963",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67007859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67007859"
         }
      },
      "body" : "Ping? I think the code I linked above is simpler and easier to read.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T16:39:50Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67007859",
      "id" : 67007859,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67007859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67020645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67020645"
         }
      },
      "body" : "How accurate was your simulation? If I approximate the chance as buckets*P[binomial(n,1.0/buckets)], where n<=buckets (due to max_load_factor=1.0 by default for unordered_map), this would randomly fail about once every 9000 transmissions for n=10000 buckets=10000.\r\n\r\nAccording to this approximation, if we want the random failure chance to be less than once in a billion, you need:\r\n* `> 10` for up to 13 transactions\r\n* `> 11` for up to 23 transactions\r\n* `> 12` for up to 56 transactions\r\n* `> 13` for up to 291 transactions\r\n* `> 14` for up to 3423 transactions\r\n* `> 15` for up to 53645 transactions\r\n* `> 16` for up to 913429 transactions\r\n\r\n",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T17:47:56Z",
      "diff_hunk" : "@@ -75,12 +76,20 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     prefilled_count = cmpctblock.prefilledtxn.size();\n \n     // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n-    std::map<uint64_t, uint16_t> shorttxids;\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n     uint16_t index_offset = 0;\n     for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n         while (txn_available[i + index_offset])\n             index_offset++;\n         shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67020645",
      "id" : 67020645,
      "original_commit_id" : "da8ae90dc107efa9ce36f970c7a45659869e5742",
      "original_position" : 24,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67020645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67030264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67030264"
         }
      },
      "body" : "Yes, I just looked at the first example of \"prev block not found\" in the debug log of one my long-running listening nodes, and it's a peer that fails to send connecting headers on initial startup:\r\n\r\n```\r\n2016-05-30 12:50:07 Added connection to [redacted] peer=963241\r\n2016-05-30 12:50:07 received: version (102 bytes) peer=963241\r\n2016-05-30 12:50:07 send version message: version 70012, blocks=414057, us=0.0.0.0:8333, them=[redacted], peer=963241\r\n2016-05-30 12:50:07 sending: version (102 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: verack (0 bytes) peer=963241\r\n2016-05-30 12:50:07 receive version message: /[redacted subver I've never heard of before]/: version 70002, blocks=16863, us=[redacted], peer=963241, peeraddr=[redacted]\r\n2016-05-30 12:50:07 sending: ping (8 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: addr (31 bytes) peer=963241\r\n2016-05-30 12:50:07 initial getheaders (414056) to peer=963241 (startheight:16863)\r\n2016-05-30 12:50:07 sending: getheaders (997 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: inv (37 bytes) peer=963241\r\n2016-05-30 12:50:08 sending: inv (37 bytes) peer=963241\r\n2016-05-30 12:50:08 received: verack (0 bytes) peer=963241\r\n2016-05-30 12:50:08 received: getaddr (0 bytes) peer=963241\r\n2016-05-30 12:50:08 received: ping (8 bytes) peer=963241\r\n2016-05-30 12:50:08 sending: pong (8 bytes) peer=963241\r\n2016-05-30 12:50:08 received: pong (8 bytes) peer=963241\r\n2016-05-30 12:50:08 received: headers (162003 bytes) peer=963241\r\n2016-05-30 12:50:08 ERROR: AcceptBlockHeader: prev block not found\r\n2016-05-30 12:50:08 ProcessMessages(headers, 162003 bytes) FAILED peer=963241\r\n```\r\n\r\nGiven that no new information was exchanged in the less than 2 seconds this interaction took, I think this would result in an infinite loop where my peer would send me ~160kb of data every 2 seconds...",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T18:36:55Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67030264",
      "id" : 67030264,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67030264",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67042310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67042310"
         }
      },
      "body" : "This requires fPreferHeaders in order for fPreferHeaderAndIDs to work, which I was deliberately trying to avoid.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T19:42:45Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67042310",
      "id" : 67042310,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67042310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273405"
         }
      },
      "body" : "I think there's an off by one here.  If shorttxids.size() == 0, and prefilledtxn.size() == 1, then sending a compact block with prefilledtxn[0].index = 1 would pass this check, but cause an out-of-bounds memory access below.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:11:43Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273405",
      "id" : 67273405,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 68,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273405",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273833"
         }
      },
      "body" : "comment nit: i was convinced there were all kinds of potential for overflows until I found the sanity check on the prefilledtxn index values that is done in deserialization (which also explained why you have this uint16_t max check, which was inexplicable from looking at the surrounding code).  Adding a short comment explaining the logic would be helpful to future code readers.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:16:41Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273833",
      "id" : 67273833,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 66,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273833",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273846"
         }
      },
      "body" : "nit: this could be shortened using `cmpctblock.BlockTxCount()`",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:16:53Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273846",
      "id" : 67273846,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 58,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67274625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67274625"
         }
      },
      "body" : "Agree with @sipa about making this a `vector<bool>`!",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:23:09Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67274625",
      "id" : 67274625,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67274625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277374"
         }
      },
      "body" : "I think HAVE_DATA is the wrong check if we are a pruning node.  We should do `if (pindex->nTx > 0)` instead.\r\n\r\nOn further thought, `pindex->nTx > 0` isn't right either, if there are any scenarios where a pruning node might re-request (via cmpctblock) a previously validated block in order to reorg to the chain that block is on.  I think elsewhere in the code, we catch this case by checking to see if the block is requested, and rely on the download logic being smart enough to not request useless blocks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:02:32Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277374",
      "id" : 67277374,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 358,
      "path" : "src/main.cpp",
      "position" : 358,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277374",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277972"
         }
      },
      "body" : "Again, here we should instead check if `pindex->pprev->nTx > 0`, so that this will work in the pruning case (it probably doesn't actually matter much in this specific case, but I think it's better to not use HAVE_DATA to minimize future errors).\r\n\r\nAlso, I think before we try to work on reconstructing the block and potentially requesting it, we should have a check that either we requested this CMPCTBLOCK, or that the header is valid and has more work than our tip.  Otherwise I believe we'd be vulnerable to a fill-up-your-disk attack.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:12:19Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277972",
      "id" : 67277972,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 368,
      "path" : "src/main.cpp",
      "position" : 368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277972",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67279075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67279075"
         }
      },
      "body" : "We should clear the block as no longer being in flight.  Otherwise we're relying on the `Misbehaving()` to cause a disconnect, which would eventually clear the state -- but this seems error prone, eg if the node happens to be whitelisted.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:29:25Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                    if (!(*queuedBlockIt)->partialBlock)\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n+                    else {\n+                        // The block was already in flight using compact blocks from the same peer\n+                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                        return true;\n+                    }\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67279075",
      "id" : 67279075,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 389,
      "path" : "src/main.cpp",
      "position" : 389,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67279075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Reply getdata MSG_CMPCT_BLOCK to MSG_BLOCK inv : https://github.com/NicolasDorier/bitcoin/commit/83cc735bfa803e1e7eee02e458127e8d94c24534",
      "created_at" : "2016-06-16T19:53:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226594840",
      "id" : 226594840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-16T19:53:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226594840",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67413739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67413739"
         }
      },
      "body" : "I really dont like doing a malloc() for such a small buffer :/",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67413739",
      "id" : 67413739,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67413739",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67414301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67414301"
         }
      },
      "body" : "You're already doing a malloc for each shortid in the unordered_map above.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:03:41Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67414301",
      "id" : 67414301,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67414301",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67418447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67418447"
         }
      },
      "body" : "True, but I didnt want to implement my own unordered_map...a vector\\<bool\\> is easy :p",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:30:57Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67418447",
      "id" : 67418447,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67418447",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67439082"
         }
      },
      "body" : "Use `vTxHashes[it->vTxHashesIdx] = std::move(vTxHashes[vTxHashes.size() - 1])` or `std::swap(vTxHashes[it->vTxHashesIdx], vTxHashes[vTxHashes.size() - 1])` to avoid needing std::shared_ptr copy (which needs an atomic operation to increment the refcount).",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T23:00:33Z",
      "diff_hunk" : "@@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n+    if (vTxHashes.size() > 1) {\n+        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxHashes.size() - 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439082",
      "id" : 67439082,
      "original_commit_id" : "52783001e3cb06759bc823c71ab04e3690b81ad1",
      "original_position" : 15,
      "path" : "src/txmempool.cpp",
      "position" : 15,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T23:00:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67439082",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67439622"
         }
      },
      "body" : "If not for this find, we wouldn't need a wtxid index in the mempool... as long we don't build `vTxHashes` asynchronously, it could be done by storing a `CTxMemPool::txiter` in `vTxHashes` instead of a `std::shared_ptr<const CTransaction>`.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T23:06:25Z",
      "diff_hunk" : "@@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n+    if (vTxHashes.size() > 1) {\n+        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxHashes.size() - 1];\n+        txiter newhashit = mapTx.find(vTxHashes[it->vTxHashesIdx].first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67439622",
      "id" : 67439622,
      "original_commit_id" : "52783001e3cb06759bc823c71ab04e3690b81ad1",
      "original_position" : 16,
      "path" : "src/txmempool.cpp",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T23:07:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67439622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67448620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67448620"
         }
      },
      "body" : "I avoided doing that since I didnt want to look up iterator invalidation in boost's multi index map, will do that now.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T00:57:40Z",
      "diff_hunk" : "@@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n+    if (vTxHashes.size() > 1) {\n+        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxHashes.size() - 1];\n+        txiter newhashit = mapTx.find(vTxHashes[it->vTxHashesIdx].first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67448620",
      "id" : 67448620,
      "original_commit_id" : "52783001e3cb06759bc823c71ab04e3690b81ad1",
      "original_position" : 16,
      "path" : "src/txmempool.cpp",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T00:57:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67448620",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67453756"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67453756"
         }
      },
      "body" : "Further thought: just drop this condition, and always process the CMPCTBLOCK.  We don't need the parents of this block to have arrived to correctly reconstruct and process the CMPCTBLOCK (just like we are able to process full blocks out of order).  This fixes the sync bug that is popping up in the RPC tests.\r\n\r\nThen you can also get rid of the code in the else{} down below, where you invoke the HEADERS processing. \r\n\r\nHowever, we should reuse the direct fetch logic that is implemented in the headers processing, so that if we are receiving a CMPCTBLOCK that is the tip of a reorg, and we're missing some intermediate block (for which we have headers, of course, or else this announcement would be dropped), then we should go back and request those intermediate blocks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T02:27:52Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67453756",
      "id" : 67453756,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 368,
      "path" : "src/main.cpp",
      "position" : 368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T02:29:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67453756",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67461680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67461680"
         }
      },
      "body" : "Yes, I found that out after looking it up :)\n\nOn June 16, 2016 9:19:08 PM PDT, Pieter Wuille <notifications@github.com> wrote:\n>> @@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n>>      BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n>>          mapNextTx.erase(txin.prevout);\n>>  \n>> +    if (vTxHashes.size() > 1) {\n>> +        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxHashes.size() -\n>1];\n>> +        txiter newhashit =\n>mapTx.find(vTxHashes[it->vTxHashesIdx].first);\n>\n>They are never invalidated until you delete the item itself.\n>http://www.boost.org/doc/libs/1_60_0/libs/multi_index/doc/tutorial/indices.html#guarantees\n>\n>\n>---\n>You are receiving this because you were mentioned.\n>Reply to this email directly or view it on GitHub:\n>https://github.com/bitcoin/bitcoin/pull/8068/files/ba9b1415c5c226eee55f77b10095335240d7af5e..52783001e3cb06759bc823c71ab04e3690b81ad1#r67459055\n",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T05:17:07Z",
      "diff_hunk" : "@@ -447,6 +450,15 @@ void CTxMemPool::removeUnchecked(txiter it)\n     BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n+    if (vTxHashes.size() > 1) {\n+        vTxHashes[it->vTxHashesIdx] = vTxHashes[vTxHashes.size() - 1];\n+        txiter newhashit = mapTx.find(vTxHashes[it->vTxHashesIdx].first);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67461680",
      "id" : 67461680,
      "original_commit_id" : "52783001e3cb06759bc823c71ab04e3690b81ad1",
      "original_position" : 16,
      "path" : "src/txmempool.cpp",
      "position" : 16,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T05:17:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67461680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "I have a concern with how the block reconstruction mechanism interacts with any mempool policy -- first seen, replace by fee, or opt-in replace by fee. I am worried that mempool policies can be used to greatly increase reconstruction failure rates.\r\n\r\nSuppose a new block is found by a miner, containing a bunch of transactions. A malicious node is close to the miner and is able to see the block first. The malicious node has included many high fee transactions such that they have a large portion of the txns  included in the block (or really, any portion of the txns). Before the block propagates very far, the malicious node sends replace by fee messages for those transactions. This evicts the old transactions that would go into that block and decreases the block reconstruction success rate.\r\n\r\nThere are many variants of above attack, including one where a txn is simply frequently RBF'd without trying to condition on when a new block is found.\r\n\r\n\r\nThis kind of attack is also possible with a first seen policy. An attacker generates two transactions of equal fee spending the same coins and propagates them both, such that they reach half the network. This transaction now has a high likelihood of not being reconstructable depending on how that txn propagates (perhaps along a boundary of some sort). Sending multiple such transactions could, each time, partition the network in two, virtually guaranteeing a failure to reconstruct if each partition is fully independent and a reasonable number of transactions (log(nodes)) is used.\r\n\r\n\r\nI'm not sure that there are many effective mitigations to this, other than attempting to flag transactions that seem to have been used in this manner for the prefill.",
      "created_at" : "2016-06-17T14:00:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226776252",
      "id" : 226776252,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-17T14:00:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226776252",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67535136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67535136"
         }
      },
      "body" : "If BLOCK_HAVE_DATA is set, there is no need to process the CMPCTBLOCK, regardless of pruning, no?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T16:07:43Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67535136",
      "id" : 67535136,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 358,
      "path" : "src/main.cpp",
      "position" : 358,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T16:07:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67535136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@JeremyRubin Being able to use more than just the currently active mempool was part of the motivation in switching to use sharedptr rather than the manual rc used earlier. Before making a getblocktxn it could go and check the relaypool, orphanpool, or even a not yet existing pool of rejected transactions. But that would be a further optimization that I don't think is necessary to shove in the very first implementation now. The specific mempool policy shouldn't matter that much because it isn't limited to using the mempool.",
      "created_at" : "2016-06-17T16:17:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226813548",
      "id" : 226813548,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-17T16:17:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226813548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67536925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67536925"
         }
      },
      "body" : "1) Agree, just drop this condition. We can deal with discontinuous blocks just fine (maybe we should check that we're not too far ahead of the main chain, though EDIT: CanDirectFetch already does that).\r\n\r\n2) I agree we also need direct fetching logic in response to CMPCTBLOCK, but it's less needed than for HEADERS, as CMPCTBLOCK are usually just sent as a single tip. Also, I really want that direct fetching logic to be factored out into a separate function first, which can be used for both responding to INV, HEADERS and CMPCTBLOCK.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T16:20:18Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67536925",
      "id" : 67536925,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 368,
      "path" : "src/main.cpp",
      "position" : 368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T16:29:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67536925",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67560230"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67560230"
         }
      },
      "body" : "Oops, I meant I think we need a cs_main lock here (deleted other comment).",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-17T19:05:44Z",
      "diff_hunk" : "@@ -5169,6 +5276,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                    if (!(*queuedBlockIt)->partialBlock)\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n+                    else {\n+                        // The block was already in flight using compact blocks from the same peer\n+                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                        return true;\n+                    }\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    // Dirty hack to jump to BLOCKTXN code (TODO: move message handling into their own functions)\n+                    BlockTransactions txn;\n+                    txn.blockhash = cmpctblock.header.GetHash();\n+                    CDataStream blockTxnMsg(SER_NETWORK, PROTOCOL_VERSION);\n+                    blockTxnMsg << txn;\n+                    return ProcessMessage(pfrom, NetMsgType::BLOCKTXN, blockTxnMsg, nTimeReceived, chainparams);\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            // Dirty hack to process as if it were just a headers message (TODO: move message handling into their own functions)\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67560230",
      "id" : 67560230,
      "original_commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "original_position" : 432,
      "path" : "src/main.cpp",
      "position" : 432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-17T19:05:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67560230",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "Summary from last Thursday's meeting: this will get an extra week to be ready for merge* (thus exception from the feature freeze). Next meeting we should decide whether this is along far enough to merge. If so it will still make it into 0.13. If not, it will be merged after 0.13 is branched, and will thus roll forward to 0.14.\r\n\r\n\\* This doesn't mean that there cannot be improvements or small fixes left to do, there can be further development on master after merge, but it should be far enough along that we can be confident that before the rc1/0.13 branch-off, scheduled for 2016-07-06, it will be release-quality",
      "created_at" : "2016-06-18T14:57:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226946706",
      "id" : 226946706,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-18T14:57:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226946706",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@JeremyRubin Indeed, sadly this is inherit in any similar optimizations :(.  As @gmaxwell points out we can limit the impact by broadening the scope of what we look at during reconstruction, but we will never be able to fully solve this problem. Still, the goal of this work is to reduce bandwidth during relay on the P2P network, not neccessarily improve relay times, as other solutions are better targeted at that. I hope to write up a \"how to set up a UDP-based relay network\" post soon to encourage people to set up really effecienct block relay networks that dont (as much) suffer from these issues.",
      "created_at" : "2016-06-18T19:38:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226961099",
      "id" : 226961099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-18T19:38:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226961099",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "@TheBlueMatt @gmaxwell, thanks for your responses.\r\n\r\nI agree that this seems like a fundamental problem with such optimizations. @TheBlueMatt, it might help to clarify the BIP to emphasize that the latency reduction side effect is easily attacked, relying on the decreased latency would be a DOS vector waiting to happen.\r\n\r\nI do not think that looking at more caches is a great solution as the probability of failure to reconstruct grows with number of txns looked at and as sipa points out, the memory churn overhead is somewhat large.\r\n",
      "created_at" : "2016-06-19T02:40:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226976048",
      "id" : 226976048,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-19T02:40:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226976048",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@laanwj thanks for the update.\r\n\r\nUpdates: Pulled in #8220, which is required. Various small code updates in a few places, nothing that changes behavior, except for sync logic:\r\nPulled out the fix that removes the DoS penalty for non-conencting header messages. Still think thats a really useful change, but it could be replaced with a return or something now since the compact block stuff doesnt rely on it, so should be separate. @sdaftuar and @sipa tried to use some of the AcceptBlock logic in the do-we-process-compact-blocks logic but I'm pretty sure it was wrong, so its now a combination of that code copied into the net-processing code and some slight tweaks (you can see the proposed changes at https://github.com/TheBlueMatt/bitcoin/pull/6/commits/4b212d279eec0c10ed237936cb292a873c526c4f and https://github.com/TheBlueMatt/bitcoin/pull/6/commits/5f1692d1d6aded853f846e33ff0ade2e9f7241f5)",
      "created_at" : "2016-06-19T08:35:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-226986053",
      "id" : 226986053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-19T08:35:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/226986053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   }
]
