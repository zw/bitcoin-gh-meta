[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16710](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16710.html) (build: Enable -Wsuggest-override if available by hebasto)\n* [#16702](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16702.html) (p2p: supplying and using asmap to improve IP bucketing in addrman by naumenkogs)\n* [#16528](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16528.html) ([WIP] Native Descriptor Wallets (take 2) by achow101)\n* [#16440](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16440.html) (BIP-322: Generic signed message format by kallewoof)\n* [#15590](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/15590.html) (Descriptor: add GetAddressType() and IsSegWit() by Sjors)\n* [#13751](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13751.html) (Utils and libraries: Drops the boost/algorithm/string/split.hpp dependency by l2a5b1)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-09-04T04:11:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#issuecomment-527731575",
      "id" : 527731575,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16800",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzczMTU3NQ==",
      "updated_at" : "2019-09-04T18:33:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527731575",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nThanks for the great work on miniscript and the C++ implementation!\r\n\r\nThis version seems to deviate somewhat to the version in the [upstream repo](https://github.com/sipa/miniscript) which makes it unclear to me which of the issues I found during my review that have been addressed:\r\n* [Avoid termination due to unhandled exception when parsing invalid arguments to after(...), older(...), thresh(...) and thresh_m(...)](https://github.com/sipa/miniscript/pull/3)\r\n* [Avoid assertion failure on after(k) or older(k) where k < 1 or k >= 0x80000000UL](https://github.com/sipa/miniscript/pull/4)\r\n* [Avoid running out of stack space by limiting recursion depth in Parse(...)](https://github.com/sipa/miniscript/pull/5)\r\n* [Policies with too high nesting depth are not rejected: It is possible to create small inputs that cause extreme memory usage (in practice: OOM kill or std::bad_alloc)](https://github.com/sipa/miniscript/issues/7)\r\n\r\nCould you clarify? :-)",
      "created_at" : "2019-09-04T08:23:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#issuecomment-527797423",
      "id" : 527797423,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16800",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzc5NzQyMw==",
      "updated_at" : "2019-09-04T08:59:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527797423",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320708381"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320708381"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like these already are macros on mac from `/home/travis/build/bitcoin/bitcoin/depends/SDKs/MacOSX10.11.sdk/usr/include/mach/boolean.h`?\r\n\r\nAnd also in windows: https://travis-ci.org/bitcoin/bitcoin/jobs/580527642#L3384",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T11:32:07Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\"_mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    FALSE,     //!< OP_0\n+    TRUE,      //!< OP_1",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320708381",
      "id" : 320708381,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDcwODM4MQ==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 165,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 283549870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320708381",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320709735"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320709735"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\ntest/miniscript_tests.cpp:115:20: error: default initialization of an object of const type 'const (anonymous namespace)::KeyConverter' without a user-provided default constructor\r\n```\r\n\r\nhttps://travis-ci.org/bitcoin/bitcoin/jobs/580527646#L3225",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T11:35:27Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+    std::map<CKeyID, CPubKey> pkmap;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+            pkmap.emplace(keyid, pubkey);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata, 32).Finalize(hash.data());\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata, 32).Finalize(hash.data());\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;\n+\n+    //! Public keys in text form are their usual hex notation (no xpubs, ...).\n+    bool ToString(const CPubKey& key, std::string& ret) const { ret = HexStr(key.begin(), key.end()); return true; }\n+\n+    //! Convert a public key to bytes.\n+    std::vector<unsigned char> ToPKBytes(const CPubKey& key) const { return {key.begin(), key.end()}; }\n+\n+    //! Convert a public key to its Hash160 bytes (precomputed).\n+    std::vector<unsigned char> ToPKHBytes(const CPubKey& key) const\n+    {\n+        auto it = g_testdata->pkhashes.find(key);\n+        assert(it != g_testdata->pkhashes.end());\n+        return {it->second.begin(), it->second.end()};\n+    }\n+\n+    //! Parse a public key from a range of hex characters.\n+    template<typename I>\n+    bool FromString(I first, I last, CPubKey& key) const {\n+        auto bytes = ParseHex(std::string(first, last));\n+        key.Set(bytes.begin(), bytes.end());\n+        return key.IsValid();\n+    }\n+\n+    template<typename I>\n+    bool FromPKBytes(I first, I last, CPubKey& key) const {\n+        key.Set(first, last);\n+        return key.IsValid();\n+    }\n+\n+    template<typename I>\n+    bool FromPKHBytes(I first, I last, CPubKey& key) const {\n+        assert(last - first == 20);\n+        CKeyID keyid;\n+        std::copy(first, last, keyid.begin());\n+        auto it = g_testdata->pkmap.find(keyid);\n+        assert(it != g_testdata->pkmap.end());\n+        key = it->second;\n+        return true;\n+    }\n+};\n+\n+//! Singleton instance of KeyConverter.\n+const KeyConverter CONVERTER;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320709735",
      "id" : 320709735,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDcwOTczNQ==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 115,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 283549870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320709735",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320710696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320710696"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\nRunning tests: miniscript_tests from test/miniscript_tests.cpp\r\nRunning 2 test cases...\r\nTest cases order is shuffled using seed: 1580527639\r\nEntering test module \"Bitcoin Core Test Suite\"\r\ntest/miniscript_tests.cpp(282): Entering test suite \"miniscript_tests\"\r\ntest/miniscript_tests.cpp(322): Entering test case \"random_tests\"\r\nscript/miniscript.h:599:33: runtime error: unsigned integer overflow: 0 - 1 cannot be represented in type 'size_t' (aka 'unsigned long')",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T11:38:09Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\"_mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    FALSE,     //!< OP_0\n+    TRUE,      //!< OP_1\n+    PK,        //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERFIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    THRESH_M,  //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK/PK_H/THRESH_M)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+    //! Internal code for ToScript.\n+    template<typename Ctx>\n+    CScript MakeScript(const Ctx& ctx, bool verify = false) const {\n+        std::vector<unsigned char> bytes;\n+        switch (nodetype) {\n+            case NodeType::PK: return CScript() << ctx.ToPKBytes(keys[0]);\n+            case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(keys[0]) << OP_EQUALVERIFY;\n+            case NodeType::OLDER: return CScript() << k << OP_CHECKSEQUENCEVERIFY;\n+            case NodeType::AFTER: return CScript() << k << OP_CHECKLOCKTIMEVERIFY;\n+            case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + subs[0]->MakeScript(ctx) + (CScript() << OP_FROMALTSTACK);\n+            case NodeType::WRAP_S: return (CScript() << OP_SWAP) + subs[0]->MakeScript(ctx, verify);\n+            case NodeType::WRAP_C: return subs[0]->MakeScript(ctx) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+            case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_V: return subs[0]->MakeScript(ctx, true) + (subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+            case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_N: return subs[0]->MakeScript(ctx) + CScript() << OP_0NOTEQUAL;\n+            case NodeType::TRUE: return CScript() << OP_1;\n+            case NodeType::FALSE: return CScript() << OP_0;\n+            case NodeType::AND_V: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx, verify);\n+            case NodeType::AND_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLAND);\n+            case NodeType::OR_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLOR);\n+            case NodeType::OR_D: return subs[0]->MakeScript(ctx) + (CScript() << OP_IFDUP << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_C: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_I: return (CScript() << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::ANDOR: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[2]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::THRESH_M: {\n+                CScript script = CScript() << k;\n+                for (const auto& key : keys) {\n+                    script << ctx.ToPKBytes(key);\n+                }\n+                return script << keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+            }\n+            case NodeType::THRESH: {\n+                CScript script = subs[0]->MakeScript(ctx);\n+                for (size_t i = 1; i < subs.size(); ++i) {\n+                    script = (script + subs[i]->MakeScript(ctx)) << OP_ADD;\n+                }\n+                return script << k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            }\n+        }\n+        assert(false);\n+        return {};\n+    }\n+\n+    //! Internal code for ToString.\n+    template<typename Ctx>\n+    std::string MakeString(const Ctx& ctx, bool& success, bool wrapped = false) const {\n+        switch (nodetype) {\n+            case NodeType::WRAP_A: return \"a\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_S: return \"s\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_C: return \"c\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_D: return \"d\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_V: return \"v\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_J: return \"j\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_N: return \"n\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::AND_V:\n+                // t:X is syntactic sugar for and_v(X,1).\n+                if (subs[1]->nodetype == NodeType::TRUE) return \"t\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            case NodeType::OR_I:\n+                if (subs[0]->nodetype == NodeType::FALSE) return \"l\" + subs[1]->MakeString(ctx, success, true);\n+                if (subs[1]->nodetype == NodeType::FALSE) return \"u\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        std::string ret = wrapped ? \":\" : \"\";\n+\n+        switch (nodetype) {\n+            case NodeType::PK: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::PK_H: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::AFTER: return std::move(ret) + \"after(\" + std::to_string(k) + \")\";\n+            case NodeType::OLDER: return std::move(ret) + \"older(\" + std::to_string(k) + \")\";\n+            case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::TRUE: return std::move(ret) + \"1\";\n+            case NodeType::FALSE: return std::move(ret) + \"0\";\n+            case NodeType::AND_V: return std::move(ret) + \"and_v(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::AND_B: return std::move(ret) + \"and_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_B: return std::move(ret) + \"or_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_D: return std::move(ret) + \"or_d(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_C: return std::move(ret) + \"or_c(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_I: return std::move(ret) + \"or_i(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::ANDOR:\n+                // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                if (subs[2]->nodetype == NodeType::FALSE) return std::move(ret) + \"and_n(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+                return std::move(ret) + \"andor(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \",\" + subs[2]->MakeString(ctx, success) + \")\";\n+            case NodeType::THRESH_M: {\n+                auto str = std::move(ret) + \"thresh_m(\" + std::to_string(k);\n+                for (const auto& key : keys) {\n+                    std::string key_str;\n+                    success &= ctx.ToString(key, key_str);\n+                    str += \",\" + std::move(key_str);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            case NodeType::THRESH: {\n+                auto str = std::move(ret) + \"thresh(\" + std::to_string(k);\n+                for (const auto& sub : subs) {\n+                    str += \",\" + sub->MakeString(ctx, success);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            default: assert(false); // Wrappers should have been handled above\n+        }\n+        return \"\";\n+    }\n+\n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {0, 0, 0};\n+            case NodeType::PK_H: return {3, 0, 0};\n+            case NodeType::OLDER: return {1, 0, {}};\n+            case NodeType::AFTER: return {1, 0, {}};\n+            case NodeType::SHA256: return {4, 0, {}};\n+            case NodeType::RIPEMD160: return {4, 0, {}};\n+            case NodeType::HASH256: return {4, 0, {}};\n+            case NodeType::HASH160: return {4, 0, {}};\n+            case NodeType::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case NodeType::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case NodeType::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case NodeType::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case NodeType::THRESH_M: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case NodeType::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case NodeType::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::TRUE: return {0, 0, {}};\n+            case NodeType::FALSE: return {0, {}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t stat = 0, dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    dsat += sub->ops.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ops.sat.valid) diffs.push_back((int32_t)sub->ops.sat.value - sub->ops.dsat.value);\n+                }\n+                if (diffs.size() < k) return {stat, {}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {stat, sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {1, 1};\n+            case NodeType::PK_H: return {2, 2};\n+            case NodeType::OLDER: return {0, {}};\n+            case NodeType::AFTER: return {0, {}};\n+            case NodeType::SHA256: return {1, {}};\n+            case NodeType::RIPEMD160: return {1, {}};\n+            case NodeType::HASH256: return {1, {}};\n+            case NodeType::HASH160: return {1, {}};\n+            case NodeType::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case NodeType::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case NodeType::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case NodeType::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case NodeType::THRESH_M: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case NodeType::WRAP_A: return subs[0]->ss;\n+            case NodeType::WRAP_S: return subs[0]->ss;\n+            case NodeType::WRAP_C: return subs[0]->ss;\n+            case NodeType::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case NodeType::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_N: return subs[0]->ss;\n+            case NodeType::TRUE: return {0, {}};\n+            case NodeType::FALSE: return {{}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    dsat += sub->ss.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ss.sat.valid) diffs.push_back((int32_t)sub->ss.sat.value - sub->ss.dsat.value);\n+                }\n+                if (diffs.size() < k) return {{}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n+public:\n+    //! Return the size of the script for this expression (faster than ToString().size()).\n+    size_t ScriptSize() const { return scriptlen; }\n+\n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.stat + ops.sat.value; }\n+\n+    //! Check the ops limit of this script against the consensus limit.\n+    bool CheckOpsLimit() const { return GetOps() <= MAX_OPS_PER_SCRIPT; }\n+\n+    //! Return the maximum number of stack elements needed to satisfy this script non-malleably.\n+    uint32_t GetStackSize() const { return ss.sat.value; }\n+\n+    //! Check the maximum stack size for this script against the policy limit.\n+    bool CheckStackSize() const { return GetStackSize() <= MAX_STANDARD_P2WSH_STACK_ITEMS; }\n+\n+    //! Return the expression type.\n+    Type GetType() const { return typ; }\n+\n+    //! Check whether this node is valid at all.\n+    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+\n+    //! Check whether this node is valid as a script on its own.\n+    bool IsValidTopLevel() const { return GetType() << \"B\"_mst; }\n+\n+    //! Check whether this script can always be satisfied in a non-malleable way.\n+    bool IsNonMalleable() const { return GetType() << \"m\"_mst; }\n+\n+    //! Check whether this script always needs a signature.\n+    bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n+\n+    //! Do all sanity checks.\n+    bool IsSafeTopLevel() const { return GetType() << \"Bms\"_mst && CheckOpsLimit() && CheckStackSize(); }\n+\n+    //! Construct the script for this miniscript (including subexpressions).\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const { return MakeScript(ctx); }\n+\n+    //! Convert this miniscript to its textual descriptor notation.\n+    template<typename Ctx>\n+    bool ToString(const Ctx& ctx, std::string& out) const {\n+        bool ret = true;\n+        out = MakeString(ctx, ret);\n+        if (!ret) out = \"\";\n+        return ret;\n+    }\n+\n+    //! Equality testing.\n+    bool operator==(const Node<Key>& arg) const\n+    {\n+        if (nodetype != arg.nodetype) return false;\n+        if (k != arg.k) return false;\n+        if (data != arg.data) return false;\n+        if (keys != arg.keys) return false;\n+        if (subs.size() != arg.subs.size()) return false;\n+        for (size_t i = 0; i < subs.size(); ++i) {\n+            if (!(*subs[i] == *arg.subs[i])) return false;\n+        }\n+        assert(scriptlen == arg.scriptlen);\n+        assert(typ == arg.typ);\n+        return true;\n+    }\n+\n+    // Constructors with various argument combinations.\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+};\n+\n+namespace internal {\n+\n+//! Parse a miniscript from its textual descriptor form.\n+template<typename Key, typename Ctx>\n+inline NodeRef<Key> Parse(Span<const char>& in, const Ctx& ctx) {\n+    auto expr = Expr(in);\n+    // Parse wrappers\n+    for (int i = 0; i < expr.size(); ++i) {\n+        if (expr[i] == ':') {\n+            auto in2 = expr.subspan(i + 1);\n+            auto sub = Parse<Key>(in2, ctx);\n+            if (!sub || in2.size()) return {};\n+            for (size_t j = i; j-- > 0; ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320710696",
      "id" : 320710696,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDcxMDY5Ng==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 599,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 283549870,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320710696",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902315"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902315"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks for investigating; fixed.",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T18:13:21Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\"_mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    FALSE,     //!< OP_0\n+    TRUE,      //!< OP_1\n+    PK,        //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERFIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    THRESH_M,  //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK/PK_H/THRESH_M)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+    //! Internal code for ToScript.\n+    template<typename Ctx>\n+    CScript MakeScript(const Ctx& ctx, bool verify = false) const {\n+        std::vector<unsigned char> bytes;\n+        switch (nodetype) {\n+            case NodeType::PK: return CScript() << ctx.ToPKBytes(keys[0]);\n+            case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(keys[0]) << OP_EQUALVERIFY;\n+            case NodeType::OLDER: return CScript() << k << OP_CHECKSEQUENCEVERIFY;\n+            case NodeType::AFTER: return CScript() << k << OP_CHECKLOCKTIMEVERIFY;\n+            case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + subs[0]->MakeScript(ctx) + (CScript() << OP_FROMALTSTACK);\n+            case NodeType::WRAP_S: return (CScript() << OP_SWAP) + subs[0]->MakeScript(ctx, verify);\n+            case NodeType::WRAP_C: return subs[0]->MakeScript(ctx) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+            case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_V: return subs[0]->MakeScript(ctx, true) + (subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+            case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_N: return subs[0]->MakeScript(ctx) + CScript() << OP_0NOTEQUAL;\n+            case NodeType::TRUE: return CScript() << OP_1;\n+            case NodeType::FALSE: return CScript() << OP_0;\n+            case NodeType::AND_V: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx, verify);\n+            case NodeType::AND_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLAND);\n+            case NodeType::OR_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLOR);\n+            case NodeType::OR_D: return subs[0]->MakeScript(ctx) + (CScript() << OP_IFDUP << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_C: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_I: return (CScript() << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::ANDOR: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[2]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::THRESH_M: {\n+                CScript script = CScript() << k;\n+                for (const auto& key : keys) {\n+                    script << ctx.ToPKBytes(key);\n+                }\n+                return script << keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+            }\n+            case NodeType::THRESH: {\n+                CScript script = subs[0]->MakeScript(ctx);\n+                for (size_t i = 1; i < subs.size(); ++i) {\n+                    script = (script + subs[i]->MakeScript(ctx)) << OP_ADD;\n+                }\n+                return script << k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            }\n+        }\n+        assert(false);\n+        return {};\n+    }\n+\n+    //! Internal code for ToString.\n+    template<typename Ctx>\n+    std::string MakeString(const Ctx& ctx, bool& success, bool wrapped = false) const {\n+        switch (nodetype) {\n+            case NodeType::WRAP_A: return \"a\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_S: return \"s\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_C: return \"c\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_D: return \"d\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_V: return \"v\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_J: return \"j\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_N: return \"n\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::AND_V:\n+                // t:X is syntactic sugar for and_v(X,1).\n+                if (subs[1]->nodetype == NodeType::TRUE) return \"t\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            case NodeType::OR_I:\n+                if (subs[0]->nodetype == NodeType::FALSE) return \"l\" + subs[1]->MakeString(ctx, success, true);\n+                if (subs[1]->nodetype == NodeType::FALSE) return \"u\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        std::string ret = wrapped ? \":\" : \"\";\n+\n+        switch (nodetype) {\n+            case NodeType::PK: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::PK_H: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::AFTER: return std::move(ret) + \"after(\" + std::to_string(k) + \")\";\n+            case NodeType::OLDER: return std::move(ret) + \"older(\" + std::to_string(k) + \")\";\n+            case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::TRUE: return std::move(ret) + \"1\";\n+            case NodeType::FALSE: return std::move(ret) + \"0\";\n+            case NodeType::AND_V: return std::move(ret) + \"and_v(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::AND_B: return std::move(ret) + \"and_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_B: return std::move(ret) + \"or_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_D: return std::move(ret) + \"or_d(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_C: return std::move(ret) + \"or_c(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_I: return std::move(ret) + \"or_i(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::ANDOR:\n+                // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                if (subs[2]->nodetype == NodeType::FALSE) return std::move(ret) + \"and_n(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+                return std::move(ret) + \"andor(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \",\" + subs[2]->MakeString(ctx, success) + \")\";\n+            case NodeType::THRESH_M: {\n+                auto str = std::move(ret) + \"thresh_m(\" + std::to_string(k);\n+                for (const auto& key : keys) {\n+                    std::string key_str;\n+                    success &= ctx.ToString(key, key_str);\n+                    str += \",\" + std::move(key_str);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            case NodeType::THRESH: {\n+                auto str = std::move(ret) + \"thresh(\" + std::to_string(k);\n+                for (const auto& sub : subs) {\n+                    str += \",\" + sub->MakeString(ctx, success);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            default: assert(false); // Wrappers should have been handled above\n+        }\n+        return \"\";\n+    }\n+\n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {0, 0, 0};\n+            case NodeType::PK_H: return {3, 0, 0};\n+            case NodeType::OLDER: return {1, 0, {}};\n+            case NodeType::AFTER: return {1, 0, {}};\n+            case NodeType::SHA256: return {4, 0, {}};\n+            case NodeType::RIPEMD160: return {4, 0, {}};\n+            case NodeType::HASH256: return {4, 0, {}};\n+            case NodeType::HASH160: return {4, 0, {}};\n+            case NodeType::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case NodeType::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case NodeType::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case NodeType::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case NodeType::THRESH_M: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case NodeType::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case NodeType::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::TRUE: return {0, 0, {}};\n+            case NodeType::FALSE: return {0, {}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t stat = 0, dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    dsat += sub->ops.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ops.sat.valid) diffs.push_back((int32_t)sub->ops.sat.value - sub->ops.dsat.value);\n+                }\n+                if (diffs.size() < k) return {stat, {}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {stat, sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {1, 1};\n+            case NodeType::PK_H: return {2, 2};\n+            case NodeType::OLDER: return {0, {}};\n+            case NodeType::AFTER: return {0, {}};\n+            case NodeType::SHA256: return {1, {}};\n+            case NodeType::RIPEMD160: return {1, {}};\n+            case NodeType::HASH256: return {1, {}};\n+            case NodeType::HASH160: return {1, {}};\n+            case NodeType::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case NodeType::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case NodeType::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case NodeType::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case NodeType::THRESH_M: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case NodeType::WRAP_A: return subs[0]->ss;\n+            case NodeType::WRAP_S: return subs[0]->ss;\n+            case NodeType::WRAP_C: return subs[0]->ss;\n+            case NodeType::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case NodeType::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_N: return subs[0]->ss;\n+            case NodeType::TRUE: return {0, {}};\n+            case NodeType::FALSE: return {{}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    dsat += sub->ss.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ss.sat.valid) diffs.push_back((int32_t)sub->ss.sat.value - sub->ss.dsat.value);\n+                }\n+                if (diffs.size() < k) return {{}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {{}, {}};\n+    }\n+\n+public:\n+    //! Return the size of the script for this expression (faster than ToString().size()).\n+    size_t ScriptSize() const { return scriptlen; }\n+\n+    //! Return the maximum number of ops needed to satisfy this script non-malleably.\n+    uint32_t GetOps() const { return ops.stat + ops.sat.value; }\n+\n+    //! Check the ops limit of this script against the consensus limit.\n+    bool CheckOpsLimit() const { return GetOps() <= MAX_OPS_PER_SCRIPT; }\n+\n+    //! Return the maximum number of stack elements needed to satisfy this script non-malleably.\n+    uint32_t GetStackSize() const { return ss.sat.value; }\n+\n+    //! Check the maximum stack size for this script against the policy limit.\n+    bool CheckStackSize() const { return GetStackSize() <= MAX_STANDARD_P2WSH_STACK_ITEMS; }\n+\n+    //! Return the expression type.\n+    Type GetType() const { return typ; }\n+\n+    //! Check whether this node is valid at all.\n+    bool IsValid() const { return !(GetType() == \"\"_mst); }\n+\n+    //! Check whether this node is valid as a script on its own.\n+    bool IsValidTopLevel() const { return GetType() << \"B\"_mst; }\n+\n+    //! Check whether this script can always be satisfied in a non-malleable way.\n+    bool IsNonMalleable() const { return GetType() << \"m\"_mst; }\n+\n+    //! Check whether this script always needs a signature.\n+    bool NeedsSignature() const { return GetType() << \"s\"_mst; }\n+\n+    //! Do all sanity checks.\n+    bool IsSafeTopLevel() const { return GetType() << \"Bms\"_mst && CheckOpsLimit() && CheckStackSize(); }\n+\n+    //! Construct the script for this miniscript (including subexpressions).\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const { return MakeScript(ctx); }\n+\n+    //! Convert this miniscript to its textual descriptor notation.\n+    template<typename Ctx>\n+    bool ToString(const Ctx& ctx, std::string& out) const {\n+        bool ret = true;\n+        out = MakeString(ctx, ret);\n+        if (!ret) out = \"\";\n+        return ret;\n+    }\n+\n+    //! Equality testing.\n+    bool operator==(const Node<Key>& arg) const\n+    {\n+        if (nodetype != arg.nodetype) return false;\n+        if (k != arg.k) return false;\n+        if (data != arg.data) return false;\n+        if (keys != arg.keys) return false;\n+        if (subs.size() != arg.subs.size()) return false;\n+        for (size_t i = 0; i < subs.size(); ++i) {\n+            if (!(*subs[i] == *arg.subs[i])) return false;\n+        }\n+        assert(scriptlen == arg.scriptlen);\n+        assert(typ == arg.typ);\n+        return true;\n+    }\n+\n+    // Constructors with various argument combinations.\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<unsigned char> arg, uint32_t val = 0) : nodetype(nt), k(val), data(std::move(arg)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<Key> key, uint32_t val = 0) : nodetype(nt), k(val), keys(std::move(key)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, std::vector<NodeRef<Key>> sub, uint32_t val = 0) : nodetype(nt), k(val), subs(std::move(sub)), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+    Node(NodeType nt, uint32_t val = 0) : nodetype(nt), k(val), ops(CalcOps()), ss(CalcStackSize()), typ(CalcType()), scriptlen(CalcScriptLen()) {}\n+};\n+\n+namespace internal {\n+\n+//! Parse a miniscript from its textual descriptor form.\n+template<typename Key, typename Ctx>\n+inline NodeRef<Key> Parse(Span<const char>& in, const Ctx& ctx) {\n+    auto expr = Expr(in);\n+    // Parse wrappers\n+    for (int i = 0; i < expr.size(); ++i) {\n+        if (expr[i] == ':') {\n+            auto in2 = expr.subspan(i + 1);\n+            auto sub = Parse<Key>(in2, ctx);\n+            if (!sub || in2.size()) return {};\n+            for (size_t j = i; j-- > 0; ) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902315",
      "id" : 320902315,
      "in_reply_to_id" : 320710696,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDkwMjMxNQ==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 599,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 283801896,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902315",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902469"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902469"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed pedantry by using `const KeyConverter CONVERTER{};` instead.",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T18:13:43Z",
      "diff_hunk" : "@@ -0,0 +1,351 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\n+#include <string>\n+\n+#include <test/setup_common.h>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <uint256.h>\n+#include <crypto/ripemd160.h>\n+#include <crypto/sha256.h>\n+#include <script/miniscript.h>\n+\n+namespace {\n+\n+/** TestData groups various kinds of precomputed data necessary in this test. */\n+struct TestData {\n+    //! The only public keys used in this test.\n+    std::vector<CPubKey> pubkeys;\n+    //! A map from the public keys to their CKeyIDs (faster than hashing every time).\n+    std::map<CPubKey, CKeyID> pkhashes;\n+    std::map<CKeyID, CPubKey> pkmap;\n+\n+    // Various precomputed hashes\n+    std::vector<std::vector<unsigned char>> sha256;\n+    std::vector<std::vector<unsigned char>> ripemd160;\n+    std::vector<std::vector<unsigned char>> hash256;\n+    std::vector<std::vector<unsigned char>> hash160;\n+\n+    TestData()\n+    {\n+        // We generate 255 public keys and 255 hashes of each type.\n+        for (int i = 1; i <= 255; ++i) {\n+            // This 32-byte array functions as both private key data and hash preimage (31 zero bytes plus any nonzero byte).\n+            unsigned char keydata[32] = {0};\n+            keydata[31] = i;\n+\n+            // Compute CPubkey and CKeyID\n+            CKey key;\n+            key.Set(keydata, keydata + 32, true);\n+            CPubKey pubkey = key.GetPubKey();\n+            CKeyID keyid = pubkey.GetID();\n+            pubkeys.push_back(pubkey);\n+            pkhashes.emplace(pubkey, keyid);\n+            pkmap.emplace(keyid, pubkey);\n+\n+            // Compute various hashes\n+            std::vector<unsigned char> hash;\n+            hash.resize(32);\n+            CSHA256().Write(keydata, 32).Finalize(hash.data());\n+            sha256.push_back(hash);\n+            CHash256().Write(keydata, 32).Finalize(hash.data());\n+            hash256.push_back(hash);\n+            hash.resize(20);\n+            CRIPEMD160().Write(keydata, 32).Finalize(hash.data());\n+            ripemd160.push_back(hash);\n+            CHash160().Write(keydata, 32).Finalize(hash.data());\n+            hash160.push_back(hash);\n+        }\n+    }\n+};\n+\n+//! Global TestData object\n+std::unique_ptr<const TestData> g_testdata;\n+\n+/** A class encapulating conversion routing for CPubKey. */\n+struct KeyConverter {\n+    typedef CPubKey Key;\n+\n+    //! Public keys in text form are their usual hex notation (no xpubs, ...).\n+    bool ToString(const CPubKey& key, std::string& ret) const { ret = HexStr(key.begin(), key.end()); return true; }\n+\n+    //! Convert a public key to bytes.\n+    std::vector<unsigned char> ToPKBytes(const CPubKey& key) const { return {key.begin(), key.end()}; }\n+\n+    //! Convert a public key to its Hash160 bytes (precomputed).\n+    std::vector<unsigned char> ToPKHBytes(const CPubKey& key) const\n+    {\n+        auto it = g_testdata->pkhashes.find(key);\n+        assert(it != g_testdata->pkhashes.end());\n+        return {it->second.begin(), it->second.end()};\n+    }\n+\n+    //! Parse a public key from a range of hex characters.\n+    template<typename I>\n+    bool FromString(I first, I last, CPubKey& key) const {\n+        auto bytes = ParseHex(std::string(first, last));\n+        key.Set(bytes.begin(), bytes.end());\n+        return key.IsValid();\n+    }\n+\n+    template<typename I>\n+    bool FromPKBytes(I first, I last, CPubKey& key) const {\n+        key.Set(first, last);\n+        return key.IsValid();\n+    }\n+\n+    template<typename I>\n+    bool FromPKHBytes(I first, I last, CPubKey& key) const {\n+        assert(last - first == 20);\n+        CKeyID keyid;\n+        std::copy(first, last, keyid.begin());\n+        auto it = g_testdata->pkmap.find(keyid);\n+        assert(it != g_testdata->pkmap.end());\n+        key = it->second;\n+        return true;\n+    }\n+};\n+\n+//! Singleton instance of KeyConverter.\n+const KeyConverter CONVERTER;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902469",
      "id" : 320902469,
      "in_reply_to_id" : 320709735,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDkwMjQ2OQ==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 115,
      "path" : "src/test/miniscript_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 283802118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902469",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902597"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed by renaming to `JUST_0` and `JUST_1`.",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T18:13:59Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\"_mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    FALSE,     //!< OP_0\n+    TRUE,      //!< OP_1",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r320902597",
      "id" : 320902597,
      "in_reply_to_id" : 320708381,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMDkwMjU5Nw==",
      "original_commit_id" : "892acd4877e0fbf91157198ef7f0734bd5cd36ac",
      "original_position" : 165,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 283802289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/320902597",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@practicalswift Thanks for reminding me, I had forgotten about those (and wasn't really looking at the miniscript repo while working on this PR). Specifically:\r\n* The overflow/underflow issue and the OOM issue don't apply here, as they're in the compiler code which I'm not PR'ing here.\r\n* The unhandled exception I've fixed independently because `stoul` and friends are locale dependent (both here and upstream).\r\n* The stack depth we need to fix still, I've commented on the issue.\r\n\r\nAlso, this PR should be perfectly in sync with the upstream repo, so if you want to PR fixes, they can go there preferably, and I'll incorporate them here.",
      "created_at" : "2019-09-04T18:18:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#issuecomment-528022659",
      "id" : 528022659,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16800",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyODAyMjY1OQ==",
      "updated_at" : "2019-09-04T18:18:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/528022659",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r321021420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321021420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Looks like this is still failing on https://bitcoinbuilds.org/index.php?job=e1623137-779c-47dd-8a8a-ebaee60766ec\r\n\r\n```\r\nEntering test module \"Bitcoin Core Test Suite\"\r\ntest/miniscript_tests.cpp(282): Entering test suite \"miniscript_tests\"\r\ntest/miniscript_tests.cpp(284): Entering test case \"fixed_tests\"\r\ntest/miniscript_tests.cpp(284): Leaving test case \"fixed_tests\"; testing time: 35249us\r\ntest/miniscript_tests.cpp(322): Entering test case \"random_tests\"\r\nscript/miniscript.h:508:33: runtime error: unsigned integer overflow: 4294967295 + 11 cannot be represented in type 'unsigned int'\r\n    #0 0x561901402481 in miniscript::Node<CPubKey>::CalcStackSize() const /home/ubuntu/src/src/./script/miniscript.h:508:33",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-04T23:41:26Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,     //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK,        //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERFIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    THRESH_M,  //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK/PK_H/THRESH_M)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+    //! Internal code for ToScript.\n+    template<typename Ctx>\n+    CScript MakeScript(const Ctx& ctx, bool verify = false) const {\n+        std::vector<unsigned char> bytes;\n+        switch (nodetype) {\n+            case NodeType::PK: return CScript() << ctx.ToPKBytes(keys[0]);\n+            case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(keys[0]) << OP_EQUALVERIFY;\n+            case NodeType::OLDER: return CScript() << k << OP_CHECKSEQUENCEVERIFY;\n+            case NodeType::AFTER: return CScript() << k << OP_CHECKLOCKTIMEVERIFY;\n+            case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + subs[0]->MakeScript(ctx) + (CScript() << OP_FROMALTSTACK);\n+            case NodeType::WRAP_S: return (CScript() << OP_SWAP) + subs[0]->MakeScript(ctx, verify);\n+            case NodeType::WRAP_C: return subs[0]->MakeScript(ctx) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+            case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_V: return subs[0]->MakeScript(ctx, true) + (subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+            case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_N: return subs[0]->MakeScript(ctx) + CScript() << OP_0NOTEQUAL;\n+            case NodeType::JUST_1: return CScript() << OP_1;\n+            case NodeType::JUST_0: return CScript() << OP_0;\n+            case NodeType::AND_V: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx, verify);\n+            case NodeType::AND_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLAND);\n+            case NodeType::OR_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLOR);\n+            case NodeType::OR_D: return subs[0]->MakeScript(ctx) + (CScript() << OP_IFDUP << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_C: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_I: return (CScript() << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::ANDOR: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[2]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::THRESH_M: {\n+                CScript script = CScript() << k;\n+                for (const auto& key : keys) {\n+                    script << ctx.ToPKBytes(key);\n+                }\n+                return script << keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+            }\n+            case NodeType::THRESH: {\n+                CScript script = subs[0]->MakeScript(ctx);\n+                for (size_t i = 1; i < subs.size(); ++i) {\n+                    script = (script + subs[i]->MakeScript(ctx)) << OP_ADD;\n+                }\n+                return script << k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            }\n+        }\n+        assert(false);\n+        return {};\n+    }\n+\n+    //! Internal code for ToString.\n+    template<typename Ctx>\n+    std::string MakeString(const Ctx& ctx, bool& success, bool wrapped = false) const {\n+        switch (nodetype) {\n+            case NodeType::WRAP_A: return \"a\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_S: return \"s\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_C: return \"c\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_D: return \"d\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_V: return \"v\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_J: return \"j\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_N: return \"n\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::AND_V:\n+                // t:X is syntactic sugar for and_v(X,1).\n+                if (subs[1]->nodetype == NodeType::JUST_1) return \"t\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            case NodeType::OR_I:\n+                if (subs[0]->nodetype == NodeType::JUST_0) return \"l\" + subs[1]->MakeString(ctx, success, true);\n+                if (subs[1]->nodetype == NodeType::JUST_0) return \"u\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        std::string ret = wrapped ? \":\" : \"\";\n+\n+        switch (nodetype) {\n+            case NodeType::PK: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::PK_H: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::AFTER: return std::move(ret) + \"after(\" + std::to_string(k) + \")\";\n+            case NodeType::OLDER: return std::move(ret) + \"older(\" + std::to_string(k) + \")\";\n+            case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::JUST_1: return std::move(ret) + \"1\";\n+            case NodeType::JUST_0: return std::move(ret) + \"0\";\n+            case NodeType::AND_V: return std::move(ret) + \"and_v(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::AND_B: return std::move(ret) + \"and_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_B: return std::move(ret) + \"or_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_D: return std::move(ret) + \"or_d(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_C: return std::move(ret) + \"or_c(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_I: return std::move(ret) + \"or_i(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::ANDOR:\n+                // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                if (subs[2]->nodetype == NodeType::JUST_0) return std::move(ret) + \"and_n(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+                return std::move(ret) + \"andor(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \",\" + subs[2]->MakeString(ctx, success) + \")\";\n+            case NodeType::THRESH_M: {\n+                auto str = std::move(ret) + \"thresh_m(\" + std::to_string(k);\n+                for (const auto& key : keys) {\n+                    std::string key_str;\n+                    success &= ctx.ToString(key, key_str);\n+                    str += \",\" + std::move(key_str);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            case NodeType::THRESH: {\n+                auto str = std::move(ret) + \"thresh(\" + std::to_string(k);\n+                for (const auto& sub : subs) {\n+                    str += \",\" + sub->MakeString(ctx, success);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            default: assert(false); // Wrappers should have been handled above\n+        }\n+        return \"\";\n+    }\n+\n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {0, 0, 0};\n+            case NodeType::PK_H: return {3, 0, 0};\n+            case NodeType::OLDER: return {1, 0, {}};\n+            case NodeType::AFTER: return {1, 0, {}};\n+            case NodeType::SHA256: return {4, 0, {}};\n+            case NodeType::RIPEMD160: return {4, 0, {}};\n+            case NodeType::HASH256: return {4, 0, {}};\n+            case NodeType::HASH160: return {4, 0, {}};\n+            case NodeType::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case NodeType::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case NodeType::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case NodeType::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case NodeType::THRESH_M: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case NodeType::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case NodeType::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::JUST_1: return {0, 0, {}};\n+            case NodeType::JUST_0: return {0, {}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t stat = 0, dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    dsat += sub->ops.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ops.sat.valid) diffs.push_back((int32_t)sub->ops.sat.value - (int32_t)sub->ops.dsat.value);\n+                }\n+                if (diffs.size() < k) return {stat, {}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {stat, sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {1, 1};\n+            case NodeType::PK_H: return {2, 2};\n+            case NodeType::OLDER: return {0, {}};\n+            case NodeType::AFTER: return {0, {}};\n+            case NodeType::SHA256: return {1, {}};\n+            case NodeType::RIPEMD160: return {1, {}};\n+            case NodeType::HASH256: return {1, {}};\n+            case NodeType::HASH160: return {1, {}};\n+            case NodeType::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case NodeType::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case NodeType::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case NodeType::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case NodeType::THRESH_M: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case NodeType::WRAP_A: return subs[0]->ss;\n+            case NodeType::WRAP_S: return subs[0]->ss;\n+            case NodeType::WRAP_C: return subs[0]->ss;\n+            case NodeType::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case NodeType::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_N: return subs[0]->ss;\n+            case NodeType::JUST_1: return {0, {}};\n+            case NodeType::JUST_0: return {{}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    dsat += sub->ss.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ss.sat.valid) diffs.push_back((int32_t)sub->ss.sat.value - (int32_t)sub->ss.dsat.value);\n+                }\n+                if (diffs.size() < k) return {{}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {sat_sum + dsat, dsat};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r321021420",
      "id" : 321021420,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTAyMTQyMA==",
      "original_commit_id" : "046a0b9cc261f8ded799eeae9f6d11b9095ea03a",
      "original_position" : 508,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 283954717,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-05T22:32:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321021420",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r321829854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321829854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed by switching to a different algorithm.",
      "commit_id" : "037e55adc005e9d8253d3d35e7a30b2e8521389c",
      "created_at" : "2019-09-06T17:12:38Z",
      "diff_hunk" : "@@ -0,0 +1,992 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One final type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint16_t m_flags;\n+\n+    //! Internal constructed used by the \"\"_mst operator.\n+    explicit constexpr Type(uint16_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,     //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK,        //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERFIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    THRESH_M,  //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK/PK_H/THRESH_M)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+    //! Internal code for ToScript.\n+    template<typename Ctx>\n+    CScript MakeScript(const Ctx& ctx, bool verify = false) const {\n+        std::vector<unsigned char> bytes;\n+        switch (nodetype) {\n+            case NodeType::PK: return CScript() << ctx.ToPKBytes(keys[0]);\n+            case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(keys[0]) << OP_EQUALVERIFY;\n+            case NodeType::OLDER: return CScript() << k << OP_CHECKSEQUENCEVERIFY;\n+            case NodeType::AFTER: return CScript() << k << OP_CHECKLOCKTIMEVERIFY;\n+            case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + subs[0]->MakeScript(ctx) + (CScript() << OP_FROMALTSTACK);\n+            case NodeType::WRAP_S: return (CScript() << OP_SWAP) + subs[0]->MakeScript(ctx, verify);\n+            case NodeType::WRAP_C: return subs[0]->MakeScript(ctx) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+            case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_V: return subs[0]->MakeScript(ctx, true) + (subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+            case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::WRAP_N: return subs[0]->MakeScript(ctx) + CScript() << OP_0NOTEQUAL;\n+            case NodeType::JUST_1: return CScript() << OP_1;\n+            case NodeType::JUST_0: return CScript() << OP_0;\n+            case NodeType::AND_V: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx, verify);\n+            case NodeType::AND_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLAND);\n+            case NodeType::OR_B: return subs[0]->MakeScript(ctx) + subs[1]->MakeScript(ctx) + (CScript() << OP_BOOLOR);\n+            case NodeType::OR_D: return subs[0]->MakeScript(ctx) + (CScript() << OP_IFDUP << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_C: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::OR_I: return (CScript() << OP_IF) + subs[0]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::ANDOR: return subs[0]->MakeScript(ctx) + (CScript() << OP_NOTIF) + subs[2]->MakeScript(ctx) + (CScript() << OP_ELSE) + subs[1]->MakeScript(ctx) + (CScript() << OP_ENDIF);\n+            case NodeType::THRESH_M: {\n+                CScript script = CScript() << k;\n+                for (const auto& key : keys) {\n+                    script << ctx.ToPKBytes(key);\n+                }\n+                return script << keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+            }\n+            case NodeType::THRESH: {\n+                CScript script = subs[0]->MakeScript(ctx);\n+                for (size_t i = 1; i < subs.size(); ++i) {\n+                    script = (script + subs[i]->MakeScript(ctx)) << OP_ADD;\n+                }\n+                return script << k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+            }\n+        }\n+        assert(false);\n+        return {};\n+    }\n+\n+    //! Internal code for ToString.\n+    template<typename Ctx>\n+    std::string MakeString(const Ctx& ctx, bool& success, bool wrapped = false) const {\n+        switch (nodetype) {\n+            case NodeType::WRAP_A: return \"a\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_S: return \"s\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_C: return \"c\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_D: return \"d\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_V: return \"v\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_J: return \"j\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::WRAP_N: return \"n\" + subs[0]->MakeString(ctx, success, true);\n+            case NodeType::AND_V:\n+                // t:X is syntactic sugar for and_v(X,1).\n+                if (subs[1]->nodetype == NodeType::JUST_1) return \"t\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            case NodeType::OR_I:\n+                if (subs[0]->nodetype == NodeType::JUST_0) return \"l\" + subs[1]->MakeString(ctx, success, true);\n+                if (subs[1]->nodetype == NodeType::JUST_0) return \"u\" + subs[0]->MakeString(ctx, success, true);\n+                break;\n+            default:\n+                break;\n+        }\n+\n+        std::string ret = wrapped ? \":\" : \"\";\n+\n+        switch (nodetype) {\n+            case NodeType::PK: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::PK_H: {\n+                std::string key_str;\n+                success = ctx.ToString(keys[0], key_str);\n+                return std::move(ret) + \"pk_h(\" + std::move(key_str) + \")\";\n+            }\n+            case NodeType::AFTER: return std::move(ret) + \"after(\" + std::to_string(k) + \")\";\n+            case NodeType::OLDER: return std::move(ret) + \"older(\" + std::to_string(k) + \")\";\n+            case NodeType::HASH256: return std::move(ret) + \"hash256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::HASH160: return std::move(ret) + \"hash160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::SHA256: return std::move(ret) + \"sha256(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::RIPEMD160: return std::move(ret) + \"ripemd160(\" + HexStr(data.begin(), data.end()) + \")\";\n+            case NodeType::JUST_1: return std::move(ret) + \"1\";\n+            case NodeType::JUST_0: return std::move(ret) + \"0\";\n+            case NodeType::AND_V: return std::move(ret) + \"and_v(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::AND_B: return std::move(ret) + \"and_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_B: return std::move(ret) + \"or_b(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_D: return std::move(ret) + \"or_d(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_C: return std::move(ret) + \"or_c(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::OR_I: return std::move(ret) + \"or_i(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+            case NodeType::ANDOR:\n+                // and_n(X,Y) is syntactic sugar for andor(X,Y,0).\n+                if (subs[2]->nodetype == NodeType::JUST_0) return std::move(ret) + \"and_n(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \")\";\n+                return std::move(ret) + \"andor(\" + subs[0]->MakeString(ctx, success) + \",\" + subs[1]->MakeString(ctx, success) + \",\" + subs[2]->MakeString(ctx, success) + \")\";\n+            case NodeType::THRESH_M: {\n+                auto str = std::move(ret) + \"thresh_m(\" + std::to_string(k);\n+                for (const auto& key : keys) {\n+                    std::string key_str;\n+                    success &= ctx.ToString(key, key_str);\n+                    str += \",\" + std::move(key_str);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            case NodeType::THRESH: {\n+                auto str = std::move(ret) + \"thresh(\" + std::to_string(k);\n+                for (const auto& sub : subs) {\n+                    str += \",\" + sub->MakeString(ctx, success);\n+                }\n+                return std::move(str) + \")\";\n+            }\n+            default: assert(false); // Wrappers should have been handled above\n+        }\n+        return \"\";\n+    }\n+\n+    internal::Ops CalcOps() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {0, 0, 0};\n+            case NodeType::PK_H: return {3, 0, 0};\n+            case NodeType::OLDER: return {1, 0, {}};\n+            case NodeType::AFTER: return {1, 0, {}};\n+            case NodeType::SHA256: return {4, 0, {}};\n+            case NodeType::RIPEMD160: return {4, 0, {}};\n+            case NodeType::HASH256: return {4, 0, {}};\n+            case NodeType::HASH160: return {4, 0, {}};\n+            case NodeType::AND_V: return {subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, {}};\n+            case NodeType::AND_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, subs[0]->ops.sat + subs[1]->ops.sat, subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_B: return {1 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat + subs[1]->ops.dsat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_D: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), subs[0]->ops.dsat + subs[1]->ops.dsat};\n+            case NodeType::OR_C: return {2 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat + subs[0]->ops.dsat), {}};\n+            case NodeType::OR_I: return {3 + subs[0]->ops.stat + subs[1]->ops.stat, Choose(subs[0]->ops.sat, subs[1]->ops.sat), Choose(subs[0]->ops.dsat, subs[1]->ops.dsat)};\n+            case NodeType::ANDOR: return {3 + subs[0]->ops.stat + subs[1]->ops.stat + subs[2]->ops.stat, Choose(subs[1]->ops.sat + subs[0]->ops.sat, subs[0]->ops.dsat + subs[2]->ops.sat), subs[0]->ops.dsat + subs[2]->ops.dsat};\n+            case NodeType::THRESH_M: return {1, (uint32_t)keys.size(), (uint32_t)keys.size()};\n+            case NodeType::WRAP_A: return {2 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_S: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_C: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::WRAP_D: return {3 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_V: return {subs[0]->ops.stat + (subs[0]->GetType() << \"x\"_mst), subs[0]->ops.sat, {}};\n+            case NodeType::WRAP_J: return {4 + subs[0]->ops.stat, subs[0]->ops.sat, 0};\n+            case NodeType::WRAP_N: return {1 + subs[0]->ops.stat, subs[0]->ops.sat, subs[0]->ops.dsat};\n+            case NodeType::JUST_1: return {0, 0, {}};\n+            case NodeType::JUST_0: return {0, {}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t stat = 0, dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    stat += sub->ops.stat + 1;\n+                    dsat += sub->ops.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ops.sat.valid) diffs.push_back((int32_t)sub->ops.sat.value - (int32_t)sub->ops.dsat.value);\n+                }\n+                if (diffs.size() < k) return {stat, {}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {stat, sat_sum + dsat, dsat};\n+            }\n+        }\n+        assert(false);\n+        return {0, {}, {}};\n+    }\n+\n+    internal::StackSize CalcStackSize() const {\n+        switch (nodetype) {\n+            case NodeType::PK: return {1, 1};\n+            case NodeType::PK_H: return {2, 2};\n+            case NodeType::OLDER: return {0, {}};\n+            case NodeType::AFTER: return {0, {}};\n+            case NodeType::SHA256: return {1, {}};\n+            case NodeType::RIPEMD160: return {1, {}};\n+            case NodeType::HASH256: return {1, {}};\n+            case NodeType::HASH160: return {1, {}};\n+            case NodeType::ANDOR: return {Choose(subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[2]->ss.sat), subs[0]->ss.dsat + subs[2]->ss.dsat};\n+            case NodeType::AND_V: return {subs[0]->ss.sat + subs[1]->ss.sat, {}};\n+            case NodeType::AND_B: return {subs[0]->ss.sat + subs[1]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_B: return {Choose(subs[0]->ss.dsat + subs[1]->ss.sat, subs[0]->ss.sat + subs[1]->ss.dsat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_C: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), {}};\n+            case NodeType::OR_D: return {Choose(subs[0]->ss.sat, subs[0]->ss.dsat + subs[1]->ss.sat), subs[0]->ss.dsat + subs[1]->ss.dsat};\n+            case NodeType::OR_I: return {Choose(subs[0]->ss.sat + 1, subs[1]->ss.sat + 1), Choose(subs[0]->ss.dsat + 1, subs[1]->ss.dsat + 1)};\n+            case NodeType::THRESH_M: return {(uint32_t)keys.size() + 1, (uint32_t)keys.size() + 1};\n+            case NodeType::WRAP_A: return subs[0]->ss;\n+            case NodeType::WRAP_S: return subs[0]->ss;\n+            case NodeType::WRAP_C: return subs[0]->ss;\n+            case NodeType::WRAP_D: return {1 + subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_V: return {subs[0]->ss.sat, {}};\n+            case NodeType::WRAP_J: return {subs[0]->ss.sat, 1};\n+            case NodeType::WRAP_N: return subs[0]->ss;\n+            case NodeType::JUST_1: return {0, {}};\n+            case NodeType::JUST_0: return {{}, 0};\n+            case NodeType::THRESH: {\n+                uint32_t dsat = 0;\n+                int32_t sat_sum = 0;\n+                std::vector<int32_t> diffs;\n+                for (const auto& sub : subs) {\n+                    dsat += sub->ss.dsat.value; // The type system requires \"d\" for thresh, so dsat must always be valid.\n+                    if (sub->ss.sat.valid) diffs.push_back((int32_t)sub->ss.sat.value - (int32_t)sub->ss.dsat.value);\n+                }\n+                if (diffs.size() < k) return {{}, dsat};\n+                std::sort(diffs.begin(), diffs.end());\n+                for (size_t i = diffs.size() - k; i < diffs.size(); ++i) sat_sum += diffs[i];\n+                return {sat_sum + dsat, dsat};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16800#discussion_r321829854",
      "id" : 321829854,
      "in_reply_to_id" : 321021420,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTgyOTg1NA==",
      "original_commit_id" : "046a0b9cc261f8ded799eeae9f6d11b9095ea03a",
      "original_position" : 508,
      "path" : "src/script/miniscript.h",
      "position" : null,
      "pull_request_review_id" : 284991288,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16800",
      "updated_at" : "2019-09-06T17:12:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321829854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
