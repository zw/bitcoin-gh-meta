[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99413385"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99413385"
         }
      },
      "body" : "Is there some reason not to use exceptions?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-03T20:09:30Z",
      "diff_hunk" : "@@ -786,6 +786,21 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, bool keepReserveKey = true, const CTxDestination& destChange = CNoDestination());\n \n     /**\n+     * Bumps the fee of an opt-in-RBF transaction <txid>,\n+     * replacing it with a new transaction <wtxNew>\n+     */\n+    enum BumpFeeResult\n+    {\n+        BumpFeeResult_OK,\n+        BumpFeeResult_INVALID_ADDRESS_OR_KEY,\n+        BumpFeeResult_INVALID_REQUEST,\n+        BumpFeeResult_INVALID_PARAMETER,\n+        BumpFeeResult_WALLET_ERROR,\n+        BumpFeeResult_MISC_ERROR,\n+    };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99413385",
      "id" : 99413385,
      "original_commit_id" : "45ec058131e2d0066c2db396e3090a183032b407",
      "original_position" : 15,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 20093949,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99413385",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99413798"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99413798"
         }
      },
      "body" : "I though about using exceptions but came to the conclusion that a simple result state enum will (probably) allow more flexibility for further optimisations. But no strong opinion.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-03T20:12:01Z",
      "diff_hunk" : "@@ -786,6 +786,21 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, bool keepReserveKey = true, const CTxDestination& destChange = CNoDestination());\n \n     /**\n+     * Bumps the fee of an opt-in-RBF transaction <txid>,\n+     * replacing it with a new transaction <wtxNew>\n+     */\n+    enum BumpFeeResult\n+    {\n+        BumpFeeResult_OK,\n+        BumpFeeResult_INVALID_ADDRESS_OR_KEY,\n+        BumpFeeResult_INVALID_REQUEST,\n+        BumpFeeResult_INVALID_PARAMETER,\n+        BumpFeeResult_WALLET_ERROR,\n+        BumpFeeResult_MISC_ERROR,\n+    };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99413798",
      "id" : 99413798,
      "original_commit_id" : "45ec058131e2d0066c2db396e3090a183032b407",
      "original_position" : 15,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 20094408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99413798",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "I prefer an enum here (I'll elaborate if wanted).",
      "created_at" : "2017-02-03T20:13:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-277350461",
      "id" : 277350461,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-02-03T20:13:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/277350461",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Concept ACK, it is better to have this in wallet than in the RPC code, especially as the code is going to be used by the GUI.\r\n\r\nNo opinion on how to handle the errors. Though returning an enum is consistent with some other wallet functions that return a status.\r\n\r\nAside: As said earlier on IRC I'm not entirely happy with the current trend of moving everything wallet related to CWallet - we're creating a \"god class\". It would be nice to see if we can parcel up the functionality and separate concerns, to avoid a huge file and exponentially growing complexity.\r\n\r\nBut in any case, this is a step forward...\r\n",
      "created_at" : "2017-02-06T13:26:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-277679692",
      "id" : 277679692,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-02-06T13:26:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/277679692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99681884"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99681884"
         }
      },
      "body" : "could use \"enum class\" here to avoid the \"BumpFeeResult_\" prefixes here while still requiring them where the values are referenced.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-06T20:56:16Z",
      "diff_hunk" : "@@ -786,6 +786,21 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, bool keepReserveKey = true, const CTxDestination& destChange = CNoDestination());\n \n     /**\n+     * Bumps the fee of an opt-in-RBF transaction <txid>,\n+     * replacing it with a new transaction <wtxNew>\n+     */\n+    enum BumpFeeResult\n+    {\n+        BumpFeeResult_OK,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99681884",
      "id" : 99681884,
      "original_commit_id" : "8993411d7b3e6fe2c4baa917874941ed95c39188",
      "original_position" : 9,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 20366230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99681884",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99683051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99683051"
         }
      },
      "body" : "It appears that you are only copying, not moving the CalculateMaximumSignedTxSize function in this commit (8993411d7b3e6fe2c4baa917874941ed95c39188 `[Move] move bumpfee core logic to CWallet`). Would make more sense to remove it from rpcwallet.cpp in this commit instead of the next one.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-06T21:01:38Z",
      "diff_hunk" : "@@ -2290,6 +2291,223 @@ bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount&\n     return res;\n }\n \n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99683051",
      "id" : 99683051,
      "original_commit_id" : "8993411d7b3e6fe2c4baa917874941ed95c39188",
      "original_position" : 19,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 20366230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99683051",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99685109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99685109"
         }
      },
      "body" : "Enum is not being used in this commit (8993411d7b3e6fe2c4baa917874941ed95c39188 `[Move] move bumpfee core logic to CWallet`), would probably make more sense to define in the next commit.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-06T21:11:50Z",
      "diff_hunk" : "@@ -786,6 +786,21 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, bool keepReserveKey = true, const CTxDestination& destChange = CNoDestination());\n \n     /**\n+     * Bumps the fee of an opt-in-RBF transaction <txid>,\n+     * replacing it with a new transaction <wtxNew>\n+     */\n+    enum BumpFeeResult",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99685109",
      "id" : 99685109,
      "original_commit_id" : "8993411d7b3e6fe2c4baa917874941ed95c39188",
      "original_position" : 7,
      "path" : "src/wallet/wallet.h",
      "position" : null,
      "pull_request_review_id" : 20366230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99685109",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99686304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99686304"
         }
      },
      "body" : "Can drop \"enum\" in c++.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-06T21:17:56Z",
      "diff_hunk" : "@@ -2313,71 +2313,85 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n     if (!pwalletMain->DummySignTx(txNew, vCoins)) {\n         // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n         // implies that we can sign for every input.\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction contains inputs that cannot be signed\");\n+        return -1;\n     }\n     return GetVirtualTransactionSize(txNew);\n }\n \n enum CWallet::BumpFeeResult CWallet::BumpFee(uint256 txid, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable, CAmount& nOldFee, CAmount& nNewFee, std::shared_ptr<CWalletTx>& wtxNew, std::vector<std::string>& vErrors)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99686304",
      "id" : 99686304,
      "original_commit_id" : "45ec058131e2d0066c2db396e3090a183032b407",
      "original_position" : 10,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 20366230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99686304",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99689422"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99689422"
         }
      },
      "body" : "I don't think it's a good idea to return a mutable pointer to a copy of the CWalletTx that isn't actually in mapwallet, because changes a caller makes to this pointer might have unexpected or no effects. Since the shared pointer doesn't appear to be needed here or in #9697, I think it'd be better to return just wtxBumped.tx or wtxBumped.GetHash() instead.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-06T21:32:56Z",
      "diff_hunk" : "@@ -2469,43 +2487,47 @@ enum CWallet::BumpFeeResult CWallet::BumpFee(uint256 txid, int newConfirmTarget,\n     CTransaction txNewConst(tx);\n     int nIn = 0;\n     for (auto& input : tx.vin) {\n-        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find(input.prevout.hash);\n-        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n+        assert(mi != mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n         const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n         const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n         SignatureData sigdata;\n-        if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+        if (!ProduceSignature(TransactionSignatureCreator(this, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n+            vErrors.push_back(\"Can't sign transaction.\");\n+            return CWallet::BumpFeeResult_WALLET_ERROR;\n         }\n         UpdateTransaction(tx, nIn, sigdata);\n         nIn++;\n     }\n \n     // commit/broadcast the tx\n-    CReserveKey reservekey(pwalletMain);\n-    CWalletTx wtxBumped(pwalletMain, MakeTransactionRef(std::move(tx)));\n-    wtxBumped.mapValue[\"replaces_txid\"] = hash.ToString();\n+    CReserveKey reservekey(this);\n+    CWalletTx wtxBumped(this, MakeTransactionRef(std::move(tx)));\n+    wtxBumped.mapValue[\"replaces_txid\"] = txid.ToString();\n     CValidationState state;\n-    if (!pwalletMain->CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n+    if (!CommitTransaction(wtxBumped, reservekey, g_connman.get(), state)) {\n         // NOTE: CommitTransaction never returns false, so this should never happen.\n-        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+        vErrors.push_back(strprintf(\"Error: The transaction was rejected! Reason given: %s\", state.GetRejectReason()));\n+        return CWallet::BumpFeeResult_WALLET_ERROR;\n     }\n \n-    UniValue vErrors(UniValue::VARR);\n     if (state.IsInvalid()) {\n         // This can happen if the mempool rejected the transaction.  Report\n         // what happened in the \"errors\" response.\n         vErrors.push_back(strprintf(\"Error: The transaction was rejected: %s\", FormatStateMessage(state)));\n     }\n \n     // mark the original tx as bumped\n-    if (!pwalletMain->MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n+    if (!MarkReplaced(wtx.GetHash(), wtxBumped.GetHash())) {\n         // TODO: see if JSON-RPC has a standard way of returning a response\n         // along with an exception. It would be good to return information about\n         // wtxBumped to the caller even if marking the original transaction\n         // replaced does not succeed for some reason.\n         vErrors.push_back(\"Error: Created new bumpfee transaction but could not mark the original transaction as replaced.\");\n     }\n+\n+    wtxNew = std::make_shared<CWalletTx>(wtxBumped);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99689422",
      "id" : 99689422,
      "original_commit_id" : "45ec058131e2d0066c2db396e3090a183032b407",
      "original_position" : 219,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 20366230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99689422",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Completely rewrote the refactor.\r\n* Moved/refactored relevant code into `feeBumper.cpp` (`CFeeBump`) which breaks the pattern of `CWallet` as god class.\r\n* Split `BumpFee` into three steps, Bump, Sign (new `CWallet` function, can later be used by `CreateTransaction`) and Commit.\r\n",
      "created_at" : "2017-02-07T20:43:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-278133565",
      "id" : 278133565,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-02-07T20:43:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/278133565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99929982"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99929982"
         }
      },
      "body" : "Don't see a reason to require shared_ptr here. CMutableTransaction& would allow callers to use it or not use it. Similarly for other shared_ptr arguments.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-07T21:11:12Z",
      "diff_hunk" : "@@ -2318,50 +2318,70 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n     return GetVirtualTransactionSize(txNew);\n }\n \n-enum CWallet::BumpFeeResult CWallet::BumpFee(uint256 txid, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable, CAmount& nOldFee, CAmount& nNewFee, std::shared_ptr<CWalletTx>& wtxNew, std::vector<std::string>& vErrors)\n+bool CWallet::SignTransaction(std::shared_ptr<CMutableTransaction> tx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r99929982",
      "id" : 99929982,
      "original_commit_id" : "65e2e0085a608d9f570bc911349a5953a6ca88ee",
      "original_position" : 5,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 20620991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/99929982",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102847930"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102847930"
         }
      },
      "body" : "I don't think there's a reason to have these typedefs or even to use shared pointers in feebumper at all. Shared pointers are a great tool in places where they are actually needed, but plain c++ references that don't need to be deferenced, don't require reference counting, and can't be null are a better option in the places where they work. Another disadvantage of shared_ptr interfaces is that the requirement to wrap everything in shared_ptr can start spreading virally from callers, to callers callers, etc.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-23T23:41:35Z",
      "diff_hunk" : "@@ -451,7 +451,9 @@ struct CMutableTransaction\n };\n \n typedef std::shared_ptr<const CTransaction> CTransactionRef;\n+typedef std::shared_ptr<CMutableTransaction> CMutableTransactionRef;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102847930",
      "id" : 102847930,
      "original_commit_id" : "cc585d5c182405997fe79e1f87bbee0747606e5d",
      "original_position" : 4,
      "path" : "src/primitives/transaction.h",
      "position" : null,
      "pull_request_review_id" : 20620991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102847930",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102848081"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102848081"
         }
      },
      "body" : "I think the less verbose `BumpFeeResult::OK` would be preferable to `CFeeBumper::BumpFeeResult::OK`\r\n\r\nCould move enum above class to accomplish this. Or could change \"enum class\" to \"enum\" for `CFeeBumper::OK`.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-23T23:42:36Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+class CFeeBumper\n+{\n+public:\n+    enum class BumpFeeResult",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102848081",
      "id" : 102848081,
      "original_commit_id" : "cc585d5c182405997fe79e1f87bbee0747606e5d",
      "original_position" : 16,
      "path" : "src/wallet/feebumper.h",
      "position" : null,
      "pull_request_review_id" : 20620991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102848081",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102848152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102848152"
         }
      },
      "body" : "Seeing all these getters makes me think this API grouping is not a good idea. We have this class with two functions that do real work (constructor and commit), and then a bunch of members, and a bunch of getters, and somehow the caller is supposed to keep track of all the getters and know which ones are valid to call at different stages in the object lifetime. Also, member lifetimes are unnecessarily prolonged (constructor's return values like nOldFee/nNewFee/currentResult/vErrors do not need to be kept alive in order for the commit method to do it's job).\r\n\r\nI think a better API here would look something like:\r\n\r\n```\r\nvoid CreateBumpTx(<input const ref args>, <output ref args>);\r\nvoid CommitBumpTx(<input const ref args>, <output ref args>);\r\n```\r\n\r\nwithout the stateful class.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-02-23T23:43:04Z",
      "diff_hunk" : "@@ -0,0 +1,45 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+class CFeeBumper\n+{\n+public:\n+    enum class BumpFeeResult\n+    {\n+        OK,\n+        INVALID_ADDRESS_OR_KEY,\n+        INVALID_REQUEST,\n+        INVALID_PARAMETER,\n+        MISC_ERROR,\n+    };\n+\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable);\n+    CFeeBumper::BumpFeeResult getResult() const { return currentResult; }\n+    const std::vector<std::string>& getErrors() const { return vErrors; }\n+    CAmount getOldFee() const { return nOldFee; }\n+    CAmount getNewFee() const { return nNewFee; }\n+    CMutableTransactionRef getBumpedTxRef() const { return mtx; }\n+    uint256 getBumpedTxId() const { return bumpedTxid; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102848152",
      "id" : 102848152,
      "original_commit_id" : "cc585d5c182405997fe79e1f87bbee0747606e5d",
      "original_position" : 31,
      "path" : "src/wallet/feebumper.h",
      "position" : null,
      "pull_request_review_id" : 20620991,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/102848152",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Added a commit c81a8a7ddef6f3c1e4cb0816aa12ae16b91cbf02 that addresses the shared pointer for `CMutableTransaction`.\r\n\r\nThe second commit a9c25b611504225d61291365ab6025dbd426e2d0 moves the enum class `BumpFeeResult` into the global scope.\r\n\r\nI haven't implemented the proposed API change (https://github.com/bitcoin/bitcoin/pull/9681#discussion_r102848152) which maybe could be a follow up. I'n not sure if this would go into a direction to purely static in/out functions.",
      "created_at" : "2017-03-02T10:18:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-283613919",
      "id" : 283613919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-02T10:18:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/283613919",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r103938745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/103938745"
         }
      },
      "body" : "Maybe split into two asserts, to be a little easier to read, and so you can tell which condition failed from the error.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-02T14:44:02Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r103938745",
      "id" : 103938745,
      "original_commit_id" : "a9c25b611504225d61291365ab6025dbd426e2d0",
      "original_position" : 32,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 24746265,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/103938745",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Needed rebase (#8775).\r\nSquashed down to three relevant commits.",
      "created_at" : "2017-03-03T15:26:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-283983349",
      "id" : 283983349,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-03T15:26:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/283983349",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "utACK 4ce1d6fb995bc30551571fe3621f185ea66eae7f\r\n\r\nComparing against previous a9c25b611504225d61291365ab6025dbd426e2d0, there were no changes except for some whitespace and a renamed local iterator variable.",
      "created_at" : "2017-03-03T15:48:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-283989381",
      "id" : 283989381,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-03T15:48:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/283989381",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "> [...] renamed local iterator variable.\r\n\r\nHad to change this to respect the `-Wshadow ` (#9828) change",
      "created_at" : "2017-03-03T15:50:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-283989760",
      "id" : 283989760,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-03T15:50:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/283989760",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "It would be really nice to have this merged soon. This PR is blocking the bumpfee GUI PR #9697, which is blocking the RBF checkbox PR #9592, which is blocking the RBF RPC PR #9672, and possibly the `-walletrbf` default PR #9527. It would be great to start clearing this backlog.\r\n\r\nI guess maybe this needs another reviewer? It also needs a rebase to avoid trivial conflicts with #9853 and #9643.",
      "created_at" : "2017-03-09T14:32:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-285366958",
      "id" : 285366958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-09T14:32:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/285366958",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105293055"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105293055"
         }
      },
      "body" : "There is a minor bug here. This needs to pass `pWallet` into `CalculateMaximumSignedTxSize` so it can stop using `pwalletMain`. When making this change, I also had to make the `CWallet::DummySignTx` method const. Feel free to use my complete fix: https://github.com/ryanofsky/bitcoin/commit/731ca5c652d42806e82892695f4e43082c9d6a20\r\n\r\n",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-09T23:03:42Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pwalletMain->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::MISC_ERROR;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::MISC_ERROR;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::INVALID_REQUEST;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::MISC_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::MISC_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105293055",
      "id" : 105293055,
      "original_commit_id" : "4ce1d6fb995bc30551571fe3621f185ea66eae7f",
      "original_position" : 123,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 26167988,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105293055",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "body" : "Rebased (carefully).\r\nAdded @ryanofsky's https://github.com/ryanofsky/bitcoin/commit/731ca5c652d42806e82892695f4e43082c9d6a20",
      "created_at" : "2017-03-10T07:51:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-285601666",
      "id" : 285601666,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-10T07:51:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/285601666",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105475770"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105475770"
         }
      },
      "body" : "This appears to be WALLET_ERROR not MISC_ERROR in master:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/8910b4717e5bb946ee6988f7fe9fd461f53a5935/src/wallet/rpcwallet.cpp#L2875",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-10T19:52:45Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pwalletMain->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::MISC_ERROR;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105475770",
      "id" : 105475770,
      "original_commit_id" : "e9c88c855e558b7372445414a57ef635d18d22eb",
      "original_position" : 78,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 26362684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105475770",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105476597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105476597"
         }
      },
      "body" : "pwalletMain should be pwallet, also a few places below",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-10T19:57:07Z",
      "diff_hunk" : "@@ -2933,157 +2850,55 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             }\n         } else if (options.exists(\"totalFee\")) {\n             totalFee = options[\"totalFee\"].get_int64();\n-            CAmount requiredFee = CWallet::GetRequiredFee(maxNewTxSize);\n-            if (totalFee < requiredFee ) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER,\n-                                   strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n-                                             FormatMoney(requiredFee)));\n-            }\n         }\n \n         if (options.exists(\"replaceable\")) {\n             replaceable = options[\"replaceable\"].get_bool();\n         }\n     }\n \n-    // calculate the old fee and fee-rate\n-    CAmount nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n-    CFeeRate nOldFeeRate(nOldFee, txSize);\n-    CAmount nNewFee;\n-    CFeeRate nNewFeeRate;\n-    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n-    // future proof against changes to network wide policy for incremental relay\n-    // fee that our node may not be aware of.\n-    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n-    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n-        walletIncrementalRelayFee = ::incrementalRelayFee;\n-    }\n-\n-    if (totalFee > 0) {\n-        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n-        if (totalFee < minTotalFee) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n-                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n-        }\n-        nNewFee = totalFee;\n-        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n-    } else {\n-        // if user specified a confirm target then don't consider any global payTxFee\n-        if (specifiedConfirmTarget) {\n-            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n-        }\n-        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n-        else {\n-            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n-        }\n-\n-        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n-\n-        // New fee rate must be at least old rate + minimum incremental relay rate\n-        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n-        // in that unit (fee per kb).\n-        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n-        // add 1 satoshi to the result, because it may have been rounded down.\n-        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n-            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n-            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n-        }\n-    }\n-\n-    // Check that in all cases the new fee doesn't violate maxTxFee\n-     if (nNewFee > maxTxFee) {\n-         throw JSONRPCError(RPC_WALLET_ERROR,\n-                            strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n-                                      FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n-     }\n-\n-    // check that fee rate is higher than mempool's minimum fee\n-    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n-    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n-    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n-    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n-    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n-    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n-    }\n-\n-    // Now modify the output to increase the fee.\n-    // If the output is not large enough to pay the fee, fail.\n-    CAmount nDelta = nNewFee - nOldFee;\n-    assert(nDelta > 0);\n-    CMutableTransaction tx(*(wtx.tx));\n-    CTxOut* poutput = &(tx.vout[nOutput]);\n-    if (poutput->nValue < nDelta) {\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Change output is too small to bump the fee\");\n-    }\n-\n-    // If the output would become dust, discard it (converting the dust to fee)\n-    poutput->nValue -= nDelta;\n-    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n-        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n-        nNewFee += poutput->nValue;\n-        tx.vout.erase(tx.vout.begin() + nOutput);\n-    }\n-\n-    // Mark new tx not replaceable, if requested.\n-    if (!replaceable) {\n-        for (auto& input : tx.vin) {\n-            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n-        }\n-    }\n+    LOCK2(cs_main, pwallet->cs_wallet);\n+    EnsureWalletIsUnlocked(pwallet);\n \n-    // sign the new tx\n-    CTransaction txNewConst(tx);\n-    int nIn = 0;\n-    for (auto& input : tx.vin) {\n-        std::map<uint256, CWalletTx>::const_iterator mi = pwallet->mapWallet.find(input.prevout.hash);\n-        assert(mi != pwallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        const CScript& scriptPubKey = mi->second.tx->vout[input.prevout.n].scriptPubKey;\n-        const CAmount& amount = mi->second.tx->vout[input.prevout.n].nValue;\n-        SignatureData sigdata;\n-        if (!ProduceSignature(TransactionSignatureCreator(pwallet, &txNewConst, nIn, amount, SIGHASH_ALL), scriptPubKey, sigdata)) {\n-            throw JSONRPCError(RPC_WALLET_ERROR, \"Can't sign transaction.\");\n+    CFeeBumper feeBump(pwalletMain, hash, newConfirmTarget, specifiedConfirmTarget, totalFee, replaceable);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r105476597",
      "id" : 105476597,
      "original_commit_id" : "a6183598ea15d0b9acd8e22b3f8af6ac444f9db6",
      "original_position" : 235,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 26362684,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105476597",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r106417852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106417852"
         }
      },
      "body" : "Thanks. Great catch... fixed now.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-16T13:37:26Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pwalletMain->mapWallet.find(input.prevout.hash);\n+        assert(mi != pwalletMain->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pwalletMain->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::MISC_ERROR;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r106417852",
      "id" : 106417852,
      "original_commit_id" : "e9c88c855e558b7372445414a57ef635d18d22eb",
      "original_position" : 78,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 27337797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106417852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Fixed @ryanofsky findings and squashed into a single commit.",
      "created_at" : "2017-03-16T13:37:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-287058863",
      "id" : 287058863,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-16T13:37:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/287058863",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r106691358"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106691358"
         }
      },
      "body" : "In commit \"Bumpfee move request parameter interaction to the top\":\r\n\r\nThis commit seems to be changing behavior in a way that I think would be good to avoid. Previously, if you passed a negative or 0 totalFee option, you would get an \"Insufficient totalFee\" error. But now, an automatic fee will be calculated, ignoring the totalFee value that was passed.\r\n\r\nI think you could fix this by writing:\r\n\r\n```\r\ntotalFee = options[\"totalFee\"].get_int64();\r\nif (totalFee <= 0) {\r\n    throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid totalFee %s (must be greater than 0)\", FormatMoney(totalFee)));\r\n}\r\n```",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-17T16:30:34Z",
      "diff_hunk" : "@@ -2933,157 +2850,55 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             }\n         } else if (options.exists(\"totalFee\")) {\n             totalFee = options[\"totalFee\"].get_int64();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r106691358",
      "id" : 106691358,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 122,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 122,
      "pull_request_review_id" : 27629759,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/106691358",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r107272568"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/107272568"
         }
      },
      "body" : "I'd prefer this not to be an assert. Is it possible to return an error rather than assert?\r\n\r\nI know that this was here before the code move, but my worry is that moving it to wallet.cpp might encourage people to call this function without knowing that they must lock the wallet and verify that all the transaction inputs are in the wallet map first.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-21T20:55:04Z",
      "diff_hunk" : "@@ -2240,6 +2241,26 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     return res;\n }\n \n+bool CWallet::SignTransaction(CMutableTransaction &tx)\n+{\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n+        assert(mi != mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r107272568",
      "id" : 107272568,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 19,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 28234984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/107272568",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r107275222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/107275222"
         }
      },
      "body" : "I'm not sure if you need to check this here, when you already checked it in `CFeeBumper::CFeeBumper()`?\r\n\r\nIf this check fails, I think you need to return false from this function immediately rather than fall through, since the function goes on to deference the transaction in the map.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-21T21:06:07Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)\n+{\n+    AssertLockHeld(pWallet->cs_wallet);\n+    vErrors.clear();\n+    if (txid.IsNull() || !pWallet->mapWallet.count(txid)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r107275222",
      "id" : 107275222,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 236,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 28234984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/107275222",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108150909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108150909"
         }
      },
      "body" : "Yes. That's correct. I'm adding a commit that restores that behaviour.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T11:57:08Z",
      "diff_hunk" : "@@ -2933,157 +2850,55 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             }\n         } else if (options.exists(\"totalFee\")) {\n             totalFee = options[\"totalFee\"].get_int64();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108150909",
      "id" : 108150909,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 122,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 122,
      "pull_request_review_id" : 29163475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108150909",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108150986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108150986"
         }
      },
      "body" : "Right. This is a valid point. Adding a commit that returns false instead of the `assert()`.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T11:57:34Z",
      "diff_hunk" : "@@ -2240,6 +2241,26 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     return res;\n }\n \n+bool CWallet::SignTransaction(CMutableTransaction &tx)\n+{\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto& input : tx.vin) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(input.prevout.hash);\n+        assert(mi != mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108150986",
      "id" : 108150986,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 19,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 29163545,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108150986",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108151239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108151239"
         }
      },
      "body" : "I think it's sane to keep this check... but your right, it should immediately return. Will fix.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T11:59:25Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)\n+{\n+    AssertLockHeld(pWallet->cs_wallet);\n+    vErrors.clear();\n+    if (txid.IsNull() || !pWallet->mapWallet.count(txid)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108151239",
      "id" : 108151239,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 236,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29163821,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108151239",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Addressed @ryanofsky and @jnewbery points.\r\nHopefully soon ready for merge.",
      "created_at" : "2017-03-27T13:43:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-289457048",
      "id" : 289457048,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-27T13:43:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289457048",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "utACK ccbdb2ceadade6059d7c375592f01db7feda05f6. The three new commits, as well as the main commit 1d8529bf3c279e8e2128425cec12c2b8263a5e54 (previously ACKed) all look good.",
      "created_at" : "2017-03-27T20:02:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-289568639",
      "id" : 289568639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-27T20:02:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289568639",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108267934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108267934"
         }
      },
      "body" : "I don't think you need to change the signature of `CalculateMaximumSignedTxSize`, and the prior version seems better",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:12:07Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108267934",
      "id" : 108267934,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 23,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108267934",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108268950"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108268950"
         }
      },
      "body" : "make_pair with emplace_back is not necessary, may as well fix it.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:16:30Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108268950",
      "id" : 108268950,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 33,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108268950",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108273486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108273486"
         }
      },
      "body" : "might make more sense for CalculateMaximumSignexTxSize to take a vErrors argument, as this is non-obvious to me (from local code) why maxNewTxSize < 0 means there were unsignable inputs.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:36:01Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108273486",
      "id" : 108273486,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 123,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108273486",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275082"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275082"
         }
      },
      "body" : "Reason to change this line from `CWallet::GetRequiredFee`?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:43:12Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275082",
      "id" : 108275082,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 150,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275082",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275706"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275706"
         }
      },
      "body" : "This is also static, please keep CWallet::",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:46:11Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275706",
      "id" : 108275706,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 162,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275706",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275796"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275796"
         }
      },
      "body" : "This is also static, please keep CWallet::\r\n",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T20:46:40Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108275796",
      "id" : 108275796,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 166,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108275796",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108281199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108281199"
         }
      },
      "body" : "Maybe you should refactor this to:\r\n```c++\r\n if (nOldFee >= nNewFee) {\r\n    vErrors.push_back(\"Attempt to increase fee decreased fee.\");\r\n    currentResult = BumpFeeResult::WALLET_ERROR;     \r\n    return;\r\n}\r\n```",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T21:12:17Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108281199",
      "id" : 108281199,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 205,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 205,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108281199",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108281936"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108281936"
         }
      },
      "body" : "You should just make this a case of the switch.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T21:15:53Z",
      "diff_hunk" : "@@ -2883,206 +2857,48 @@ UniValue bumpfee(const JSONRPCRequest& request)\n         }\n     }\n \n-    // retrieve the original tx from the wallet\n     LOCK2(cs_main, pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n-    if (!pwallet->mapWallet.count(hash)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n-    }\n-    CWalletTx& wtx = pwallet->mapWallet[hash];\n-\n-    if (pwallet->HasWalletSpend(hash)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Transaction has descendants in the wallet\");\n-    }\n \n+    CFeeBumper feeBump(pwallet, hash, newConfirmTarget, specifiedConfirmTarget, totalFee, replaceable);\n+    BumpFeeResult res = feeBump.getResult();\n+    if (res != BumpFeeResult::OK)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108281936",
      "id" : 108281936,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 73,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108281936",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108283089"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108283089"
         }
      },
      "body" : "Maybe you should fail to commit `if (!vErrors.empty())`?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T21:21:45Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)\n+{\n+    AssertLockHeld(pWallet->cs_wallet);\n+    vErrors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108283089",
      "id" : 108283089,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 235,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108283089",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108283375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108283375"
         }
      },
      "body" : "I think I would prefer to see commit be done via RAII (but maybe that's bad if you make a container of CFeeBumpers...)",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-27T21:23:13Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108283375",
      "id" : 108283375,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 232,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 232,
      "pull_request_review_id" : 29288929,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108283375",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108345663"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108345663"
         }
      },
      "body" : "Indeed. This seems to be a rebase issue. Will change.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T06:55:05Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108345663",
      "id" : 108345663,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 23,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108345663",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346243"
         }
      },
      "body" : "Maybe, though the scope of this PR is  ideally  pure refactoring to make it usable over the UI. Let's optimise such things later.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T06:59:21Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346243",
      "id" : 108346243,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 123,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346243",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346641"
         }
      },
      "body" : "Yes. This seems to be again a rebase issue. Though, changing it to `pWallet` would allow to be more flexible when multi wallet takes off... but changing it back for now.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T07:02:09Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346641",
      "id" : 108346641,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 166,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346641",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346696"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346696"
         }
      },
      "body" : "Let's do this later and focus now on refactoring out the core functionality.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T07:02:33Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346696",
      "id" : 108346696,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 205,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 205,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346696",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346893"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346893"
         }
      },
      "body" : "Hmm.. not sure if RAII for a bump commit is appropriate. IMO the commit (it actually does sign and broadcast) should be a clearly visible call.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T07:03:51Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108346893",
      "id" : 108346893,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 232,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 232,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108346893",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108347191"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108347191"
         }
      },
      "body" : "Good point. Will change.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T07:05:57Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)\n+{\n+    AssertLockHeld(pWallet->cs_wallet);\n+    vErrors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108347191",
      "id" : 108347191,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 235,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29369443,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108347191",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Thanks @JeremyRubin for the review. Fixed the relevant points.",
      "created_at" : "2017-03-28T07:09:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-289683061",
      "id" : 289683061,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-28T07:09:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289683061",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108410196"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108410196"
         }
      },
      "body" : "In commit \"Restore CalculateMaximumSignedTxSize function signature\":\r\n\r\nPrevious signature took a CWallet reference instead of a pointer. (Just an observation, feel free to leave it.)",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T12:48:35Z",
      "diff_hunk" : "@@ -20,7 +20,7 @@\n // calculation, but we should be able to refactor after priority is removed).\n // NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n // be IsAllFromMe).\n-int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108410196",
      "id" : 108410196,
      "original_commit_id" : "2b573c4ebeb08dc954bd65adeab79b7ddf826fd1",
      "original_position" : 5,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29437895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108410196",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108410473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108410473"
         }
      },
      "body" : "In commit \"Use static calls for GetRequiredFee and GetMinimumFee, remove make_pair from emplace_back\"\r\n\r\nCould drop parens around mi->second. (Just an observation, feel free to leave.)",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T12:49:57Z",
      "diff_hunk" : "@@ -30,7 +30,7 @@ int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWal\n     for (auto& input : tx.vin) {\n         const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n         assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+        vCoins.emplace_back(&(mi->second), input.prevout.n);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108410473",
      "id" : 108410473,
      "original_commit_id" : "aa55df28bc3a69e81a6509418aacf23b64fda711",
      "original_position" : 5,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29437895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108410473",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108422407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108422407"
         }
      },
      "body" : "`vErrors.clear()` is now redundant.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T13:37:51Z",
      "diff_hunk" : "@@ -232,6 +232,9 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n bool CFeeBumper::commit(CWallet *pWallet)\n {\n     AssertLockHeld(pWallet->cs_wallet);\n+    if (!vErrors.empty()) {\n+        return false;\n+    }\n     vErrors.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108422407",
      "id" : 108422407,
      "original_commit_id" : "99070569662dde84a4f4b1d38cd53762063f53d2",
      "original_position" : 7,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29451007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108422407",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108434057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108434057"
         }
      },
      "body" : "I think it makes sense to just change it now... https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209694 is where it got introduced, I think it still may be possible to trigger & throwing seems better for this than crashing your node.\r\n\r\nI'll leave it up to you though -- just let me know if you decide not to & I'll prepare a patch.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T14:19:13Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108434057",
      "id" : 108434057,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 205,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 205,
      "pull_request_review_id" : 29451007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108434057",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108437264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108437264"
         }
      },
      "body" : "What if you do something like\r\n```c++\r\ncommit() {\r\n    assert(!comitted)\r\n    comitted = true;\r\n     ...\r\n}\r\n~CFeeBumper() {\r\n    if (vErrors.empty())\r\n    assert(comitted);\r\n}\r\n```\r\nTo ensure that if a CFeeBump could be comitted, it is & comitting isn't tried multiple times?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T14:30:24Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108437264",
      "id" : 108437264,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 232,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 232,
      "pull_request_review_id" : 29451007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108437264",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108439499"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108439499"
         }
      },
      "body" : "You do not use vErrors to store more than one error, so may as well just use a std::string (this clarifies it is set-once).\r\n\r\nAlternatively, you could use a smart pointer to a string and just check that it is not nullptr.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T14:38:02Z",
      "diff_hunk" : "@@ -0,0 +1,46 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+enum class BumpFeeResult\n+{\n+    OK,\n+    INVALID_ADDRESS_OR_KEY,\n+    INVALID_REQUEST,\n+    INVALID_PARAMETER,\n+    WALLET_ERROR,\n+    MISC_ERROR,\n+};\n+\n+class CFeeBumper\n+{\n+public:\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable);\n+    BumpFeeResult getResult() const { return currentResult; }\n+    const std::vector<std::string>& getErrors() const { return vErrors; }\n+    CAmount getOldFee() const { return nOldFee; }\n+    CAmount getNewFee() const { return nNewFee; }\n+    CMutableTransaction* getBumpedTxRef() { return &mtx; }\n+    uint256 getBumpedTxId() const { return bumpedTxid; }\n+\n+    bool commit(CWallet *pWalletNonConst);\n+\n+private:\n+    const uint256 txid;\n+    uint256 bumpedTxid;\n+    CMutableTransaction mtx;\n+    std::vector<std::string> vErrors;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108439499",
      "id" : 108439499,
      "original_commit_id" : "99070569662dde84a4f4b1d38cd53762063f53d2",
      "original_position" : 40,
      "path" : "src/wallet/feebumper.h",
      "position" : 40,
      "pull_request_review_id" : 29451007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108439499",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108440268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108440268"
         }
      },
      "body" : "maybe change to/add ```&& BumpFeeResult::OK == currentResult```",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T14:40:33Z",
      "diff_hunk" : "@@ -0,0 +1,279 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(&(mi->second), input.prevout.n);\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, pWallet);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = CWallet::GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)\n+{\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!vErrors.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108440268",
      "id" : 108440268,
      "original_commit_id" : "99070569662dde84a4f4b1d38cd53762063f53d2",
      "original_position" : 235,
      "path" : "src/wallet/feebumper.cpp",
      "position" : null,
      "pull_request_review_id" : 29451007,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108440268",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108456651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108456651"
         }
      },
      "body" : "L265 and L274 can both add an error that then get's spit out over the JSON-RPC \"errors\" array. I haven't changed this in this PR.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T15:35:27Z",
      "diff_hunk" : "@@ -0,0 +1,46 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+enum class BumpFeeResult\n+{\n+    OK,\n+    INVALID_ADDRESS_OR_KEY,\n+    INVALID_REQUEST,\n+    INVALID_PARAMETER,\n+    WALLET_ERROR,\n+    MISC_ERROR,\n+};\n+\n+class CFeeBumper\n+{\n+public:\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable);\n+    BumpFeeResult getResult() const { return currentResult; }\n+    const std::vector<std::string>& getErrors() const { return vErrors; }\n+    CAmount getOldFee() const { return nOldFee; }\n+    CAmount getNewFee() const { return nNewFee; }\n+    CMutableTransaction* getBumpedTxRef() { return &mtx; }\n+    uint256 getBumpedTxId() const { return bumpedTxid; }\n+\n+    bool commit(CWallet *pWalletNonConst);\n+\n+private:\n+    const uint256 txid;\n+    uint256 bumpedTxid;\n+    CMutableTransaction mtx;\n+    std::vector<std::string> vErrors;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108456651",
      "id" : 108456651,
      "original_commit_id" : "99070569662dde84a4f4b1d38cd53762063f53d2",
      "original_position" : 40,
      "path" : "src/wallet/feebumper.h",
      "position" : 40,
      "pull_request_review_id" : 29488149,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108456651",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108457522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108457522"
         }
      },
      "body" : "Not sure but this looks after too much hand holding. But if someone wants to implement this, yeah, maybe after this PR?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T15:38:54Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);\n+    mtx =  *wtx.tx;\n+    CTxOut* poutput = &(mtx.vout[nOutput]);\n+    if (poutput->nValue < nDelta) {\n+        vErrors.push_back(\"Change output is too small to bump the fee\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // If the output would become dust, discard it (converting the dust to fee)\n+    poutput->nValue -= nDelta;\n+    if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n+        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        nNewFee += poutput->nValue;\n+        mtx.vout.erase(mtx.vout.begin() + nOutput);\n+    }\n+\n+    // Mark new tx not replaceable, if requested.\n+    if (!newTxReplaceable) {\n+        for (auto& input : mtx.vin) {\n+            if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n+        }\n+    }\n+\n+    currentResult = BumpFeeResult::OK;\n+}\n+\n+bool CFeeBumper::commit(CWallet *pWallet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108457522",
      "id" : 108457522,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 232,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 232,
      "pull_request_review_id" : 29489109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108457522",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108457745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108457745"
         }
      },
      "body" : "Let's try to keep the scope (\"refactoring\"), behaviours changes have already sneaked into this PR.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-28T15:39:38Z",
      "diff_hunk" : "@@ -0,0 +1,275 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CWallet *pWallet, const CTransaction &tx)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(pWallet, *wtx.tx);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = pWallet->GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",\n+                                                                FormatMoney(requiredFee)));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n+    } else {\n+        // if user specified a confirm target then don't consider any global payTxFee\n+        if (specifiedConfirmTarget) {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, CAmount(0));\n+        }\n+        // otherwise use the regular wallet logic to select payTxFee or default confirm target\n+        else {\n+            nNewFee = pWallet->GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool);\n+        }\n+\n+        nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n+\n+        // New fee rate must be at least old rate + minimum incremental relay rate\n+        // walletIncrementalRelayFee.GetFeePerK() should be exact, because it's initialized\n+        // in that unit (fee per kb).\n+        // However, nOldFeeRate is a calculated value from the tx fee/size, so\n+        // add 1 satoshi to the result, because it may have been rounded down.\n+        if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK()) {\n+            nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + 1 + walletIncrementalRelayFee.GetFeePerK());\n+            nNewFee = nNewFeeRate.GetFee(maxNewTxSize);\n+        }\n+    }\n+\n+    // Check that in all cases the new fee doesn't violate maxTxFee\n+     if (nNewFee > maxTxFee) {\n+         vErrors.push_back(strprintf(\"Specified or calculated fee %s is too high (cannot be higher than maxTxFee %s)\",\n+                               FormatMoney(nNewFee), FormatMoney(maxTxFee)));\n+         currentResult = BumpFeeResult::WALLET_ERROR;\n+         return;\n+     }\n+\n+    // check that fee rate is higher than mempool's minimum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        vErrors.push_back(strprintf(\"New fee rate (%s) is less than the minimum fee rate (%s) to get into the mempool. totalFee value should to be at least %s or settxfee value should be at least %s to add transaction.\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFee(maxNewTxSize)), FormatMoney(minMempoolFeeRate.GetFeePerK())));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // If the output is not large enough to pay the fee, fail.\n+    CAmount nDelta = nNewFee - nOldFee;\n+    assert(nDelta > 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108457745",
      "id" : 108457745,
      "original_commit_id" : "1d8529bf3c279e8e2128425cec12c2b8263a5e54",
      "original_position" : 205,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 205,
      "pull_request_review_id" : 29489344,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-28T15:41:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108457745",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Amend-changed the last commit to remove the redundant `vErrors.clear()`.\r\nAdded a check for `currentResult == BumpFeeResult::OK` during commit.",
      "created_at" : "2017-03-28T15:43:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-289812422",
      "id" : 289812422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-28T15:43:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/289812422",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108679775"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108679775"
         }
      },
      "body" : "Having this and the totalFee error be separate is somewhat strange, maybe combine them now that the checks are in the same place (in an additional commit) into one generic error so we dont have users chasing error messages for a few rounds?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-29T13:47:23Z",
      "diff_hunk" : "@@ -0,0 +1,278 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(&(mi->second), input.prevout.n);\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),\n+    nOldFee(0),\n+    nNewFee(0)\n+{\n+    vErrors.clear();\n+    bumpedTxid.SetNull();\n+    AssertLockHeld(pWallet->cs_wallet);\n+    if (!pWallet->mapWallet.count(txid)) {\n+        vErrors.push_back(\"Invalid or non-wallet transaction id\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+    auto it = pWallet->mapWallet.find(txid);\n+    const CWalletTx& wtx = it->second;\n+\n+    if (pWallet->HasWalletSpend(txid)) {\n+        vErrors.push_back(\"Transaction has descendants in the wallet\");\n+        currentResult = BumpFeeResult::INVALID_PARAMETER;\n+        return;\n+    }\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it_mp = mempool.mapTx.find(txid);\n+        if (it_mp != mempool.mapTx.end() && it_mp->GetCountWithDescendants() > 1) {\n+            vErrors.push_back(\"Transaction has descendants in the mempool\");\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+    }\n+\n+    if (wtx.GetDepthInMainChain() != 0) {\n+        vErrors.push_back(\"Transaction has been mined, or is conflicted with a mined transaction\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (!SignalsOptInRBF(wtx)) {\n+        vErrors.push_back(\"Transaction is not BIP 125 replaceable\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    if (wtx.mapValue.count(\"replaced_by_txid\")) {\n+        vErrors.push_back(strprintf(\"Cannot bump transaction %s which was already bumped by transaction %s\", txid.ToString(), wtx.mapValue.at(\"replaced_by_txid\")));\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // check that original tx consists entirely of our inputs\n+    // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n+    if (!pWallet->IsAllFromMe(wtx, ISMINE_SPENDABLE)) {\n+        vErrors.push_back(\"Transaction contains inputs that don't belong to this wallet\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // figure out which output was change\n+    // if there was no change output or multiple change outputs, fail\n+    int nOutput = -1;\n+    for (size_t i = 0; i < wtx.tx->vout.size(); ++i) {\n+        if (pWallet->IsChange(wtx.tx->vout[i])) {\n+            if (nOutput != -1) {\n+                vErrors.push_back(\"Transaction has multiple change outputs\");\n+                currentResult = BumpFeeResult::WALLET_ERROR;\n+                return;\n+            }\n+            nOutput = i;\n+        }\n+    }\n+    if (nOutput == -1) {\n+        vErrors.push_back(\"Transaction does not have a change output\");\n+        currentResult = BumpFeeResult::WALLET_ERROR;\n+        return;\n+    }\n+\n+    // Calculate the expected size of the new transaction.\n+    int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n+    const int64_t maxNewTxSize = CalculateMaximumSignedTxSize(*wtx.tx, pWallet);\n+    if (maxNewTxSize < 0) {\n+        vErrors.push_back(\"Transaction contains inputs that cannot be signed\");\n+        currentResult = BumpFeeResult::INVALID_ADDRESS_OR_KEY;\n+        return;\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    nOldFee = wtx.GetDebit(ISMINE_SPENDABLE) - wtx.tx->GetValueOut();\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+    CFeeRate nNewFeeRate;\n+    // The wallet uses a conservative WALLET_INCREMENTAL_RELAY_FEE value to\n+    // future proof against changes to network wide policy for incremental relay\n+    // fee that our node may not be aware of.\n+    CFeeRate walletIncrementalRelayFee = CFeeRate(WALLET_INCREMENTAL_RELAY_FEE);\n+    if (::incrementalRelayFee > walletIncrementalRelayFee) {\n+        walletIncrementalRelayFee = ::incrementalRelayFee;\n+    }\n+\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(maxNewTxSize) + ::incrementalRelayFee.GetFee(maxNewTxSize);\n+        if (totalFee < minTotalFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee, must be at least %s (oldFee %s + incrementalFee %s)\",\n+                                                                FormatMoney(minTotalFee), FormatMoney(nOldFeeRate.GetFee(maxNewTxSize)), FormatMoney(::incrementalRelayFee.GetFee(maxNewTxSize))));\n+            currentResult = BumpFeeResult::INVALID_PARAMETER;\n+            return;\n+        }\n+        CAmount requiredFee = CWallet::GetRequiredFee(maxNewTxSize);\n+        if (totalFee < requiredFee) {\n+            vErrors.push_back(strprintf(\"Insufficient totalFee (cannot be less than required fee %s)\",",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108679775",
      "id" : 108679775,
      "original_commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "original_position" : 152,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 152,
      "pull_request_review_id" : 29725626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-29T14:40:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108679775",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108688929"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108688929"
         }
      },
      "body" : "nit: pass txidIn by reference or std::move it here.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-29T14:21:31Z",
      "diff_hunk" : "@@ -0,0 +1,278 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"consensus/validation.h\"\n+#include \"wallet/feebumper.h\"\n+#include \"wallet/wallet.h\"\n+#include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n+#include \"validation.h\" //for mempool access\n+#include \"txmempool.h\"\n+#include \"utilmoneystr.h\"\n+#include \"util.h\"\n+#include \"net.h\"\n+\n+// Calculate the size of the transaction assuming all signatures are max size\n+// Use DummySignatureCreator, which inserts 72 byte signatures everywhere.\n+// TODO: re-use this in CWallet::CreateTransaction (right now\n+// CreateTransaction uses the constructed dummy-signed tx to do a priority\n+// calculation, but we should be able to refactor after priority is removed).\n+// NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+// be IsAllFromMe).\n+int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *pWallet)\n+{\n+    CMutableTransaction txNew(tx);\n+    std::vector<std::pair<const CWalletTx *, unsigned int>> vCoins;\n+    // Look up the inputs.  We should have already checked that this transaction\n+    // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n+    // wallet, with a valid index into the vout array.\n+    for (auto& input : tx.vin) {\n+        const auto mi = pWallet->mapWallet.find(input.prevout.hash);\n+        assert(mi != pWallet->mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n+        vCoins.emplace_back(&(mi->second), input.prevout.n);\n+    }\n+    if (!pWallet->DummySignTx(txNew, vCoins)) {\n+        // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n+        // implies that we can sign for every input.\n+        return -1;\n+    }\n+    return GetVirtualTransactionSize(txNew);\n+}\n+\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable)\n+    :\n+    txid(txidIn),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108688929",
      "id" : 108688929,
      "original_commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "original_position" : 45,
      "path" : "src/wallet/feebumper.cpp",
      "position" : 45,
      "pull_request_review_id" : 29725626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-29T14:40:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108688929",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108692011"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108692011"
         }
      },
      "body" : "This feels like a super strange API...you're getting a reference to memory owned by CFeeBumper, passing it to the wallet, then calling a method owned by CFeeBumper which assumes you mutated its (seemingly internal) state. Given you're already passing a pwallet reference into CFeeBumper, maybe replace this with bool SignTransaction(CWallet *pwalletIn)?",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-29T14:33:31Z",
      "diff_hunk" : "@@ -0,0 +1,46 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+enum class BumpFeeResult\n+{\n+    OK,\n+    INVALID_ADDRESS_OR_KEY,\n+    INVALID_REQUEST,\n+    INVALID_PARAMETER,\n+    WALLET_ERROR,\n+    MISC_ERROR,\n+};\n+\n+class CFeeBumper\n+{\n+public:\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable);\n+    BumpFeeResult getResult() const { return currentResult; }\n+    const std::vector<std::string>& getErrors() const { return vErrors; }\n+    CAmount getOldFee() const { return nOldFee; }\n+    CAmount getNewFee() const { return nNewFee; }\n+    CMutableTransaction* getBumpedTxRef() { return &mtx; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108692011",
      "id" : 108692011,
      "original_commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "original_position" : 31,
      "path" : "src/wallet/feebumper.h",
      "position" : 31,
      "pull_request_review_id" : 29725626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-29T14:40:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108692011",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108693090"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108693090"
         }
      },
      "body" : "Can you document the return value here? It initially confused me because I thought it would return false if it set vErrors, when, in fact, it might add vErrors and then return true.",
      "commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "created_at" : "2017-03-29T14:37:27Z",
      "diff_hunk" : "@@ -0,0 +1,46 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_FEEBUMPER_H\n+#define BITCOIN_WALLET_FEEBUMPER_H\n+\n+#include <primitives/transaction.h>\n+\n+class CWallet;\n+class uint256;\n+\n+enum class BumpFeeResult\n+{\n+    OK,\n+    INVALID_ADDRESS_OR_KEY,\n+    INVALID_REQUEST,\n+    INVALID_PARAMETER,\n+    WALLET_ERROR,\n+    MISC_ERROR,\n+};\n+\n+class CFeeBumper\n+{\n+public:\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool specifiedConfirmTarget, CAmount totalFee, bool newTxReplaceable);\n+    BumpFeeResult getResult() const { return currentResult; }\n+    const std::vector<std::string>& getErrors() const { return vErrors; }\n+    CAmount getOldFee() const { return nOldFee; }\n+    CAmount getNewFee() const { return nNewFee; }\n+    CMutableTransaction* getBumpedTxRef() { return &mtx; }\n+    uint256 getBumpedTxId() const { return bumpedTxid; }\n+\n+    bool commit(CWallet *pWalletNonConst);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#discussion_r108693090",
      "id" : 108693090,
      "original_commit_id" : "fb7bb67a4177dc18065944ec8504f3820c20383c",
      "original_position" : 34,
      "path" : "src/wallet/feebumper.h",
      "position" : 34,
      "pull_request_review_id" : 29725626,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/9681",
      "updated_at" : "2017-03-29T14:40:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108693090",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Added a commit that addresses @TheBlueMatt's points.\r\n- Changed `CFeeBumper`'s interface. It has now a `signTransaction` method instead of the  indeed strange  `getBumpedTxRef()`.\r\n- Made use of `std::move` for the txIn.\r\n- Added some comments",
      "created_at" : "2017-03-30T07:28:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-290325978",
      "id" : 290325978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-03-30T07:29:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/290325978",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased (trivial) after #9424",
      "created_at" : "2017-04-02T08:13:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-290971853",
      "id" : 290971853,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-04-02T08:13:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/290971853",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "utACK 5f59d3ecb7f1b63579e7f07fc520459cdf119c81, confirmed first 8 commits (previously acked as 99070569662dde84a4f4b1d38cd53762063f53d2) did not change in the rebase, other than the log category fix. New 9th commit also looks fine.\r\n\r\nI think it would be good to merge this because it is a burden to maintain separately and keep reviewing. It's been rebased many times and is blocking other prs.",
      "created_at" : "2017-04-07T13:37:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9681#issuecomment-292538273",
      "id" : 292538273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9681",
      "updated_at" : "2017-04-07T13:37:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/292538273",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/7133040?v=3",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   }
]
