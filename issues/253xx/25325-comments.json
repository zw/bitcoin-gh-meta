[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [john-moffett](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1356988307), [jonatack](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1357119390), [LarryRuane](https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1483180518), [achow101](https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516886734) |\n| Stale ACK | [sipa](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1349066025) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "created_at" : "2022-06-10T17:46:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1152596519",
      "id" : 1152596519,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Eszon",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1152596519/reactions"
      },
      "updated_at" : "2023-04-20T20:11:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1152596519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "rebased to 9205b60 with minor fixes in `pool.h` so it is usable in `boost::unordered_map`",
      "created_at" : "2022-06-19T05:15:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1159619246",
      "id" : 1159619246,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585FHmKu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1159619246/reactions"
      },
      "updated_at" : "2022-06-19T05:15:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1159619246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953055591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No need for passing `seedval` by reference.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T19:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953055591",
      "id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844znln",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082762327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T19:55:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953062958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty sure this was not written by Satoshi, or in 2010.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:04:37Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953062958",
      "id" : 953062958,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII5844zpYu",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 1,
      "pull_request_review_id" : 1082773235,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:04:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953067528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Actually this it is necessary because `seedval` is modified, see the constructor in line 42 where `m_s0` and `m_s1` are initialized. I could use a pointer instead of reference or add a comment to make that more clear?",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:10:49Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953067528",
      "id" : 953067528,
      "in_reply_to_id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844zqgI",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082780041,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:10:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953069117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, no, I just didn't pay attention to how it was used. My mistake.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:13:00Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953069117",
      "id" : 953069117,
      "in_reply_to_id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844zq49",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082783050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:13:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r973734050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's how rumors start! Maybe it was Satoshi? ;-) I'll update that.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-09-18T15:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r973734050",
      "id" : 973734050,
      "in_reply_to_id" : 953062958,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII5846CgCi",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 1,
      "pull_request_review_id" : 1111554848,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-18T15:00:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "In a semi-related event, I've recently created a big benchmark of a lot of different hashmaps. See here: https://martin.ankerl.com/2022/08/27/hashmap-bench-01/\r\n\r\nSome findings that I think are relevant for this PR:\r\n\r\n* I have added the `PoolAllocator` developed here to the benchmarks and combined it with both `std::unordered_map` and `boost::unordered_map` and it works without any problems.\r\n* boost has completely reworked the hashmap and released that in version 1.80. Just changing the map to that implementation will probably provide some speedup. [More info here](https://www.boost.org/doc/libs/1_80_0/libs/unordered/doc/html/unordered.html#benchmarks).\r\n* Both `boost::unordered_map` and `std::unordered_map` benefit a lot memory-wise from the `PoolAllocator`.\r\n* Boost has it's own pool allocator: `boost::container::pmr::unsynchronized_pool_resource` It behaves relatively similar to PoolAllocator, although slower in my benchmarks. So this might be an alternative to the `PoolAllocator`.\r\n* Other implementations like `gtl::parallel_flat_hash_map` are much faster and have low memory overhead, so they might be a good choice performance wise, although they carry much more risk because usage is not so widespread.",
      "created_at" : "2022-09-18T15:13:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1250328856",
      "id" : 1250328856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585KhoEY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1250328856/reactions"
      },
      "updated_at" : "2022-09-18T15:13:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1250328856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased to [f1b20f0](https://github.com/bitcoin/bitcoin/commit/f1b20f04644ddc07bd9bbfc066f9701d54139d52) to fix copyright header in `xoroshiro128plusplus.h`. Nothing else changed.",
      "created_at" : "2022-09-24T06:11:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1256876909",
      "id" : 1256876909,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585K6mtt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1256876909/reactions"
      },
      "updated_at" : "2022-09-24T06:11:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1256876909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r979171391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "f1b20f04644ddc07bd9bbfc066f9701d54139d52",
      "created_at" : "2022-09-24T06:11:46Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r979171391",
      "id" : 979171391,
      "in_reply_to_id" : 953062958,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846XPg_",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : null,
      "pull_request_review_id" : 1119175139,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-24T06:11:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-10-19T09:31:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1283707743",
      "id" : 1283707743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Mg9Nf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1283707743/reactions"
      },
      "updated_at" : "2022-10-19T09:31:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1283707743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebase to 509d97a fixes merge conflict in `Makefile.test_util.include`, fixes a comment, adds benchmark priority, fix Win64 64bit shift warning.",
      "created_at" : "2022-10-21T15:58:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1287155740",
      "id" : 1287155740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585MuHAc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1287155740/reactions"
      },
      "updated_at" : "2022-10-21T17:22:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1287155740",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004102333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: consider deleting copy ctor and copy assignment operators\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..00bd1ed90 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -269,6 +269,9 @@ public:\r\n     {\r\n         return m_chunk_size_bytes;\r\n     }\r\n+\r\n+    PoolResource(const PoolResource&) = delete;\r\n+    PoolResource& operator=(const PoolResource&) = delete;\r\n };\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T07:27:36Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004102333",
      "id" : 1004102333,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII58472WK9",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 70,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004112858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: maybe use templates instead of `void*`?\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..38c5f9d62 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -139,7 +139,8 @@ class PoolResource final\r\n     /**\r\n      * Replaces node with placement constructed ListNode that points to the previous node\r\n      */\r\n-    void PlacementAddToList(void* p, ListNode*& node)\r\n+    template <typename T>\r\n+    void PlacementAddToList(T* p, ListNode*& node)\r\n     {\r\n         node = new (p) ListNode{node};\r\n     }\r\n@@ -232,7 +233,8 @@ public:\r\n     /**\r\n      * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\r\n      */\r\n-    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\r\n+    template <typename T>\r\n+    void Deallocate(T* p, std::size_t bytes, std::size_t alignment) noexcept\r\n     {\r\n         if (IsFreeListUsable(bytes, alignment)) {\r\n             const std::size_t num_alignments = NumElemAlignBytes(bytes);\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T07:38:21Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004112858",
      "id" : 1004112858,
      "line" : 142,
      "node_id" : "PRRC_kwDOABII58472Yva",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 142,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004137199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: might slightly improve performance but haven't benchmarked\r\n```suggestion\r\n    std::vector<std::byte*> m_allocated_chunks{};\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T08:02:29Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004137199",
      "id" : 1004137199,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII58472erv",
      "original_commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1009306384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it's better to leave this as void*, because I don't want any overloaded operator new or operator delete called depending on the type.",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-31T11:25:10Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1009306384",
      "id" : 1009306384,
      "in_reply_to_id" : 1004112858,
      "line" : 142,
      "node_id" : "PRRC_kwDOABII5848KMsQ",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 142,
      "pull_request_review_id" : 1161718255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-31T11:25:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-19T01:44:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1320735162",
      "id" : 1320735162,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585OuNG6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1320735162/reactions"
      },
      "updated_at" : "2022-11-19T01:44:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1320735162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-30T01:21:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1331525171",
      "id" : 1331525171,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585PXXYz",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1331525171/reactions"
      },
      "updated_at" : "2022-11-30T01:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1331525171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036283541"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'll add these when I rebase to fix the merge conflict :+1: ",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2022-11-30T17:55:51Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036283541",
      "id" : 1036283541,
      "in_reply_to_id" : 1004102333,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII5849xG6V",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 70,
      "pull_request_review_id" : 1199784602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T17:55:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036285674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I thought std::list is more fitting here, because I don't need random access, and only every once in a while one element is added. The list is only iterated once when bitcoind shutsdown. So it's not at all performance relevant here",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2022-11-30T17:57:55Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036285674",
      "id" : 1036285674,
      "in_reply_to_id" : 1004137199,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII5849xHbq",
      "original_commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1199787521,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T17:57:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, this approach is much easier to be convinced about, I feel. Happy to see that most of the performance gains carry over.\r\n\r\nI've ran a partial reindex under valgrind with this PR (to height 592178, which took several days), to really stress test it. No issues. I'll do a more in-depth code review soon.",
      "created_at" : "2022-12-05T19:19:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1338010318",
      "id" : 1338010318,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585PwGrO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1338010318/reactions"
      },
      "updated_at" : "2022-12-05T19:19:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1338010318",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081878044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo: space before `3`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:22:38Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081878044",
      "id" : 1081878044,
      "line" : 64,
      "node_id" : "PRRC_kwDOABII585AfCYc",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 64,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081883320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Allocators don't need to be able to handle allocations of size 0, so I think the `+ 1` could be dropped here (shifting the indices down by 1).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:27:33Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081883320",
      "id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585AfDq4",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081894944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I know there are rules that make move constructors/assignment operators not automatically appear when copy equivalents are specified, but I'd still prefer explicitly disabling those too.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:38:52Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081894944",
      "id" : 1081894944,
      "line" : 193,
      "node_id" : "PRRC_kwDOABII585AfGgg",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 193,
      "original_position" : 193,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 193,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081903348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems this comment would be more appropriate if put a few lines higher. The placement here makes it look like it's related to the freelist empty test.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:47:10Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081903348",
      "id" : 1081903348,
      "line" : 215,
      "node_id" : "PRRC_kwDOABII585AfIj0",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 215,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment seems like it should be moved up as well.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:52:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909031",
      "id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585AfJ8n",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200"
         }
      },
      "author_association" : "MEMBER",
      "body" : "And this one too.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:53:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909200",
      "id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585AfJ_Q",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think there is an upstream resource; it's just handled by the default allocator.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:53:45Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909913",
      "id" : 1081909913,
      "line" : 234,
      "node_id" : "PRRC_kwDOABII585AfKKZ",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 234,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 234,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo: `cunks`.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:54:01Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910140",
      "id" : 1081910140,
      "line" : 239,
      "node_id" : "PRRC_kwDOABII585AfKN8",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 239,
      "original_position" : 239,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 239,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Likewise, no upstream resource here?",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:54:37Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910577",
      "id" : 1081910577,
      "line" : 249,
      "node_id" : "PRRC_kwDOABII585AfKUx",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 249,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081913776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems like a debugging leftover.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:58:43Z",
      "diff_hunk" : "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081913776",
      "id" : 1081913776,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AfLGw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : 115,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081922160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could this use `std::forward_list`?",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:09:09Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081922160",
      "id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AfNJw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081923544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A comment to explain where this estimation formula comes from would be useful (or encapsulate the `sizeof(void*) * 3` constant as a static member of the resource?).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:10:36Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <class Key, class T, class Hash, class Pred, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+static inline size_t DynamicUsage(const std::unordered_map<Key,\n+                                                           T,\n+                                                           Hash,\n+                                                           Pred,\n+                                                           PoolAllocator<std::pair<const Key, T>,\n+                                                                         MAX_BLOCK_SIZE_BYTES,\n+                                                                         ALIGN_BYTES>>& m)\n+{\n+    auto* pool_resource = m.get_allocator().resource();\n+\n+    size_t estimated_list_node_size = MallocUsage(sizeof(void*) * 3);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081923544",
      "id" : 1081923544,
      "line" : 181,
      "node_id" : "PRRC_kwDOABII585AfNfY",
      "original_commit_id" : "ecc73d72c72287b8e630266dc5bd08786dc85780",
      "original_line" : 181,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/memusage.h",
      "position" : 23,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081925749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: use variable names following the style guide when introducing new ones (e.g. `m_cache_coins_memory_resource`).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:12:55Z",
      "diff_hunk" : "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081925749",
      "id" : 1081925749,
      "line" : 229,
      "node_id" : "PRRC_kwDOABII585AfOB1",
      "original_commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "original_line" : 229,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 30,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082378917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm not 100% sure that is the case\r\n\r\nIn https://eel.is/c++draft/allocator.requirements#general-39 it states that \"the return value is unspecified\", so it it seems to me that it can be any value, but it doesn't say that the behavior is unspecified. So it could return any pointer or even `nullptr`\r\n\r\nIn http://eel.is/c++draft/basic.stc.dynamic.allocation#2 it says \"The effect of indirecting through a pointer returned from a request for zero size is undefined\", so one might return any value, but it must not be dereferenced (which seems logic, with 0 elements there's nothing to dereference). The footnote here says \"C++ differs from C in requiring a zero request to return a non-null pointer\", so this too seems like a pointer should be returned\r\n\r\nSo I think `allocate(0)` is not forbidden",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:15:37Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082378917",
      "id" : 1082378917,
      "in_reply_to_id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585Ag8ql",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1263376994,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:15:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082384437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'll remove the comment, it doesn't make much sense",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:22:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082384437",
      "id" : 1082384437,
      "in_reply_to_id" : 1081903348,
      "line" : 215,
      "node_id" : "PRRC_kwDOABII585Ag-A1",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 215,
      "pull_request_review_id" : 1263391388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:22:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082385811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The location seems ok to me, when that line is reached we know the freelist is empty so we need to get memory from the chunk",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:24:27Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082385811",
      "id" : 1082385811,
      "in_reply_to_id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585Ag-WT",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1263395000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:24:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082387056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that line fits too, this comments on  the `m_available_memory_it + round_bytes`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:25:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082387056",
      "id" : 1082387056,
      "in_reply_to_id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585Ag-pw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1263398108,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:25:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082577659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I could, but itt would be less convenient, because forward_list doesn't even have a `size()` which I use in `NumAllocatedChunks()`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T14:03:44Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082577659",
      "id" : 1082577659,
      "in_reply_to_id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AhtL7",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1263645793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T14:03:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082640705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fair enough.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T14:45:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082640705",
      "id" : 1082640705,
      "in_reply_to_id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585Ah8lB",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1263736203,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T14:45:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082683009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see; it'd reduce memory usage very slightly, but if it comes with extra complexity it's probably not worth it.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:12:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082683009",
      "id" : 1082683009,
      "in_reply_to_id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AiG6B",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1263783313,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:12:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, it's just a tiny nit of course. Given the somewhat out of place comment above I wondered if perhaps a few more comments somehow got misplaced.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:15:15Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685605",
      "id" : 1082685605,
      "in_reply_to_id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585AiHil",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1263787310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:15:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685801"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:15:22Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685801",
      "id" : 1082685801,
      "in_reply_to_id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585AiHlp",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1263787539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:15:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083220507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Noticed while running `make check` and looking for `pool_tests` in the output: the following minor change in the first commit  2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 will run the tests in the expected order.\r\n\r\n<details><summary>suggestion</summary><p>\r\n\r\n```diff\r\n   test/net_tests.cpp \\\r\n   test/netbase_tests.cpp \\\r\n-  test/pool_tests.cpp \\\r\n   test/orphanage_tests.cpp \\\r\n   test/pmt_tests.cpp \\\r\n   test/policy_fee_tests.cpp \\\r\n   test/policyestimator_tests.cpp \\\r\n+  test/pool_tests.cpp \\\r\n   test/pow_tests.cpp \\\r\n```\r\n\r\ncurrently\r\n\r\n```\r\nRunning tests: net_peer_eviction_tests from test/net_peer_eviction_tests.cpp\r\nRunning tests: net_tests from test/net_tests.cpp\r\nRunning tests: netbase_tests from test/netbase_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: orphanage_tests from test/orphanage_tests.cpp\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\n```\r\n\r\nafter\r\n\r\n```\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\nRunning tests: policyestimator_tests from test/policyestimator_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: pow_tests from test/pow_tests.cpp\r\nRunning tests: prevector_tests from test/prevector_tests.cpp\r\nRunning tests: raii_event_tests from test/raii_event_tests.cpp\r\n```\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T01:33:47Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083220507",
      "id" : 1083220507,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AkKIb",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 4,
      "pull_request_review_id" : 1264557141,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T01:43:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:09:41Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249932",
      "id" : 1083249932,
      "in_reply_to_id" : 1081878044,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRUM",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592811,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:09:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:09:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249938",
      "id" : 1083249938,
      "in_reply_to_id" : 1081903348,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRUS",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:09:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249976"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:05Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249976",
      "id" : 1083249976,
      "in_reply_to_id" : 1081909913,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRU4",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 234,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:12Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250008",
      "id" : 1083250008,
      "in_reply_to_id" : 1081910140,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVY",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 239,
      "original_position" : 239,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:18Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250013",
      "id" : 1083250013,
      "in_reply_to_id" : 1081910577,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVd",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592861,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250035"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:29Z",
      "diff_hunk" : "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250035",
      "id" : 1083250035,
      "in_reply_to_id" : 1081925749,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVz",
      "original_commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "original_line" : 229,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : null,
      "pull_request_review_id" : 1264592876,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Interesting that the order here has any effect on the order of tests, I would have expected that the test suite orders alphabetically. I'll add this to my next update",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:18:17Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250755",
      "id" : 1083250755,
      "in_reply_to_id" : 1083220507,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AkRhD",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 4,
      "pull_request_review_id" : 1264593480,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:18:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "removed in rebase to 80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:18:49Z",
      "diff_hunk" : "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250811",
      "id" : 1083250811,
      "in_reply_to_id" : 1081913776,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRh7",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : null,
      "pull_request_review_id" : 1264593524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:18:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this is technically speaking UB: it may construct an out-of-bounds pointer; even without dereferencing, doing so is UB (unless it's the exactly-one-past-the-end pointer). It's of course fine in practice, but I think the proper way to write it is `round_bytes > m_available_memory_end - m_available_memory_it`.\r\n\r\nFrom https://en.cppreference.com/w/cpp/language/operator_arithmetic:\r\n\r\n> If the pointer `P` points to the ith element of an array, then the expressions `P + n`, `n + P`, and `P - n` are pointers of the same type that point to the i+nth, i+nth, and i-nth element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer `P` such that the expression `P - 1` points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior. \r\n\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-23T21:16:40Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591",
      "id" : 1084564591,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII585ApSRv",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 225,
      "pull_request_review_id" : 1266351016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-23T22:16:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085963632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f Is the public helper member `PoolResource::IsEqual()` intended to be used (it's currently not)?",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:37:32Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085963632",
      "id" : 1085963632,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585Aun1w",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 261,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085967553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274 it looks like `CHUNK_SIZE_BYTES` should be `m_chunk_size_bytes` or `ChunkSizeBytes()`\r\n```suggestion\r\n     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() +  m_chunk_size_bytes`\r\n```\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:41:52Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085967553",
      "id" : 1085967553,
      "line" : 117,
      "node_id" : "PRRC_kwDOABII585AuozB",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 117,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085970688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f `BLOCK_ALIGNMENT_BYTES` is undefined (maybe `n * block alignment bytes`?)",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:44:45Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085970688",
      "id" : 1085970688,
      "line" : 105,
      "node_id" : "PRRC_kwDOABII585AupkA",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 105,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085971981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32\r\n```suggestion\r\n        // if any available memory remains, put it in the freelist.\r\n```",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:45:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085971981",
      "id" : 1085971981,
      "line" : 155,
      "node_id" : "PRRC_kwDOABII585Aup4N",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 155,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085974737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32\r\n```suggestion\r\n     * How many multiples of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\r\n```",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:48:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085974737",
      "id" : 1085974737,
      "line" : 123,
      "node_id" : "PRRC_kwDOABII585AuqjR",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 123,
      "original_position" : 123,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 123,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085980287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f missing headers (algorithm for `std::max` and iterator for `std::distance`)\r\n\r\n<details><summary>diffs</summary><p>\r\n\r\n```diff\r\n+#include <algorithm>\r\n #include <array>\r\n #include <cassert>\r\n #include <cstddef>\r\n+#include <iterator>\r\n #include <list>\r\n```\r\n\r\nand also in src/bench/pool.cpp\r\n\r\n```diff\r\n+#include <functional>\r\n #include <unordered_map>\r\n+#include <utility>\r\n```\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:53:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085980287",
      "id" : 1085980287,
      "line" : 11,
      "node_id" : "PRRC_kwDOABII585Aur5_",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 11,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 11,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:26:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086981056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Question, are these user-defined copy-constructor and copy-assignment operators actually needed, and if yes, should the move operators be specified as well? \r\n\r\n<details><summary>Rationale</summary><p>\r\n\r\nPer https://en.cppreference.com/w/cpp/language/rule_of_three#rule-of-five, \"Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the [move constructor](https://en.cppreference.com/w/cpp/language/move_constructor) and the [move assignment operator](https://en.cppreference.com/w/cpp/language/move_operator), any class for which move semantics are desirable, has to declare all five special member functions. Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.\"\r\n\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T17:57:15Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086981056",
      "id" : 1086981056,
      "line" : 305,
      "node_id" : "PRRC_kwDOABII585AygPA",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 305,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 305,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086988389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Noting that these two `==` and `!=` template methods don't appear to be otherwise used in this PR.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T18:02:41Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086988389",
      "id" : 1086988389,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585AyiBl",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 354,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1087172548"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice. (In practice on my particular system, `86 / 100` is the lowest value that passes.)",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T21:07:15Z",
      "diff_hunk" : "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1087172548",
      "id" : 1087172548,
      "line" : 170,
      "node_id" : "PRRC_kwDOABII585AzO_E",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 170,
      "original_position" : 170,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 170,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089264098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice find, I'll change the `if`",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:02:27Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089264098",
      "id" : 1089264098,
      "in_reply_to_id" : 1084564591,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII585A7Nni",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 225,
      "pull_request_review_id" : 1273173146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:02:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089267866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, this is unused; I originally used this in the `operator==`. I'll remove it",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:06:59Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089267866",
      "id" : 1089267866,
      "in_reply_to_id" : 1085963632,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585A7Oia",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 261,
      "pull_request_review_id" : 1273179379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:07:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089285815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "right, also the .get() is no more",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:26:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089285815",
      "id" : 1089285815,
      "in_reply_to_id" : 1085967553,
      "line" : 117,
      "node_id" : "PRRC_kwDOABII585A7S63",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 117,
      "pull_request_review_id" : 1273216602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:26:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089290030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It should be `n*ELEM_ALIGN_BYTES`",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:31:02Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089290030",
      "id" : 1089290030,
      "in_reply_to_id" : 1085970688,
      "line" : 105,
      "node_id" : "PRRC_kwDOABII585A7T8u",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 105,
      "pull_request_review_id" : 1273228793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:31:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089291634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the savings are a bit less than 86/100 on 32bit due to 32bit alignment, that's why I have the number a bit on the high side here",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:32:56Z",
      "diff_hunk" : "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089291634",
      "id" : 1089291634,
      "in_reply_to_id" : 1087172548,
      "line" : 170,
      "node_id" : "PRRC_kwDOABII585A7UVy",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 170,
      "original_position" : 170,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 170,
      "pull_request_review_id" : 1273232771,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:32:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089308331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It's not actually used anywhere currently, but this is needed when move-assigning containers that use the allocator. The containers need to check in a move-assignment if the allocators `operator==` returns true or false, and if they return true it means that both containers use the same resource and they can just destroy lhs and then move the pointers of rhs to lhs without copying elements. When they don't compare equal when the resource is different, all the objects in rhs need to be recreated.\r\n\r\nThe best explanation that I found for this stuff is this post from Howard Hinnant (he wrote `std::chrono` among other things) : https://stackoverflow.com/a/27472502/48181",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:52:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089308331",
      "id" : 1089308331,
      "in_reply_to_id" : 1086988389,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585A7Yar",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 354,
      "pull_request_review_id" : 1273277158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:52:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3 per `git range-diff 4b51290 80722d8 e715861`\r\n",
      "created_at" : "2023-01-27T21:30:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407093805",
      "id" : 1407093805,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T3owt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407093805/reactions"
      },
      "updated_at" : "2023-01-27T22:26:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407093805",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089464988"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Moving is useless for this class, as all it holds is a pointer as member variable. Copying and moving a pointer is the same.",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T21:45:25Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089464988",
      "id" : 1089464988,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A7-qc",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273528688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T21:45:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089475233"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks. I wondered if the move constructor is used, because while this branch compiles for me (Clang 15 on ARM64) with the move assignment disabled (`PoolAllocator& operator=(PoolAllocator&&) noexcept = delete;`), it doesn't build with the move constructor disabled (`PoolAllocator(PoolAllocator&&) noexcept = delete;`).\r\n\r\n```\r\n./coins.h:230:33: note: in instantiation of member function 'std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, std::equal_to<COutPoint>, PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>, 128, 8>>::unordered_map' requested here\r\n    mutable CCoinsMap cacheCoins{0, CCoinsMap::hasher{}, CCoinsMap::key_equal{}, &m_cache_coins_memory_resource};\r\n                                ^\r\n./support/allocators/pool.h:297:5: note: 'PoolAllocator' has been explicitly marked deleted here\r\n    PoolAllocator(PoolAllocator&&) noexcept = delete;\r\n    ^\r\n1 error generated.\r\n```",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T21:59:55Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089475233",
      "id" : 1089475233,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A8BKh",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273544582,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T21:59:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T22:07:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407124835",
      "id" : 1407124835,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T3wVj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407124835/reactions"
      },
      "updated_at" : "2023-01-27T22:07:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407124835",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646554"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:16Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646554",
      "id" : 1089646554,
      "in_reply_to_id" : 1083220507,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_a",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : null,
      "pull_request_review_id" : 1273801553,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:22Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646562",
      "id" : 1089646562,
      "in_reply_to_id" : 1084564591,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_i",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801557,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:28Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646577",
      "id" : 1089646577,
      "in_reply_to_id" : 1085963632,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_x",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801564,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646584"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646584",
      "id" : 1089646584,
      "in_reply_to_id" : 1085967553,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_4",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801573,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:42Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646608",
      "id" : 1089646608,
      "in_reply_to_id" : 1085970688,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8rAQ",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801589,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089647580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the problem with adding the `PoolAllocator(PoolAllocator&&) noexcept = delete;` is that it makes the function available for overload resolution, but if its chosen the compilation fails https://stackoverflow.com/a/35406415/48181",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:23:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089647580",
      "id" : 1089647580,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A8rPc",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273802345,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:23:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for reviewing @jonatack and @sipa! I've addressed all comments with e715861",
      "created_at" : "2023-01-28T05:24:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407297445",
      "id" : 1407297445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T4ael",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407297445/reactions"
      },
      "updated_at" : "2023-01-28T05:24:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407297445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs (fairly trivial) rebase after merge of #17487.",
      "created_at" : "2023-01-30T16:21:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1408930176",
      "id" : 1408930176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T-pGA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408930176/reactions"
      },
      "updated_at" : "2023-01-30T16:21:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408930176",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-30T17:05:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1408992234",
      "id" : 1408992234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T-4Pq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408992234/reactions"
      },
      "updated_at" : "2023-01-30T17:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408992234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased to resolve conflicts, diff should be viewable with `git range-diff 82903a7 e715861 f58a5eee6f`",
      "created_at" : "2023-01-30T17:21:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409017964",
      "id" : 1409017964,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T--hs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409017964/reactions"
      },
      "updated_at" : "2023-01-30T17:21:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409017964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "<strike>re-ACK f58a5eee6ff69582d6e46e93dd52e07202d257a8</strike>\r\n\r\nThe unit test CI failures look unrelated -- I didn't reproduce them running `make check` locally (Clang 15 on ARM64). \r\n\r\nEdit: there are now more of the failures and some seem related.",
      "created_at" : "2023-01-30T17:53:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409063626",
      "id" : 1409063626,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T_JrK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409063626/reactions"
      },
      "updated_at" : "2023-01-30T19:00:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409063626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hm it looks like in some environments the new check fails:\r\n```\r\ncoins_tests.cpp(984): error: in \"coins_tests/ccoins_flush_behavior\": check view->DynamicMemoryUsage() < cache_usage has failed\r\n```\r\n\r\nI think the problem is this: The test from @jamesob assumes that memory usage goes down when the cache is flushed. But the pool is internally using chunks of 262144 bytes, and when flushed this memory block will be deallocated but might be allocated again right away when the map is created, so memory usage doesn't necessarily change. E.g. in Windows some control block is immediately allocated for the map, and this makes the pool allocator allocate its first chunk",
      "created_at" : "2023-01-30T18:12:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409090307",
      "id" : 1409090307,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T_QMD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409090307/reactions"
      },
      "updated_at" : "2023-01-30T18:33:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409090307",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixup LGTM modulo squashing. The remaining CI failures are due to https://cirrus-ci.com/task/5963593934438400 (that seems unrelated?) and to https://github.com/bitcoin/bitcoin/issues/27001 that should be fixed in https://github.com/bitcoin/bitcoin/pull/26998.",
      "created_at" : "2023-01-30T20:58:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409322773",
      "id" : 1409322773,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UAI8V",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409322773/reactions"
      },
      "updated_at" : "2023-01-30T21:04:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409322773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-30T23:33:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409521445",
      "id" : 1409521445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UA5cl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409521445/reactions"
      },
      "updated_at" : "2023-01-30T23:33:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409521445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Squashed and rebased again due to #26999\r\n\r\nSee the full range-diff after the 2 rebases: `git range-diff ceb74b8 e715861 c25a754b`\r\n\r\nBiggest change was updating the method `TestFlushBehavior` in coins_test.cpp",
      "created_at" : "2023-01-31T06:11:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409824656",
      "id" : 1409824656,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UCDeQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409824656/reactions"
      },
      "updated_at" : "2023-01-31T06:11:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409824656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 0007d69f249068a14b9b5a97d46ace9dabdc2c8b",
      "created_at" : "2023-01-31T22:16:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1411143425",
      "id" : 1411143425,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UHFcB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411143425/reactions"
      },
      "updated_at" : "2023-01-31T22:16:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411143425",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "FWIW, I rebased this on top of #27011, and am running a few CPU cores on it. No issues so far.",
      "created_at" : "2023-02-02T20:56:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1414360875",
      "id" : 1414360875,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UTW8r",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414360875/reactions"
      },
      "updated_at" : "2023-02-02T20:56:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414360875",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-13T15:34:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1428150986",
      "id" : 1428150986,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VH9rK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428150986/reactions"
      },
      "updated_at" : "2023-02-13T15:34:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428150986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased due to #27011. Note that this adds a `/*deterministic=*/true` [here in test/fuzz/coins_view.cpp](https://github.com/bitcoin/bitcoin/pull/25325/commits/78f597be2879c39d9d2b98e21ed0120d2308de20#diff-1ef3b6a1936b50f3d5ec4a1786d9e2d63d1a3e1815b103e67f20601995f355b4R119), see `git range-diff 0007d69...78f597b`",
      "created_at" : "2023-02-14T08:04:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1429293948",
      "id" : 1429293948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VMUt8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429293948/reactions"
      },
      "updated_at" : "2023-02-14T08:04:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429293948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-15T15:49:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1431581351",
      "id" : 1431581351,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VVDKn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431581351/reactions"
      },
      "updated_at" : "2023-02-15T15:49:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431581351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "yet another rebase, only dropping the \"Add xoroshiro128++ PRNG\" commit which has already been added in #26153 (commit 5f05b27841af0bed1b6e7de5f46ffe33e5919e4d)",
      "created_at" : "2023-02-15T18:07:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1431795348",
      "id" : 1431795348,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VV3aU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431795348/reactions"
      },
      "updated_at" : "2023-02-15T18:07:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431795348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re-ACK b5eba9ad001f1035dd641bc5880cb6bb53a8b07f",
      "created_at" : "2023-02-16T18:34:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1433537441",
      "id" : 1433537441,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Vcguh",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433537441/reactions"
      },
      "updated_at" : "2023-02-16T18:34:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433537441",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-17T23:35:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1435395920",
      "id" : 1435395920,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VjmdQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435395920/reactions"
      },
      "updated_at" : "2023-02-17T23:35:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435395920",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased adds `#include <test/util/random.h>`",
      "created_at" : "2023-02-18T06:50:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1435501826",
      "id" : 1435501826,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VkAUC",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435501826/reactions"
      },
      "updated_at" : "2023-02-18T07:11:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435501826",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "re-ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-02-18T15:32:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1435700864",
      "id" : 1435700864,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Vkw6A",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435700864/reactions"
      },
      "updated_at" : "2023-02-18T15:32:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435700864",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117323095"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117323095"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`m_untouched_memory_end` now called `m_available_memory_end`",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-02-24T17:01:36Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117323095",
      "id" : 1117323095,
      "line" : 118,
      "node_id" : "PRRC_kwDOABII585CmP9X",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 118,
      "original_position" : 118,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 118,
      "pull_request_review_id" : 1313921906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117323095/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-24T17:12:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117323095",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/116917595?v=4",
         "events_url" : "https://api.github.com/users/john-moffett/events{/privacy}",
         "followers_url" : "https://api.github.com/users/john-moffett/followers",
         "following_url" : "https://api.github.com/users/john-moffett/following{/other_user}",
         "gists_url" : "https://api.github.com/users/john-moffett/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/john-moffett",
         "id" : 116917595,
         "login" : "john-moffett",
         "node_id" : "U_kgDOBvgFWw",
         "organizations_url" : "https://api.github.com/users/john-moffett/orgs",
         "received_events_url" : "https://api.github.com/users/john-moffett/received_events",
         "repos_url" : "https://api.github.com/users/john-moffett/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/john-moffett/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/john-moffett/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/john-moffett"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117328292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117328292"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Extra \"is\" after \"memory\".",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-02-24T17:04:53Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1117328292",
      "id" : 1117328292,
      "line" : 155,
      "node_id" : "PRRC_kwDOABII585CmROk",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 155,
      "pull_request_review_id" : 1313921906,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117328292/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-02-24T17:12:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1117328292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/116917595?v=4",
         "events_url" : "https://api.github.com/users/john-moffett/events{/privacy}",
         "followers_url" : "https://api.github.com/users/john-moffett/followers",
         "following_url" : "https://api.github.com/users/john-moffett/following{/other_user}",
         "gists_url" : "https://api.github.com/users/john-moffett/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/john-moffett",
         "id" : 116917595,
         "login" : "john-moffett",
         "node_id" : "U_kgDOBvgFWw",
         "organizations_url" : "https://api.github.com/users/john-moffett/orgs",
         "received_events_url" : "https://api.github.com/users/john-moffett/received_events",
         "repos_url" : "https://api.github.com/users/john-moffett/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/john-moffett/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/john-moffett/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/john-moffett"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1124914676"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124914676"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this condition is guaranteed by the other static assertions, but this expression seems incorrect. In general, `A & (B-1) == 0` doesn't mean that A is a multiple of B, does it? If A=8 and B=3, then `8 & (3-1)` is zero, but 8 isn't a multiple of 3. If A=8, B=4, then `8 & (4-1)` is also zero, so we get the correct result (8 is a multiple of 4), but it's kind of by accident. To state it differently, if `MAX_BLOCK_SIZE_BYTES` is some large power of 2 (which is guaranteed above), then in binary it's `1000...0`, so ANDing with any smaller value will always produce zero.\r\n\r\nMaybe this is better:\r\n```suggestion\r\n    static_assert((MAX_BLOCK_SIZE_BYTES % ELEM_ALIGN_BYTES) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\r\n```\r\n",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-03T19:18:22Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1124914676",
      "id" : 1124914676,
      "line" : 91,
      "node_id" : "PRRC_kwDOABII585DDNX0",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 91,
      "pull_request_review_id" : 1324475821,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124914676/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-04T08:12:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124914676",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125417231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125417231"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't understand the purpose of adding `sizeof(void*) * 4`; could you leave a brief comment if you get the chance? (Unless I'm just being clueless!)",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-04T08:09:04Z",
      "diff_hunk" : "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125417231",
      "id" : 1125417231,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585DFIEP",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 140,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 18,
      "pull_request_review_id" : 1324475821,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125417231/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-04T08:12:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125417231",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In line 89 there is an assert that `ELEM_ALIGN_BYTES` is multiple of 2:\r\n```cpp\r\nstatic_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\r\n```\r\nSo given that line 91 should make sense, `ELEM_ALIGN_BYTES - 1` becomes a bitmask and actually asserts that `MAX_BLOCK_SIZE_BYTES` is multiple of `ELEM_ALIGN_BYTES`. But right, on its own that assert wouldn't be enough and using `%` is probably a bit more clear.",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-04T11:10:04Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443783",
      "id" : 1125443783,
      "in_reply_to_id" : 1124914676,
      "line" : 91,
      "node_id" : "PRRC_kwDOABII585DFOjH",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 91,
      "pull_request_review_id" : 1324997430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443783/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-04T11:10:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443783",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443786"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Posting here now, I can add this as a comment later: \r\n\r\nThe value here determines the maximum bytes that the `PoolAllocator` supports. When bigger blocks are allocated, this is just forwarded to `new`.\r\n\r\nThe thing with `sizeof(void*) * 4` is, it is not enough to just support up to sizes of the `std::pair<const COutPoint, CCoinsCacheEntry>`, because the different implementations of `std::unordered_map` use more memory for each node. Most implementations wrap the std::pair into a struct that contains a single pointer, so they can link them in a single linked list. But not all; e.g. Microsoft's STL uses a double linked list. Also libstd++ and libc++ wrap the pair differently, which can lead to different memory usage due to alignement, and some might store the hash value as well; depending on if the hash'es `operator()` is `noexcept` or not. All in all, correctly determining the size used for allocation is really hard and brittle because this depends on a lot of implementation details.\r\n\r\nSo with adding 4 * the size of a pointer we err on the safe side; and nodes can surely be allocated with all implementions of std::unordered_map. `m_free_lists` might be a bit larger than it needs to be and have a few pointers that never hold a freelist, but at least we can be sure that `std::unordered_map` nodes are actually allocated with the pool.",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-04T11:10:05Z",
      "diff_hunk" : "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1125443786",
      "id" : 1125443786,
      "in_reply_to_id" : 1125417231,
      "line" : 140,
      "node_id" : "PRRC_kwDOABII585DFOjK",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 140,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 18,
      "pull_request_review_id" : 1324997436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443786/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-05T08:30:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125443786",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@LarryRuane awesome that you'll hold a PR review club about this PR! I'll try to join, but can't yet guarantee that I'll have the time.",
      "created_at" : "2023-03-04T11:13:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1454703666",
      "id" : 1454703666,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585WtQQy",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1454703666/reactions"
      },
      "updated_at" : "2023-03-04T11:13:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1454703666",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128581100"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128581100"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why is `std::size_t` preferred over `size_t` within this file?",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-07T20:59:16Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128581100",
      "id" : 1128581100,
      "line" : 69,
      "node_id" : "PRRC_kwDOABII585DRMfs",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 69,
      "pull_request_review_id" : 1329522422,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128581100/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T15:18:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128581100",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128596813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128596813"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Possibly related to https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591, the first time this runs, both `m_available_memory_it` and `m_available_memory_end` are `nullptr`; is it UB to pass these to `std::distance()`? I think it's okay, just wanted to raise as a possible concern. You could do something like\r\n```suggestion\r\n        size_t remaining_available_bytes = m_available_memory_it ? std::distance(m_available_memory_it, m_available_memory_end) : 0;\r\n```",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-07T21:13:46Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1128596813",
      "id" : 1128596813,
      "line" : 156,
      "node_id" : "PRRC_kwDOABII585DRQVN",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 156,
      "pull_request_review_id" : 1329522422,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128596813/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T15:18:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128596813",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129602006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129602006"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This benchmark doesn't re-use memory (add to freelist then remove from freelist); maybe it would be better if it did because that's what happens with the real coins cache, maybe something like this:\r\n\r\n<details>\r\n<summary>patch</summary>\r\n\r\n```diff\r\n-    size_t batch_size = 5000;\r\n+    // The steady-state size of the map will be half of this value;\r\n+    // power-of-2 to avoid expensive mod operation during benchmark.\r\n+    constexpr size_t batch_size = 1 << 13;\r\n \r\n     // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\r\n     // do this at least 10 times so we get reasonable accurate results\r\n \r\n     bench.batch(batch_size).minEpochIterations(10).run([&] {\r\n         auto rng = ankerl::nanobench::Rng(1234);\r\n-        for (size_t i = 0; i < batch_size; ++i) {\r\n-            map[rng()];\r\n+        for (size_t i = 0; i < batch_size * 10; ++i) {\r\n+            uint64_t r{rng()};\r\n+            // if the map has few entries, more likely add an entry, else delete\r\n+            if ((r & (batch_size-1)) < map.size()) {\r\n+                map.erase(map.begin());\r\n+            } else {\r\n+                map[r];\r\n+            }\r\n         }\r\n         map.clear();\r\n     });\r\n```\r\n</details>\r\n\r\nI don't think it matters which entry we delete, since `map.begin()` could return any entry. Deleting a truly random entry gets more complicated, and I don't think it changes the performance significantly. The loop iterates `batch_size * 10` instead of `batch_size` so we reach steady-state (about equal numbers of insertions and deletions).",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-08T15:15:44Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129602006",
      "id" : 1129602006,
      "line" : 24,
      "node_id" : "PRRC_kwDOABII585DVFvW",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 24,
      "original_position" : 24,
      "original_start_line" : 13,
      "path" : "src/bench/pool.cpp",
      "position" : 24,
      "pull_request_review_id" : 1329522422,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129602006/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 13,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-08T15:18:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129602006",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129641656"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129641656"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is explicitly defined in the standard here, in 5.1: http://eel.is/c++draft/expr.add#5",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-08T15:41:04Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129641656",
      "id" : 1129641656,
      "in_reply_to_id" : 1128596813,
      "line" : 156,
      "node_id" : "PRRC_kwDOABII585DVPa4",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 156,
      "pull_request_review_id" : 1330928582,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129641656/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T15:41:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129641656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129645169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129645169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No real reason. Technically in C++ I believe `std::size_t` should be preferred, especially when using includes like `<cstddef>` instead of `<stddef.h>`. I personally usually use just `size_t` everywhere and never had a compile problem.",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-08T15:43:20Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129645169",
      "id" : 1129645169,
      "in_reply_to_id" : 1128581100,
      "line" : 69,
      "node_id" : "PRRC_kwDOABII585DVQRx",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 69,
      "pull_request_review_id" : 1330932760,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129645169/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-03-08T15:43:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129645169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129650014"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129650014"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Actually it does reuse memory, when calling `map.clear()` all of the entries of the map are deallocated and thus the `pool_resource` gets them and puts them into the freelist. The memory is only ever released in the destructor of `pool_resource`",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-08T15:46:30Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129650014",
      "id" : 1129650014,
      "in_reply_to_id" : 1129602006,
      "line" : 24,
      "node_id" : "PRRC_kwDOABII585DVRde",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 24,
      "original_position" : 24,
      "original_start_line" : 13,
      "path" : "src/bench/pool.cpp",
      "position" : 24,
      "pull_request_review_id" : 1330938802,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129650014/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 13,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-08T15:47:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129650014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129703688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129703688"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's a good point, I hadn't noticed that. But perhaps it's good to make the load more realistic to get better benchmarking results. I'm assuming that when UTXOs become spent TXOs during block validation, they're removed from this unordered_map, but maybe that's not true? Just seems like doing many interleaving allocations and deallocations would be more realistic, but maybe not. But this suggestion is non-blocking.\r\n\r\nIn case anyone is wondering, I observed that the benchmark does cause allocations (and deallocations) that are too large for the pool, and these are for the hash bucket arrays. (I'm sure the fuzzer does that too, so far I've run only the benchmark.)",
      "commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-08T16:17:58Z",
      "diff_hunk" : "@@ -0,0 +1,50 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <support/allocators/pool.h>\n+\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    size_t batch_size = 5000;\n+\n+    // make sure each iteration of the benchmark contains exactly 5000 inserts and one clear.\n+    // do this at least 10 times so we get reasonable accurate results\n+\n+    bench.batch(batch_size).minEpochIterations(10).run([&] {\n+        auto rng = ankerl::nanobench::Rng(1234);\n+        for (size_t i = 0; i < batch_size; ++i) {\n+            map[rng()];\n+        }\n+        map.clear();\n+    });",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1129703688",
      "id" : 1129703688,
      "in_reply_to_id" : 1129602006,
      "line" : 24,
      "node_id" : "PRRC_kwDOABII585DVekI",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 24,
      "original_position" : 24,
      "original_start_line" : 13,
      "path" : "src/bench/pool.cpp",
      "position" : 24,
      "pull_request_review_id" : 1331004938,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129703688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 13,
      "start_side" : "RIGHT",
      "updated_at" : "2023-03-08T16:17:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1129703688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Kicked off a bitcoinperf run; will have some results tomorrow.",
      "created_at" : "2023-03-21T00:46:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477135406",
      "id" : 1477135406,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YC0wu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477135406/reactions"
      },
      "updated_at" : "2023-03-21T00:46:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477135406",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Cool! Seeing a **~8% speedup** over a modern region of the chain with **lower memory usage**.\r\n\r\n---\r\n\r\n![ibd local range dbcache=8000 667200 697200](https://user-images.githubusercontent.com/73197/226613375-a9d038f5-f596-4a04-af8e-a63798ab4752.png)\r\n\r\n|                 bench name                 |                                                                                                     command                                                                                                     |\r\n|--------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.dbcache=8000.667200.697200 | `bitcoind -dbcache=8000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n### #25325 vs. $mergebase (absolute)\r\n|                         bench name                         |  x  |           #25325           |        $mergebase         |\r\n|------------------------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.dbcache=8000.667200.697200.total_secs      |   3 | 4205.0444 (Â± 23.6683)      | 4536.8536 (Â± 7.9194)      |\r\n| ibd.local.range.dbcache=8000.667200.697200.peak_rss_KiB    |   3 | 4428684.0000 (Â± 3557.8525) | 4806934.6667 (Â± 108.7791) |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_kernel_secs |   3 | 210.8233 (Â± 1.0422)        | 209.8300 (Â± 0.9361)       |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_user_secs   |   3 | 26000.4633 (Â± 15.5244)     | 26412.5367 (Â± 8.9365)     |\r\n\r\n\r\n### #25325 vs. $mergebase (relative)\r\n|                         bench name                         |  x  | #25325 | $mergebase |\r\n|------------------------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.dbcache=8000.667200.697200.total_secs      |   3 |   1.00 |      1.079 |\r\n| ibd.local.range.dbcache=8000.667200.697200.peak_rss_KiB    |   3 |   1.00 |      1.085 |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_kernel_secs |   3 |   1.00 |      1.000 |\r\n| ibd.local.range.dbcache=8000.667200.697200.cpu_user_secs   |   3 |   1.00 |      1.016 |\r\n\r\n",
      "created_at" : "2023-03-21T13:02:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477800508",
      "id" : 1477800508,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YFXI8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 2,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477800508/reactions"
      },
      "updated_at" : "2023-03-21T13:02:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477800508",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the benchmark @jamesob! There was no cache flush in the benchmark, that's why the memory usage was lower. When flushes would happen with e.g. lower dbcache size or longer range of blocks memory usage should be about equal, but then there should be an even larger performance benefit for this PR because it can cache more data with the same memory.",
      "created_at" : "2023-03-21T14:18:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477921746",
      "id" : 1477921746,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YF0vS",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477921746/reactions"
      },
      "updated_at" : "2023-03-21T14:18:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477921746",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> When flushes would happen with e.g. lower dbcache size or longer range of blocks memory usage should be about equal, but then there should be an even larger performance benefit for this PR because it can cache more data with the same memory.\r\n\r\nYup - I started another run with dbcache=1000.",
      "created_at" : "2023-03-21T14:28:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1477939852",
      "id" : 1477939852,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YF5KM",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 1,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477939852/reactions"
      },
      "updated_at" : "2023-03-21T14:28:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1477939852",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144023009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144023009"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n            assert(free_block.size <= chunk_size_remaining);                 // ensure no overflow\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T21:48:20Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            assert(free_block.ptr == chunk_ptr_remaining);                   // ensure addresses match\n+            assert(free_block.size <= chunk_size_remaining);                 // ensure we no overflow",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144023009",
      "id" : 1144023009,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMGfh",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 116,
      "original_position" : 116,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144023009/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144023009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025036"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n            std::size_t alignment = std::size_t{1} << InsecureRandRange(8);           // 1, 2, ..., 128\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T21:51:08Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025036",
      "id" : 1144025036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMG_M",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 121,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025651"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        for (const std::byte* ptr : resource.m_allocated_chunks) {\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T21:52:02Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144025651",
      "id" : 1144025651,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMHIz",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 95,
      "original_position" : 95,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025651/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144025651",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144026131"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144026131"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, this would test slightly more\r\n```suggestion\r\n        assert(chunk_ptr_remaining == chunk_it->ptr + chunk_it->size); // ensure we are at the end of the chunks\r\n        ++chunk_it;\r\n        assert(chunk_it == chunks.end());\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T21:52:37Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            assert(free_block.ptr == chunk_ptr_remaining);                   // ensure addresses match\n+            assert(free_block.size <= chunk_size_remaining);                 // ensure we no overflow\n+            assert((free_block.ptr & (resource.ELEM_ALIGN_BYTES - 1)) == 0); // ensure correct alignment\n+            chunk_ptr_remaining += free_block.size;\n+            chunk_size_remaining -= free_block.size;\n+        }\n+        assert(chunk_ptr_remaining == chunks.back().ptr + chunks.back().size); // ensure we are t the end of the chunks",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144026131",
      "id" : 1144026131,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMHQT",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 121,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144026131/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144026131",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Light ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d\r\n\r\nNot particularly well versed in allocators, but the logic of the allocator and its tests makes sense, and the benchmarks seem to show there is a noticeable improvement.\r\n\r\nOne thing I did notice though is that when configured with `--enable-debug`, the benchmark `PoolAllocator_StdUnorderedMapWithPoolResource` is a little bit slower than `PoolAllocator_StdUnorderedMap`. Without `--enable-debug`, it's quite a bit faster. I didn't measure the effect of this in actual IBD, but configuring with `--enable-debug` is already known to make things slower, so it shouldn't matter much.\r\n\r\nWith `--enable-debug`:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|---------------:|--------:|----------:|:----------\r\n|              239.73 |        4,171,384.12 |    0.1% |        2,516.56 |         401.94 |    0.1% |      0.14 | `PoolAllocator_StdUnorderedMap`\r\n|              277.15 |        3,608,128.61 |    0.1% |        2,792.06 |         432.32 |    0.1% |      0.17 | `PoolAllocator_StdUnorderedMapWithPoolResource`\r\n\r\nWithout `--enable-debug`:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|---------------:|--------:|----------:|:----------\r\n|               21.53 |       46,436,178.12 |    0.3% |          279.84 |          59.34 |    0.4% |      0.01 | `PoolAllocator_StdUnorderedMap`\r\n|               10.45 |       95,674,714.97 |    0.2% |           82.34 |          13.71 |    0.8% |      0.01 | `PoolAllocator_StdUnorderedMapWithPoolResource`",
      "created_at" : "2023-03-21T22:16:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1478663359",
      "id" : 1478663359,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YIpy_",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478663359/reactions"
      },
      "updated_at" : "2023-03-21T22:16:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478663359",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144046537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144046537"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Probably not important, but if a bug caused a cycle in a freelist, I think the test would allocate an unbounded amount of memory (pushing to `free_blocks`), which would be not a nice way to fail. I think you could calculate an upper bound of the number of free blocks (number of chunks times chunk size divided by this free list's blocksize), then assert if the number of iterations exceeds that number.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T22:20:54Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144046537",
      "id" : 1144046537,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585EMMPJ",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : 82,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : 85,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144046537/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 82,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144046537",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144070292"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144070292"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit, and would this make the test too specific? I don't think so, but something to consider.\r\n```suggestion\r\n    void* b = resource.Allocate(8, 1);\r\n    BOOST_TEST(block == b);\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T22:59:58Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144070292",
      "id" : 1144070292,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMSCU",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 40,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144070292/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144070292",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144072741"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144072741"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    // can't use resource because alignment is too big, allocate system memory\r\n    b = resource.Allocate(8, 16);\r\n    BOOST_TEST(block == b);\r\n    block = b;\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T23:04:47Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144072741",
      "id" : 1144072741,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMSol",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : 49,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144072741/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144072741",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144076687"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144076687"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n    // can't use resource because size is too big, allocate system memory\r\n    b = resource.Allocate(16, 8);\r\n    BOOST_TEST(block != b);\r\n    block = b;\r\n\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T23:12:24Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144076687",
      "id" : 1144076687,
      "line" : 64,
      "node_id" : "PRRC_kwDOABII585EMTmP",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 64,
      "original_position" : 61,
      "original_start_line" : 60,
      "path" : "src/test/pool_tests.cpp",
      "position" : 64,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144076687/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 63,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144076687",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144079597"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144079597"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`counts` is unused",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T23:18:14Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144079597",
      "id" : 1144079597,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMUTt",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144079597/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144079597",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144084403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144084403"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        // set each byte to num_bytes\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T23:26:43Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144084403",
      "id" : 1144084403,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMVez",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144084403/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144084403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100307"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100307"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This test doesn't allocate zero bytes, it allocates 1 to n bytes. It seems like zero-byte allocations should be allowed. See comments below.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-21T23:59:59Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100307",
      "id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EMZXT",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100307/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100307",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100854"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If we want to test zero-length allocations (but requires a change to `Deallocate()`, see comment there).\r\n```suggestion\r\n    for (uint8_t num_bytes = 0; num_bytes < num_allocs; ++num_bytes) {\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T00:01:12Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144100854",
      "id" : 1144100854,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMZf2",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 83,
      "original_position" : 83,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100854/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144100854",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144101007"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144101007"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If we want to test zero-length allocations (but requires a change to `Deallocate()`, see comment there).\r\n```suggestion\r\n    uint8_t val = 0;\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T00:01:34Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144101007",
      "id" : 1144101007,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMZiP",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144101007/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144101007",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144103123"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144103123"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This allows zero-byte allocations, which I think is supported by the standard allocator, so we should too (right?) I benchmarked this change and there was no difference, but my benchmark setup is not very good, so that should definitely be tested.\r\n```suggestion\r\n            if (bytes > 0) {\r\n                const std::size_t num_alignments = NumElemAlignBytes(bytes);\r\n                // put the memory block into the linked list. We can placement construct the FreeList\r\n                // into the memory since we can be sure the alignment is correct.\r\n                PlacementAddToList(p, m_free_lists[num_alignments]);\r\n            }\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T00:06:46Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const std::ptrdiff_t round_bytes = static_cast<std::ptrdiff_t>(num_alignments * ELEM_ALIGN_BYTES);\n+            if (round_bytes > m_available_memory_end - m_available_memory_it) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144103123",
      "id" : 1144103123,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585EMaDT",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : 244,
      "path" : "src/support/allocators/pool.h",
      "position" : 247,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144103123/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 244,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144103123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Back with results for dbcache=1000; less noticeable speedup (5%) and increased memory usage (11%).\r\n\r\n---\r\n\r\n![ibd local range dbcache=1000 667200 697200](https://user-images.githubusercontent.com/73197/226771758-dc8f9974-8304-472e-a9fb-15c2e493d5f2.png)\r\n\r\n|                 bench name                 |                                                                                                     command                                                                                                     |\r\n|--------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.dbcache=1000.667200.697200 | `bitcoind -dbcache=1000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n### #25325 vs. $mergebase (absolute)\r\n|                         bench name                         |  x  |           #25325            |         $mergebase         |\r\n|------------------------------------------------------------|----:|-----------------------------|----------------------------|\r\n| ibd.local.range.dbcache=1000.667200.697200.total_secs      |   3 | 4721.4819 (Â± 11.2932)       | 4990.6752 (Â± 19.7466)      |\r\n| ibd.local.range.dbcache=1000.667200.697200.peak_rss_KiB    |   3 | 2906596.0000 (Â± 86412.3208) | 2607876.0000 (Â± 4288.9414) |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_kernel_secs |   3 | 499.0333 (Â± 4.3527)         | 581.9333 (Â± 4.1179)        |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_user_secs   |   3 | 26882.3333 (Â± 17.6349)      | 27490.5000 (Â± 12.0885)     |\r\n\r\n\r\n### #25325 vs. $mergebase (relative)\r\n|                         bench name                         |  x  | #25325 | $mergebase |\r\n|------------------------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.dbcache=1000.667200.697200.total_secs      |   3 |   1.00 |      1.057 |\r\n| ibd.local.range.dbcache=1000.667200.697200.peak_rss_KiB    |   3 |   1.11 |      1.000 |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_kernel_secs |   3 |   1.00 |      1.166 |\r\n| ibd.local.range.dbcache=1000.667200.697200.cpu_user_secs   |   3 |   1.00 |      1.023 |\r\n\r\n",
      "created_at" : "2023-03-22T00:34:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1478764099",
      "id" : 1478764099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YJCZD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478764099/reactions"
      },
      "updated_at" : "2023-03-22T00:34:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478764099",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144123098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144123098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This change will cause the pool resource allocator to be used much more often (since the max block size is 128).\r\n```suggestion\r\n            std::size_t size = (InsecureRandRange(200) / alignment + 1) * alignment;  // multiple of alignment\r\n```",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T00:53:33Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1144123098",
      "id" : 1144123098,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EMe7a",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 122,
      "original_position" : 122,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1351433045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144123098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T01:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1144123098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "created_at" : "2023-03-22T14:33:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1479679004",
      "id" : 1479679004,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YMhwc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479679004/reactions"
      },
      "updated_at" : "2023-03-22T14:33:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479679004",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jamesob interesting that it didn't see a bigger speedup, but I guess it depends on a lot of other factors as well. How fast is your harddisk, and how much RAM does your computer have?",
      "created_at" : "2023-03-22T17:23:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1479975523",
      "id" : 1479975523,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YNqJj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479975523/reactions"
      },
      "updated_at" : "2023-03-22T17:23:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1479975523",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145197139"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145197139"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That here would be `BOOST_TEST(block != b)`, because since `b` now has to come from the `::operator new` and not from the freelist",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T17:42:03Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145197139",
      "id" : 1145197139,
      "in_reply_to_id" : 1144072741,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585EQlJT",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : 49,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1353164917,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145197139/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T17:42:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145197139",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145200479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145200479"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "With the above change, if I'm not mistaken I don't think it's safe to check for `BOOST_TEST(block != b)` here too. This too calls `::operator new`, and because the previous memory was deallocated already, it might give out the same block of memory, depending on however malloc is implemented",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T17:45:14Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145200479",
      "id" : 1145200479,
      "in_reply_to_id" : 1144076687,
      "line" : 64,
      "node_id" : "PRRC_kwDOABII585EQl9f",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 64,
      "original_position" : 61,
      "original_start_line" : 60,
      "path" : "src/test/pool_tests.cpp",
      "position" : 64,
      "pull_request_review_id" : 1353169975,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145200479/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 63,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-22T17:45:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145200479",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145236261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145236261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "After having a closer look, you are right that currently allocating & freeing 0 bytes does not work with the resource. But I think I can't allow allocating 0 bytes with the resource at all, because when allocating multple 0 bytes it would always give out the same pointer, and the standard says that this is not allowed: https://cplusplus.github.io/LWG/issue9\r\n\r\nSo I think the best solution is to just add a `bytes > 0` condition to `IsFreeListUsable`, so that `::operator new` will be used in that case.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T18:17:48Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145236261",
      "id" : 1145236261,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EQusl",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1353221884,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145236261/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T18:17:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145236261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145435338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145435338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Alternatively, just round up size 0 to be at least 1 alignment?",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T21:38:42Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145435338",
      "id" : 1145435338,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585ERfTK",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1353515008,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145435338/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T21:43:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145435338",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145478812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145478812"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@martinus, good catch!\r\n@sipa, good idea, this does seem to work (hope this is what you meant):\r\n```\r\n     [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\r\n     {\r\n-        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\r\n+        return bytes > 0 ? ((bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES) : 1;\r\n     }\r\n```\r\nBenchmark results are identical for me, but this should be confirmed.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T22:40:34Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145478812",
      "id" : 1145478812,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585ERp6c",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1353572550,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145478812/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T22:40:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145478812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145490940"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145490940"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, or even:\r\n\r\n```c++\r\nreturn (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES + (bytes == 0);\r\n```\r\n\r\nwhich might be a minuscule amount faster.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-22T23:01:16Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1145490940",
      "id" : 1145490940,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585ERs38",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1353605999,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145490940/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-22T23:01:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145490940",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146502076"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146502076"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's clever! They generate similar code, but this first way is slightly less code https://godbolt.org/z/Pz77TTEd8\r\n```\r\nint f(int bytes)\r\n{\r\n    return bytes > 0 ? (bytes+8-1)/8 : 1;\r\n}\r\n```\r\n\r\nOr https://godbolt.org/z/adzasoPad\r\n```\r\nint f(int bytes)\r\n{\r\n    return (bytes+8-1)/8 + (bytes == 0);\r\n}\r\n```\r\nThat's using x86-64 gcc 11.3; results are similar for x86-64 clang 16.0.0.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-23T17:02:37Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146502076",
      "id" : 1146502076,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EVju8",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1355086199,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146502076/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-23T17:02:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146502076",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146560809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146560809"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The code generation is a bit different when you use unsigned types, then the `+ (bytes == 0)` version is the shortedst for me. In my microbenchmark the `+ (bytes == 0)` is also fastest, but in practice its most likely irrelevant",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-23T17:37:12Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146560809",
      "id" : 1146560809,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EVyEp",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1355173295,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 2,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 2,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146560809/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-23T17:37:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146560809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146653864"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146653864"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'll implement the ` + (bytes == 0)` for NumElemAlignBytes",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-23T18:30:28Z",
      "diff_hunk" : "@@ -0,0 +1,349 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*ELEM_ALIGN_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back() + m_chunk_size_bytes`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const std::ptrdiff_t round_bytes = static_cast<std::ptrdiff_t>(num_alignments * ELEM_ALIGN_BYTES);\n+            if (round_bytes > m_available_memory_end - m_available_memory_it) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1146653864",
      "id" : 1146653864,
      "in_reply_to_id" : 1144103123,
      "line" : 247,
      "node_id" : "PRRC_kwDOABII585EWIyo",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 247,
      "original_position" : 247,
      "original_start_line" : 244,
      "path" : "src/support/allocators/pool.h",
      "position" : 247,
      "pull_request_review_id" : 1355311138,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146653864/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 244,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-23T18:30:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146653864",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated  d87cb99 -> 9f947fc3d4b779f017332135323b34e8f216f613 ([pr25325.1](https://github.com/martinus/bitcoin/commits/pr25325.1) -> [pr25325.2](https://github.com/martinus/bitcoin/commits/pr25325.2))\r\n\r\nThere is a single behavior change in pool.h, now `NumElemAlignBytes` adds `+ (bytes == 0)` so that allocations of 0 bytes work with the PoolAllocator.\r\n\r\nOther than that, updated tests to include allocation of 0 bytes, and fixed all the nits.\r\n\r\nI tried to to benchmark to see any diffference with the new `+ (bytes == 0)` check or with the `bytes > 0 ?` variant, and all behave exactly the same in the `PoolAllocator_StdUnorderedMapWithPoolResource` benchmark. Exactly the same number of instructions, same number of branches, and the time fluctuates only due to measurement precision:\r\n\r\n|               ns/op |                op/s |    err% |          ins/op |          cyc/op |    IPC |         bra/op |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|               40.69 |       24,575,107.54 |    0.1% |          151.20 |          129.46 |  1.168 |          23.54 |    2.1% |      1.10 | old d87cb99bb3\r\n|               40.70 |       24,568,640.94 |    0.2% |          151.20 |          129.48 |  1.168 |          23.54 |    2.0% |      1.10 | `bytes > 0 ?`\r\n|               40.47 |       24,707,366.33 |    0.7% |          151.20 |          128.74 |  1.174 |          23.54 |    2.1% |      1.10 | new  9f947fc3d4: `+ (bytes == 0)`\r\n",
      "created_at" : "2023-03-23T19:34:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1481782854",
      "id" : 1481782854,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YUjZG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1481782854/reactions"
      },
      "updated_at" : "2023-03-24T05:46:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1481782854",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147123753"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147123753"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've left that out on purpose, I didn't want to complicate this code any further. So far this case never happened",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-24T05:09:44Z",
      "diff_hunk" : "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147123753",
      "id" : 1147123753,
      "in_reply_to_id" : 1144046537,
      "line" : 85,
      "node_id" : "PRRC_kwDOABII585EX7gp",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : 82,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : 85,
      "pull_request_review_id" : 1356009221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147123753/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 82,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T05:09:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147123753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147124025"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147124025"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've implemented the `+ (bytes == 0)` version in 9f947fc3d4b779f017332135323b34e8f216f613",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-24T05:10:24Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147124025",
      "id" : 1147124025,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EX7k5",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1356009620,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147124025/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T05:10:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147124025",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852238"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852238"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> The code generation is a bit different when you use unsigned types, then the `+ (bytes == 0)` version is the shortedst for me. In my microbenchmark the `+ (bytes == 0)` is also fastest, but in practice its most likely irrelevant\r\n\r\nYes, it seems to be one instruction shorter after updating @LarryRuane's examples (thanks for doing them) to `size_t` and checking with gcc 12.2 and clang 16.",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-24T17:03:47Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852238",
      "id" : 1147852238,
      "in_reply_to_id" : 1144100307,
      "line" : 86,
      "node_id" : "PRRC_kwDOABII585EatXO",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 86,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 86,
      "pull_request_review_id" : 1357116645,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852238/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-03-24T17:03:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852238",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852733"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852733"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(Only if you have to retouch, or maybe in a follow-up), perhaps add this comment:\r\n\r\n```cpp\r\nBOOST_TEST(b != block); // as `b` has to come from `::operator new` and not from the freelist",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-24T17:04:18Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/random.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1147852733",
      "id" : 1147852733,
      "in_reply_to_id" : 1144072741,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585Eate9",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 50,
      "original_position" : 50,
      "original_start_line" : 49,
      "path" : "src/test/pool_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1357117819,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852733/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "subject_type" : "line",
      "updated_at" : "2023-03-24T17:04:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147852733",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-03-24T17:40:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1483180518",
      "id" : 1483180518,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585YZ4nm",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1483180518/reactions"
      },
      "updated_at" : "2023-03-24T17:40:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1483180518",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/8321330?v=4",
         "events_url" : "https://api.github.com/users/LarryRuane/events{/privacy}",
         "followers_url" : "https://api.github.com/users/LarryRuane/followers",
         "following_url" : "https://api.github.com/users/LarryRuane/following{/other_user}",
         "gists_url" : "https://api.github.com/users/LarryRuane/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/LarryRuane",
         "id" : 8321330,
         "login" : "LarryRuane",
         "node_id" : "MDQ6VXNlcjgzMjEzMzA=",
         "organizations_url" : "https://api.github.com/users/LarryRuane/orgs",
         "received_events_url" : "https://api.github.com/users/LarryRuane/received_events",
         "repos_url" : "https://api.github.com/users/LarryRuane/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/LarryRuane/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/LarryRuane/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/LarryRuane"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sipa could you have another look after my update from d87cb99 -> 9f947fc3d4b779f017332135323b34e8f216f613?",
      "created_at" : "2023-03-28T07:21:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1486343844",
      "id" : 1486343844,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Yl86k",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1486343844/reactions"
      },
      "updated_at" : "2023-03-28T07:21:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1486343844",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-04-20T20:11:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516886734",
      "id" : 1516886734,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585aadrO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516886734/reactions"
      },
      "updated_at" : "2023-04-20T20:11:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516886734",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Posthumous utACK 9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-04-20T20:32:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1516910306",
      "id" : 1516910306,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585aajbi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516910306/reactions"
      },
      "updated_at" : "2023-04-20T20:32:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1516910306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Wohoo :tada: Thanks everyone for making this happen!",
      "created_at" : "2023-04-21T04:12:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1517233030",
      "id" : 1517233030,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585abyOG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517233030/reactions"
      },
      "updated_at" : "2023-04-21T04:12:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1517233030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422138"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422138"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@martinus\r\n\r\nCould assessing of the `std::unordered_map::node_type` improve this heuristic?",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-11-19T15:34:19Z",
      "diff_hunk" : "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422138",
      "id" : 1398422138,
      "in_reply_to_id" : 1125417231,
      "line" : 148,
      "node_id" : "PRRC_kwDOABII585TWjp6",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 148,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 26,
      "pull_request_review_id" : 1738642653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422138/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-19T15:34:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422138",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422857"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@hebasto Unfortunately not, I actually wanted to use this but learned that this is actually just the type of the node handle which more or less is just a pointer to the data. The actual type of the node used for allocation is not exposed by the standard. If it were, it would make the pool implementation quite a bit simpler",
      "commit_id" : "9f947fc3d4b779f017332135323b34e8f216f613",
      "created_at" : "2023-11-19T15:38:35Z",
      "diff_hunk" : "@@ -131,7 +132,15 @@ struct CCoinsCacheEntry\n     CCoinsCacheEntry(Coin&& coin_, unsigned char flag) : coin(std::move(coin_)), flags(flag) {}\n };\n \n-typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n+using CCoinsMap = std::unordered_map<COutPoint,\n+                                     CCoinsCacheEntry,\n+                                     SaltedOutpointHasher,\n+                                     std::equal_to<COutPoint>,\n+                                     PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>,\n+                                                   sizeof(std::pair<const COutPoint, CCoinsCacheEntry>) + sizeof(void*) * 4,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1398422857",
      "id" : 1398422857,
      "in_reply_to_id" : 1125417231,
      "line" : 148,
      "node_id" : "PRRC_kwDOABII585TWj1J",
      "original_commit_id" : "d87cb99bb37637e26a9e00b9f7de4bc6f44cb79d",
      "original_line" : 148,
      "original_position" : 18,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 26,
      "pull_request_review_id" : 1738643496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422857/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "subject_type" : "line",
      "updated_at" : "2023-11-19T15:38:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1398422857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   }
]
