[
   {
      "body" : "Concept ACK!   I'm glad that you're working on this. I think it's the right approach.\r\nThe other advantage is that right now, IIRC, once the ulimit maximum of locked pages is reached, no more data will be locked... silent... and the massive locked page inflation makes it easy to hit any reasonable limit quickly.",
      "created_at" : "2016-09-18T09:23:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247836948",
      "id" : 247836948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T09:23:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247836948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "There is no\r\n```\r\nstatic inline std::pair<std::string,UniValue> Pair(const char *, size_t)\r\n```\r\n",
      "created_at" : "2016-09-18T09:50:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247838140",
      "id" : 247838140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T09:50:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247838140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "> The other advantage is that right now, IIRC, once the ulimit maximum of locked pages is reached, no more data will be locked... silent... and the massive locked page inflation makes it easy to hit any reasonable limit quickly.\r\n\r\nIndeed. I've also been thinking about heartbleed-like attacks. Currently key data is scattered all around the heap and stack, with this approach it is consolidated in a few places which are separate from the normal heap where e.g. network buffers are allocated.\r\n\r\nIt would help even more if the secret data is separated with a 'moat' of unmapped pages from the normal heap, so that a large read can't get there.\r\n\r\nI've done nothing special to accomplish this at the moment, though, apart from trying to use the OS page allocation directly. Which reminds me that on POSIX I should probably be using `mmap` not `posix_memalign` which may just grab the memory from the heap.\r\n\r\n> static inline std::pair<std::string,UniValue> Pair(const char *, size_t)\r\n\r\nGah, that needs a silly cast to uint64_t (I guess this error comes up on 32-bit platforms?).\r\n",
      "created_at" : "2016-09-18T10:22:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247839585",
      "id" : 247839585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T10:25:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247839585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303352"
         }
      },
      "body" : "`_allocator` here please.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-18T11:04:53Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303352",
      "id" : 79303352,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303409"
         }
      },
      "body" : "As you use `x` down in for cycles, please change this.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-18T11:07:36Z",
      "diff_hunk" : "@@ -11,110 +11,210 @@\n \n BOOST_FIXTURE_TEST_SUITE(allocator_tests, BasicTestingSetup)\n \n-// Dummy memory page locker for platform independent tests\n-static const void *last_lock_addr, *last_unlock_addr;\n-static size_t last_lock_len, last_unlock_len;\n-class TestLocker\n+BOOST_AUTO_TEST_CASE(arena_tests)\n {\n-public:\n-    bool Lock(const void *addr, size_t len)\n+    // Fake memory base address for testing\n+    // without actually using memory.\n+    void *synth_base = reinterpret_cast<void*>(0x08000000);\n+    const size_t synth_size = 1024*1024;\n+    Arena b(synth_base, synth_size, 16);\n+    void *x = b.alloc(1000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303409",
      "id" : 79303409,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 17,
      "path" : "src/test/allocator_tests.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303409",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303418"
         }
      },
      "body" : "I'm using `_in` as convention in this file, but yes it shouldn't shadow here.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-18T11:08:05Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303418",
      "id" : 79303418,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@paveljanik Ok, I've made your variable naming changes. But let's please discuss higher-level concerns first before bombarding nits in code that may be thrown away anyway.",
      "created_at" : "2016-09-18T11:10:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247841551",
      "id" : 247841551,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T11:10:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247841551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "The higher level is already wrote by @gmaxwell, no need to repeat it.\r\n\r\nWith `ulimit -l` being unlimited, RPC returns:\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 262144\r\n  }\r\n}\r\n```\r\n\r\nAfter `ulimit -l 128`, the result is:\r\n\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 0\r\n  }\r\n}\r\n```\r\n\r\nNo memory locked at all? Or when we jump out of the limit, you do not lock anything?\r\n\r\nHmm, arena is 256k min. Will try with lower arena size.\r\n\r\nChanged arenasize to 128k and:\r\n\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 131072\r\n  }\r\n}\r\n```\r\nGood!",
      "created_at" : "2016-09-18T12:00:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247843668",
      "id" : 247843668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T12:16:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247843668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79304140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79304140"
         }
      },
      "body" : "New file, new convention? Welcome to Bitcoin Core...\r\n\r\n*Edit*: There is no need to markup irony ;-)",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-18T12:00:39Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79304140",
      "id" : 79304140,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79304140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "The default `ulimit -l` values can bring a lot of fun here... OS X unlimited, SUSE Linux 64k etc.",
      "created_at" : "2016-09-18T12:19:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247844473",
      "id" : 247844473,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T12:19:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247844473",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "> No memory locked at all? Or when we jump out of the limit, you do not lock anything?\r\n\r\nIt allocates and locks memory per arena. If locking the first arena (of 256Kib) fails, nothing will be locked. You could set the `ARENA_SIZE` to 128 kilobytes and retry. Possibly it could read the ulimit value and create the first arena of that size, if it is less than the default of 256, I don't know how OS specific this is, though it seems UNIX-like OSes at least have `getrlimit(RLIMIT_MEMLOCK)`.\r\n\r\n> OS X unlimited, SUSE Linux 64k etc.\r\n\r\nYes on Ubuntu it's also unlimited by default. OpenBSD has 5 MiB. 64k seems utterly useless.\r\n",
      "created_at" : "2016-09-18T13:59:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247849284",
      "id" : 247849284,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T14:05:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247849284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "> Possibly it could read the ulimit value and create the first arena of that size, if it is less than the default of 256\r\n\r\nDone, it should always get one arena of locked memory as long as the limit is larger then 0. If not it will act as a NonLockedPoolManager, nothing else to do.\r\n",
      "created_at" : "2016-09-18T14:40:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247851518",
      "id" : 247851518,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T14:40:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247851518",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "After `ulimit -l 128`:\r\n\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 192608,\r\n    \"total\": 393216,\r\n    \"locked\": 131072\r\n  }\r\n}\r\n```",
      "created_at" : "2016-09-18T14:56:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247852368",
      "id" : 247852368,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T14:56:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247852368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "That's exactly what should be expected. It uses all the locked memory allowed to it by the limit. Thanks for testing.",
      "created_at" : "2016-09-18T15:40:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247854921",
      "id" : 247854921,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T15:41:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247854921",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "You might want to make the allocation increment just one page and on start have an initial allocation that is equal to whatever typical usage is in the current configuration.  This would both reduce over-allocation and increase the chances that we get all that ulimit would allow. Not a strong opinion, just a design tweak.  Guard pages sound like a good idea. They should be at least as large as any object that exists in the system. Causing the locked page pool to be at a random address would be helpful too.",
      "created_at" : "2016-09-18T19:45:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247869926",
      "id" : 247869926,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T19:45:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247869926",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "> You might want to make the allocation increment just one page and on start have an initial allocation that is equal to whatever typical usage is in the current configuration. \r\n\r\nThe practical problem here is that having tons of one-page (or two-page for that matter) arenas reduces performance, at least with the current implementation. I don't think allocating 256kB (or whatever the ulimit is, if it is less) on the first time this is used is such a bad compromise given Bitcoin Core's frequent use of this memory. As said my relatively large (not huge) wallet already requires 512kiB (which is really ~300KiB rounded up, but we're not programming for the C64 here).\r\n\r\nAlso there would be some residual memory wasted if the pool consists of 4k/8k blocks spread around. And mind the syscall overhead when requesting from OS in such small quantities.\r\n\r\nNote that I'm all for changing the 256kB parameter to say, 128kB, if that is marginally better. As I've documented in the comments it's a compromise.\r\n\r\n> Causing the locked page pool to be at a random address would be helpful too.\r\n\r\nHm, I guess, by specifying a random argument to mmap (modulus the virtual address size, rounded to a page) and then 'probing' the address space where it can be put. I think this is a great idea for later, but I'm not aiming to do so in this pull (maybe we can borrow some code from ASLR?). Also here you don't want the individual arenas too small or it'd spray the address space to unusability, as well as burden the MMU tables.\r\n",
      "created_at" : "2016-09-19T07:21:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247925627",
      "id" : 247925627,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-19T09:36:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247925627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Review comment on the first two commits: if you'd change the variable name of the field/variable whose type changes, it's obvious from the diff that you've adapted all places in the code that affect it (makes it easier to guarantee that there are no sizeofs left).",
      "created_at" : "2016-09-19T09:45:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247950946",
      "id" : 247950946,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-19T09:45:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247950946",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79357806"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79357806"
         }
      },
      "body" : "std::once_flag ?",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T09:49:43Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79357806",
      "id" : 79357806,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 29,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79357806",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79358460"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79358460"
         }
      },
      "body" : "s/uint32_t/ChunkFlags/ ?\r\n",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T09:53:39Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79358460",
      "id" : 79358460,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79358460",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79358595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79358595"
         }
      },
      "body" : "Use align_up?",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T09:54:33Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79358595",
      "id" : 79358595,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 56,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79358595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79359379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79359379"
         }
      },
      "body" : "Code style nit: braces on the same line, except for namespaces, classes, functions, methods.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T09:59:17Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79359379",
      "id" : 79359379,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 63,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79359379",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79362401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79362401"
         }
      },
      "body" : "Typo: otherwise",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T10:20:44Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(0, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr == nullptr)\n+        return nullptr;\n+    // VirtualLock is used to attempt to keep keying material out of swap Note\n+    // that it does not provide this as a guarantee, but, in practice, memory\n+    // that has been VirtualLock'd almost never gets written to the pagefile\n+    // except in rare circumstances where memory is extremely low.\n+    *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr = 0;\n+    len = align_up(len, page_size);\n+    if (posix_memalign(&addr, page_size, len) != 0)\n+        return 0;\n+    *lockingSuccess = mlock(addr, len) == 0;\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    free(addr);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)\n+{\n+}\n+\n+LockedPool::~LockedPool()\n+{\n+}\n+void* LockedPool::alloc(size_t size)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    // Try allocating from each current arena\n+    for (auto &arena: arenas)\n+    {\n+        void *addr = arena.alloc(size);\n+        if (addr)\n+            return addr;\n+    }\n+    // If that fails, create a new one\n+    if (new_arena(ARENA_SIZE, ARENA_ALIGN))\n+    {\n+        return arenas.back().alloc(size);\n+    }\n+    return nullptr;\n+}\n+\n+void LockedPool::free(void *ptr)\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    // TODO we can do better than this linear search by keeping a map of arena\n+    // extents to arena, and looking up the address.\n+    for (auto &arena: arenas)\n+    {\n+        try {\n+            arena.free(ptr);\n+            return;\n+        } catch(std::runtime_error &e) {\n+            // Next\n+        }\n+    }\n+    throw std::runtime_error(\"LockedPool: invalid or double free\");\n+}\n+\n+LockedPool::Stats LockedPool::stats() const\n+{\n+    std::lock_guard<std::mutex> lock(mutex);\n+    LockedPool::Stats r;\n+    r.used = r.free = r.total = 0;\n+    r.locked = cumulative_bytes_locked;\n+    for (const auto &arena: arenas)\n+    {\n+        Arena::Stats i = arena.stats();\n+        r.used += i.used;\n+        r.free += i.free;\n+        r.total += i.total;\n+    }\n+    return r;\n+}\n+\n+bool LockedPool::new_arena(size_t size, size_t align)\n+{\n+    bool locked;\n+    void *addr = allocator->AllocateLocked(size, &locked);\n+    if (!addr)\n+        return false;\n+    if (locked) {\n+        cumulative_bytes_locked += size;\n+    } else if (lf_cb) { // Call the locking-failed callback if locking failed\n+        if (!lf_cb()) { // If the callback returns false, free the memory and fail, other consider the user warned and proceed.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79362401",
      "id" : 79362401,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 306,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79362401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79381029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79381029"
         }
      },
      "body" : "Does bitwise logic with enums work with C++11? I didn't dare try.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T12:39:30Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79381029",
      "id" : 79381029,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79381029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "> Review comment on the first two commits: if you'd change the variable name of the field/variable whose type changes, it's obvious from the diff that you've adapted all places in the code that affect it\r\n\r\nGood idea, I did this for the class field at least (chKey to vchKey and chIV to vchIV), makes sense as a general suggestion.\r\n\r\n",
      "created_at" : "2016-09-19T12:39:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247981919",
      "id" : 247981919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-19T12:39:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247981919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79382347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79382347"
         }
      },
      "body" : "Nice, that breaks the only dependency on boost",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T12:46:39Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79382347",
      "id" : 79382347,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 29,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79382347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79409343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79409343"
         }
      },
      "body" : "enums automatically decay to the integer type they are derived from for supported operations. Also, any reason for not just using a boolean? Do we expect more flags to be added in the future?",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T14:53:01Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79409343",
      "id" : 79409343,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79409343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79441447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79441447"
         }
      },
      "body" : "> enums automatically decay to the integer type they are derived from for supported operations. \r\n\r\nRight - it always broke down when trying to assign the result of a bitwise operation back to the enum type. Good to hear that this is not a problem anymore.\r\n\r\n> Do we expect more flags to be added in the future?\r\n\r\nNo, I don't expect more flags to be added.\r\n\r\nI'm thinking of using the typical C heap solution: use the LSB of size as used-flag, then set the minimum for the required alignment to 2. It'd be silly to set the alignment to 1 anyway.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T17:17:10Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79441447",
      "id" : 79441447,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79441447",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79442989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79442989"
         }
      },
      "body" : "You need to cast to assign back to the enum type, as integers aren't automatically converted to enums, only the other way around.\r\n\r\nWhat I meant was that you'd just have an enum with two values, and you wouldn't use any bitwise logic. But that would not make it much more clear than just using a boolean.\r\n\r\n> I'm thinking of using the typical C heap solution: use the LSB of size as used-flag, then set the minimum for the required alignment to 2. It'd be silly to set the alignment to 1 anyway.\r\n\r\nOr use the MSB and disallow locking over 2 GiB :)",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-19T17:24:05Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79442989",
      "id" : 79442989,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T08:59:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79442989",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79583838"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79583838"
         }
      },
      "body" : "> Or use the MSB and disallow locking over 2 GiB :)\r\n\r\nGood idea, going with that, it's less invasive.",
      "commit_id" : "7cf33e2c40fd25d56e53a221257baaf806dd1a39",
      "created_at" : "2016-09-20T10:52:35Z",
      "diff_hunk" : "@@ -0,0 +1,224 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_LOCKEDPOOL_H\n+#define BITCOIN_SUPPORT_LOCKEDPOOL_H\n+\n+#include <stdint.h>\n+#include <list>\n+#include <map>\n+#include <mutex>\n+\n+#include <boost/thread/once.hpp>\n+\n+/**\n+ * OS-dependent allocation and deallocation of locked/pinned memory pages.\n+ * Abstract base class.\n+ */\n+class LockedPageAllocator\n+{\n+public:\n+    virtual ~LockedPageAllocator() {}\n+    /** Allocate and lock memory pages.\n+     * If len is not a multiple of the system page size, it is rounded up.\n+     * Returns 0 in case of allocation failure.\n+     *\n+     * If locking the memory pages could not be accomplished it will still\n+     * return the memory, however the lockingSuccess flag will be false.\n+     * lockingSuccess is undefined if the allocation fails.\n+     */\n+    virtual void* AllocateLocked(size_t len, bool *lockingSuccess) = 0;\n+\n+    /** Unlock and free memory pages.\n+     * Clear the memory before unlocking.\n+     */\n+    virtual void FreeLocked(void* addr, size_t len) = 0;\n+};\n+\n+/* An arena manages a contiguous region of memory by dividing it into\n+ * chunks.\n+ */\n+class Arena\n+{\n+public:\n+    Arena(void *base, size_t size, size_t alignment);\n+    virtual ~Arena();\n+\n+    /* Per-chunk flags */\n+    enum ChunkFlags: uint32_t {\n+        INUSE = 1\n+    };\n+    /* A chunk of memory. */\n+    struct Chunk\n+    {\n+        Chunk(size_t size_in, uint32_t flags_in):\n+            size(size_in), flags(flags_in) {}\n+        size_t size;\n+        uint32_t flags;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79583838",
      "id" : 79583838,
      "original_commit_id" : "0b4126ae291070ac9c255529e51649be9b155d7c",
      "original_position" : 58,
      "path" : "src/support/lockedpool.h",
      "position" : 63,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-20T10:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79583838",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   }
]
