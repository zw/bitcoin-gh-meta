{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "MEMBER",
   "body" : "Originally suggested by @jb55 [here](https://github.com/ElementsProject/lightning/issues/1297#issuecomment-409385730) on the c-lightning repo.\r\n\r\nA prune event can cause data to disappear that an RPC client still needs.\r\n\r\nAs long as the client doesn't fall too far behind this is unlikely to happen, because we always keep the most recent 550MB around. But even then it's nice to have certainty, and applications do sometimes crash, or get DOS'ed.\r\n\r\nA bigger problem are wallets, which can now be dynamically loaded and unloaded. In addition, multiprocess #10102 would allow use cases like leaving the daemon running and only loading the wallet when the GUI starts, a much snappier user experience than we have now where the user always has to wait at launch. But with a pruned node, this can lead to rescan failing because it fell too far behind, forcing the user to re-download the entire chain. \r\n\r\nSo it would be nice if RPC clients (as well as a wallet process) can tell the node not to prune below a certain hight. That creates three new problems:\r\n\r\n1. what do you do when storage reaches `prune=`? \r\n2. what if the client forgets to cancel this request?\r\n3. do we want to bother tracking this per RPC user, and how do you combine these wishes?\r\n\r\nOne approach is to have a second parameter that specifies the max additional storage allowed before pruning kicks in regardless:\r\n\r\n* `keepheight <height> <maxspace>` with `current_height` and `300 MB` (~ 1 day) being the default\r\n\r\nMultiple RPC users could call this, and we could track the lowest requested height and the highest maxspace. These automatically expire once there's more than `maxspace` block data on top of `height`.\r\n\r\nThis is enough for the use case of a client like c-lightning that's usually up to date, but might be away for a day due to a crash. However they might as well just recommend `prune=850` for the same effect, so I'm not sure how useful this is. Although it automatically expires, there's no way for a client to clean this up.\r\n\r\nAnother approach is to allow any RPC client to set whatever value they like, as well as read the current value. That means clients can clean up, but they have no way of knowing if there are other clients, so it seems brittle.\r\n\r\nKeeping track of this setting per RPC user, and then honoring the \"max\", seems the most sensible.\r\n\r\nInstead of a `maxspace` parameter, the node could also pause syncing when it's about to run out of space (`<maxpause>` hours). However this seems impractical if e.g. a user opens a wallet once and then deletes it.\r\n\r\nSo perhaps there's no point in any of this and instead we should just refetch a range of historical blocks if they're needed, something #10794 can do.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 1,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13943/comments",
   "created_at" : "2018-08-11T12:52:04Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13943/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/13943",
   "id" : 349732036,
   "labels" : [
      {
         "color" : "ebd775",
         "default" : false,
         "id" : 64584,
         "name" : "Brainstorming",
         "node_id" : "MDU6TGFiZWw2NDU4NA==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Brainstorming"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13943/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWUzNDk3MzIwMzY=",
   "number" : 13943,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "RFC: keepheight RPC for pruned nodes",
   "updated_at" : "2018-09-06T02:16:36Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13943",
   "user" : {
      "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
      "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
      "followers_url" : "https://api.github.com/users/Sjors/followers",
      "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/Sjors",
      "id" : 10217,
      "login" : "Sjors",
      "node_id" : "MDQ6VXNlcjEwMjE3",
      "organizations_url" : "https://api.github.com/users/Sjors/orgs",
      "received_events_url" : "https://api.github.com/users/Sjors/received_events",
      "repos_url" : "https://api.github.com/users/Sjors/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/Sjors"
   }
}
