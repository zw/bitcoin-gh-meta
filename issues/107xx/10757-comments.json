[
   {
      "body" : "Some ideas for additions:\r\n- Non-fee total output amount\r\n- Coinbase reward\r\n- Money supply including this block\r\n- Transaction weight `txweight` (it can be derived from existing fields, however)\r\n\r\nI would prefer to see both `time` and `mediantime` returned, since they are available.\r\n\r\nShould we return non-independent fields, such as `avgfee` when also including `totalfee` and `txs`?\r\n\r\nI find that for bitcoin-related data, the median is often more useful than the average of a distribution. Including `medianweight`, `medianfee`, `medianfeerate`, `medianoutput` etc would expose these useful quantities to the user.",
      "created_at" : "2017-07-07T15:03:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313707397",
      "id" : 313707397,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:03:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313707397",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> but once written, why not keep it?\r\n\r\nBecause more code => more bugs and more maintenance effort. I prefer:\r\n\r\nIf it's not really needed, why add it?\r\n\r\nThis is perhaps a nice-to-have, but since #8704, `getblock` can return all transactions in a block (without requiring `txindex`). Those can then be parsed and analysed offline.\r\n\r\nIs there a compelling use-case I'm missing here? This seems like a feature only a small subset of users would be interested in, in which case an offline tools seems more appropriate.\r\n\r\nSorry - not meaning to be negative, but my default reaction to new RPCs/arguments tends towards NACK unless I can see a compelling and widespread use-case.",
      "created_at" : "2017-07-07T15:28:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313714215",
      "id" : 313714215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:28:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313714215",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> This is perhaps a nice-to-have, but since #8704, getblock can return all transactions in a block (without requiring txindex). Those can then be parsed and analysed offline.\r\n\r\nThis code pulls each transaction input's previous outpoint in order to compute transaction fees. Replicating that in RPC would require thousands of calls for most blocks.",
      "created_at" : "2017-07-07T15:50:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720092",
      "id" : 313720092,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:50:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720092",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> This code pulls each transaction input's previous outpoint\r\n\r\nAh yes, of course. Concept ACK in that case. Doing this with `getblock` / `getrawtransaction` is infeasible.",
      "created_at" : "2017-07-07T15:53:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720976",
      "id" : 313720976,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:53:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720976",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> Because more code => more bugs and more maintenance effort. I prefer:\r\n\r\nSure, but I mean, removing for example the avgfee or avgfeerate won't  safe much code or testing code, just a few lines. Forget I said this, if there's specific functions to remove because nobody will want them, let's remove those and focus on the ones people want. Adding specific things only a few people want can also happen in their own branches, so it's no big deal.\r\n\r\nThe only use case is gather statistics, presumably to plot things, create charts. That is, at least, compelling to me, but I don't think that will have widespread usage. I also don't think all rpc calls have it. Is getchaintxstats, for example, a widespread use case?\r\n\r\nIf that's enough reason not to merge this, it's fine, I can maintain it as a separate branch that I periodically rebase, it is simple enough, so that won't be a big deal. On the other hand, if I can get it reviewed and merged it'll be less work for me in the long run and I also get the review.\r\n\r\n> Non-fee total output amount\r\n> Coinbase reward\r\n\r\nSounds good.\r\n\r\n> Money supply including this block\r\n\r\nMhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\n> Transaction weight txweight (it can be derived from existing fields, however)\r\n\r\nIn fact I'm using weight for everything. I should s/size/weight/ and probably also show size separately. \r\nMaybe separate feerates in by weight and serialize size? I don't know...\r\n\r\n> I would prefer to see both time and mediantime returned, since they are available.\r\n\r\nYeah, the mediantime takes a little bit longer to be calculated but not much and one can always disable anything. In fact, the height and time shouldn't be treated in any special way for being \"the x axis\" and should be allowed to be disabled like the rest.\r\n\r\n> Should we return non-independent fields, such as avgfee when also including totalfee and txs?\r\n\r\nThis is a good question. This is mostly what I meant by \"why not if it's this easy?\".\r\nBut yeah, I guess non-independent are good candidates to be removed.\r\n\r\nre median: yeah, that sounds interesting too, good idea!\r\n",
      "created_at" : "2017-07-07T16:29:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313729916",
      "id" : 313729916,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313729916",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "> Mhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\nI was thinking of the more trivial version, rather than the `supply - provably_unspendable` version, so keeping that as external code makes more sense. Maintaining the sum of spendable outputs against block height is a much more ambitious idea, and it may make sense in the future. However, it is probably out of scope of this PR.",
      "created_at" : "2017-07-07T16:37:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313731922",
      "id" : 313731922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313731922",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:37:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127",
      "id" : 126259127,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nstd::set<std::string> allowed_plot_values = {\"minfee\", \"maxfee\", \"...\"};\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:52:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721",
      "id" : 126260721,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 150,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:53:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851",
      "id" : 126260851,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 151,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\n\"...\" + boost::join(allowed_plot_values, \",\")\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:54:32Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000",
      "id" : 126261000,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 160,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing result example.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:55:17Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085",
      "id" : 126261085,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 163,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Duplicate.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T22:55:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101",
      "id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nstd::set<std::string> plot_values;\r\nif (request.params.size() > 2) {\r\n  boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\r\n\r\n  // only validate in this case\r\n  // ... \r\n} else {\r\n  plot_values = allowed_plot_values;\r\n}\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T23:00:26Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710",
      "id" : 126261710,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 190,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T23:03:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049",
      "id" : 126262049,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 137,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (allowed_plot_values.count(plot_value) == 0) {\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-07T23:07:37Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450",
      "id" : 126262450,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402"
         }
      },
      "author_association" : "MEMBER",
      "body" : "One is HelpExampleCli and the other is HelpExampleRpc",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-08T00:08:10Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402",
      "id" : 126267402,
      "in_reply_to_id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48741927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ops sorry, overlooked it.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-08T00:16:40Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869",
      "id" : 126267869,
      "in_reply_to_id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48742472,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "duh, I was so much over-complicating things so much for no good reason...thank you!",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-08T00:57:06Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648",
      "id" : 126269648,
      "in_reply_to_id" : 126262450,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48744410,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Thanks again for the great feedback!\r\n\r\n@promag I think I solved all your nits except for https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101\r\n\r\n@clarkmoody I think I added most of your suggestions, explicitly excluding anything that involved accumulations neither from height=1 nor from height=start.\r\nThe former potentially implies a world of complexity and the latter can be trivially calculated on the visual side: I would completely discard any accumulator redundancy in this rpc beforehand.\r\n\r\nAnd for the rest of the redundancies, @jnewbery and @clarkmoody - thanks again for pointing it out -, it's never too late to remove them before merging like a trivial squash and it's never too soon to start saying which ones you would bikesay* out first. Also bikesay the names for the curves and even the order in the list (duplicated for c++ and python).\r\n\r\nIn the meantime, I embraced redundancy since, as said, it will be trivial for me to remove later. And also the pertinent optimizations to skip calculations when plot_values.count(\"minfee\") == 0 or actually only when the extra calculation is more expensive than the searching in plot_values which is a set of strings.\r\n\r\nFor example, we have blockfees, reward, subsidy, complying with consensus rule ```reward == blockfees + subsidy```. Only 2 of the 3 are necessary, at least one is redundant. My personal preference is removing either subsidy or reward or subsidy, but not blockfees. But at said once written there's no problem with me in just making sure their tests don't surprise me until we decide which ones didn't deserve it. \r\n\r\nWhich one seems bikesaying in principle. But not in this case. \r\nblockfees/total_fees serves for other calculations like avgfeerate. Let's not remove that one, just rename it.\r\n\r\nBut it is more interesting to propose new ones than to rename or vote for removal IMO. I believe the most interesting addition to this point was utxo_size_inc, which would welcomed some review from people who measures sizes more carefully like @sipa , since this doesn't use GetSerializeSize for Coin intentionally, independently of the optimization to read Coin if available in the utxo before calling RpcGetTx. I'm still not sure what to do with pre/post segwit feerates, does anybody care about the pre ones? which one needs the scale factor? none?\r\n\r\nREM CalculateTruncatedMedian doesn't need to be a template at this point, but there's no harm being static IMO\r\n\r\nEDIT: still some TODOs, mostly documentation and pending decisions\r\n",
      "created_at" : "2017-07-08T07:27:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840344",
      "id" : 313840344,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:32:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840344",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "@jtimon no problem. There are some nits to fix but I'll review more in depth later.",
      "created_at" : "2017-07-08T07:36:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840707",
      "id" : 313840707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:36:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840707",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Drop `_`? Same below.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-09T00:11:49Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902",
      "id" : 126292902,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Keep argument order as `ReadBlockFromDisk`? Is there a convention for where the *output arguments* should be?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-09T00:13:04Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910",
      "id" : 126292910,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit, could sort only after `size == 1` case.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-09T00:19:36Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958",
      "id" : 126292958,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 68,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`static constexpr ...`",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:34:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455",
      "id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove empty line.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:34:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503",
      "id" : 126457503,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 107,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:51:49Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550",
      "id" : 126462550,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 296,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nUpdateBlockStats(chainActive[i], ...);\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:52:22Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704",
      "id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Replace `plotvalues` with `stats`? Also, 3rd argument could be object `options`?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:54:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400",
      "id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit, negative block could mean `end = height - end` to avoid early blocks (not new concept here I believe)?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T15:56:31Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865",
      "id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not that I know of, but your proposed change sounds good to me.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T17:56:12Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736",
      "id" : 126492736,
      "in_reply_to_id" : 126292910,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48982074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273"
         }
      },
      "author_association" : "MEMBER",
      "body" : "what's the gain? https://stackoverflow.com/a/41132221/935325 says it's the same...",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T17:58:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273",
      "id" : 126493273,
      "in_reply_to_id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48982680,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will be slightly less efficient, no?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T18:00:48Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852",
      "id" : 126493852,
      "in_reply_to_id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48983341,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mhmm, interesting. To be clear you mean start=-10 end=200 would be equivalent to start=190 end=200, right?\r\n",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T18:03:16Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452",
      "id" : 126494452,
      "in_reply_to_id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48984019,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Isn't the string simpler?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-10T18:03:56Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613",
      "id" : 126494613,
      "in_reply_to_id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48984210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Well, yes, conserving the old name only saves 1 line of extra disruption. But I guess if we're touching the variable name we should use the new style. just bytes?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-11T00:28:26Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538",
      "id" : 126569538,
      "in_reply_to_id" : 126292902,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : null,
      "pull_request_review_id" : 49066057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, I meant negative values are relative to the tip. To get the stats for the last 10 blocks you would pass start = -10 without querying the current block height.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-11T10:45:53Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629",
      "id" : 126654629,
      "in_reply_to_id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49157689,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ignore `options` suggestion.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-11T10:46:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771",
      "id" : 126654771,
      "in_reply_to_id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49157867,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess it takes few more cycles but non critical code should be cleaner?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-07-11T10:48:01Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004",
      "id" : 126655004,
      "in_reply_to_id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 49158135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "Here are some images generated using this branch in combination with (WIP): https://github.com/jtimon/rpc-explorer\r\n\r\nGUI detail:\r\n\r\n![screenshot_plotter](https://user-images.githubusercontent.com/1008458/28092233-ed1cb2ca-6692-11e7-9374-38a98cd6c258.png)\r\n\r\nGUI detail zoom:\r\n\r\n![screenshot_plotter_zoom](https://user-images.githubusercontent.com/1008458/28092271-048e594a-6693-11e7-9572-81f80980a087.png)\r\n\r\nHide some:\r\n\r\n![plotter1](https://user-images.githubusercontent.com/1008458/28092276-083a4518-6693-11e7-815d-c45d0acbfc4d.png)\r\n\r\nHide more:\r\n\r\n![plotter2](https://user-images.githubusercontent.com/1008458/28092279-0ac02fd2-6693-11e7-87c5-84d230985d6c.png)\r\n\r\nFees:\r\n\r\n![plotterfees](https://user-images.githubusercontent.com/1008458/28092284-0d22c2a8-6693-11e7-937d-451bfe0c5da5.png)\r\n\r\nUtxo size increase:\r\n\r\n![plotter_utxo](https://user-images.githubusercontent.com/1008458/28092288-0f6bc3d4-6693-11e7-910e-b18e3bfa44a2.png)\r\n",
      "created_at" : "2017-07-11T21:47:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314581913",
      "id" : 314581913,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-11T21:49:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314581913",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779"
         }
      },
      "body" : "Maybe. I'll wait for someone else to weight in since it doesn't seem a big deal either way. ",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T22:42:03Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779",
      "id" : 126826779,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 49349707,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T22:42:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Without the documentation for the result it was impossible to distinguish a weird choice to spring discussion from an implementation mistake. Removed the other TODO comments.\r\nCoded more pending suggestions by @promag (hopefully all pending ones? if not, please insist) with some extra bikeshedding derived from s/plotvalues/stats/ and adapt tests to start and end being allowed to be negative.\r\n\r\nMore cleanups can be done, specially in the tests if we go further with https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704 and not calculate in inverse order (there's no point if we don't get the slight optimization).\r\n\r\n",
      "created_at" : "2017-07-12T05:54:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314659201",
      "id" : 314659201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-12T05:54:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314659201",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Needed rebase.\r\nIf somebody made a web for it, it may be interesting to show number of segwit txs too http://segwit.5gbfree.com/countsegwit\r\n\r\n",
      "created_at" : "2017-08-24T20:27:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-324747757",
      "id" : 324747757,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-24T20:27:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/324747757",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Just wanted to say that this would be massively helpful to track statistics. I hope this finds it's way into a release soon.",
      "created_at" : "2017-08-29T08:35:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-325594164",
      "id" : 325594164,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-29T08:35:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/325594164",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31221696?v=4",
         "events_url" : "https://api.github.com/users/forklol/events{/privacy}",
         "followers_url" : "https://api.github.com/users/forklol/followers",
         "following_url" : "https://api.github.com/users/forklol/following{/other_user}",
         "gists_url" : "https://api.github.com/users/forklol/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/forklol",
         "id" : 31221696,
         "login" : "forklol",
         "organizations_url" : "https://api.github.com/users/forklol/orgs",
         "received_events_url" : "https://api.github.com/users/forklol/received_events",
         "repos_url" : "https://api.github.com/users/forklol/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/forklol/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/forklol/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/forklol"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reversed the order of the values to the natural one, since as discussed the optimization of doing fetching the blocks in reverse order is not worth the loss in clarity of the code.\r\nAdded segwit tx counter stat, and also the total size and weight for those txs (txs that at least have one sw input, txs sending to sw outputs don't count).\r\n",
      "created_at" : "2017-08-31T06:57:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326207756",
      "id" : 326207756,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-08-31T06:57:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326207756",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Perhaps a better name for \\<stat\\>_old is \\<stat\\>_virtual, _virt or _v. Or perhaps prepend it with \"v\"  just like the tx size in the output of `getrawtransaction` (vsize).\r\n\r\nFor example:\r\n\r\n`avgfeerate_old` becomes `vavgfeerate`\r\n`maxfeerate_old` becomes `vmaxfeerate`\r\n`medianfeerate_old` becomes `vmedianfeerate`\r\n\r\netc.",
      "created_at" : "2017-09-01T15:29:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326610892",
      "id" : 326610892,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-01T15:29:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326610892",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I just finished calling `getblockstats` on every block in the chain and saving it into a database. I didn't encounter any issues and the performance is quite good (100-1000ms per \"full\" block on an i7 6900k /w 32gb ram + nvme ssd).\r\n\r\nBtw, if anyone is interested in the dataset I can share it. Just convo me at freenode irc (nick: \"trippysalmon\"). It includes some other stats as well, like rolling average hashrates.",
      "created_at" : "2017-09-03T17:34:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326819183",
      "id" : 326819183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-03T17:37:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326819183",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r136726580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136726580"
         }
      },
      "author_association" : "OWNER",
      "body" : "For feerate you should use the virtual size, not total size.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-09-03T21:19:17Z",
      "diff_hunk" : "@@ -1531,6 +1538,313 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r136726580",
      "id" : 136726580,
      "original_commit_id" : "b2d93e4dfa647a4223ee37bd233d373f2cde25b1",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 60305113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/136726580",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Just noticed this PR; I'll definitely be incorporating it into Statoshi once it's merged! :+1: ",
      "created_at" : "2017-09-03T22:09:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-326834401",
      "id" : 326834401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-03T22:09:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/326834401",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/288011?v=4",
         "events_url" : "https://api.github.com/users/jlopp/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jlopp/followers",
         "following_url" : "https://api.github.com/users/jlopp/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jlopp/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jlopp",
         "id" : 288011,
         "login" : "jlopp",
         "organizations_url" : "https://api.github.com/users/jlopp/orgs",
         "received_events_url" : "https://api.github.com/users/jlopp/received_events",
         "repos_url" : "https://api.github.com/users/jlopp/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jlopp/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jlopp/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jlopp"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r137426640"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137426640"
         }
      },
      "author_association" : "MEMBER",
      "body" : "feerate is using vsize, feerate_old is using old size. Perhaps we just want to remove the whole *_old family.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-09-07T01:06:08Z",
      "diff_hunk" : "@@ -1531,6 +1538,313 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r137426640",
      "id" : 137426640,
      "in_reply_to_id" : 136726580,
      "original_commit_id" : "b2d93e4dfa647a4223ee37bd233d373f2cde25b1",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 61091554,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/137426640",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@trippysalmon I think you mean replacing s/<stat>feerate/v<stat>feerate/ and s/<stat>feerate_old/<stat>feerate/.\r\nAs discussed with @sipa the *feerate_old are using old size and the *feerate ones are using vsize.\r\n\r\nHow much interest there is in maintaining the old ones?\r\nPre-segwit both are identical and post segwit the old ones mean the how high the feerate would have been for mempool and mining purposes if you weren't using segwit.\r\nFor example, the same tx can have feerate 4 sat/vbyte (new) and 2 sat/byte (old), meaning for the same fee, your tx gets propagated/mined as if you had paid twice as much thanks to segwit's discount.\r\n\r\nIf there's not much interest, perhaps it's just better to just remove all the old ones.\r\nBy the way, I said before that we hold on removing redundant or uninteresting stats.\r\nI would start with reward, which the caller can calculate by simply adding subsidy and totalfees.\r\n\r\nNeeds rebase.",
      "created_at" : "2017-09-07T01:19:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327655184",
      "id" : 327655184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T01:19:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327655184",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2017-09-07T06:22:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327699176",
      "id" : 327699176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T06:22:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327699176",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@jtimon ah yes, I got it now. I misinterpreted the meaning of the `_old` statistics.\r\n\r\nIn that case the `_old` statistics are indeed not that interesting. I would however like to see a pre segwit `total_size` statistic. That one is currently missing and it's kind of a hassle to calculate it through RPC calls.\r\n\r\nI will update my pre segwit total_vsize [PR](https://github.com/jtimon/bitcoin/pull/9) soon.",
      "created_at" : "2017-09-07T15:10:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-327829878",
      "id" : 327829878,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-07T15:51:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/327829878",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@trippysalmon not sure what you mean by \"pre segwit total size\". Total size is included, but size it's size post and pre segwit. You mean you want a stat for total vsize ? Not sure that's very interesting...",
      "created_at" : "2017-09-08T13:53:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328109201",
      "id" : 328109201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T13:53:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328109201",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "@jtimon yes I'm talking about total_vsize. Perhaps it depends on my particular use-case (comparing and graphing total_size vs total_vsize). My reasoning is that it is easy to add and compute inside core but not so much through RPC calls.\r\n\r\nIf you think total_vsize is not useful/interesting to others I don't mind maintaining it in a custom patch. I'm actually already using it in a project atm.\r\n\r\nedit: never mind, total_vsize can be calculated by `total_weight / 4`",
      "created_at" : "2017-09-08T15:54:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328142732",
      "id" : 328142732,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T21:28:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328142732",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Removed reward and *feerate_old as discussed, but didn't squashed just in case.\r\nDiscussing with @trippysalmon we thought could show vsize instead of weight, but the former is just the latter / 4 (ie WITNESS_SCALE_FACTOR) and presenting the weight we can completely forget about rounding concerns (plus that's what getblock presents too, perhaps that's a reason to exclude it here).\r\n",
      "created_at" : "2017-09-08T23:52:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-328238904",
      "id" : 328238904,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-09-08T23:52:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/328238904",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Using this branch more, at first a range of heights was convenient but I was ready to wait even if I had to call this rpc block by block.\r\nRight now, that's what I'm doing since once you start caching, calling this function is never a success but a cache failure. It is completely understandable that one doesn't want to manage failure ranges when failures can be discovered individually and thus processed in parallel.\r\nThat's probably opinionated, but perhaps others trying to use this got many errors forgetting \"[0]\" in some places.\r\n\r\nSupporting ranges may be an optimization for users, but since I have been lucky enough to attract some potential users of this rpc call, I can ask: will anybody miss the height ranges?\r\n\r\nSince I'm indexing my cache by block height and that's inherently \"reorg unfriendly\" I mostly see 2 options going forward:\r\n\r\n1) Subscribe to the zmq interface, detect reorgs and remove block stats above the reorg height (while at it, one can put new blocks in the cache preemtively even if nobody asked for them yet)\r\n\r\n2) Stop indexing the block stat cache by  height, do it by block hash. This is compatible with reorgs (more space but less disk writing and it's also required for advanced features like plotting abandoned/orphan chains).\r\n\r\nI am inclined to trying both as a user since I want to subscribe to blocks but I also don't want to erase blocks I have seen and don't want to lose the option to chart reorged chains.\r\n\r\nA second question is simply, assuming the height ranges are removed, would anyone else apart from me use the option to search by single block hash instead of single height?\r\n\r\nAnyway, that would be my preference: replace height ranges with single height or single block hash (both options).\r\nPlease let me know what you think.",
      "created_at" : "2017-10-05T15:23:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-334499898",
      "id" : 334499898,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-15T15:13:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/334499898",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I use this RPC call extensively (and persist the results in a DB) and never used the block height range, only single blocks.\r\n\r\n> Anyway, that would be my preference: replace height ranges with single height or single block height (both options).\r\n\r\nI think you meant block hash as the second option? For my use-case it doesn't really matter if I have to use the block height or block hash. Either option works for me.\r\n\r\n--\r\n\r\nAlso, something that I needed today was the median transaction size. I don't think it can be calculated using the existing statistics or am I wrong?\r\n\r\nIt's only a [minor change](https://github.com/trippysalmon/bitcoin/commit/4a1d4d06e4c20356fe0e4359a3af2acfda06b1fc) and could be interesting to track over time to see it change when more complex scripts are made available.",
      "created_at" : "2017-10-13T20:00:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-336553230",
      "id" : 336553230,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-13T20:00:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/336553230",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/31451072?v=4",
         "events_url" : "https://api.github.com/users/trippysalmon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/trippysalmon/followers",
         "following_url" : "https://api.github.com/users/trippysalmon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/trippysalmon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/trippysalmon",
         "id" : 31451072,
         "login" : "trippysalmon",
         "organizations_url" : "https://api.github.com/users/trippysalmon/orgs",
         "received_events_url" : "https://api.github.com/users/trippysalmon/received_events",
         "repos_url" : "https://api.github.com/users/trippysalmon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/trippysalmon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/trippysalmon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/trippysalmon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, squashed, added \"mintxsize\", \"maxtxsize\", \"mediantxsize\" and \"avgtxsize\" stats.\r\n\r\nRegarding the ranges, thanks for the feedback, I'll wait to hear from other people.\r\n\r\nEDIT: btw, some of the tests are commented because tx sizes don't seem to be deterministic, I suspect due to coin selection. Not sure what to do about that.\r\n",
      "created_at" : "2017-10-17T12:15:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-337212106",
      "id" : 337212106,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-10-17T12:18:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/337212106",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145622618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145622618"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Shouldn't this be GetTransaction(..., false) ?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-19T07:51:39Z",
      "diff_hunk" : "@@ -1564,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145622618",
      "id" : 145622618,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 67,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 70447630,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145622618",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659377"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659377"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the values, fees and fee rates should be wrapped with ValueFromAmount, so outputs are decimal bitcoins rather than integer satoshis, for consistency with other RPC calls.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-19T10:21:34Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659377",
      "id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 70489270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659377",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659877"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "None of the transactions have witness data, so this isn't actually checking whether swtxs, swtotal_size, swtotal_weight ever output anything other than 0, or whether weight is ever anything other than size*4.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-19T10:24:02Z",
      "diff_hunk" : "@@ -0,0 +1,187 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = node.getblockstats(start=start_height, end=start_height + max_stat_pos)\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats, all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats.keys())\n+\n+        assert_equal(stats['height'][0], start_height)\n+        assert_equal(stats['height'][max_stat_pos], start_height + max_stat_pos)\n+\n+        assert_equal(stats['txs'][0], 1)\n+        assert_equal(stats['swtxs'][0], 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659877",
      "id" : 145659877,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 84,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 70489270,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/145659877",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106768"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106768"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No, we want to allow the slow fetch too. If the data is calculable we want to provide it no matter if more slowly. This rpc call shouldn't be expected to be fast anyway.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-21T14:33:58Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106768",
      "id" : 146106768,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 71008762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106768",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106887"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106887"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is true. When I wrote this segwit wasn't activated, but now it would be nice to add segwit txs to the test because otherwise this functionality isn't really being tested. Good call.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-21T14:37:23Z",
      "diff_hunk" : "@@ -0,0 +1,187 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = node.getblockstats(start=start_height, end=start_height + max_stat_pos)\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats, all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats.keys())\n+\n+        assert_equal(stats['height'][0], start_height)\n+        assert_equal(stats['height'][max_stat_pos], start_height + max_stat_pos)\n+\n+        assert_equal(stats['txs'][0], 1)\n+        assert_equal(stats['swtxs'][0], 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146106887",
      "id" : 146106887,
      "in_reply_to_id" : 145659877,
      "original_commit_id" : "caeaf86de426f9b71c0828be23253827dd0149fb",
      "original_position" : 84,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 71008834,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146106887",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146541947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146541947"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm presuming this reply should be to the \"GetTransaction(..., false)\" comment. Getting fee info without txindex seems like a weird thing to do to me, but if it's supported then presumably the getblockstats RPC help text doesn't need to still say \"It won't work .. without -txindex.\" ?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-24T12:24:24Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146541947",
      "id" : 146541947,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 71497165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146541947",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146551957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551957"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, sorry. Was meant for the other comment. Actually looking at the code again the slow search will only find txs in the utxo, so using false should be fine. I'll test it with false.\r\n\r\nRegarding using BTC instead of satoshis, I think we want to move everything to satoshis but we don't do it because it would be too disruptive, so we only do it with new calls.\r\nThe caller can trivially divide by 100000000 to get BTC if they want t show that. ",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-24T13:04:35Z",
      "diff_hunk" : "@@ -1570,6 +1571,309 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat].push_back((int64_t)pindex->nHeight);\n+        } else if (stat == \"time\") {\n+            map_stats[stat].push_back(pindex->GetBlockTime());\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat].push_back(pindex->GetMedianTimePast());\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r146551957",
      "id" : 146551957,
      "in_reply_to_id" : 145659377,
      "original_commit_id" : "2497afa41126fd4e5cf17b095980c19fc1b813a5",
      "original_position" : 136,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 71509206,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/146551957",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148021712"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148021712"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Avoid special case for truncated zeros with new CFeeRate::GetTruncatedFee\":\r\n\r\nI found this commit message hard to understand. Would suggest something more like:\r\n\r\n> [refactoring] Add new CFeeRate::GetTruncatedFee method\r\n>\r\n> Add new truncated fee method that unlike the CFeeRate::GetFee will round fees between 1 and -1 satoshi to zero instead of 1 or -1. This does not change the behavior of CFeeRate::GetFee.\r\n\r\n\r\n",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T14:56:59Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t bytes) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148021712",
      "id" : 148021712,
      "original_commit_id" : "ced73054c5690e2c46caf1389700e9832f528881",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148021712",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148024745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148024745"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Separate ReadBlockCheckPruned() from getblock()\"\r\n\r\nSince this is throwing on error it seems like it would be friendlier to just return the CBlock instead of taking it as output parameter.\r\n\r\n```c++\r\nCBlock ReadBlockChecked(const BlockIndex*)\r\n```\r\n\r\nAlso it would be good if commit message mentioned this is a refactoring and not a change in behavior.\r\n\r\n",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:05:59Z",
      "diff_hunk" : "@@ -688,6 +688,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(CBlock& block, const CBlockIndex* pblockindex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148024745",
      "id" : 148024745,
      "original_commit_id" : "d8b8582496c09407aa836359008c104d99a309df",
      "original_position" : 4,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148024745",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148026891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148026891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats to plot things\"\r\n\r\nMaybe call this \"GetTransactionChecked\" instead of \"RpcGetTx\" to be consistent with \"ReadBlockChecked\" in previous commit.\r\n\r\nAlso again since this is throwing on error this would be simpler to use if it just returned CTransactionRef instead of using an output parameter.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:12:17Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148026891",
      "id" : 148026891,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 21,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148026891",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148027175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148027175"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\"\r\n\r\nIf statement should be on new line, or preceded by `else`, or just dropped since the code below will handle this case anyway.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:13:12Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148027175",
      "id" : 148027175,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 36,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148027175",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148031472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148031472"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> what's the gain? https://stackoverflow.com/a/41132221/935325 says it's the same...\r\n\r\nGain is just that constexpr is more descriptive, and that stackoverflow answer isn't really correct. `const` and `constexpr` aren't identical even for integers, for example `const` is valid here:\r\n\r\n```c++\r\nstatic const int X = rand();\r\n```\r\nwhere `constexpr` would not be:\r\n\r\n```c++\r\nstatic constexpr int X = rand();\r\n```\r\n\r\nAlso that stackoverflow answer is relying on special case treatment for integers that doesn't apply to other types like floats. `constexpr` is just better for declaring compile time constants that `const`, so we should prefer it.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:26:30Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148031472",
      "id" : 148031472,
      "in_reply_to_id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148031472",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148034720"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148034720"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\"\r\n\r\nMaybe s/selected/requested/ since \"selected\" sounds more like something the RPC is computing.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:36:34Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs (including coinbase).\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height;\n+    }\n+    if (height < 0 || height > current_tip) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1) {\n+        boost::split(stats, request.params[1].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& stat : stats) {\n+            if (valid_stats.count(stat) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid selected statistic %s\", stat));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148034720",
      "id" : 148034720,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 283,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148034720",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148035291"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148035291"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\"\r\n\r\n`stats` reference should be const, and again I think `map_stats` should be a return value instead of an output parameter so calling this function is simpler and less error prone.\r\n\r\nAlso 'UpdateBlockStats' should probably be called 'GetBlockStats' because 'UpdateBlockStats' sounds like something that would be called repeatedly to update existing statistics, where this function is just computing and returning wholly new statistics.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:38:13Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148035291",
      "id" : 148035291,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 51,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148035291",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148039141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148039141"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\"\r\n\r\nIt seems clumsy and unnecessary to have to list these entries three separate places (here, in UpdateBlockStats, and in the getblockstats help string). It seems like it would be better to drop this listing and simplify the code by just building a fixed map:\r\n\r\n```c++\r\nstd::map<std::string, UniValue> GetBlockStats(CBlockIndex* block)\r\n{\r\n    ...\r\n    return {\r\n        {\"height\", (int64_t)pindex->nHeight},\r\n        {\"time\", pindex->GetBlockTime()},\r\n        ...\r\n    }\r\n}\r\n```\r\n\r\nIf in the future there are statistics that are expensive to compute, it would be easy to add options to UpdateBlockStats to skip them.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:49:57Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148039141",
      "id" : 148039141,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 191,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148039141",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148040858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148040858"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\"\r\n\r\nIt seems weird for a JSON api to be taking a comma separated string instead of a list of strings. Do we have other RPCs that use comma separated strings?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T15:55:38Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148040858",
      "id" : 148040858,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 229,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148040858",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148049297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148049297"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"RPC: Introduce getblockstats\":\r\n\r\nBug: This should be `current_tip + height + 1` so height -1 will return tip.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:21:54Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs (including coinbase).\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148049297",
      "id" : 148049297,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148049297",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148050658"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148050658"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"QA: Test new getblockstats RPC\"\r\n\r\nUnneeded parentheses",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:26:31Z",
      "diff_hunk" : "@@ -0,0 +1,186 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148050658",
      "id" : 148050658,
      "original_commit_id" : "44dcea038b44890e5f49c71ff26cfcb4ecf0da15",
      "original_position" : 17,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148050658",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148050746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148050746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"QA: Test new getblockstats RPC\"\r\n\r\nUnneeded parentheses (assert is not a function)",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:26:49Z",
      "diff_hunk" : "@@ -0,0 +1,186 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148050746",
      "id" : 148050746,
      "original_commit_id" : "44dcea038b44890e5f49c71ff26cfcb4ecf0da15",
      "original_position" : 18,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148050746",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148055540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148055540"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"QA: Test new getblockstats RPC\"\r\n\r\nSeems like it would be simpler to combine the two asserts\r\n\r\n```python\r\nassert_equal(set(all_values), set(stats[0]))\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:42:25Z",
      "diff_hunk" : "@@ -0,0 +1,186 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = []\n+        for i in range(start_height, start_height + max_stat_pos + 1):\n+            stats.append(node.getblockstats(height=i))\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats[0], all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats[0].keys())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148055540",
      "id" : 148055540,
      "original_commit_id" : "44dcea038b44890e5f49c71ff26cfcb4ecf0da15",
      "original_position" : 80,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148055540",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148056136"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148056136"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"QA: Test new getblockstats RPC\"\r\n\r\nCould simplify with list comprehension:\r\n\r\n```python\r\nstats = [node.getblockstats(height=start_height + i) for i in range(max_stat_pos+1)]\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:44:17Z",
      "diff_hunk" : "@@ -0,0 +1,186 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = []",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148056136",
      "id" : 148056136,
      "original_commit_id" : "44dcea038b44890e5f49c71ff26cfcb4ecf0da15",
      "original_position" : 44,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148056136",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148057310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148057310"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"QA: Test new getblockstats RPC\"\r\n\r\nAgain, seems like it would be simpler to just check for equality:\r\n\r\n```python\r\nstats = node.getblockstats(height=1, stats='minfee,maxfee')\r\nassert_equal(set(stats), {\"minfee\", \"maxfee\"})\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2017-10-31T16:48:26Z",
      "diff_hunk" : "@@ -0,0 +1,186 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if (check_cointains):\n+            assert(val in data)\n+        else:\n+            assert(val not in data)\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = []\n+        for i in range(start_height, start_height + max_stat_pos + 1):\n+            stats.append(node.getblockstats(height=i))\n+\n+        all_values = [\n+            \"height\",\n+            \"time\",\n+            \"mediantime\",\n+            \"txs\",\n+            \"swtxs\",\n+            \"ins\",\n+            \"outs\",\n+            \"subsidy\",\n+            \"totalfee\",\n+            \"utxo_increase\",\n+            \"utxo_size_inc\",\n+            \"total_size\",\n+            \"total_weight\",\n+            \"swtotal_size\",\n+            \"swtotal_weight\",\n+            \"total_out\",\n+            \"minfee\",\n+            \"maxfee\",\n+            \"medianfee\",\n+            \"avgfee\",\n+            \"minfeerate\",\n+            \"maxfeerate\",\n+            \"medianfeerate\",\n+            \"avgfeerate\",\n+            \"mintxsize\",\n+            \"maxtxsize\",\n+            \"mediantxsize\",\n+            \"avgtxsize\",\n+        ]\n+        assert_contains(stats[0], all_values)\n+        # Make sure all valid statistics are included\n+        assert_contains(all_values, stats[0].keys())\n+\n+        print(stats)\n+        assert_equal(stats[0]['height'], start_height)\n+        assert_equal(stats[max_stat_pos]['height'], start_height + max_stat_pos)\n+\n+        assert_equal(stats[0]['txs'], 1)\n+        assert_equal(stats[0]['swtxs'], 0)\n+        assert_equal(stats[0]['ins'], 0)\n+        assert_equal(stats[0]['outs'], 2)\n+        assert_equal(stats[0]['totalfee'], 0)\n+        assert_equal(stats[0]['utxo_increase'], 2)\n+        assert_equal(stats[0]['utxo_size_inc'], 173)\n+        assert_equal(stats[0]['total_size'], 0)\n+        assert_equal(stats[0]['total_weight'], 0)\n+        assert_equal(stats[0]['swtotal_size'], 0)\n+        assert_equal(stats[0]['swtotal_weight'], 0)\n+        assert_equal(stats[0]['total_out'], 0)\n+        assert_equal(stats[0]['minfee'], 0)\n+        assert_equal(stats[0]['maxfee'], 0)\n+        assert_equal(stats[0]['medianfee'], 0)\n+        assert_equal(stats[0]['avgfee'], 0)\n+        assert_equal(stats[0]['minfeerate'], 0)\n+        assert_equal(stats[0]['maxfeerate'], 0)\n+        assert_equal(stats[0]['medianfeerate'], 0)\n+        assert_equal(stats[0]['avgfeerate'], 0)\n+        assert_equal(stats[0]['mintxsize'], 0)\n+        assert_equal(stats[0]['maxtxsize'], 0)\n+        assert_equal(stats[0]['mediantxsize'], 0)\n+        assert_equal(stats[0]['avgtxsize'], 0)\n+\n+        assert_equal(stats[1]['txs'], 2)\n+        assert_equal(stats[1]['swtxs'], 0)\n+        assert_equal(stats[1]['ins'], 1)\n+        assert_equal(stats[1]['outs'], 4)\n+        assert_equal(stats[1]['totalfee'], 3840)\n+        assert_equal(stats[1]['utxo_increase'], 3)\n+        assert_equal(stats[1]['utxo_size_inc'], 238)\n+        # assert_equal(stats[1]['total_size'], 191)\n+        # assert_equal(stats[1]['total_weight'], 768)\n+        assert_equal(stats[1]['total_out'], 4999996160)\n+        assert_equal(stats[1]['minfee'], 3840)\n+        assert_equal(stats[1]['maxfee'], 3840)\n+        assert_equal(stats[1]['medianfee'], 3840)\n+        assert_equal(stats[1]['avgfee'], 3840)\n+        assert_equal(stats[1]['minfeerate'], 20)\n+        assert_equal(stats[1]['maxfeerate'], 20)\n+        assert_equal(stats[1]['medianfeerate'], 20)\n+        assert_equal(stats[1]['avgfeerate'], 20)\n+        # assert_equal(stats[1]['mintxsize'], 192)\n+        # assert_equal(stats[1]['maxtxsize'], 192)\n+        # assert_equal(stats[1]['mediantxsize'], 192)\n+        # assert_equal(stats[1]['avgtxsize'], 192)\n+\n+        assert_equal(stats[max_stat_pos]['txs'], 4)\n+        assert_equal(stats[max_stat_pos]['swtxs'], 0)\n+        assert_equal(stats[max_stat_pos]['ins'], 3)\n+        assert_equal(stats[max_stat_pos]['outs'], 8)\n+        assert_equal(stats[max_stat_pos]['totalfee'], 76160)\n+        assert_equal(stats[max_stat_pos]['utxo_increase'], 5)\n+        assert_equal(stats[max_stat_pos]['utxo_size_inc'], 388)\n+        # assert_equal(stats[max_stat_pos]['total_size'], 643)\n+        # assert_equal(stats[max_stat_pos]['total_weight'], 2572)\n+        assert_equal(stats[max_stat_pos]['total_out'], 9999920000)\n+        assert_equal(stats[max_stat_pos]['minfee'], 3840)\n+        assert_equal(stats[max_stat_pos]['maxfee'], 67800)\n+        assert_equal(stats[max_stat_pos]['medianfee'], 4520)\n+        assert_equal(stats[max_stat_pos]['avgfee'], 25386)\n+        assert_equal(stats[max_stat_pos]['minfeerate'], 20)\n+        # assert_equal(stats[max_stat_pos]['maxfeerate'], 300)\n+        assert_equal(stats[max_stat_pos]['medianfeerate'], 20)\n+        assert_equal(stats[max_stat_pos]['avgfeerate'], 118)\n+        # assert_equal(stats[max_stat_pos]['mintxsize'], 192)\n+        # assert_equal(stats[max_stat_pos]['maxtxsize'], 226)\n+        # assert_equal(stats[max_stat_pos]['mediantxsize'], 225)\n+        # assert_equal(stats[max_stat_pos]['avgtxsize'], 214)\n+\n+        # Test invalid parameters raise the proper json exceptions\n+        tip = start_height + max_stat_pos\n+        assert_raises_rpc_error(-8, 'Target block height %d after current tip %d' % (tip+1, tip), node.getblockstats, height=tip+1)\n+        assert_raises_rpc_error(-8, 'Target block height %d after current tip %d' % (-1, tip), node.getblockstats, height=-tip-1)\n+\n+        # Make sure not valid stats aren't allowed\n+        inv_sel_stat = 'asdfghjkl'\n+        inv_stats = [\n+            'minfee,%s' % inv_sel_stat,\n+            '%s,minfee' % inv_sel_stat,\n+            'minfee,%s,maxfee' % inv_sel_stat,\n+        ]\n+        for inv_stat in inv_stats:\n+            assert_raises_rpc_error(-8, 'Invalid selected statistic %s' % inv_sel_stat, node.getblockstats, height=1, stats=inv_stat)\n+        # Make sure we aren't always returning inv_sel_stat as the culprit stat\n+        assert_raises_rpc_error(-8, 'Invalid selected statistic aaa%s' % inv_sel_stat, node.getblockstats, height=1, stats='minfee,aaa%s' % inv_sel_stat)\n+\n+        # Make sure only the selected statistics are included\n+        stats = node.getblockstats(height=1, stats='minfee,maxfee')\n+        some_values = [",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148057310",
      "id" : 148057310,
      "original_commit_id" : "44dcea038b44890e5f49c71ff26cfcb4ecf0da15",
      "original_position" : 176,
      "path" : "test/functional/getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 73199569,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/148057310",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161619680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161619680"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't know. I don't mind moving to a list of strings if that's preferred. Makes sense.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-01-15T21:39:39Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161619680",
      "id" : 161619680,
      "in_reply_to_id" : 148040858,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 229,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 88938359,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161619680",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161620060"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161620060"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Some statistics are already more expensive to compute than others, it seems like a good feature to allow the user to optionally skip some from the beginning.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-01-15T21:42:16Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161620060",
      "id" : 161620060,
      "in_reply_to_id" : 148039141,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 191,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 88938819,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161620060",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161620738"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161620738"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, it made sense to be update when the call did a loop from start height to end height, but not now that it calculates stats for a single block.\r\n",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-01-15T21:47:01Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161620738",
      "id" : 161620738,
      "in_reply_to_id" : 148035291,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 51,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 88939635,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161620738",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161639518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161639518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, but it is currently calculating everything regardless of the stats requested...it wasn't like that before, I should re-introduce the optimzations for the option to really make sense.\r\nEven if not all of them are expensive, perhaps one caller is only interested in one or a few stats and if the caller is going to make many calls for many heights, the performance hit of any undesired stat adds up.\r\n ",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-01-16T00:40:27Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r161639518",
      "id" : 161639518,
      "in_reply_to_id" : 148039141,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 191,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 88961158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/161639518",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed all nits by @ryanofsky except for https://github.com/bitcoin/bitcoin/pull/10757#discussion_r148039141 . Instead of solving it, I added a few new commits for people to discuss on.\r\n\r\nThe tests still can't test size or feerates while passing/failing in a deterministic fashion, but just by rebasing now \"swtxs\" seems to be actually tested without me doing anything (probably by https://github.com/bitcoin/bitcoin/pull/11403 being merged), as requested in  https://github.com/bitcoin/bitcoin/pull/10757#discussion_r145659877\r\n\r\nI thought of a simpler way to deterministacally get sizes and feerates: simply force the desired/expected size for each of the few txs this test creates. Using something like:\r\n\r\n```\r\nwhile not desired_size(tx, desired_size)\r\n     tx = try_creating_tx_again()\r\n```\r\n\r\nor something of the sort. \r\n\r\nI'll try that next, but please comment on the latest commits.\r\n ",
      "created_at" : "2018-01-16T04:37:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-357851666",
      "id" : 357851666,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-01-16T04:37:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357851666",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "This needs rebase, but some feedback on the latest things and potential squashes would be nice before doing so.\r\n",
      "created_at" : "2018-01-31T21:59:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-362085037",
      "id" : 362085037,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-01-31T21:59:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/362085037",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "What do you think about using a static blockchain so that testing is deterministic? I added some code to save the generated chain, and to reuse it if it's present and it doesn't seem too bad -- just using getblock(__,0) to get hex encoded blocks, and dumping them gives a 56kB file (or 10kB gzipped). That seems within the ballpark of something that could easily just be added as a static data file to the test suite?\r\n\r\nI don't think `while tx_isnt_what_i_want: try_again()` is a good approach -- it seems a bit too easy to accidentally become `while i_trigger_a_bug: try_again()` which kind-of defeats the point of testing.\r\n\r\nI'm not a huge fan of the `for(stat:stats) { if (stat == \"x\") m[stat] = x(); else if ...; }` approach. What about something along the lines of:\r\n\r\n```\r\n    auto set_stat = [&](const char* stat, const UniValue val)\r\n                    { if (stats.count(stat) != 0) map_stats[stat] = val; };\r\n\r\n    set_stat(\"height\", (int64_t)pindex->nHeight);\r\n    set_stat(\"time\", pindex->GetBlockTime());\r\n    set_stat(\"mediantime\", pindex->GetMedianTimePast());\r\n    ...\r\n```\r\n? I don't think any of the calculations at that point are particularly heavy, so it shouldn't make things much slower (and any that are could probably just be put in an `if (is_loop_outputs_required) { .. }` block or similar).\r\n\r\nI think the optimisation commits make sense. Maybe add bools for `medianfeerate`, `medianfee`, `mediantxsize` so you're not calling `.count()` inside the loops. The naming of the bools is annoyingly ungrammatical (\"is_loop_inputs_required\" should be \"are_loop_inputs_required\" in english), but I don't have a better suggestion.\r\n\r\nMight be good to explicitly say which stats want -txindex enabled and won't work with pruning in the help (fee related and utxo size I think?) Could make the default be \"whatever stats we can output efficiently\" rather than \"everything\", though not sure that's a good idea.",
      "created_at" : "2018-02-01T05:13:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-362160709",
      "id" : 362160709,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-02-01T05:13:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/362160709",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> What do you think about using a static blockchain so that testing is deterministic? I added some code to save the generated chain, and to reuse it if it's present and it doesn't seem too bad -- just using getblock(__,0) to get hex encoded blocks, and dumping them gives a 56kB file (or 10kB gzipped). That seems within the ballpark of something that could easily just be added as a static data file to the test suite?\r\n\r\nI didn't found the time to try that but if you can share that code that would be great. What you're saying seems reasonable to me, I don't know if other people would have a problem with that. And I cannot think of a simpler way to make this test deterministic.\r\n\r\nI will look into the other suggestions, thanks.",
      "created_at" : "2018-02-04T18:29:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-362928394",
      "id" : 362928394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-02-04T18:29:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/362928394",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MarcoFalke what is the status of this in terms of testing?\r\n\r\nI think @ajtowns is right that *size, and *feerate fields can only be deterministically tested, but I don't have the time to write that at this point. I would be happy to review and test if anybody wants to take over though.\r\n\r\nIn the meantime, I would be happy to include the new call even if it's without any stat that depends on signature size or coin selection for deterministic testing and those fields and their tests are already written.\r\n  ",
      "created_at" : "2018-03-22T09:35:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-375233914",
      "id" : 375233914,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-03-22T09:35:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/375233914",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needed rebase. And still needs squashing pending on requested feedback.\r\n\r\nAlso, since testing some of the stats deterministically is not trivial, I think the new rpc call should be introduced only with the stats that can be deterministacally tested (even though we will miss some of the most interesting ones like sizes, fees and feerates) and then make the tests deterministic and add the missing stats.\r\nThoughts?\r\n",
      "created_at" : "2018-03-30T04:07:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-377440180",
      "id" : 377440180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-03-30T04:07:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/377440180",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Proposed patch that makes testing of the stats kind of deterministic at https://github.com/jtimon/bitcoin/pull/11/commits\r\n\r\nIdea is you do `./feature_rpc_getblockstats --gen-test-data` to  generate a test blockchain and the expected statistics for that blockchain, and will write it to data/rpc_getblockstats.json file (about 50kB uncompressed text). You then check the stats look reasonable, and commit that file to git, and then when you/travis runs the test case without --gen-test-data it will load the chain from the file and check that the calculated stats still match what was recorded as being expected.\r\n\r\nIf additional stats are added, you'll need to edit the test case to update the EXPECTED_STATS variable; and you'll need to add the expected values to the json file (by hand I guess), both of which should show up nicely in git diff.",
      "created_at" : "2018-03-30T07:45:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-377468912",
      "id" : 377468912,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-03-30T07:47:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/377468912",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks a lot, incorporated those changes. Fixed some older nits too.\r\nPlease re-review.",
      "created_at" : "2018-04-07T00:41:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-379419446",
      "id" : 379419446,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-07T00:41:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/379419446",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274008"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: RPC: Introduce getblockstats to plot things\r\n\r\nnit: Copy initialization works here. `UniValue stats_univalue = request.params[1].get_array();`",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-13T02:47:41Z",
      "diff_hunk" : "@@ -1612,6 +1613,304 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    map_stats[\"height\"] = (int64_t)pindex->nHeight;\n+    map_stats[\"time\"] = pindex->GetBlockTime();\n+    map_stats[\"mediantime\"] = pindex->GetMedianTimePast();\n+    map_stats[\"subsidy\"] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+    map_stats[\"totalfee\"] = totalfee;\n+    map_stats[\"txs\"] = (int64_t)block.vtx.size();\n+    map_stats[\"swtxs\"] = swtxs;\n+    map_stats[\"ins\"] = inputs;\n+    map_stats[\"outs\"] = outputs;\n+    map_stats[\"utxo_increase\"] = outputs - inputs;\n+    map_stats[\"utxo_size_inc\"] = utxo_size_inc;\n+    map_stats[\"total_size\"] = total_size;\n+    map_stats[\"total_weight\"] = total_weight;\n+    map_stats[\"swtotal_size\"] = swtotal_size;\n+    map_stats[\"swtotal_weight\"] = swtotal_weight;\n+    map_stats[\"total_out\"] = total_out;\n+    map_stats[\"minfee\"] = (minfee == MAX_MONEY) ? 0 : minfee;\n+    map_stats[\"maxfee\"] = maxfee;\n+    map_stats[\"medianfee\"] = CalculateTruncatedMedian(fee_array);\n+    map_stats[\"avgfee\"] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+    map_stats[\"minfeerate\"] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+    map_stats[\"maxfeerate\"] = maxfeerate;\n+    map_stats[\"medianfeerate\"] = CalculateTruncatedMedian(feerate_array);\n+    map_stats[\"avgfeerate\"] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+    map_stats[\"mintxsize\"] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+    map_stats[\"maxtxsize\"] = maxtxsize;\n+    map_stats[\"mediantxsize\"] = CalculateTruncatedMedian(txsize_array);\n+    map_stats[\"avgtxsize\"] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+\n+    return map_stats;\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, X_fee or X_feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs.\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height + 1;\n+    }\n+    if (height < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+    }\n+    if (height > current_tip) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        UniValue stats_univalue(UniValue::VARR);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274008",
      "id" : 181274008,
      "original_commit_id" : "cf6585a6ec6497467f5d26a76fc09b14897f191f",
      "original_position" : 286,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274008",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274172"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274172"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Seems to be updated to an array, but comment is not updated.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-13T02:49:31Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274172",
      "id" : 181274172,
      "in_reply_to_id" : 148040858,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 229,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274172",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274673"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: RPC: Introduce getblockstats to plot things\r\n\r\nThe `nStart` and `nEnd` seem wrong. Should just be height now, no?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-13T02:54:43Z",
      "diff_hunk" : "@@ -1612,6 +1613,304 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    map_stats[\"height\"] = (int64_t)pindex->nHeight;\n+    map_stats[\"time\"] = pindex->GetBlockTime();\n+    map_stats[\"mediantime\"] = pindex->GetMedianTimePast();\n+    map_stats[\"subsidy\"] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+    map_stats[\"totalfee\"] = totalfee;\n+    map_stats[\"txs\"] = (int64_t)block.vtx.size();\n+    map_stats[\"swtxs\"] = swtxs;\n+    map_stats[\"ins\"] = inputs;\n+    map_stats[\"outs\"] = outputs;\n+    map_stats[\"utxo_increase\"] = outputs - inputs;\n+    map_stats[\"utxo_size_inc\"] = utxo_size_inc;\n+    map_stats[\"total_size\"] = total_size;\n+    map_stats[\"total_weight\"] = total_weight;\n+    map_stats[\"swtotal_size\"] = swtotal_size;\n+    map_stats[\"swtotal_weight\"] = swtotal_weight;\n+    map_stats[\"total_out\"] = total_out;\n+    map_stats[\"minfee\"] = (minfee == MAX_MONEY) ? 0 : minfee;\n+    map_stats[\"maxfee\"] = maxfee;\n+    map_stats[\"medianfee\"] = CalculateTruncatedMedian(fee_array);\n+    map_stats[\"avgfee\"] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+    map_stats[\"minfeerate\"] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+    map_stats[\"maxfeerate\"] = maxfeerate;\n+    map_stats[\"medianfeerate\"] = CalculateTruncatedMedian(feerate_array);\n+    map_stats[\"avgfeerate\"] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+    map_stats[\"mintxsize\"] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+    map_stats[\"maxtxsize\"] = maxtxsize;\n+    map_stats[\"mediantxsize\"] = CalculateTruncatedMedian(txsize_array);\n+    map_stats[\"avgtxsize\"] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+\n+    return map_stats;\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274673",
      "id" : 181274673,
      "original_commit_id" : "cf6585a6ec6497467f5d26a76fc09b14897f191f",
      "original_position" : 227,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274673",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274966"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: RPC: Introduce getblockstats\r\n\r\nI got confused by the `push_back(Pair(...))` syntax. Can you just use `pushKV(stat, map_stats[stat])` which seems to be more standard?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-13T02:57:54Z",
      "diff_hunk" : "@@ -1612,6 +1613,304 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    map_stats[\"height\"] = (int64_t)pindex->nHeight;\n+    map_stats[\"time\"] = pindex->GetBlockTime();\n+    map_stats[\"mediantime\"] = pindex->GetMedianTimePast();\n+    map_stats[\"subsidy\"] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+    map_stats[\"totalfee\"] = totalfee;\n+    map_stats[\"txs\"] = (int64_t)block.vtx.size();\n+    map_stats[\"swtxs\"] = swtxs;\n+    map_stats[\"ins\"] = inputs;\n+    map_stats[\"outs\"] = outputs;\n+    map_stats[\"utxo_increase\"] = outputs - inputs;\n+    map_stats[\"utxo_size_inc\"] = utxo_size_inc;\n+    map_stats[\"total_size\"] = total_size;\n+    map_stats[\"total_weight\"] = total_weight;\n+    map_stats[\"swtotal_size\"] = swtotal_size;\n+    map_stats[\"swtotal_weight\"] = swtotal_weight;\n+    map_stats[\"total_out\"] = total_out;\n+    map_stats[\"minfee\"] = (minfee == MAX_MONEY) ? 0 : minfee;\n+    map_stats[\"maxfee\"] = maxfee;\n+    map_stats[\"medianfee\"] = CalculateTruncatedMedian(fee_array);\n+    map_stats[\"avgfee\"] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+    map_stats[\"minfeerate\"] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+    map_stats[\"maxfeerate\"] = maxfeerate;\n+    map_stats[\"medianfeerate\"] = CalculateTruncatedMedian(feerate_array);\n+    map_stats[\"avgfeerate\"] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+    map_stats[\"mintxsize\"] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+    map_stats[\"maxtxsize\"] = maxtxsize;\n+    map_stats[\"mediantxsize\"] = CalculateTruncatedMedian(txsize_array);\n+    map_stats[\"avgtxsize\"] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+\n+    return map_stats;\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, X_fee or X_feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs.\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height + 1;\n+    }\n+    if (height < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+    }\n+    if (height > current_tip) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        UniValue stats_univalue(UniValue::VARR);\n+        stats_univalue = request.params[1].get_array();\n+        for (unsigned int i = 0; i < stats_univalue.size(); i++) {\n+            const std::string stat = stats_univalue[i].get_str();\n+            if (valid_stats.count(stat) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid requested statistic %s\", stat));\n+            }\n+            stats.insert(stat);\n+        }\n+    } else {\n+        stats = valid_stats;\n+    }\n+\n+    const CBlockIndex* pblockindex = chainActive[height];\n+    const CBlock block = GetBlockChecked(pblockindex);\n+    std::map<std::string, UniValue> map_stats = GetBlockStatsMap(block, pblockindex, stats);\n+\n+    UniValue ret(UniValue::VOBJ);\n+    for (const std::string stat : stats) {\n+        ret.push_back(Pair(stat, map_stats[stat]));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181274966",
      "id" : 181274966,
      "original_commit_id" : "cf6585a6ec6497467f5d26a76fc09b14897f191f",
      "original_position" : 305,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181274966",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181276481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181276481"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: RPC: Introduce getblockstats\r\n\r\nI had to check the RPC help doc to see if this was a mistake. Would be helpful to leave an explicit comment: `// Don't count coinbase reward`.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-13T03:07:54Z",
      "diff_hunk" : "@@ -1612,6 +1613,304 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181276481",
      "id" : 181276481,
      "original_commit_id" : "cf6585a6ec6497467f5d26a76fc09b14897f191f",
      "original_position" : 103,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181276481",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181616478"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181616478"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Surfacing this error seems like the the wrong error handling strategy. In the context this is used, the transaction should never be in the mempool and it should *always* be found if the txindex is present.\r\n\r\nI think it would be better for the RPC to raise an RPC error that the txindex is required if it is not present, and an RPC error for an unexpected internal error (txindex is corrupt) otherwise.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T03:45:05Z",
      "diff_hunk" : "@@ -1612,6 +1613,304 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181616478",
      "id" : 181616478,
      "original_commit_id" : "cf6585a6ec6497467f5d26a76fc09b14897f191f",
      "original_position" : 17,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181616478",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617056"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: Tests: Test new getblockstats RPC\r\n\r\ntypo: check_co**i**ntains",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T03:53:01Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617056",
      "id" : 181617056,
      "original_commit_id" : "69dd52d83918e8f34b29e264d604d6f5b11425b5",
      "original_position" : 15,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617056",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617123"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617123"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: Tests: Test new getblockstats RPC\r\n\r\nI think it's worth testing the case of no txindex.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T03:53:49Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if check_cointains:\n+            assert val in data\n+        else:\n+            assert val not in data\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    EXPECTED_STATS = [\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    ]\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617123",
      "id" : 181617123,
      "original_commit_id" : "69dd52d83918e8f34b29e264d604d6f5b11425b5",
      "original_position" : 56,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617123",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617257"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: Tests: Test new getblockstats RPC\r\n\r\nThe `assert_contains` function appears unused.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T03:55:39Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617257",
      "id" : 181617257,
      "original_commit_id" : "69dd52d83918e8f34b29e264d604d6f5b11425b5",
      "original_position" : 15,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617257",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617517"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: Tests: Save and load block and corresponding expected statistics\r\n\r\nIf all these test cases are getting removed anyway, I'd just drop them from the previous commit.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T03:58:53Z",
      "diff_hunk" : "@@ -70,90 +86,63 @@ def run_test(self):\n         self.sync_all()\n         node.generate(1)\n \n-        start_height = 101\n-        max_stat_pos = 2\n-        stats = [node.getblockstats(height=start_height + i) for i in range(max_stat_pos+1)]\n+        self.expected_stats = self.get_stats()\n+\n+        blocks = []\n+        tip = node.getbestblockhash()\n+        blkhash = None\n+        height = 0\n+        while tip != blkhash:\n+            blkhash = node.getblockhash(height)\n+            blocks.append(node.getblock(blkhash, 0))\n+            height += 1\n+\n+        with open(filename, \"w\") as f:\n+            f.write(\"\"\"{\\n  \"stats\": \"\"\")\n+            json.dump(self.expected_stats, f, indent=4)\n+            f.write(\"\"\",\\n  \"blocks\": \"\"\")\n+            json.dump(blocks, f)\n+            f.write(\"\"\"\\n}\\n\"\"\")\n+\n+    def load_test_data(self, filename):\n+        node = self.nodes[0]\n+\n+        with open(filename, \"r\") as f:\n+            d = json.load(f)\n+            blocks = d[\"blocks\"]\n+            self.expected_stats = d[\"stats\"]\n+            del d\n+\n+        for b in blocks:\n+            node.submitblock(b)\n+\n+    def get_stats(self):\n+        node = self.nodes[0]\n+        return [node.getblockstats(height=self.start_height + i) for i in range(self.max_stat_pos+1)]\n+\n+    def run_test(self):\n+        test_data = os.path.join(TESTSDIR, self.options.test_data)\n+        if self.options.gen_test_data:\n+            self.generate_test_data(test_data)\n+        else:\n+            self.load_test_data(test_data)\n+\n+        node = self.nodes[0]\n+        stats = self.get_stats()\n \n         # Make sure all valid statistics are included but nothing else is\n         assert_equal(set(stats[0].keys()), set(self.EXPECTED_STATS))\n \n-        print(stats)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617517",
      "id" : 181617517,
      "original_commit_id" : "bb4c8f96359ea545c433a7a6ff876a692557fe9f",
      "original_position" : 91,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617517",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617905"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "commit: Tests: Save and load block and corresponding expected statistics\r\n\r\nInstead of hand-crafting the JSON, I think it's better to just create a dict with `stats` and `blocks` keys and json.dump that. It seems you might be doing this for better control over the indentation, but the data file added in the next commit has each stat on its own line.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T04:03:55Z",
      "diff_hunk" : "@@ -70,90 +86,63 @@ def run_test(self):\n         self.sync_all()\n         node.generate(1)\n \n-        start_height = 101\n-        max_stat_pos = 2\n-        stats = [node.getblockstats(height=start_height + i) for i in range(max_stat_pos+1)]\n+        self.expected_stats = self.get_stats()\n+\n+        blocks = []\n+        tip = node.getbestblockhash()\n+        blkhash = None\n+        height = 0\n+        while tip != blkhash:\n+            blkhash = node.getblockhash(height)\n+            blocks.append(node.getblock(blkhash, 0))\n+            height += 1\n+\n+        with open(filename, \"w\") as f:\n+            f.write(\"\"\"{\\n  \"stats\": \"\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181617905",
      "id" : 181617905,
      "original_commit_id" : "bb4c8f96359ea545c433a7a6ff876a692557fe9f",
      "original_position" : 56,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 111864271,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181617905",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181623181"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181623181"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It puts the stats on separate lines, but all the blocks on a single line. Seemed like a good idea at the time (multiline stats hand editable, block data as a minimal blob), but doesn't make much difference.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-16T05:08:39Z",
      "diff_hunk" : "@@ -70,90 +86,63 @@ def run_test(self):\n         self.sync_all()\n         node.generate(1)\n \n-        start_height = 101\n-        max_stat_pos = 2\n-        stats = [node.getblockstats(height=start_height + i) for i in range(max_stat_pos+1)]\n+        self.expected_stats = self.get_stats()\n+\n+        blocks = []\n+        tip = node.getbestblockhash()\n+        blkhash = None\n+        height = 0\n+        while tip != blkhash:\n+            blkhash = node.getblockhash(height)\n+            blocks.append(node.getblock(blkhash, 0))\n+            height += 1\n+\n+        with open(filename, \"w\") as f:\n+            f.write(\"\"\"{\\n  \"stats\": \"\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r181623181",
      "id" : 181623181,
      "in_reply_to_id" : 181617905,
      "original_commit_id" : "bb4c8f96359ea545c433a7a6ff876a692557fe9f",
      "original_position" : 56,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 112280718,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/181623181",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed @jimpo 's nits, thanks.\r\n",
      "created_at" : "2018-04-19T10:22:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-382685844",
      "id" : 382685844,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-19T10:22:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/382685844",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182941877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182941877"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be `medianfeerate`, not `_weight`.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T04:10:47Z",
      "diff_hunk" : "@@ -1612,6 +1613,303 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182941877",
      "id" : 182941877,
      "original_commit_id" : "3699947a9e5a9b8bf4871298dc14e415e50174d6",
      "original_position" : 78,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 113844660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182941877",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942079"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`loop_inputs` is also needed when `utxo_size_inc` is requested. Setting `loop_outputs = loop_inputs || stats.count(\"total_out\")` might simplify things a little.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T04:12:58Z",
      "diff_hunk" : "@@ -1612,6 +1613,303 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942079",
      "id" : 182942079,
      "original_commit_id" : "3699947a9e5a9b8bf4871298dc14e415e50174d6",
      "original_position" : 85,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 113844660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942079",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942644"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could move the \"Invalid requested statistic\" check to here, ie:\r\n\r\n```\r\n    for (auto stat : stats) {\r\n        if (map_stats.count(stat) == 0) {\r\n            throw JSONRPCError(...);\r\n        }\r\n        ret.pushKV(stat, map_stats[stat]);\r\n   }\r\n```\r\n\r\nThen you wouldn't need `valid_stats`. Downside is the error response would only come after the valid stats were corrected.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T04:19:52Z",
      "diff_hunk" : "@@ -1612,6 +1613,303 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    const bool do_calculate_size = do_mediantxsize || stats.count(\"total_size\") != 0 || stats.count(\"avgtxsize\") != 0 ||\n+        stats.count(\"mintxsize\") != 0 || stats.count(\"maxtxsize\") != 0 || stats.count(\"swtotal_size\") != 0;\n+\n+    const bool do_calculate_weight = stats.count(\"total_weight\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0 || stats.count(\"medianfeerate_weight\") != 0;\n+\n+    const bool do_calculate_sw = stats.count(\"swtxs\") != 0 || stats.count(\"swtotal_size\") != 0 ||\n+        stats.count(\"swtotal_weight\") != 0;\n+\n+    const bool loop_inputs = stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out; // Don't count coinbase reward\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    map_stats[\"height\"] = (int64_t)pindex->nHeight;\n+    map_stats[\"time\"] = pindex->GetBlockTime();\n+    map_stats[\"mediantime\"] = pindex->GetMedianTimePast();\n+    map_stats[\"subsidy\"] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+    map_stats[\"totalfee\"] = totalfee;\n+    map_stats[\"txs\"] = (int64_t)block.vtx.size();\n+    map_stats[\"swtxs\"] = swtxs;\n+    map_stats[\"ins\"] = inputs;\n+    map_stats[\"outs\"] = outputs;\n+    map_stats[\"utxo_increase\"] = outputs - inputs;\n+    map_stats[\"utxo_size_inc\"] = utxo_size_inc;\n+    map_stats[\"total_size\"] = total_size;\n+    map_stats[\"total_weight\"] = total_weight;\n+    map_stats[\"swtotal_size\"] = swtotal_size;\n+    map_stats[\"swtotal_weight\"] = swtotal_weight;\n+    map_stats[\"total_out\"] = total_out;\n+    map_stats[\"minfee\"] = (minfee == MAX_MONEY) ? 0 : minfee;\n+    map_stats[\"maxfee\"] = maxfee;\n+    map_stats[\"medianfee\"] = CalculateTruncatedMedian(fee_array);\n+    map_stats[\"avgfee\"] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+    map_stats[\"minfeerate\"] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+    map_stats[\"maxfeerate\"] = maxfeerate;\n+    map_stats[\"medianfeerate\"] = CalculateTruncatedMedian(feerate_array);\n+    map_stats[\"avgfeerate\"] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+    map_stats[\"mintxsize\"] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+    map_stats[\"maxtxsize\"] = maxtxsize;\n+    map_stats[\"mediantxsize\"] = CalculateTruncatedMedian(txsize_array);\n+    map_stats[\"avgtxsize\"] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+\n+    return map_stats;\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, X_fee or X_feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs.\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height + 1;\n+    }\n+    if (height < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+    }\n+    if (height > current_tip) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        UniValue stats_univalue = request.params[1].get_array();\n+        for (unsigned int i = 0; i < stats_univalue.size(); i++) {\n+            const std::string stat = stats_univalue[i].get_str();\n+            if (valid_stats.count(stat) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid requested statistic %s\", stat));\n+            }\n+            stats.insert(stat);\n+        }\n+    } else {\n+        stats = valid_stats;\n+    }\n+\n+    const CBlockIndex* pblockindex = chainActive[height];\n+    const CBlock block = GetBlockChecked(pblockindex);\n+    std::map<std::string, UniValue> map_stats = GetBlockStatsMap(block, pblockindex, stats);\n+\n+    UniValue ret(UniValue::VOBJ);\n+    for (const std::string stat : stats) {\n+        ret.pushKV(stat, map_stats[stat]);\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942644",
      "id" : 182942644,
      "original_commit_id" : "3699947a9e5a9b8bf4871298dc14e415e50174d6",
      "original_position" : 305,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 113844660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942644",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942912"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942912"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "These initialisations are a bit hard to follow. What do you think of:\r\n\r\n```\r\ntemplate<typename T> static inline bool SetHasKeys(const std::set<T>& set) {return false;}\r\ntemplate<typename T, typename Tk, typename... Args> static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\r\n{\r\n    return (set.count(key) != 0) || SetHasKeys(set, args...);\r\n}\r\n\r\n    const bool loop_inputs = do_medianfee || do_medianfeerate ||\r\n       SetHasKeys(stats, \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\", \"utxo_size_inc\");\r\n```\r\n\r\ninstead? Seems easier to understand to me, should be equally efficient at runtime, and the recursive template thing is in use elsewhere already.\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T04:22:58Z",
      "diff_hunk" : "@@ -1612,6 +1613,303 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942912",
      "id" : 182942912,
      "original_commit_id" : "3699947a9e5a9b8bf4871298dc14e415e50174d6",
      "original_position" : 73,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 113844660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182942912",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182943314"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182943314"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Suggest adding:\r\n\r\n```\r\n       # Make sure each stat can be queried on its own\r\n       for stat in self.EXPECTED_STATS:\r\n           for i in range(self.max_stat_pos+1):\r\n               result = node.getblockstats(height=self.start_height + i, stats=[stat])\r\n               assert_equal(list(result.keys()), [stat])\r\n               if result[stat] != self.expected_stats[i][stat]:\r\n                   self.log.info(\"result[%s] (%d) failed, %r != %r\" % (stat, i, result[stat], self.expected_stats[i][stat]))\r\n               assert_equal(result[stat], self.expected_stats[i][stat])\r\n```\r\n\r\nto ensure that each statistic can be queried on its own (in particular ensuring the GetBlockStatsMap() doesn't optimise out collecting the data needed for each stat). The above should automatically catch problems if new stats are introduced since it's just re-using the results from the all-the-stats check.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T04:27:27Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):\n+    for val in values:\n+        if check_cointains:\n+            assert val in data\n+        else:\n+            assert val not in data\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+    EXPECTED_STATS = [\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    ]\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def run_test(self):\n+        node = self.nodes[0]\n+        node.generate(101)\n+\n+        node.sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.generate(1)\n+        self.sync_all()\n+\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        node.sendtoaddress(address=node.getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[1].sendtoaddress(address=node.getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        node.generate(1)\n+\n+        start_height = 101\n+        max_stat_pos = 2\n+        stats = [node.getblockstats(height=start_height + i) for i in range(max_stat_pos+1)]\n+\n+        # Make sure all valid statistics are included but nothing else is\n+        assert_equal(set(stats[0].keys()), set(self.EXPECTED_STATS))\n+\n+        print(stats)\n+        assert_equal(stats[0]['height'], start_height)\n+        assert_equal(stats[max_stat_pos]['height'], start_height + max_stat_pos)\n+\n+        assert_equal(stats[0]['txs'], 1)\n+        assert_equal(stats[0]['swtxs'], 0)\n+        assert_equal(stats[0]['ins'], 0)\n+        assert_equal(stats[0]['outs'], 2)\n+        assert_equal(stats[0]['totalfee'], 0)\n+        assert_equal(stats[0]['utxo_increase'], 2)\n+        assert_equal(stats[0]['utxo_size_inc'], 173)\n+        assert_equal(stats[0]['total_size'], 0)\n+        assert_equal(stats[0]['total_weight'], 0)\n+        assert_equal(stats[0]['swtotal_size'], 0)\n+        assert_equal(stats[0]['swtotal_weight'], 0)\n+        assert_equal(stats[0]['total_out'], 0)\n+        assert_equal(stats[0]['minfee'], 0)\n+        assert_equal(stats[0]['maxfee'], 0)\n+        assert_equal(stats[0]['medianfee'], 0)\n+        assert_equal(stats[0]['avgfee'], 0)\n+        assert_equal(stats[0]['minfeerate'], 0)\n+        assert_equal(stats[0]['maxfeerate'], 0)\n+        assert_equal(stats[0]['medianfeerate'], 0)\n+        assert_equal(stats[0]['avgfeerate'], 0)\n+        assert_equal(stats[0]['mintxsize'], 0)\n+        assert_equal(stats[0]['maxtxsize'], 0)\n+        assert_equal(stats[0]['mediantxsize'], 0)\n+        assert_equal(stats[0]['avgtxsize'], 0)\n+\n+        assert_equal(stats[1]['txs'], 2)\n+        assert_equal(stats[1]['swtxs'], 0)\n+        assert_equal(stats[1]['ins'], 1)\n+        assert_equal(stats[1]['outs'], 4)\n+        assert_equal(stats[1]['totalfee'], 3760)\n+        assert_equal(stats[1]['utxo_increase'], 3)\n+        assert_equal(stats[1]['utxo_size_inc'], 234)\n+        # assert_equal(stats[1]['total_size'], 188)\n+        # assert_equal(stats[1]['total_weight'], 752)\n+        assert_equal(stats[1]['total_out'], 4999996240)\n+        assert_equal(stats[1]['minfee'], 3760)\n+        assert_equal(stats[1]['maxfee'], 3760)\n+        assert_equal(stats[1]['medianfee'], 3760)\n+        assert_equal(stats[1]['avgfee'], 3760)\n+        assert_equal(stats[1]['minfeerate'], 20)\n+        assert_equal(stats[1]['maxfeerate'], 20)\n+        assert_equal(stats[1]['medianfeerate'], 20)\n+        assert_equal(stats[1]['avgfeerate'], 20)\n+        # assert_equal(stats[1]['mintxsize'], 192)\n+        # assert_equal(stats[1]['maxtxsize'], 192)\n+        # assert_equal(stats[1]['mediantxsize'], 192)\n+        # assert_equal(stats[1]['avgtxsize'], 192)\n+\n+        assert_equal(stats[max_stat_pos]['txs'], 4)\n+        assert_equal(stats[max_stat_pos]['swtxs'], 2)\n+        assert_equal(stats[max_stat_pos]['ins'], 3)\n+        assert_equal(stats[max_stat_pos]['outs'], 8)\n+        assert_equal(stats[max_stat_pos]['totalfee'], 56880)\n+        assert_equal(stats[max_stat_pos]['utxo_increase'], 5)\n+        assert_equal(stats[max_stat_pos]['utxo_size_inc'], 380)\n+        # assert_equal(stats[max_stat_pos]['total_size'], 643)\n+        # assert_equal(stats[max_stat_pos]['total_weight'], 2572)\n+        assert_equal(stats[max_stat_pos]['total_out'], 9999939360)\n+        assert_equal(stats[max_stat_pos]['minfee'], 3320)\n+        assert_equal(stats[max_stat_pos]['maxfee'], 49800)\n+        assert_equal(stats[max_stat_pos]['medianfee'], 3760)\n+        assert_equal(stats[max_stat_pos]['avgfee'], 18960)\n+        assert_equal(stats[max_stat_pos]['minfeerate'], 20)\n+        # assert_equal(stats[max_stat_pos]['maxfeerate'], 300)\n+        assert_equal(stats[max_stat_pos]['medianfeerate'], 20)\n+        assert_equal(stats[max_stat_pos]['avgfeerate'], 109)\n+        # assert_equal(stats[max_stat_pos]['mintxsize'], 192)\n+        # assert_equal(stats[max_stat_pos]['maxtxsize'], 226)\n+        # assert_equal(stats[max_stat_pos]['mediantxsize'], 225)\n+        # assert_equal(stats[max_stat_pos]['avgtxsize'], 214)\n+\n+        # Test invalid parameters raise the proper json exceptions\n+        tip = start_height + max_stat_pos\n+        assert_raises_rpc_error(-8, 'Target block height %d after current tip %d' % (tip+1, tip), node.getblockstats, height=tip+1)\n+        assert_raises_rpc_error(-8, 'Target block height %d is negative' % (-1), node.getblockstats, height=-tip-2)\n+\n+        # Make sure not valid stats aren't allowed\n+        inv_sel_stat = 'asdfghjkl'\n+        inv_stats = [\n+            [inv_sel_stat],\n+            ['minfee' , inv_sel_stat],\n+            [inv_sel_stat, 'minfee'],\n+            ['minfee', inv_sel_stat, 'maxfee'],\n+        ]\n+        for inv_stat in inv_stats:\n+            assert_raises_rpc_error(-8, 'Invalid requested statistic %s' % inv_sel_stat, node.getblockstats, height=1, stats=inv_stat)\n+        # Make sure we aren't always returning inv_sel_stat as the culprit stat\n+        assert_raises_rpc_error(-8, 'Invalid requested statistic aaa%s' % inv_sel_stat, node.getblockstats, height=1, stats=['minfee' , 'aaa%s' % inv_sel_stat])\n+\n+        # Make sure only the selected statistics are included\n+        some_stats = {'minfee', 'maxfee'}\n+        stats = node.getblockstats(height=1, stats=list(some_stats))\n+        # Make sure only valid stats that have been requested appear\n+        assert_equal(set(stats.keys()), some_stats)\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182943314",
      "id" : 182943314,
      "original_commit_id" : "05eddd0361bff229b8bae68e3eb129ea3967e93a",
      "original_position" : 178,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 113844660,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/182943314",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183131662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183131662"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, github hid this reminder about the comment from me, fixing.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T18:17:11Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"swtxs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"swtotal_size\",\n+        \"swtotal_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"avgfee\",\n+        \"minfeerate\",\n+        \"maxfeerate\",\n+        \"medianfeerate\",\n+        \"avgfeerate\",\n+        \"mintxsize\",\n+        \"maxtxsize\",\n+        \"mediantxsize\",\n+        \"avgtxsize\",\n+    };\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work in some cases with pruning or without -txindex.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_stats, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183131662",
      "id" : 183131662,
      "in_reply_to_id" : 148040858,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 229,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114078077,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183131662",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183145068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183145068"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Do you know if fancy templating stuff like this will slow down compilation times noticeably? I'd kind of prefer a normal iterative runtime approach for simplicity, especially given that it would be far from the most expensive part of this API call.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T19:13:31Z",
      "diff_hunk" : "@@ -1612,6 +1613,303 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    std::map<std::string, UniValue> map_stats;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+\n+    const bool loop_outputs = stats.count(\"total_out\") != 0 || stats.count(\"utxo_size_inc\") != 0 ||\n+        stats.count(\"totalfee\") != 0 || stats.count(\"avgfee\") != 0 || stats.count(\"avgfeerate\") != 0 ||\n+        do_medianfee || stats.count(\"minfee\") != 0 || stats.count(\"maxfee\") != 0 ||\n+        do_medianfeerate || stats.count(\"minfeerate\") != 0 || stats.count(\"maxfeerate\") != 0;\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183145068",
      "id" : 183145068,
      "in_reply_to_id" : 182942912,
      "original_commit_id" : "3699947a9e5a9b8bf4871298dc14e415e50174d6",
      "original_position" : 73,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114094825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183145068",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183152048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183152048"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I ended up taking the code suggestion, even though I'm not eliminating the \"stats\" argument.\r\nIt is still much closer to what you wanted now.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-20T19:46:13Z",
      "diff_hunk" : "@@ -1570,6 +1571,286 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    } if (size == 1) {\n+        return scores[0];\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& stats, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(block, pindex);\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        total_out += tx_total_out;\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        txsize_array.push_back(tx_size);\n+        total_size += tx_size;\n+        mintxsize = std::min(mintxsize, tx_size);\n+        maxtxsize = std::max(maxtxsize, tx_size);\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        if (tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        // New feerate uses satoshis per virtual byte instead of per serialized byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+    }\n+\n+    for (const std::string& stat : stats) {\n+        // Update map_stats\n+        if (stat == \"height\") {\n+            map_stats[stat] = (int64_t)pindex->nHeight;\n+        } else if (stat == \"time\") {\n+            map_stats[stat] = pindex->GetBlockTime();\n+        } else if (stat == \"mediantime\") {\n+            map_stats[stat] = pindex->GetMedianTimePast();\n+        } else if (stat == \"subsidy\") {\n+            map_stats[stat] = GetBlockSubsidy(pindex->nHeight, Params().GetConsensus());\n+        } else if (stat == \"totalfee\") {\n+            map_stats[stat] = totalfee;\n+        } else if (stat == \"txs\") {\n+            map_stats[stat] = (int64_t)block.vtx.size();\n+        } else if (stat == \"swtxs\") {\n+            map_stats[stat] = swtxs;\n+        } else if (stat == \"ins\") {\n+            map_stats[stat] = inputs;\n+        } else if (stat == \"outs\") {\n+            map_stats[stat] = outputs;\n+        } else if (stat == \"utxo_increase\") {\n+            map_stats[stat] = outputs - inputs;\n+        } else if (stat == \"utxo_size_inc\") {\n+            map_stats[stat] = utxo_size_inc;\n+        } else if (stat == \"total_size\") {\n+            map_stats[stat] = total_size;\n+        } else if (stat == \"total_weight\") {\n+            map_stats[stat] = total_weight;\n+        } else if (stat == \"swtotal_size\") {\n+            map_stats[stat] = swtotal_size;\n+        } else if (stat == \"swtotal_weight\") {\n+            map_stats[stat] = swtotal_weight;\n+        } else if (stat == \"total_out\") {\n+            map_stats[stat] = total_out;\n+        } else if (stat == \"minfee\") {\n+            map_stats[stat] = (minfee == MAX_MONEY) ? 0 : minfee;\n+        } else if (stat == \"maxfee\") {\n+            map_stats[stat] = maxfee;\n+        } else if (stat == \"medianfee\") {\n+            map_stats[stat] = CalculateTruncatedMedian(fee_array);\n+        } else if (stat == \"avgfee\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0;\n+        } else if (stat == \"minfeerate\") {\n+            map_stats[stat] = (minfeerate == MAX_MONEY) ? 0 : minfeerate;\n+        } else if (stat == \"maxfeerate\") {\n+            map_stats[stat] = maxfeerate;\n+        } else if (stat == \"medianfeerate\") {\n+            map_stats[stat] = CalculateTruncatedMedian(feerate_array);\n+        } else if (stat == \"avgfeerate\") {\n+            map_stats[stat] = CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        } else if (stat == \"mintxsize\") {\n+            map_stats[stat] = mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize;\n+        } else if (stat == \"maxtxsize\") {\n+            map_stats[stat] = maxtxsize;\n+        } else if (stat == \"mediantxsize\") {\n+            map_stats[stat] = CalculateTruncatedMedian(txsize_array);\n+        } else if (stat == \"avgtxsize\") {\n+            map_stats[stat] = (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0;\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_stats = {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183152048",
      "id" : 183152048,
      "in_reply_to_id" : 148039141,
      "original_commit_id" : "f55badc57abf026da0c57e8cfa2558ca7f5b2bd8",
      "original_position" : 191,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114103973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183152048",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed nits. The latest commit I did not squash because I'm not convinced it is an improvement even though is +32-48 (see https://github.com/bitcoin/bitcoin/pull/10757#discussion_r182942644 )",
      "created_at" : "2018-04-20T19:48:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383203196",
      "id" : 383203196,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-20T19:48:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383203196",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> I'm a bit confused by the bit about the x-axis in the PR description -- isn't plotting stuff in a different PR?\r\n\r\nSorry about the confusing edits. At first, height, time and mediantime were treated separately as I was using them as potential x-axis with my caller. Now they're just treated as like any other stat.\r\n\r\n> Seems a bit strange to exclude the coinbase from total_out; there's no way to tell from the output you've got if the coinbase failed to claim all its reward.\r\n\r\nIf the coinbase tx doesn't claim subsidy + totalfee then it failed to claim all its reward.\r\nFor seeing if miners claimed all the reward, perhaps we can add a new stat coinbase_total_out or better, unclaimed_reward, since subsidy + totalfee = coinbase_total_out + unclaimed_reward.\r\n\r\nI don't see how adding the claimed reward to the total_out helps with this. The idea of discarding the coinbase is that, even if we can't discard change outputs or pay to yourself txs or similar to approximate real throughput, we definitely can clearly discard the subsidy and the fees, but if people feel strongly about this it is easy to change. Perhaps we can have this as \"total_moved\" or \"total_paid\"\r\nAnd another redundant one total_out that's total_moved + coinbase_total_out (redundant only assuming we add coinbase_total_out or unclaimed_reward).\r\n\r\nBtw, the only person who answered the question about selecting by height or block hash was @trippysalmon who said he didn't care.\r\nShould I move from height to block hash to be more consistent with getblock ?\r\nShould both options be allowed?\r\n",
      "created_at" : "2018-04-20T20:21:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383211697",
      "id" : 383211697,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-21T15:07:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383211697",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183203177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183203177"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could do:\r\n\r\n```\r\n    const bool do_all = stats.size() > 0;\r\n    const bool do_mediantxsize = do_all || SetHasKeys(stats, \"mediantxsize);\r\n    const bool do_medianfee = do_all || ...;\r\n    ...\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-21T07:45:06Z",
      "diff_hunk" : "@@ -1673,16 +1673,27 @@ static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, con\n     int64_t maxtxsize = 0;\n     std::vector<int64_t> txsize_array;\n \n-    const bool do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n-    const bool do_medianfee = stats.count(\"medianfee\") != 0;\n-    const bool do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n-    const bool loop_inputs = do_medianfee || do_medianfeerate ||\n-        SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n-    const bool loop_outputs = loop_inputs || stats.count(\"total_out\");\n-    const bool do_calculate_size = do_mediantxsize ||\n-        SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n-    const bool do_calculate_weight = SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n-    const bool do_calculate_sw = SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+    bool do_mediantxsize = true;\n+    bool do_medianfee = true;\n+    bool do_medianfeerate = true;\n+    bool loop_inputs = true;\n+    bool loop_outputs = true;\n+    bool do_calculate_size = true;\n+    bool do_calculate_weight = true;\n+    bool do_calculate_sw = true;\n+    // Calculate everything if nothing selected (default)\n+    if (stats.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183203177",
      "id" : 183203177,
      "original_commit_id" : "f80bb3cf6d6c727870dd8e7954d15285876a12a8",
      "original_position" : 23,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114165877,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183203177",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183203448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183203448"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "There's two tests for `(height < 0)` here, the first of which should be setting height to a positive value. Seems like a rebasing error?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-21T07:55:35Z",
      "diff_hunk" : "@@ -1603,6 +1613,287 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    bool do_mediantxsize = true;\n+    bool do_medianfee = true;\n+    bool do_medianfeerate = true;\n+    bool loop_inputs = true;\n+    bool loop_outputs = true;\n+    bool do_calculate_size = true;\n+    bool do_calculate_weight = true;\n+    bool do_calculate_sw = true;\n+    // Calculate everything if nothing selected (default)\n+    if (stats.size() > 0) {\n+        do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+        do_medianfee = stats.count(\"medianfee\") != 0;\n+        do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+        loop_inputs = do_medianfee || do_medianfeerate ||\n+            SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n+        loop_outputs = loop_inputs || stats.count(\"total_out\");\n+        do_calculate_size = do_mediantxsize ||\n+            SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n+        do_calculate_weight = SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n+        do_calculate_sw = SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+    }\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out; // Don't count coinbase reward\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    return {\n+        {\"height\", (int64_t)pindex->nHeight},\n+        {\"time\", pindex->GetBlockTime()},\n+        {\"mediantime\", pindex->GetMedianTimePast()},\n+        {\"subsidy\", GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())},\n+        {\"totalfee\", totalfee},\n+        {\"txs\", (int64_t)block.vtx.size()},\n+        {\"swtxs\", swtxs},\n+        {\"ins\", inputs},\n+        {\"outs\", outputs},\n+        {\"utxo_increase\", outputs - inputs},\n+        {\"utxo_size_inc\", utxo_size_inc},\n+        {\"total_size\", total_size},\n+        {\"total_weight\", total_weight},\n+        {\"swtotal_size\", swtotal_size},\n+        {\"swtotal_weight\", swtotal_weight},\n+        {\"total_out\", total_out},\n+        {\"minfee\", (minfee == MAX_MONEY) ? 0 : minfee},\n+        {\"maxfee\", maxfee},\n+        {\"medianfee\", CalculateTruncatedMedian(fee_array)},\n+        {\"avgfee\", (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0},\n+        {\"minfeerate\", (minfeerate == MAX_MONEY) ? 0 : minfeerate},\n+        {\"maxfeerate\", maxfeerate},\n+        {\"medianfeerate\", CalculateTruncatedMedian(feerate_array)},\n+        {\"avgfeerate\", CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR)},\n+        {\"mintxsize\", mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize},\n+        {\"maxtxsize\", maxtxsize},\n+        {\"mediantxsize\", CalculateTruncatedMedian(txsize_array)},\n+        {\"avgtxsize\", (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0}\n+    };\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, X_fee or X_feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic.\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic.\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs.\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height + 1;\n+    }\n+    if (height < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183203448",
      "id" : 183203448,
      "original_commit_id" : "3402b0dc83e37fd3eac97efc49b857b13aabc2e0",
      "original_position" : 303,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114166121,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183203448",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't really have a strong opinion on `total_out`, I guess I just found it a little weird it doesn't include the coinbase outputs.\r\n\r\nAs far as height vs blockhash is concerned, I think specifying by height is probably easiest for people using the api, but maybe it would be good to include the blockhash in the output (so if you get different results for a given height due to a reorg, it's easy to tell why), and/or allow either height/hash as the first param? I don't feel strongly about this either way, either.",
      "created_at" : "2018-04-21T08:03:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383276415",
      "id" : 383276415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-21T08:03:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383276415",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183211877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183211877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it is a rest from when moving from a range to a single height, but yeah, thanks.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-21T15:06:46Z",
      "diff_hunk" : "@@ -1603,6 +1613,287 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CTransactionRef GetTransactionChecked(const uint256& hash)\n+{\n+    CTransactionRef tx_out;\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, false)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+    return tx_out;\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static std::map<std::string, UniValue> GetBlockStatsMap(const CBlock& block, const CBlockIndex* pindex, const std::set<std::string>& stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t maxtxsize = 0;\n+    std::vector<int64_t> txsize_array;\n+\n+    bool do_mediantxsize = true;\n+    bool do_medianfee = true;\n+    bool do_medianfeerate = true;\n+    bool loop_inputs = true;\n+    bool loop_outputs = true;\n+    bool do_calculate_size = true;\n+    bool do_calculate_weight = true;\n+    bool do_calculate_sw = true;\n+    // Calculate everything if nothing selected (default)\n+    if (stats.size() > 0) {\n+        do_mediantxsize = stats.count(\"mediantxsize\") != 0;\n+        do_medianfee = stats.count(\"medianfee\") != 0;\n+        do_medianfeerate = stats.count(\"medianfeerate\") != 0;\n+        loop_inputs = do_medianfee || do_medianfeerate ||\n+            SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n+        loop_outputs = loop_inputs || stats.count(\"total_out\");\n+        do_calculate_size = do_mediantxsize ||\n+            SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n+        do_calculate_weight = SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n+        do_calculate_sw = SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+    }\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+                tx_total_out += out.nValue;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        total_out += tx_total_out; // Don't count coinbase reward\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            total_size += tx_size;\n+            mintxsize = std::min(mintxsize, tx_size);\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in = GetTransactionChecked(in.prevout.hash);\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            totalfee += txfee;\n+            minfee = std::min(minfee, txfee);\n+            maxfee = std::max(maxfee, txfee);\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            minfeerate = std::min(minfeerate, feerate);\n+            maxfeerate = std::max(maxfeerate, feerate);\n+        }\n+    }\n+\n+    return {\n+        {\"height\", (int64_t)pindex->nHeight},\n+        {\"time\", pindex->GetBlockTime()},\n+        {\"mediantime\", pindex->GetMedianTimePast()},\n+        {\"subsidy\", GetBlockSubsidy(pindex->nHeight, Params().GetConsensus())},\n+        {\"totalfee\", totalfee},\n+        {\"txs\", (int64_t)block.vtx.size()},\n+        {\"swtxs\", swtxs},\n+        {\"ins\", inputs},\n+        {\"outs\", outputs},\n+        {\"utxo_increase\", outputs - inputs},\n+        {\"utxo_size_inc\", utxo_size_inc},\n+        {\"total_size\", total_size},\n+        {\"total_weight\", total_weight},\n+        {\"swtotal_size\", swtotal_size},\n+        {\"swtotal_weight\", swtotal_weight},\n+        {\"total_out\", total_out},\n+        {\"minfee\", (minfee == MAX_MONEY) ? 0 : minfee},\n+        {\"maxfee\", maxfee},\n+        {\"medianfee\", CalculateTruncatedMedian(fee_array)},\n+        {\"avgfee\", (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0},\n+        {\"minfeerate\", (minfeerate == MAX_MONEY) ? 0 : minfeerate},\n+        {\"maxfeerate\", maxfeerate},\n+        {\"medianfeerate\", CalculateTruncatedMedian(feerate_array)},\n+        {\"avgfeerate\", CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR)},\n+        {\"mintxsize\", mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize},\n+        {\"maxtxsize\", maxtxsize},\n+        {\"mediantxsize\", CalculateTruncatedMedian(txsize_array)},\n+        {\"avgtxsize\", (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0}\n+    };\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, X_fee or X_feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"height\\\"     (numeric, required) The height of the target block.Negative values count back from the current tip.\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic.\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic.\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block.\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time.\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past.\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase).\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions.\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase).\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs.\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy.\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total.\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs.\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar).\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions.\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions.\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4).\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee]).\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block.\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block.\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block.\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block.\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte).\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size.\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size.\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size.\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int height = request.params[0].get_int();\n+    int current_tip = chainActive.Height();\n+    if (height < 0) {\n+        height = current_tip + height + 1;\n+    }\n+    if (height < 0) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183211877",
      "id" : 183211877,
      "in_reply_to_id" : 183203448,
      "original_commit_id" : "3402b0dc83e37fd3eac97efc49b857b13aabc2e0",
      "original_position" : 303,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114175172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183211877",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yeah, my concern is precisely that, asking for a given height and getting the results for a block it's not what you were expecting, and yeah, both solutions (optionally accepting hash instead of height or always returning the block hash work) solve that problem.\r\nI guess I like more the first option because it's less data sent, but I guess the \"hash_or_height\" param name is ugly. I will do that and ask for \"squash or remove\"?\r\n\r\nBy the way, thoughts on the \"squash or remove\" for \"?? f'RPC: Introduce getblockstats'\"?\r\nIs that what you were expecting? Oh, wait, you have a nit on that commit. I'll solve them and then ask again (unless you say \"yeah it's not worth it\" now and I skip solving that nit).\r\n",
      "created_at" : "2018-04-21T15:12:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383304176",
      "id" : 383304176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-21T15:12:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383304176",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Since all the stats are optional anyway, I ended up doing both adding an optional blockhash in the result and my preference, which was moving from height to hash_or_height.\r\nAlso did some squashing and did further simplifications on both the rpc and the tests, including inling the function, since it didn't sense anymore after moving away from height ranges and removing the hardcoded list of expected stats from the tests (since they're already hardcoded in the data file).\r\n\r\nSince the diff from last review was kind of big, I took the opportunity to rebase too.\r\n ",
      "created_at" : "2018-04-23T23:03:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383749798",
      "id" : 383749798,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-23T23:03:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383749798",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed the remaining nits: test when there's no txindex and give a specific error when txindex is required but not set as suggested by @jimpo.\r\n",
      "created_at" : "2018-04-24T00:07:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383761037",
      "id" : 383761037,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-24T00:07:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383761037",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed the tests with the node 1 in travis (in my computer the sync_all wasn't needed, oops) and did some bikeshedding.\r\n",
      "created_at" : "2018-04-24T13:36:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-383932982",
      "id" : 383932982,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-24T13:36:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/383932982",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183823240"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183823240"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`for (const std::string& stat : stats) {`",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T17:48:06Z",
      "diff_hunk" : "@@ -1612,6 +1613,274 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    CBlockIndex* pindex;\n+    if (request.params[0].isNum()) {\n+        const int height = request.params[0].get_int();\n+        const int current_tip = chainActive.Height();\n+        if (height < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+        }\n+        if (height > current_tip) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+        }\n+\n+        pindex = chainActive[height];\n+    } else {\n+        const std::string strHash = request.params[0].get_str();\n+        const uint256 hash(uint256S(strHash));\n+        pindex = LookupBlockIndex(hash);\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        const UniValue stats_univalue = request.params[1].get_array();\n+        for (unsigned int i = 0; i < stats_univalue.size(); i++) {\n+            const std::string stat = stats_univalue[i].get_str();\n+            stats.insert(stat);\n+        }\n+    }\n+\n+    const CBlock block = GetBlockChecked(pindex);\n+\n+    const bool do_all = stats.size() == 0; // Calculate everything if nothing selected (default)\n+    const bool do_mediantxsize = do_all || stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = do_all || stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = do_all || stats.count(\"medianfeerate\") != 0;\n+    const bool loop_inputs = do_all || do_medianfee || do_medianfeerate ||\n+        SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n+    const bool loop_outputs = do_all || loop_inputs || stats.count(\"total_out\");\n+    const bool do_calculate_size = do_mediantxsize ||\n+        SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n+    const bool do_calculate_weight = do_all || SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n+    const bool do_calculate_sw = do_all || SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+\n+    CAmount maxfee = 0;\n+    CAmount maxfeerate = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    int64_t inputs = 0;\n+    int64_t maxtxsize = 0;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t outputs = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    std::vector<int64_t> txsize_array;\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                tx_total_out += out.nValue;\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        total_out += tx_total_out; // Don't count coinbase reward\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+            mintxsize = std::min(mintxsize, tx_size);\n+            total_size += tx_size;\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            if (!fTxIndex) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"One or more of the selected stats requires -txindex enabled\");\n+            }\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in;\n+                uint256 hashBlock;\n+                if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, false)) {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, std::string(\"Unexpected internal error (tx index seems corrupt)\"));\n+                }\n+\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            maxfee = std::max(maxfee, txfee);\n+            minfee = std::min(minfee, txfee);\n+            totalfee += txfee;\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            maxfeerate = std::max(maxfeerate, feerate);\n+            minfeerate = std::min(minfeerate, feerate);\n+        }\n+    }\n+\n+    UniValue ret_all(UniValue::VOBJ);\n+    ret_all.pushKV(\"avgfee\", (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+    ret_all.pushKV(\"avgfeerate\", CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+    ret_all.pushKV(\"avgtxsize\", (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0);\n+    ret_all.pushKV(\"blockhash\", pindex->GetBlockHash().GetHex());\n+    ret_all.pushKV(\"height\", (int64_t)pindex->nHeight);\n+    ret_all.pushKV(\"ins\", inputs);\n+    ret_all.pushKV(\"maxfee\", maxfee);\n+    ret_all.pushKV(\"maxfeerate\", maxfeerate);\n+    ret_all.pushKV(\"maxtxsize\", maxtxsize);\n+    ret_all.pushKV(\"medianfee\", CalculateTruncatedMedian(fee_array));\n+    ret_all.pushKV(\"medianfeerate\", CalculateTruncatedMedian(feerate_array));\n+    ret_all.pushKV(\"mediantime\", pindex->GetMedianTimePast());\n+    ret_all.pushKV(\"mediantxsize\", CalculateTruncatedMedian(txsize_array));\n+    ret_all.pushKV(\"minfee\", (minfee == MAX_MONEY) ? 0 : minfee);\n+    ret_all.pushKV(\"minfeerate\", (minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+    ret_all.pushKV(\"mintxsize\", mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize);\n+    ret_all.pushKV(\"outs\", outputs);\n+    ret_all.pushKV(\"subsidy\", GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+    ret_all.pushKV(\"swtotal_size\", swtotal_size);\n+    ret_all.pushKV(\"swtotal_weight\", swtotal_weight);\n+    ret_all.pushKV(\"swtxs\", swtxs);\n+    ret_all.pushKV(\"time\", pindex->GetBlockTime());\n+    ret_all.pushKV(\"total_out\", total_out);\n+    ret_all.pushKV(\"total_size\", total_size);\n+    ret_all.pushKV(\"total_weight\", total_weight);\n+    ret_all.pushKV(\"totalfee\", totalfee);\n+    ret_all.pushKV(\"txs\", (int64_t)block.vtx.size());\n+    ret_all.pushKV(\"utxo_increase\", outputs - inputs);\n+    ret_all.pushKV(\"utxo_size_inc\", utxo_size_inc);\n+\n+    if (do_all) {\n+        return ret_all;\n+    }\n+\n+    UniValue ret(UniValue::VOBJ);\n+    for (const std::string stat : stats) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183823240",
      "id" : 183823240,
      "original_commit_id" : "e73e374b23e7765f10d1e0ad087dc270549a53ea",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114895489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183823240",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183824637"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183824637"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could avoid 2nd lookup:\r\n```cpp\r\nconst UniValue& value = ret_all[stat];\r\nif (value.isNull()) {\r\n    throw ...;\r\n}\r\nret.pushKV(stat, value);",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T17:52:16Z",
      "diff_hunk" : "@@ -1612,6 +1613,274 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    CBlockIndex* pindex;\n+    if (request.params[0].isNum()) {\n+        const int height = request.params[0].get_int();\n+        const int current_tip = chainActive.Height();\n+        if (height < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+        }\n+        if (height > current_tip) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+        }\n+\n+        pindex = chainActive[height];\n+    } else {\n+        const std::string strHash = request.params[0].get_str();\n+        const uint256 hash(uint256S(strHash));\n+        pindex = LookupBlockIndex(hash);\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        const UniValue stats_univalue = request.params[1].get_array();\n+        for (unsigned int i = 0; i < stats_univalue.size(); i++) {\n+            const std::string stat = stats_univalue[i].get_str();\n+            stats.insert(stat);\n+        }\n+    }\n+\n+    const CBlock block = GetBlockChecked(pindex);\n+\n+    const bool do_all = stats.size() == 0; // Calculate everything if nothing selected (default)\n+    const bool do_mediantxsize = do_all || stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = do_all || stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = do_all || stats.count(\"medianfeerate\") != 0;\n+    const bool loop_inputs = do_all || do_medianfee || do_medianfeerate ||\n+        SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n+    const bool loop_outputs = do_all || loop_inputs || stats.count(\"total_out\");\n+    const bool do_calculate_size = do_mediantxsize ||\n+        SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n+    const bool do_calculate_weight = do_all || SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n+    const bool do_calculate_sw = do_all || SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+\n+    CAmount maxfee = 0;\n+    CAmount maxfeerate = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    int64_t inputs = 0;\n+    int64_t maxtxsize = 0;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t outputs = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    std::vector<int64_t> txsize_array;\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                tx_total_out += out.nValue;\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        total_out += tx_total_out; // Don't count coinbase reward\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+            mintxsize = std::min(mintxsize, tx_size);\n+            total_size += tx_size;\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            if (!fTxIndex) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"One or more of the selected stats requires -txindex enabled\");\n+            }\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in;\n+                uint256 hashBlock;\n+                if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, false)) {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, std::string(\"Unexpected internal error (tx index seems corrupt)\"));\n+                }\n+\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            maxfee = std::max(maxfee, txfee);\n+            minfee = std::min(minfee, txfee);\n+            totalfee += txfee;\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+            if (do_medianfeerate) {\n+                feerate_array.push_back(feerate);\n+            }\n+            maxfeerate = std::max(maxfeerate, feerate);\n+            minfeerate = std::min(minfeerate, feerate);\n+        }\n+    }\n+\n+    UniValue ret_all(UniValue::VOBJ);\n+    ret_all.pushKV(\"avgfee\", (block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+    ret_all.pushKV(\"avgfeerate\", CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+    ret_all.pushKV(\"avgtxsize\", (block.vtx.size() > 1) ? total_size / (block.vtx.size() - 1) : 0);\n+    ret_all.pushKV(\"blockhash\", pindex->GetBlockHash().GetHex());\n+    ret_all.pushKV(\"height\", (int64_t)pindex->nHeight);\n+    ret_all.pushKV(\"ins\", inputs);\n+    ret_all.pushKV(\"maxfee\", maxfee);\n+    ret_all.pushKV(\"maxfeerate\", maxfeerate);\n+    ret_all.pushKV(\"maxtxsize\", maxtxsize);\n+    ret_all.pushKV(\"medianfee\", CalculateTruncatedMedian(fee_array));\n+    ret_all.pushKV(\"medianfeerate\", CalculateTruncatedMedian(feerate_array));\n+    ret_all.pushKV(\"mediantime\", pindex->GetMedianTimePast());\n+    ret_all.pushKV(\"mediantxsize\", CalculateTruncatedMedian(txsize_array));\n+    ret_all.pushKV(\"minfee\", (minfee == MAX_MONEY) ? 0 : minfee);\n+    ret_all.pushKV(\"minfeerate\", (minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+    ret_all.pushKV(\"mintxsize\", mintxsize == MAX_BLOCK_SERIALIZED_SIZE ? 0 : mintxsize);\n+    ret_all.pushKV(\"outs\", outputs);\n+    ret_all.pushKV(\"subsidy\", GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+    ret_all.pushKV(\"swtotal_size\", swtotal_size);\n+    ret_all.pushKV(\"swtotal_weight\", swtotal_weight);\n+    ret_all.pushKV(\"swtxs\", swtxs);\n+    ret_all.pushKV(\"time\", pindex->GetBlockTime());\n+    ret_all.pushKV(\"total_out\", total_out);\n+    ret_all.pushKV(\"total_size\", total_size);\n+    ret_all.pushKV(\"total_weight\", total_weight);\n+    ret_all.pushKV(\"totalfee\", totalfee);\n+    ret_all.pushKV(\"txs\", (int64_t)block.vtx.size());\n+    ret_all.pushKV(\"utxo_increase\", outputs - inputs);\n+    ret_all.pushKV(\"utxo_size_inc\", utxo_size_inc);\n+\n+    if (do_all) {\n+        return ret_all;\n+    }\n+\n+    UniValue ret(UniValue::VOBJ);\n+    for (const std::string stat : stats) {\n+        if (ret_all[stat].isNull()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid selected statistic %s\", stat));\n+        }\n+        ret.pushKV(stat, ret_all[stat]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183824637",
      "id" : 183824637,
      "original_commit_id" : "e73e374b23e7765f10d1e0ad087dc270549a53ea",
      "original_position" : 275,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114895489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183824637",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183826618"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183826618"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ping.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T17:58:55Z",
      "diff_hunk" : "@@ -0,0 +1,180 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+\n+def assert_contains(data, values, check_cointains=True):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183826618",
      "id" : 183826618,
      "in_reply_to_id" : 181617257,
      "original_commit_id" : "69dd52d83918e8f34b29e264d604d6f5b11425b5",
      "original_position" : 15,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 114895489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183826618",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183860805"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183860805"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Also need to add argument 1 for stats to be parsed as an array.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T19:59:19Z",
      "diff_hunk" : "@@ -122,6 +122,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"importmulti\", 1, \"options\" },\n     { \"verifychain\", 0, \"checklevel\" },\n     { \"verifychain\", 1, \"nblocks\" },\n+    { \"getblockstats\", 0, \"hash_or_height\" },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183860805",
      "id" : 183860805,
      "original_commit_id" : "ddfe0918b0d65881c897e57e83505f7054fcbfe2",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 114941850,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183860805",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183862179"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183862179"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "CLI help doc is incorrect. It should be `\"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\"` (once stats is added in client.cpp).",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T20:03:52Z",
      "diff_hunk" : "@@ -1612,6 +1613,274 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 \\\"minfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183862179",
      "id" : 183862179,
      "original_commit_id" : "e73e374b23e7765f10d1e0ad087dc270549a53ea",
      "original_position" : 88,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 114941850,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183862179",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183897081"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183897081"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mhmm, yeah. Why is this working without it?",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T22:18:11Z",
      "diff_hunk" : "@@ -122,6 +122,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"importmulti\", 1, \"options\" },\n     { \"verifychain\", 0, \"checklevel\" },\n     { \"verifychain\", 1, \"nblocks\" },\n+    { \"getblockstats\", 0, \"hash_or_height\" },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183897081",
      "id" : 183897081,
      "in_reply_to_id" : 183860805,
      "original_commit_id" : "ddfe0918b0d65881c897e57e83505f7054fcbfe2",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 114985565,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183897081",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183897785"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183897785"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Only relevant for bitcoin-cli client.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-24T22:21:48Z",
      "diff_hunk" : "@@ -122,6 +122,7 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"importmulti\", 1, \"options\" },\n     { \"verifychain\", 0, \"checklevel\" },\n     { \"verifychain\", 1, \"nblocks\" },\n+    { \"getblockstats\", 0, \"hash_or_height\" },",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r183897785",
      "id" : 183897785,
      "in_reply_to_id" : 183860805,
      "original_commit_id" : "ddfe0918b0d65881c897e57e83505f7054fcbfe2",
      "original_position" : 4,
      "path" : "src/rpc/client.cpp",
      "position" : 4,
      "pull_request_review_id" : 114986323,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/183897785",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Hopefully fixed all the newest nits, thanks again.",
      "created_at" : "2018-04-24T23:06:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-384107667",
      "id" : 384107667,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-24T23:06:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/384107667",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "ACK ddfe091",
      "created_at" : "2018-04-25T01:15:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-384129427",
      "id" : 384129427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-25T01:15:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/384129427",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Weird. I'm getting consistent failures with 2dffcdc2afd7ee98f170af933b94186c455425bc on the `sync_all()` after `load_test_data()` -- it just hangs, because node 1 is never actually seeing the blocks. If I add a `node.generate(1)` beforehand, things work. The problem seems to be that the node doing the `submitblock` calls is never leaving InitialBlockDownload, and while it's in IBD it's not relaying blocks to its peer. Ah, it looks like this only shows up when it's been more than 24 hours since `--gen-test-data` was run -- so rerunning travis or running it locally should fail reliably now, I think.\r\n\r\nAdding a call to `node.generate(1)` at the start of `load_test_data` should fix this:\r\n\r\n```\r\n     def load_test_data(self, filename):\r\n         node = self.nodes[0]\r\n+        node.generate(1) # finish IBD; will get reorged out\r\n```",
      "created_at" : "2018-04-25T21:30:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-384440743",
      "id" : 384440743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-25T21:30:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/384440743",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ajtowns I think I solved it with mocktime as discussed, but since the time is in the file generated again, I advice not to merge it after we test it again after 24 of the data file being created (last time it only started failing after that),",
      "created_at" : "2018-04-27T01:36:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-384837468",
      "id" : 384837468,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-04-27T01:36:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/384837468",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r184835724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184835724"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I find this incredibly hard to read. Why not just use floating point and calculate it all manually? Then you wouldn't have to work around rounding issues (and wouldnt have the rounding issues you see here where things are rounded to the nearest 1).",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-28T01:49:17Z",
      "diff_hunk" : "@@ -1614,6 +1625,275 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    CBlockIndex* pindex;\n+    if (request.params[0].isNum()) {\n+        const int height = request.params[0].get_int();\n+        const int current_tip = chainActive.Height();\n+        if (height < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+        }\n+        if (height > current_tip) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+        }\n+\n+        pindex = chainActive[height];\n+    } else {\n+        const std::string strHash = request.params[0].get_str();\n+        const uint256 hash(uint256S(strHash));\n+        pindex = LookupBlockIndex(hash);\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        const UniValue stats_univalue = request.params[1].get_array();\n+        for (unsigned int i = 0; i < stats_univalue.size(); i++) {\n+            const std::string stat = stats_univalue[i].get_str();\n+            stats.insert(stat);\n+        }\n+    }\n+\n+    const CBlock block = GetBlockChecked(pindex);\n+\n+    const bool do_all = stats.size() == 0; // Calculate everything if nothing selected (default)\n+    const bool do_mediantxsize = do_all || stats.count(\"mediantxsize\") != 0;\n+    const bool do_medianfee = do_all || stats.count(\"medianfee\") != 0;\n+    const bool do_medianfeerate = do_all || stats.count(\"medianfeerate\") != 0;\n+    const bool loop_inputs = do_all || do_medianfee || do_medianfeerate ||\n+        SetHasKeys(stats, \"utxo_size_inc\", \"totalfee\", \"avgfee\", \"avgfeerate\", \"minfee\", \"maxfee\", \"minfeerate\", \"maxfeerate\");\n+    const bool loop_outputs = do_all || loop_inputs || stats.count(\"total_out\");\n+    const bool do_calculate_size = do_mediantxsize ||\n+        SetHasKeys(stats, \"total_size\", \"avgtxsize\", \"mintxsize\", \"maxtxsize\", \"swtotal_size\");\n+    const bool do_calculate_weight = do_all || SetHasKeys(stats, \"total_weight\", \"avgfeerate\", \"swtotal_weight\", \"avgfeerate\", \"medianfeerate\", \"minfeerate\", \"maxfeerate\");\n+    const bool do_calculate_sw = do_all || SetHasKeys(stats, \"swtxs\", \"swtotal_size\", \"swtotal_weight\");\n+\n+    CAmount maxfee = 0;\n+    CAmount maxfeerate = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    int64_t inputs = 0;\n+    int64_t maxtxsize = 0;\n+    int64_t mintxsize = MAX_BLOCK_SERIALIZED_SIZE;\n+    int64_t outputs = 0;\n+    int64_t swtotal_size = 0;\n+    int64_t swtotal_weight = 0;\n+    int64_t swtxs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_array;\n+    std::vector<int64_t> txsize_array;\n+\n+    for (const auto& tx : block.vtx) {\n+        outputs += tx->vout.size();\n+\n+        CAmount tx_total_out = 0;\n+        if (loop_outputs) {\n+            for (const CTxOut& out : tx->vout) {\n+                tx_total_out += out.nValue;\n+                utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        total_out += tx_total_out; // Don't count coinbase reward\n+\n+        int64_t tx_size = 0;\n+        if (do_calculate_size) {\n+\n+            tx_size = tx->GetTotalSize();\n+            if (do_mediantxsize) {\n+                txsize_array.push_back(tx_size);\n+            }\n+            maxtxsize = std::max(maxtxsize, tx_size);\n+            mintxsize = std::min(mintxsize, tx_size);\n+            total_size += tx_size;\n+        }\n+\n+        int64_t weight = 0;\n+        if (do_calculate_weight) {\n+            weight = GetTransactionWeight(*tx);\n+            total_weight += weight;\n+        }\n+\n+        if (do_calculate_sw && tx->HasWitness()) {\n+            ++swtxs;\n+            swtotal_size += tx_size;\n+            swtotal_weight += weight;\n+        }\n+\n+        if (loop_inputs) {\n+\n+            if (!g_txindex) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"One or more of the selected stats requires -txindex enabled\");\n+            }\n+            CAmount tx_total_in = 0;\n+            for (const CTxIn& in : tx->vin) {\n+                CTransactionRef tx_in;\n+                uint256 hashBlock;\n+                if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, false)) {\n+                    throw JSONRPCError(RPC_INTERNAL_ERROR, std::string(\"Unexpected internal error (tx index seems corrupt)\"));\n+                }\n+\n+                CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+                tx_total_in += prevoutput.nValue;\n+                utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            }\n+\n+            CAmount txfee = tx_total_in - tx_total_out;\n+            assert(MoneyRange(txfee));\n+            if (do_medianfee) {\n+                fee_array.push_back(txfee);\n+            }\n+            maxfee = std::max(maxfee, txfee);\n+            minfee = std::min(minfee, txfee);\n+            totalfee += txfee;\n+\n+            // New feerate uses satoshis per virtual byte instead of per serialized byte\n+            CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r184835724",
      "id" : 184835724,
      "original_commit_id" : "866c1c886106a8f0757ae688b816e3824c2f52f5",
      "original_position" : 279,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 116116976,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184835724",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r184920965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184920965"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Think mocktime needs to be set prior to `submitblock`",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-04-30T07:06:59Z",
      "diff_hunk" : "@@ -0,0 +1,175 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+import json\n+import os\n+import time\n+\n+TESTSDIR = os.path.dirname(os.path.realpath(__file__))\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+\n+    start_height = 101\n+    max_stat_pos = 2\n+    STATS_NEED_TXINDEX = [\n+        'avgfee',\n+        'avgfeerate',\n+        'maxfee',\n+        'maxfeerate',\n+        'medianfee',\n+        'medianfeerate',\n+        'minfee',\n+        'minfeerate',\n+        'totalfee',\n+        'utxo_size_inc',\n+    ]\n+\n+    def add_options(self, parser):\n+        parser.add_option('--gen-test-data', dest='gen_test_data',\n+                          default=False, action='store_true',\n+                          help='Generate test data')\n+        parser.add_option('--test-data', dest='test_data',\n+                          default='data/rpc_getblockstats.json',\n+                          action='store', metavar='FILE',\n+                          help='Test data file')\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def get_stats(self):\n+        return [self.nodes[0].getblockstats(hash_or_height=self.start_height + i) for i in range(self.max_stat_pos+1)]\n+\n+    def generate_test_data(self, filename):\n+        self.nodes[0].generate(101)\n+\n+        self.nodes[0].sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=10, subtractfeefromamount=False)\n+        self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+\n+        self.expected_stats = self.get_stats()\n+\n+        blocks = []\n+        tip = self.nodes[0].getbestblockhash()\n+        blockhash = None\n+        height = 0\n+        while tip != blockhash:\n+            blockhash = self.nodes[0].getblockhash(height)\n+            blocks.append(self.nodes[0].getblock(blockhash, 0))\n+            height += 1\n+\n+        to_dump = {\n+            'blocks': blocks,\n+            'mocktime': int(time.time()),\n+            'stats': self.expected_stats,\n+        }\n+        with open(filename, 'w') as f:\n+            json.dump(to_dump, f, sort_keys=True, indent=2)\n+\n+    def load_test_data(self, filename):\n+        with open(filename, 'r') as f:\n+            d = json.load(f)\n+            blocks = d['blocks']\n+            mocktime = d['mocktime']\n+            self.expected_stats = d['stats']\n+\n+        for b in blocks:\n+            self.nodes[0].submitblock(b)\n+\n+        # Set the timestamps from the file so that the nodes can get out of Initial Block Download\n+        self.nodes[0].setmocktime(mocktime)\n+        self.nodes[1].setmocktime(mocktime)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r184920965",
      "id" : 184920965,
      "original_commit_id" : "f8ad78ad4b8733258540fe88d55a3c286660edf6",
      "original_position" : 98,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : null,
      "pull_request_review_id" : 116208294,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/184920965",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ajtowns now it seems to work 24 hours after generating the data\r\n\r\n@TheBlueMatt yeah, it looks simpler now without using CFeeRate or CFeeRate::GetTruncatedFee. Thanks\r\n\r\nIndependently of that, if we want more precision for feerates (say, move from sat/vbyte to sat/vKB or whatever), now it's the right time to decide so.\r\nI guess we could also support arbitrary precision with an optional feerates_precision parameter that defaults to 1 (ie sat/vbyte), or 1000 (ie sat/vKB) or 1024 or whatever.\r\nOr we can simply leave the latter for later if anybody asks, but it's a simple change if people want more precision.\r\n",
      "created_at" : "2018-05-01T19:20:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-385763015",
      "id" : 385763015,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-05-01T19:20:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/385763015",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r185319287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185319287"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You dont need the size() check.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-05-01T20:04:17Z",
      "diff_hunk" : "@@ -1614,6 +1625,275 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    CBlockIndex* pindex;\n+    if (request.params[0].isNum()) {\n+        const int height = request.params[0].get_int();\n+        const int current_tip = chainActive.Height();\n+        if (height < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+        }\n+        if (height > current_tip) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+        }\n+\n+        pindex = chainActive[height];\n+    } else {\n+        const std::string strHash = request.params[0].get_str();\n+        const uint256 hash(uint256S(strHash));\n+        pindex = LookupBlockIndex(hash);\n+    }\n+\n+    std::set<std::string> stats;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r185319287",
      "id" : 185319287,
      "original_commit_id" : "de63105609df02f1d74e2e133201a80126470df1",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 116683857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185319287",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r185319486"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185319486"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I believe if the hash is invalid GetBlockChecked will crash trying to deref the blockindex nullptr.",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-05-01T20:05:01Z",
      "diff_hunk" : "@@ -1614,6 +1625,275 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    size_t size = scores.size();\n+    if (size == 0) {\n+        return 0;\n+    }\n+\n+    std::sort(scores.begin(), scores.end());\n+    if (size % 2 == 0) {\n+        return (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        return scores[size / 2];\n+    }\n+}\n+\n+template<typename T>\n+static inline bool SetHasKeys(const std::set<T>& set) {return false;}\n+template<typename T, typename Tk, typename... Args>\n+static inline bool SetHasKeys(const std::set<T>& set, const Tk& key, const Args&... args)\n+{\n+    return (set.count(key) != 0) || SetHasKeys(set, args...);\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static constexpr size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( hash_or_height stats )\\n\"\n+            \"\\nCompute per block statistics for a given window. All amounts are in satoshis.\\n\"\n+            \"\\nIt won't work for some heights with pruning.\\n\"\n+            \"\\nIt won't work without -txindex for utxo_size_inc, *fee or *feerate stats.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"hash_or_height\\\"     (string or numeric, required) The block hash or height of the target block. If height, negative values count back from the current tip\\n\"\n+            \"2. \\\"stats\\\"      (array,  optional) Values to plot, by default all values, see result below)\"\n+            \"    [\"\n+            \"      \\\"height\\\",   (string, optional) Selected statistic\\n\"\n+            \"      \\\"time\\\",     (string, optional) Selected statistic\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"\\nResult: (all values are in reverse order height-wise)\\n\"\n+            \"{                             (json object)\\n\"\n+            \"  \\\"avgfee\\\": xxxxx,          (numeric) Average fee in the block\\n\"\n+            \"  \\\"avgfeerate\\\": xxxxx,      (numeric) Average feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"avgtxsize\\\": xxxxx,       (numeric) Average transaction size\\n\"\n+            \"  \\\"blockhash\\\": xxxxx,       (string) The block hash (to check for potential reorgs)\\n\"\n+            \"  \\\"height\\\": xxxxx,          (numeric) The height of the block\\n\"\n+            \"  \\\"ins\\\": xxxxx,             (numeric) The number of inputs (excluding coinbase)\\n\"\n+            \"  \\\"maxfee\\\": xxxxx,          (numeric) Maximum fee in the block\\n\"\n+            \"  \\\"maxfeerate\\\": xxxxx,      (numeric) Maximum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"maxtxsize\\\": xxxxx,       (numeric) Maximum transaction size\\n\"\n+            \"  \\\"medianfee\\\": xxxxx,       (numeric) Truncated median fee in the block\\n\"\n+            \"  \\\"medianfeerate\\\": xxxxx,   (numeric) Truncated median feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mediantime\\\": xxxxx,      (numeric) The block median time past\\n\"\n+            \"  \\\"mediantxsize\\\": xxxxx,    (numeric) Truncated median transaction size\\n\"\n+            \"  \\\"minfee\\\": xxxxx,          (numeric) Minimum fee in the block\\n\"\n+            \"  \\\"minfeerate\\\": xxxxx,      (numeric) Minimum feerate (in satoshis per virtual byte)\\n\"\n+            \"  \\\"mintxsize\\\": xxxxx,       (numeric) Minimum transaction size\\n\"\n+            \"  \\\"outs\\\": xxxxx,            (numeric) The number of outputs\\n\"\n+            \"  \\\"subsidy\\\": xxxxx,         (numeric) The block subsidy\\n\"\n+            \"  \\\"swtotal_size\\\": xxxxx,    (numeric) Total size of all segwit transactions\\n\"\n+            \"  \\\"swtotal_weight\\\": xxxxx,  (numeric) Total weight of all segwit transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"swtxs\\\": xxxxx,           (numeric) The number of segwit transactions\\n\"\n+            \"  \\\"time\\\": xxxxx,            (numeric) The block time\\n\"\n+            \"  \\\"total_out\\\": xxxxx,       (numeric) Total amount in all outputs (excluding coinbase and thus reward [ie subsidy + totalfee])\\n\"\n+            \"  \\\"total_size\\\": xxxxx,      (numeric) Total size of all non-coinbase transactions\\n\"\n+            \"  \\\"total_weight\\\": xxxxx,    (numeric) Total weight of all non-coinbase transactions divided by segwit scale factor (4)\\n\"\n+            \"  \\\"totalfee\\\": xxxxx,        (numeric) The fee total\\n\"\n+            \"  \\\"txs\\\": xxxxx,             (numeric) The number of transactions (excluding coinbase)\\n\"\n+            \"  \\\"utxo_increase\\\": xxxxx,   (numeric) The increase/decrease in the number of unspent outputs\\n\"\n+            \"  \\\"utxo_size_inc\\\": xxxxx,   (numeric) The increase/decrease in size for the utxo index (not discounting op_return and similar)\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 '[\\\"minfeerate\\\",\\\"avgfeerate\\\"]'\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    CBlockIndex* pindex;\n+    if (request.params[0].isNum()) {\n+        const int height = request.params[0].get_int();\n+        const int current_tip = chainActive.Height();\n+        if (height < 0) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d is negative\", height));\n+        }\n+        if (height > current_tip) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Target block height %d after current tip %d\", height, current_tip));\n+        }\n+\n+        pindex = chainActive[height];\n+    } else {\n+        const std::string strHash = request.params[0].get_str();\n+        const uint256 hash(uint256S(strHash));\n+        pindex = LookupBlockIndex(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r185319486",
      "id" : 185319486,
      "original_commit_id" : "de63105609df02f1d74e2e133201a80126470df1",
      "original_position" : 162,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 171,
      "pull_request_review_id" : 116683857,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T10:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/185319486",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed last 2 nits. Added a test for when blocks aren't found.\r\nAlso needed rebase.",
      "created_at" : "2018-05-07T10:53:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-387029644",
      "id" : 387029644,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2018-05-07T10:53:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/387029644",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1008458?v=4",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r186416166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186416166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Linter error:\r\n```\r\nW293 blank line contains whitespace.\r\n```",
      "commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "created_at" : "2018-05-07T13:04:12Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2017-2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#\n+# Test getblockstats rpc call\n+#\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n+import json\n+import os\n+import time\n+\n+TESTSDIR = os.path.dirname(os.path.realpath(__file__))\n+\n+class GetblockstatsTest(BitcoinTestFramework):\n+\n+    start_height = 101\n+    max_stat_pos = 2\n+    STATS_NEED_TXINDEX = [\n+        'avgfee',\n+        'avgfeerate',\n+        'maxfee',\n+        'maxfeerate',\n+        'medianfee',\n+        'medianfeerate',\n+        'minfee',\n+        'minfeerate',\n+        'totalfee',\n+        'utxo_size_inc',\n+    ]\n+\n+    def add_options(self, parser):\n+        parser.add_option('--gen-test-data', dest='gen_test_data',\n+                          default=False, action='store_true',\n+                          help='Generate test data')\n+        parser.add_option('--test-data', dest='test_data',\n+                          default='data/rpc_getblockstats.json',\n+                          action='store', metavar='FILE',\n+                          help='Test data file')\n+\n+    def set_test_params(self):\n+        self.num_nodes = 2\n+        self.extra_args = [['-txindex'], ['-paytxfee=0.003']]\n+        self.setup_clean_chain = True\n+\n+    def get_stats(self):\n+        return [self.nodes[0].getblockstats(hash_or_height=self.start_height + i) for i in range(self.max_stat_pos+1)]\n+\n+    def generate_test_data(self, filename):\n+        mocktime = time.time()\n+        self.nodes[0].generate(101)\n+\n+        self.nodes[0].sendtoaddress(address=self.nodes[1].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=10, subtractfeefromamount=True)\n+        self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=10, subtractfeefromamount=False)\n+        self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1, subtractfeefromamount=True)\n+        self.sync_all()\n+        self.nodes[0].generate(1)\n+\n+        self.expected_stats = self.get_stats()\n+\n+        blocks = []\n+        tip = self.nodes[0].getbestblockhash()\n+        blockhash = None\n+        height = 0\n+        while tip != blockhash:\n+            blockhash = self.nodes[0].getblockhash(height)\n+            blocks.append(self.nodes[0].getblock(blockhash, 0))\n+            height += 1\n+\n+        to_dump = {\n+            'blocks': blocks,\n+            'mocktime': int(mocktime),\n+            'stats': self.expected_stats,\n+        }\n+        with open(filename, 'w') as f:\n+            json.dump(to_dump, f, sort_keys=True, indent=2)\n+\n+    def load_test_data(self, filename):\n+        with open(filename, 'r') as f:\n+            d = json.load(f)\n+            blocks = d['blocks']\n+            mocktime = d['mocktime']\n+            self.expected_stats = d['stats']\n+\n+        # Set the timestamps from the file so that the nodes can get out of Initial Block Download\n+        self.nodes[0].setmocktime(mocktime)\n+        self.nodes[1].setmocktime(mocktime)\n+\n+        for b in blocks:\n+            self.nodes[0].submitblock(b)\n+\n+    def run_test(self):\n+        test_data = os.path.join(TESTSDIR, self.options.test_data)\n+        if self.options.gen_test_data:\n+            self.generate_test_data(test_data)\n+        else:\n+            self.load_test_data(test_data)\n+\n+        self.sync_all()\n+        stats = self.get_stats()\n+        expected_stats_noindex = []\n+        for stat_row in stats:\n+            expected_stats_noindex.append({k: v for k, v in stat_row.items() if k not in self.STATS_NEED_TXINDEX})\n+\n+        # Make sure all valid statistics are included but nothing else is\n+        expected_keys = self.expected_stats[0].keys()\n+        assert_equal(set(stats[0].keys()), set(expected_keys))\n+\n+        assert_equal(stats[0]['height'], self.start_height)\n+        assert_equal(stats[self.max_stat_pos]['height'], self.start_height + self.max_stat_pos)\n+\n+        for i in range(self.max_stat_pos+1):\n+            self.log.info('Checking block %d\\n' % (i))\n+            assert_equal(stats[i], self.expected_stats[i])\n+\n+            # Check selecting block by hash too\n+            blockhash = self.expected_stats[i]['blockhash']\n+            stats_by_hash = self.nodes[0].getblockstats(hash_or_height=blockhash)\n+            assert_equal(stats_by_hash, self.expected_stats[i])\n+\n+            # Check with the node that has no txindex\n+            stats_no_txindex = self.nodes[1].getblockstats(hash_or_height=blockhash, stats=list(expected_stats_noindex[i].keys()))\n+            assert_equal(stats_no_txindex, expected_stats_noindex[i])\n+\n+        # Make sure each stat can be queried on its own\n+        for stat in expected_keys:\n+            for i in range(self.max_stat_pos+1):\n+                result = self.nodes[0].getblockstats(hash_or_height=self.start_height + i, stats=[stat])\n+                assert_equal(list(result.keys()), [stat])\n+                if result[stat] != self.expected_stats[i][stat]:\n+                    self.log.info('result[%s] (%d) failed, %r != %r' % (\n+                        stat, i, result[stat], self.expected_stats[i][stat]))\n+                assert_equal(result[stat], self.expected_stats[i][stat])\n+\n+        # Make sure only the selected statistics are included (more than one)\n+        some_stats = {'minfee', 'maxfee'}\n+        stats = self.nodes[0].getblockstats(hash_or_height=1, stats=list(some_stats))\n+        assert_equal(set(stats.keys()), some_stats)\n+\n+        # Test invalid parameters raise the proper json exceptions\n+        tip = self.start_height + self.max_stat_pos\n+        assert_raises_rpc_error(-8, 'Target block height %d after current tip %d' % (tip+1, tip),\n+                                self.nodes[0].getblockstats, hash_or_height=tip+1)\n+        assert_raises_rpc_error(-8, 'Target block height %d is negative' % (-1),\n+                                self.nodes[0].getblockstats, hash_or_height=-1)\n+\n+        # Make sure not valid stats aren't allowed\n+        inv_sel_stat = 'asdfghjkl'\n+        inv_stats = [\n+            [inv_sel_stat],\n+            ['minfee' , inv_sel_stat],\n+            [inv_sel_stat, 'minfee'],\n+            ['minfee', inv_sel_stat, 'maxfee'],\n+        ]\n+        for inv_stat in inv_stats:\n+            assert_raises_rpc_error(-8, 'Invalid selected statistic %s' % inv_sel_stat,\n+                                    self.nodes[0].getblockstats, hash_or_height=1, stats=inv_stat)\n+\n+        # Make sure we aren't always returning inv_sel_stat as the culprit stat\n+        assert_raises_rpc_error(-8, 'Invalid selected statistic aaa%s' % inv_sel_stat,\n+                                self.nodes[0].getblockstats, hash_or_height=1, stats=['minfee' , 'aaa%s' % inv_sel_stat])\n+\n+        assert_raises_rpc_error(-8, 'One or more of the selected stats requires -txindex enabled',\n+                                self.nodes[1].getblockstats, hash_or_height=self.start_height + self.max_stat_pos)\n+\n+        # Mainchain's genesis block shouldn't be found on regtest\n+        assert_raises_rpc_error(-5, 'Block not found', self.nodes[0].getblockstats,\n+                                hash_or_height='000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f')\n+\n+        ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r186416166",
      "id" : 186416166,
      "original_commit_id" : "4523b5d9c47d877a037b1e1cf718727e4c4aa864",
      "original_position" : 179,
      "path" : "test/functional/rpc_getblockstats.py",
      "position" : 179,
      "pull_request_review_id" : 117988186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2018-05-07T13:04:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/186416166",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   }
]
